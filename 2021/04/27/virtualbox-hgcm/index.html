<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"github.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.json"};
  </script>

  <meta name="description" content="文章首发于安全KER https:&#x2F;&#x2F;www.anquanke.com&#x2F;post&#x2F;id&#x2F;238643 0x00 前言最近开始研究VirtualBox虚拟机逃逸漏洞，针对于VirtualBox的虚拟机逃逸，我们重点关注它的HGCM（host-guest communication mechanism）协议，本文将结合源码分析和动态调试来分析此协议，最后我们还将实现一个HGCM协议的调用库。">
<meta property="og:type" content="article">
<meta property="og:title" content="VirtualBox HGCM协议研究">
<meta property="og:url" content="https://github.com/2021/04/27/virtualbox-hgcm/index.html">
<meta property="og:site_name" content="ha1vk&#39;s blog">
<meta property="og:description" content="文章首发于安全KER https:&#x2F;&#x2F;www.anquanke.com&#x2F;post&#x2F;id&#x2F;238643 0x00 前言最近开始研究VirtualBox虚拟机逃逸漏洞，针对于VirtualBox的虚拟机逃逸，我们重点关注它的HGCM（host-guest communication mechanism）协议，本文将结合源码分析和动态调试来分析此协议，最后我们还将实现一个HGCM协议的调用库。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://p0.ssl.qhimg.com/t01a3d2f1624c2176a1.png">
<meta property="og:image" content="https://p4.ssl.qhimg.com/t014e8eb668bcd7d8e6.png">
<meta property="article:published_time" content="2021-04-27T02:30:29.000Z">
<meta property="article:modified_time" content="2025-06-26T09:47:42.251Z">
<meta property="article:author" content="ha1vk">
<meta property="article:tag" content="虚拟机逃逸">
<meta property="article:tag" content="VirtualBox">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://p0.ssl.qhimg.com/t01a3d2f1624c2176a1.png">

<link rel="canonical" href="https://github.com/2021/04/27/virtualbox-hgcm/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>VirtualBox HGCM协议研究 | ha1vk's blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">ha1vk's blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://github.com/2021/04/27/virtualbox-hgcm/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ha1vk">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ha1vk's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          VirtualBox HGCM协议研究
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-04-27 10:30:29" itemprop="dateCreated datePublished" datetime="2021-04-27T10:30:29+08:00">2021-04-27</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AE%89%E5%85%A8%E7%A0%94%E7%A9%B6/" itemprop="url" rel="index"><span itemprop="name">安全研究</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>文章首发于安全KER <a target="_blank" rel="noopener" href="https://www.anquanke.com/post/id/238643">https://www.anquanke.com/post/id/238643</a></p>
<h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>最近开始研究VirtualBox虚拟机逃逸漏洞，针对于VirtualBox的虚拟机逃逸，我们重点关注它的<code>HGCM（host-guest communication mechanism）协议</code>，本文将结合源码分析和动态调试来分析此协议，最后我们还将实现一个HGCM协议的调用库。</p>
<h2 id="0x01-VirtualBox-通信协议"><a href="#0x01-VirtualBox-通信协议" class="headerlink" title="0x01 VirtualBox 通信协议"></a>0x01 VirtualBox 通信协议</h2><h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>VirtualBox中一个名为<code>HGCM</code>的协议相当于一个<code>RPC</code>，其作用是可以让Guest里的程序通过接口调用<code>Host</code>中的服务程序中的函数。该协议的接口封装在<code>vboxguest</code>驱动程序中。</p>
<p>在Guest系统中，通过<code>VBoxGuestAdditions.iso</code>安装了一个名为<code>vboxguest</code>的驱动程序，该驱动程序主要就是提供接口给<code>Guset</code>系统里的程序，用于与<code>Host</code>主机进行通信。<br><img src="https://p0.ssl.qhimg.com/t01a3d2f1624c2176a1.png"><br>除了<code>vboxguest</code>驱动，Guset还安装有<code>vboxsf</code>驱动和<code>vboxvideo</code>，其中<code>vboxsf</code>仍然使用的是<code>vboxguest</code>的接口，而<code>vboxvideo</code>则是<code>VirtualBox</code>虚拟出来的显示设备的驱动程序，独立于前面两个驱动。由此可见，Guest与Host之前的通信关键在于<code>vboxguest</code>驱动，因此，我们的研究将从该驱动出发。</p>
<p>该驱动源码位于<code>src\VBox\Additions\common\VBoxGuest</code>目录，以Linux系统为例，其源文件为<code>VBoxGuest-linux.c</code>，首先从<code>file_operations</code>结构体可以看到有哪些操作</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">static struct file_operations   g_FileOpsUser =</span><br><span class="line">&#123;</span><br><span class="line">    owner:          THIS_MODULE,</span><br><span class="line">    open:           vgdrvLinuxOpen,</span><br><span class="line">    release:        vgdrvLinuxRelease,</span><br><span class="line">#ifdef HAVE_UNLOCKED_IOCTL</span><br><span class="line">    unlocked_ioctl: vgdrvLinuxIOCtl,</span><br><span class="line">#else</span><br><span class="line">    ioctl:          vgdrvLinuxIOCtl,</span><br><span class="line">#endif</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="GUEST-IOCTL"><a href="#GUEST-IOCTL" class="headerlink" title="GUEST IOCTL"></a>GUEST IOCTL</h3><p>可以看到定义了<code>vgdrvLinuxIOCtl</code>用于进行接口的访问，跟踪该函数，可以发现其调用了<code>vgdrvLinuxIOCtlSlow</code>函数，</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">static int vgdrvLinuxIOCtlSlow(struct file *pFilp, unsigned int uCmd, unsigned long ulArg, PVBOXGUESTSESSION pSession)</span><br><span class="line">&#123;</span><br><span class="line">    int                 rc;</span><br><span class="line">    VBGLREQHDR          Hdr;</span><br><span class="line">    PVBGLREQHDR         pHdr;</span><br><span class="line">    uint32_t            cbBuf;</span><br><span class="line"></span><br><span class="line">    Log6((&quot;vgdrvLinuxIOCtlSlow: pFilp=%p uCmd=%#x ulArg=%p pid=%d/%d\n&quot;, pFilp, uCmd, (void *)ulArg, RTProcSelf(), current-&gt;pid));</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">     * Read the header.</span><br><span class="line">     */</span><br><span class="line">    if (RT_FAILURE(RTR0MemUserCopyFrom(&amp;Hdr, ulArg, sizeof(Hdr))))</span><br><span class="line">    &#123;</span><br><span class="line">        Log((&quot;vgdrvLinuxIOCtlSlow: copy_from_user(,%#lx,) failed; uCmd=%#x\n&quot;, ulArg, uCmd));</span><br><span class="line">        return -EFAULT;</span><br><span class="line">    &#125;</span><br><span class="line">    if (RT_UNLIKELY(Hdr.uVersion != VBGLREQHDR_VERSION))</span><br><span class="line">    &#123;</span><br><span class="line">        Log((&quot;vgdrvLinuxIOCtlSlow: bad header version %#x; uCmd=%#x\n&quot;, Hdr.uVersion, uCmd));</span><br><span class="line">        return -EINVAL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">     * Buffer the request.</span><br><span class="line">     * Note! The header is revalidated by the common code.</span><br><span class="line">     */</span><br><span class="line">    cbBuf = RT_MAX(Hdr.cbIn, Hdr.cbOut);</span><br><span class="line">    if (RT_UNLIKELY(cbBuf &gt; _1M*16))</span><br><span class="line">    &#123;</span><br><span class="line">        Log((&quot;vgdrvLinuxIOCtlSlow: too big cbBuf=%#x; uCmd=%#x\n&quot;, cbBuf, uCmd));</span><br><span class="line">        return -E2BIG;</span><br><span class="line">    &#125;</span><br><span class="line">    if (RT_UNLIKELY(   Hdr.cbIn &lt; sizeof(Hdr)</span><br><span class="line">                    || (cbBuf != _IOC_SIZE(uCmd) &amp;&amp; _IOC_SIZE(uCmd) != 0)))</span><br><span class="line">    &#123;</span><br><span class="line">        Log((&quot;vgdrvLinuxIOCtlSlow: bad ioctl cbBuf=%#x _IOC_SIZE=%#x; uCmd=%#x\n&quot;, cbBuf, _IOC_SIZE(uCmd), uCmd));</span><br><span class="line">        return -EINVAL;</span><br><span class="line">    &#125;</span><br><span class="line">    pHdr = RTMemAlloc(cbBuf);</span><br><span class="line">    if (RT_UNLIKELY(!pHdr))</span><br><span class="line">    &#123;</span><br><span class="line">        LogRel((&quot;vgdrvLinuxIOCtlSlow: failed to allocate buffer of %d bytes for uCmd=%#x\n&quot;, cbBuf, uCmd));</span><br><span class="line">        return -ENOMEM;</span><br><span class="line">    &#125;</span><br><span class="line">    if (RT_FAILURE(RTR0MemUserCopyFrom(pHdr, ulArg, Hdr.cbIn)))</span><br><span class="line">    &#123;</span><br><span class="line">        Log((&quot;vgdrvLinuxIOCtlSlow: copy_from_user(,%#lx, %#x) failed; uCmd=%#x\n&quot;, ulArg, Hdr.cbIn, uCmd));</span><br><span class="line">        RTMemFree(pHdr);</span><br><span class="line">        return -EFAULT;</span><br><span class="line">    &#125;</span><br><span class="line">    if (Hdr.cbIn &lt; cbBuf)</span><br><span class="line">        RT_BZERO((uint8_t *)pHdr + Hdr.cbIn, cbBuf - Hdr.cbIn);</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">     * Process the IOCtl.</span><br><span class="line">     */</span><br><span class="line">    rc = VGDrvCommonIoCtl(uCmd, &amp;g_DevExt, pSession, pHdr, cbBuf);</span><br><span class="line">	.........................................................</span><br></pre></td></tr></table></figure>
<p>可以看到，函数中首先将用户传入的数据转为<code>VBGLREQHDR          Hdr;</code>结构体，该结构体定义如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">typedef struct VBGLREQHDR</span><br><span class="line">&#123;</span><br><span class="line">    /** IN: The request input size, and output size if cbOut is zero.</span><br><span class="line">     * @sa VMMDevRequestHeader::size  */</span><br><span class="line">    uint32_t        cbIn;</span><br><span class="line">    /** IN: Structure version (VBGLREQHDR_VERSION)</span><br><span class="line">     * @sa VMMDevRequestHeader::version */</span><br><span class="line">    uint32_t        uVersion;</span><br><span class="line">    /** IN: The VMMDev request type, set to VBGLREQHDR_TYPE_DEFAULT unless this is a</span><br><span class="line">     * kind of VMMDev request.</span><br><span class="line">     * @sa VMMDevRequestType, VMMDevRequestHeader::requestType */</span><br><span class="line">    uint32_t        uType;</span><br><span class="line">    /** OUT: The VBox status code of the operation, out direction only. */</span><br><span class="line">    int32_t         rc;</span><br><span class="line">    /** IN: The output size.  This is optional - set to zero to use cbIn as the</span><br><span class="line">     * output size. */</span><br><span class="line">    uint32_t        cbOut;</span><br><span class="line">    /** Reserved / filled in by kernel, MBZ.</span><br><span class="line">     * @sa VMMDevRequestHeader::fRequestor */</span><br><span class="line">    uint32_t        uReserved;</span><br><span class="line">&#125; VBGLREQHDR;</span><br></pre></td></tr></table></figure>
<p>然后判断一些信息是否符合要求，这里，归纳如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Hdr.uVersion = VBGLREQHDR_VERSION</span><br><span class="line">Hdr.cbIn和Hdr.cbOut不能大于_1M*16</span><br></pre></td></tr></table></figure>
<p>检查通过后，执行<code>rc = VGDrvCommonIoCtl(uCmd, &amp;g_DevExt, pSession, pHdr, cbBuf);</code>，进入<code>VGDrvCommonIoCtl</code>函数，该函数位于<code>VBoxGuest.cpp</code>源文件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">int VGDrvCommonIoCtl(uintptr_t iFunction, PVBOXGUESTDEVEXT pDevExt, PVBOXGUESTSESSION pSession, PVBGLREQHDR pReqHdr, size_t cbReq)</span><br><span class="line">&#123;</span><br><span class="line">    uintptr_t const iFunctionStripped = VBGL_IOCTL_CODE_STRIPPED(iFunction);</span><br><span class="line">    int rc;</span><br><span class="line">...............................................................</span><br><span class="line">   /*</span><br><span class="line">     * Deal with variably sized requests first.</span><br><span class="line">     */</span><br><span class="line">    rc = VINF_SUCCESS;</span><br><span class="line">    if (   iFunctionStripped == VBGL_IOCTL_CODE_STRIPPED(VBGL_IOCTL_VMMDEV_REQUEST(0))</span><br><span class="line">        || iFunctionStripped == VBGL_IOCTL_CODE_STRIPPED(VBGL_IOCTL_VMMDEV_REQUEST_BIG) )</span><br><span class="line">    &#123;</span><br><span class="line">        ........</span><br><span class="line">    &#125;</span><br><span class="line">    else if (RT_LIKELY(pReqHdr-&gt;uType == VBGLREQHDR_TYPE_DEFAULT))</span><br><span class="line">    &#123;</span><br><span class="line">        if (iFunctionStripped == VBGL_IOCTL_CODE_STRIPPED(VBGL_IOCTL_LOG(0)))</span><br><span class="line">        &#123;</span><br><span class="line">            ........</span><br><span class="line">        &#125;</span><br><span class="line">#ifdef VBOX_WITH_HGCM</span><br><span class="line">        else if (iFunction == VBGL_IOCTL_IDC_HGCM_FAST_CALL) /* (is variable size, but we don&#x27;t bother encoding it) */</span><br><span class="line">        &#123;</span><br><span class="line">            .........</span><br><span class="line">        &#125;</span><br><span class="line">        else if (   iFunctionStripped == VBGL_IOCTL_CODE_STRIPPED(VBGL_IOCTL_HGCM_CALL(0))</span><br><span class="line"># if ARCH_BITS == 64</span><br><span class="line">                 || iFunctionStripped == VBGL_IOCTL_CODE_STRIPPED(VBGL_IOCTL_HGCM_CALL_32(0))</span><br><span class="line"># endif</span><br><span class="line">                )</span><br><span class="line">        &#123;</span><br><span class="line">            ...........</span><br><span class="line">        &#125;</span><br><span class="line">        else if (iFunctionStripped == VBGL_IOCTL_CODE_STRIPPED(VBGL_IOCTL_HGCM_CALL_WITH_USER_DATA(0)))</span><br><span class="line">        &#123;</span><br><span class="line">            ..........</span><br><span class="line">        &#125;</span><br><span class="line">#endif /* VBOX_WITH_HGCM */</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            switch (iFunction)</span><br><span class="line">            &#123;</span><br></pre></td></tr></table></figure>
<p>由于我们想要进入HGCM相关的处理分支里，因此，想要满足<code>pReqHdr-&gt;uType == VBGLREQHDR_TYPE_DEFAULT</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">            switch (iFunction)</span><br><span class="line">            &#123;</span><br><span class="line">............................................</span><br><span class="line">#ifdef VBOX_WITH_HGCM</span><br><span class="line">                case VBGL_IOCTL_HGCM_CONNECT:</span><br><span class="line">                    REQ_CHECK_SIZES(VBGL_IOCTL_HGCM_CONNECT);</span><br><span class="line">                    pReqHdr-&gt;rc = vgdrvIoCtl_HGCMConnect(pDevExt, pSession, (PVBGLIOCHGCMCONNECT)pReqHdr);</span><br><span class="line">                    break;</span><br><span class="line"></span><br><span class="line">                case VBGL_IOCTL_HGCM_DISCONNECT:</span><br><span class="line">                    REQ_CHECK_SIZES(VBGL_IOCTL_HGCM_DISCONNECT);</span><br><span class="line">                    pReqHdr-&gt;rc = vgdrvIoCtl_HGCMDisconnect(pDevExt, pSession, (PVBGLIOCHGCMDISCONNECT)pReqHdr);</span><br><span class="line">                    break;</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>
<p>这里的<code>iFunction</code>值就是我们在ioctl中传入的cmd，当cmd为<code> VBGL_IOCTL_HGCM_CONNECT</code>或者<code>VBGL_IOCTL_HGCM_DISCONNECT</code>时，可以建立或者断开一个<code>HGCM</code>服务。在一般情况下，使用HGCM调用Host中的服务时，要经过三个步骤<code>VBGL_IOCTL_HGCM_CONNECT</code>-&gt;<code>VBGL_IOCTL_HGCM_CALL</code>-&gt;<code>VBGL_IOCTL_HGCM_DISCONNECT</code>，即打开服务-&gt;调用函数-&gt;关闭服务。可以在<code>src\VBox\HostServices</code>目录下看到这些服务以及它们的源码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">src\VBox\HostServices</span><br><span class="line">	DragAndDrop</span><br><span class="line">	GuestControl</span><br><span class="line">	GuestProperties</span><br><span class="line">	HostChannel</span><br><span class="line">	SharedClipboard</span><br><span class="line">	SharedFolders</span><br><span class="line">	SharedOpenGL</span><br></pre></td></tr></table></figure>
<p>从这些服务名大致能知道它们的作用，其中<code>SharedClipboard</code>用于在Host和Guest之间共享<code>粘贴板</code>，<code>SharedFolders</code>用于共享<code>文件夹</code>，而<code>SharedOpenGL</code>用于<code>3D图形加速</code>。<br>继续分析HGCM服务的调用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pReqHdr-&gt;rc = vgdrvIoCtl_HGCMConnect(pDevExt, pSession, (PVBGLIOCHGCMCONNECT)pReqHdr);</span><br></pre></td></tr></table></figure>
<p>可以知道此时将<code>pReqHdr</code>这个<code>VBGLREQHDR</code>结构体指针强制转换为<code>VBGLIOCHGCMCONNECT</code>结构体指针，该结构体定义如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">typedef struct VBGLIOCHGCMCONNECT</span><br><span class="line">&#123;</span><br><span class="line">    /** The header. */</span><br><span class="line">    VBGLREQHDR                  Hdr;</span><br><span class="line">    union</span><br><span class="line">    &#123;</span><br><span class="line">        struct</span><br><span class="line">        &#123;</span><br><span class="line">            HGCMServiceLocation Loc;</span><br><span class="line">        &#125; In;</span><br><span class="line">        struct</span><br><span class="line">        &#123;</span><br><span class="line">            uint32_t            idClient;</span><br><span class="line">        &#125; Out;</span><br><span class="line">    &#125; u;</span><br><span class="line">&#125; VBGLIOCHGCMCONNECT, RT_FAR *PVBGLIOCHGCMCONNECT;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * HGCM service location.</span><br><span class="line"> * @ingroup grp_vmmdev_req</span><br><span class="line"> */</span><br><span class="line">typedef struct HGCMSERVICELOCATION</span><br><span class="line">&#123;</span><br><span class="line">    /** Type of the location. */</span><br><span class="line">    HGCMServiceLocationType type;</span><br><span class="line"></span><br><span class="line">    union</span><br><span class="line">    &#123;</span><br><span class="line">        HGCMServiceLocationHost host;</span><br><span class="line">    &#125; u;</span><br><span class="line">&#125; HGCMServiceLocation;</span><br><span class="line"></span><br><span class="line">typedef enum</span><br><span class="line">&#123;</span><br><span class="line">    VMMDevHGCMLoc_Invalid    = 0,</span><br><span class="line">    VMMDevHGCMLoc_LocalHost  = 1,</span><br><span class="line">    VMMDevHGCMLoc_LocalHost_Existing = 2,</span><br><span class="line">    VMMDevHGCMLoc_SizeHack   = 0x7fffffff</span><br><span class="line">&#125; HGCMServiceLocationType;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * HGCM host service location.</span><br><span class="line"> * @ingroup grp_vmmdev_req</span><br><span class="line"> */</span><br><span class="line">typedef struct</span><br><span class="line">&#123;</span><br><span class="line">    char achName[128]; /**&lt; This is really szName. */</span><br><span class="line">&#125; HGCMServiceLocationHost;</span><br></pre></td></tr></table></figure>
<h3 id="VBGL-IOCTL-HGCM-CONNECT"><a href="#VBGL-IOCTL-HGCM-CONNECT" class="headerlink" title="VBGL_IOCTL_HGCM_CONNECT"></a>VBGL_IOCTL_HGCM_CONNECT</h3><h4 id="VbglR0HGCMInternalConnect"><a href="#VbglR0HGCMInternalConnect" class="headerlink" title="VbglR0HGCMInternalConnect"></a>VbglR0HGCMInternalConnect</h4><p>进入<code>vgdrvIoCtl_HGCMConnect</code>函数,</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">static int vgdrvIoCtl_HGCMConnect(PVBOXGUESTDEVEXT pDevExt, PVBOXGUESTSESSION pSession, PVBGLIOCHGCMCONNECT pInfo)</span><br><span class="line">&#123;</span><br><span class="line">    int rc;</span><br><span class="line">    HGCMCLIENTID idClient = 0;</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">     * The VbglHGCMConnect call will invoke the callback if the HGCM</span><br><span class="line">     * call is performed in an ASYNC fashion. The function is not able</span><br><span class="line">     * to deal with cancelled requests.</span><br><span class="line">     */</span><br><span class="line">    Log((&quot;VBOXGUEST_IOCTL_HGCM_CONNECT: %.128s\n&quot;,</span><br><span class="line">         pInfo-&gt;u.In.Loc.type == VMMDevHGCMLoc_LocalHost || pInfo-&gt;u.In.Loc.type == VMMDevHGCMLoc_LocalHost_Existing</span><br><span class="line">         ? pInfo-&gt;u.In.Loc.u.host.achName : &quot;&lt;not local host&gt;&quot;));</span><br><span class="line"></span><br><span class="line">    rc = VbglR0HGCMInternalConnect(&amp;pInfo-&gt;u.In.Loc, pSession-&gt;fRequestor, &amp;idClient,</span><br><span class="line">                                   vgdrvHgcmAsyncWaitCallback, pDevExt, RT_INDEFINITE_WAIT);</span><br><span class="line">    Log((&quot;VBOXGUEST_IOCTL_HGCM_CONNECT: idClient=%RX32 (rc=%Rrc)\n&quot;, idClient, rc));</span><br><span class="line">    if (RT_SUCCESS(rc))</span><br><span class="line">    &#123;</span><br><span class="line">        /*</span><br><span class="line">         * Append the client id to the client id table.</span><br><span class="line">         * If the table has somehow become filled up, we&#x27;ll disconnect the session.</span><br><span class="line">         */</span><br><span class="line">        unsigned i;</span><br><span class="line">        RTSpinlockAcquire(pDevExt-&gt;SessionSpinlock);</span><br><span class="line">        for (i = 0; i &lt; RT_ELEMENTS(pSession-&gt;aHGCMClientIds); i++)</span><br><span class="line">            if (!pSession-&gt;aHGCMClientIds[i])</span><br><span class="line">            &#123;</span><br><span class="line">                pSession-&gt;aHGCMClientIds[i] = idClient;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        RTSpinlockRelease(pDevExt-&gt;SessionSpinlock);</span><br><span class="line">        if (i &gt;= RT_ELEMENTS(pSession-&gt;aHGCMClientIds))</span><br><span class="line">        &#123;</span><br><span class="line">            LogRelMax(32, (&quot;VBOXGUEST_IOCTL_HGCM_CONNECT: too many HGCMConnect calls for one session!\n&quot;));</span><br><span class="line">            VbglR0HGCMInternalDisconnect(idClient, pSession-&gt;fRequestor, vgdrvHgcmAsyncWaitCallback, pDevExt, RT_INDEFINITE_WAIT);</span><br><span class="line"></span><br><span class="line">            pInfo-&gt;u.Out.idClient = 0;</span><br><span class="line">            return VERR_TOO_MANY_OPEN_FILES;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    pInfo-&gt;u.Out.idClient = idClient;</span><br><span class="line">    return rc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从该函数可以看出，它将调用<code>VbglR0HGCMInternalConnect</code>函数，然后返回一个<code>idClient</code>即客户端号，并将该号码缓存到<code>pSession-&gt;aHGCMClientIds</code>数组中，同时将其返回给Guest中的请求程序。我们继续跟进<code>VbglR0HGCMInternalConnect</code>函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">DECLR0VBGL(int) VbglR0HGCMInternalConnect(HGCMServiceLocation const *pLoc, uint32_t fRequestor, HGCMCLIENTID *pidClient,</span><br><span class="line">                                          PFNVBGLHGCMCALLBACK pfnAsyncCallback, void *pvAsyncData, uint32_t u32AsyncData)</span><br><span class="line">&#123;</span><br><span class="line">    int rc;</span><br><span class="line">    if (   RT_VALID_PTR(pLoc)</span><br><span class="line">        &amp;&amp; RT_VALID_PTR(pidClient)</span><br><span class="line">        &amp;&amp; RT_VALID_PTR(pfnAsyncCallback))</span><br><span class="line">    &#123;</span><br><span class="line">        /* Allocate request */</span><br><span class="line">        VMMDevHGCMConnect *pHGCMConnect = NULL;</span><br><span class="line">        rc = VbglR0GRAlloc((VMMDevRequestHeader **)&amp;pHGCMConnect, sizeof(VMMDevHGCMConnect), VMMDevReq_HGCMConnect);</span><br><span class="line">        if (RT_SUCCESS(rc))</span><br><span class="line">        &#123;</span><br><span class="line">            /* Initialize request memory */</span><br><span class="line">            pHGCMConnect-&gt;header.header.fRequestor = fRequestor;</span><br><span class="line"></span><br><span class="line">            pHGCMConnect-&gt;header.fu32Flags = 0;</span><br><span class="line"></span><br><span class="line">            memcpy(&amp;pHGCMConnect-&gt;loc, pLoc, sizeof(pHGCMConnect-&gt;loc));</span><br><span class="line">            pHGCMConnect-&gt;u32ClientID = 0;</span><br><span class="line"></span><br><span class="line">            /* Issue request */</span><br><span class="line">            rc = VbglR0GRPerform (&amp;pHGCMConnect-&gt;header.header);</span><br><span class="line">            if (RT_SUCCESS(rc))</span><br><span class="line">            &#123;</span><br><span class="line">                /* Check if host decides to process the request asynchronously. */</span><br><span class="line">                if (rc == VINF_HGCM_ASYNC_EXECUTE)</span><br><span class="line">                &#123;</span><br><span class="line">                    /* Wait for request completion interrupt notification from host */</span><br><span class="line">                    pfnAsyncCallback(&amp;pHGCMConnect-&gt;header, pvAsyncData, u32AsyncData);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                rc = pHGCMConnect-&gt;header.result;</span><br><span class="line">                if (RT_SUCCESS(rc))</span><br><span class="line">                    *pidClient = pHGCMConnect-&gt;u32ClientID;</span><br><span class="line">            &#125;</span><br><span class="line">            VbglR0GRFree(&amp;pHGCMConnect-&gt;header.header);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">        rc = VERR_INVALID_PARAMETER;</span><br><span class="line">    return rc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该函数主要是新建了一个结构体，并从最开始<code>ioctl</code>操作中传入的结构体中复制<code>HGCMServiceLocation</code>结构体数据，然后传入<code>VbglR0GRPerform</code>函数。<br>VbglR0GRPerform函数实际上就是一个对<code>in</code>和<code>out</code>汇编指令的封装，操作IO接口，可以知道，其请求的端口地址为<code>g_vbgldata.portVMMDev + VMMDEV_PORT_OFF_REQUEST</code></p>
<h4 id="VbglR0GRPerform"><a href="#VbglR0GRPerform" class="headerlink" title="VbglR0GRPerform"></a>VbglR0GRPerform</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">DECLR0VBGL(int) VbglR0GRPerform(VMMDevRequestHeader *pReq)</span><br><span class="line">&#123;</span><br><span class="line">    int rc = vbglR0Enter();</span><br><span class="line">    if (RT_SUCCESS(rc))</span><br><span class="line">    &#123;</span><br><span class="line">        if (pReq)</span><br><span class="line">        &#123;</span><br><span class="line">            RTCCPHYS PhysAddr = VbglR0PhysHeapGetPhysAddr(pReq);</span><br><span class="line">            if (   PhysAddr != 0</span><br><span class="line">                &amp;&amp; PhysAddr &lt; _4G) /* Port IO is 32 bit. */</span><br><span class="line">            &#123;</span><br><span class="line">                ASMOutU32(g_vbgldata.portVMMDev + VMMDEV_PORT_OFF_REQUEST, (uint32_t)PhysAddr);</span><br><span class="line">                /* Make the compiler aware that the host has changed memory. */</span><br><span class="line">                ASMCompilerBarrier();</span><br><span class="line">                rc = pReq-&gt;rc;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">                rc = VERR_VBGL_INVALID_ADDR;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">            rc = VERR_INVALID_PARAMETER;</span><br><span class="line">    &#125;</span><br><span class="line">    return rc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过查找<code>VMMDEV_PORT_OFF_REQUEST</code>的引用，可以发现<code>src\VBox\Devices\VMMDev\VMMDev.cpp</code>文件，可以知道这是VirtualBox虚拟出来的IO设备,在<code>vmmdevIOPortRegionMap</code>函数中，通过<code>PDMDevHlpIOPortRegister</code>函数为<code>VMMDEV_PORT_OFF_REQUEST</code>IO端口注册了一个处理函数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">static DECLCALLBACK(int) vmmdevIOPortRegionMap(PPDMDEVINS pDevIns, PPDMPCIDEV pPciDev, uint32_t iRegion,</span><br><span class="line">                                               RTGCPHYS GCPhysAddress, RTGCPHYS cb, PCIADDRESSSPACE enmType)</span><br><span class="line">&#123;</span><br><span class="line">    LogFlow((&quot;vmmdevIOPortRegionMap: iRegion=%d GCPhysAddress=%RGp cb=%RGp enmType=%d\n&quot;, iRegion, GCPhysAddress, cb, enmType));</span><br><span class="line">    RT_NOREF3(iRegion, cb, enmType);</span><br><span class="line">    PVMMDEV pThis = RT_FROM_MEMBER(pPciDev, VMMDEV, PciDev);</span><br><span class="line"></span><br><span class="line">    Assert(enmType == PCI_ADDRESS_SPACE_IO);</span><br><span class="line">    Assert(iRegion == 0);</span><br><span class="line">    AssertMsg(RT_ALIGN(GCPhysAddress, 8) == GCPhysAddress, (&quot;Expected 8 byte alignment. GCPhysAddress=%#x\n&quot;, GCPhysAddress));</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">     * Register our port IO handlers.</span><br><span class="line">     */</span><br><span class="line">    int rc = PDMDevHlpIOPortRegister(pDevIns, (RTIOPORT)GCPhysAddress + VMMDEV_PORT_OFF_REQUEST, 1,</span><br><span class="line">                                     pThis, vmmdevRequestHandler, NULL, NULL, NULL, &quot;VMMDev Request Handler&quot;);</span><br></pre></td></tr></table></figure>
<p>因此我们在Guset中的<code>ASMOutU32(g_vbgldata.portVMMDev + VMMDEV_PORT_OFF_REQUEST, (uint32_t)PhysAddr);</code>请求最终被传入到虚拟设备中的<code>vmmdevRequestHandler</code>函数中进行处理。</p>
<h4 id="vmmdevRequestHandler"><a href="#vmmdevRequestHandler" class="headerlink" title="vmmdevRequestHandler"></a>vmmdevRequestHandler</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @callback_method_impl&#123;FNIOMIOPORTOUT,</span><br><span class="line"> * Port I/O write andler for the generic request interface.&#125;</span><br><span class="line"> */</span><br><span class="line">static DECLCALLBACK(int) vmmdevRequestHandler(PPDMDEVINS pDevIns, void *pvUser, RTIOPORT Port, uint32_t u32, unsigned cb)</span><br><span class="line">&#123;</span><br><span class="line">    uint64_t tsArrival;</span><br><span class="line">    STAM_GET_TS(tsArrival);</span><br><span class="line"></span><br><span class="line">    RT_NOREF2(Port, cb);</span><br><span class="line">    PVMMDEV pThis = (VMMDevState *)pvUser;</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">     * The caller has passed the guest context physical address of the request</span><br><span class="line">     * structure. We&#x27;ll copy all of it into a heap buffer eventually, but we</span><br><span class="line">     * will have to start off with the header.</span><br><span class="line">     */</span><br><span class="line">    VMMDevRequestHeader requestHeader;</span><br><span class="line">    RT_ZERO(requestHeader);</span><br><span class="line">    PDMDevHlpPhysRead(pDevIns, (RTGCPHYS)u32, &amp;requestHeader, sizeof(requestHeader));</span><br><span class="line"></span><br><span class="line">.........................................................</span><br><span class="line">            if (pRequestHeader)</span><br><span class="line">            &#123;</span><br><span class="line">                memcpy(pRequestHeader, &amp;requestHeader, sizeof(VMMDevRequestHeader));</span><br><span class="line"></span><br><span class="line">                /* Try lock the request if it&#x27;s a HGCM call and not crossing a page boundrary.</span><br><span class="line">                   Saves on PGM interaction. */</span><br><span class="line">                VMMDEVREQLOCK   Lock   = &#123; NULL, &#123; 0, NULL &#125; &#125;;</span><br><span class="line">                PVMMDEVREQLOCK  pLock  = NULL;</span><br><span class="line">                size_t          cbLeft = requestHeader.size - sizeof(VMMDevRequestHeader);</span><br><span class="line">                if (cbLeft)</span><br><span class="line">                &#123;</span><br><span class="line">                    ...............................</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                /*</span><br><span class="line">                 * Feed buffered request thru the dispatcher.</span><br><span class="line">                 */</span><br><span class="line">                uint32_t fPostOptimize = 0;</span><br><span class="line">                PDMCritSectEnter(&amp;pThis-&gt;CritSect, VERR_IGNORED);</span><br><span class="line">                rcRet = vmmdevReqDispatcher(pThis, pRequestHeader, u32, tsArrival, &amp;fPostOptimize, &amp;pLock);</span><br><span class="line">                PDMCritSectLeave(&amp;pThis-&gt;CritSect);</span><br></pre></td></tr></table></figure>
<p>请求将被传入<code>vmmdevReqDispatcher</code>函数进行调度</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Dispatch the request to the appropriate handler function.</span><br><span class="line"> *</span><br><span class="line"> * @returns Port I/O handler exit code.</span><br><span class="line"> * @param   pThis           The VMM device instance data.</span><br><span class="line"> * @param   pReqHdr         The request header (cached in host memory).</span><br><span class="line"> * @param   GCPhysReqHdr    The guest physical address of the request (for</span><br><span class="line"> *                          HGCM).</span><br><span class="line"> * @param   tsArrival       The STAM_GET_TS() value when the request arrived.</span><br><span class="line"> * @param   pfPostOptimize  HGCM optimizations, VMMDEVREQDISP_POST_F_XXX.</span><br><span class="line"> * @param   ppLock          Pointer to the lock info pointer (latter can be</span><br><span class="line"> *                          NULL).  Set to NULL if HGCM takes lock ownership.</span><br><span class="line"> */</span><br><span class="line">static int vmmdevReqDispatcher(PVMMDEV pThis, VMMDevRequestHeader *pReqHdr, RTGCPHYS GCPhysReqHdr,</span><br><span class="line">                               uint64_t tsArrival, uint32_t *pfPostOptimize, PVMMDEVREQLOCK *ppLock)</span><br><span class="line">&#123;</span><br><span class="line">    int rcRet = VINF_SUCCESS;</span><br><span class="line">    Assert(*pfPostOptimize == 0);</span><br><span class="line"></span><br><span class="line">    switch (pReqHdr-&gt;requestType)</span><br><span class="line">    &#123;</span><br><span class="line">	...........................................</span><br><span class="line">#ifdef VBOX_WITH_HGCM</span><br><span class="line">        case VMMDevReq_HGCMConnect:</span><br><span class="line">            vmmdevReqHdrSetHgcmAsyncExecute(pThis, GCPhysReqHdr, *ppLock);</span><br><span class="line">            pReqHdr-&gt;rc = vmmdevReqHandler_HGCMConnect(pThis, pReqHdr, GCPhysReqHdr);</span><br><span class="line">            Assert(pReqHdr-&gt;rc == VINF_HGCM_ASYNC_EXECUTE || RT_FAILURE_NP(pReqHdr-&gt;rc));</span><br><span class="line">            if (RT_SUCCESS(pReqHdr-&gt;rc))</span><br><span class="line">                *pfPostOptimize |= VMMDEVREQDISP_POST_F_NO_WRITE_OUT;</span><br><span class="line">            break;</span><br><span class="line"></span><br><span class="line">        case VMMDevReq_HGCMDisconnect:</span><br><span class="line">            vmmdevReqHdrSetHgcmAsyncExecute(pThis, GCPhysReqHdr, *ppLock);</span><br><span class="line">            pReqHdr-&gt;rc = vmmdevReqHandler_HGCMDisconnect(pThis, pReqHdr, GCPhysReqHdr);</span><br><span class="line">            Assert(pReqHdr-&gt;rc == VINF_HGCM_ASYNC_EXECUTE || RT_FAILURE_NP(pReqHdr-&gt;rc));</span><br><span class="line">            if (RT_SUCCESS(pReqHdr-&gt;rc))</span><br><span class="line">                *pfPostOptimize |= VMMDEVREQDISP_POST_F_NO_WRITE_OUT;</span><br><span class="line">            break;</span><br><span class="line"></span><br><span class="line"># ifdef VBOX_WITH_64_BITS_GUESTS</span><br><span class="line">        case VMMDevReq_HGCMCall64:</span><br><span class="line"># endif</span><br><span class="line">        case VMMDevReq_HGCMCall32:</span><br><span class="line">            vmmdevReqHdrSetHgcmAsyncExecute(pThis, GCPhysReqHdr, *ppLock);</span><br><span class="line">            pReqHdr-&gt;rc = vmmdevReqHandler_HGCMCall(pThis, pReqHdr, GCPhysReqHdr, tsArrival, ppLock);</span><br><span class="line">            Assert(pReqHdr-&gt;rc == VINF_HGCM_ASYNC_EXECUTE || RT_FAILURE_NP(pReqHdr-&gt;rc));</span><br><span class="line">            if (RT_SUCCESS(pReqHdr-&gt;rc))</span><br><span class="line">                *pfPostOptimize |= VMMDEVREQDISP_POST_F_NO_WRITE_OUT;</span><br><span class="line">            break;</span><br><span class="line"></span><br><span class="line">        case VMMDevReq_HGCMCancel:</span><br><span class="line">            pReqHdr-&gt;rc = vmmdevReqHandler_HGCMCancel(pThis, pReqHdr, GCPhysReqHdr);</span><br><span class="line">            break;</span><br><span class="line"></span><br><span class="line">        case VMMDevReq_HGCMCancel2:</span><br><span class="line">            pReqHdr-&gt;rc = vmmdevReqHandler_HGCMCancel2(pThis, pReqHdr);</span><br><span class="line">            break;</span><br><span class="line">#endif /* VBOX_WITH_HGCM */</span><br><span class="line">...........................................</span><br></pre></td></tr></table></figure>
<p>在<code>VMMDevReq_HGCMConnect</code>时，使用<code>vmmdevReqHdrSetHgcmAsyncExecute</code>函数设置异步返回值，这样Guset系统驱动的<code>VbglR0HGCMInternalConnect</code>函数时将通过<code>pfnAsyncCallback(&amp;pHGCMConnect-&gt;header, pvAsyncData, u32AsyncData);</code>等待设备这里的操作完成并获取结果；设备这里将调用<code>vmmdevReqHandler_HGCMConnect</code>连接HGCM服务，继续跟踪，</p>
<h4 id="vmmdevReqHandler-HGCMConnect"><a href="#vmmdevReqHandler-HGCMConnect" class="headerlink" title="vmmdevReqHandler_HGCMConnect"></a>vmmdevReqHandler_HGCMConnect</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">/** Handle VMMDevHGCMConnect request.</span><br><span class="line"> *</span><br><span class="line"> * @param   pThis           The VMMDev instance data.</span><br><span class="line"> * @param   pHGCMConnect    The guest request (cached in host memory).</span><br><span class="line"> * @param   GCPhys          The physical address of the request.</span><br><span class="line"> */</span><br><span class="line">int vmmdevHGCMConnect(PVMMDEV pThis, const VMMDevHGCMConnect *pHGCMConnect, RTGCPHYS GCPhys)</span><br><span class="line">&#123;</span><br><span class="line">    int rc = VINF_SUCCESS;</span><br><span class="line"></span><br><span class="line">    PVBOXHGCMCMD pCmd = vmmdevHGCMCmdAlloc(pThis, VBOXHGCMCMDTYPE_CONNECT, GCPhys, pHGCMConnect-&gt;header.header.size, 0,</span><br><span class="line">                                           pHGCMConnect-&gt;header.header.fRequestor);</span><br><span class="line">    if (pCmd)</span><br><span class="line">    &#123;</span><br><span class="line">        vmmdevHGCMConnectFetch(pHGCMConnect, pCmd);</span><br><span class="line"></span><br><span class="line">        /* Only allow the guest to use existing services! */</span><br><span class="line">        ASSERT_GUEST(pHGCMConnect-&gt;loc.type == VMMDevHGCMLoc_LocalHost_Existing);</span><br><span class="line">        pCmd-&gt;u.connect.pLoc-&gt;type = VMMDevHGCMLoc_LocalHost_Existing;</span><br><span class="line"></span><br><span class="line">        vmmdevHGCMAddCommand(pThis, pCmd);</span><br><span class="line">        rc = pThis-&gt;pHGCMDrv-&gt;pfnConnect(pThis-&gt;pHGCMDrv, pCmd, pCmd-&gt;u.connect.pLoc, &amp;pCmd-&gt;u.connect.u32ClientID);</span><br><span class="line">        if (RT_FAILURE(rc))</span><br><span class="line">            vmmdevHGCMRemoveCommand(pThis, pCmd);</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        rc = VERR_NO_MEMORY;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return rc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数中主要是调用了<code>rc = pThis-&gt;pHGCMDrv-&gt;pfnConnect(pThis-&gt;pHGCMDrv, pCmd, pCmd-&gt;u.connect.pLoc, &amp;pCmd-&gt;u.connect.u32ClientID);</code>进行服务连接，其中pThis在<code>vmmdevIOPortRegionMap</code>函数中初始化</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PVMMDEV pThis = RT_FROM_MEMBER(pPciDev, VMMDEV, PciDev);</span><br></pre></td></tr></table></figure>
<p>pThis-&gt;pHGCMDrv在<code>vmmdevConstruct</code>函数中被初始化</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pThis-&gt;pHGCMDrv = PDMIBASE_QUERY_INTERFACE(pThis-&gt;pDrvBase, PDMIHGCMCONNECTOR);</span><br></pre></td></tr></table></figure>
<p>通过调试，可以知道<code>pThis-&gt;pHGCMDrv-&gt;pfnConnect</code>最终指向的是<code>iface_hgcmConnect</code>函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">In file: /home/sea/Desktop/VirtualBox-6.0.0/src/VBox/Devices/VMMDev/VMMDevHGCM.cpp</span><br><span class="line">   450         /* Only allow the guest to use existing services! */</span><br><span class="line">   451         ASSERT_GUEST(pHGCMConnect-&gt;loc.type == VMMDevHGCMLoc_LocalHost_Existing);</span><br><span class="line">   452         pCmd-&gt;u.connect.pLoc-&gt;type = VMMDevHGCMLoc_LocalHost_Existing;</span><br><span class="line">   453 </span><br><span class="line">   454         vmmdevHGCMAddCommand(pThis, pCmd);</span><br><span class="line"> ► 455         rc = pThis-&gt;pHGCMDrv-&gt;pfnConnect(pThis-&gt;pHGCMDrv, pCmd, pCmd-&gt;u.connect.pLoc, &amp;pCmd-&gt;u.connect.u32ClientID);</span><br><span class="line">   456         if (RT_FAILURE(rc))</span><br><span class="line">   457             vmmdevHGCMRemoveCommand(pThis, pCmd);</span><br><span class="line">   458     &#125;</span><br><span class="line">   459     else</span><br><span class="line">   460     &#123;</span><br><span class="line">pwndbg&gt; s</span><br><span class="line">   599 /* HGCM connector interface */</span><br><span class="line">   600 </span><br><span class="line">   601 static DECLCALLBACK(int) iface_hgcmConnect(PPDMIHGCMCONNECTOR pInterface, PVBOXHGCMCMD pCmd,</span><br><span class="line">   602                                            PHGCMSERVICELOCATION pServiceLocation,</span><br><span class="line">   603                                            uint32_t *pu32ClientID)</span><br><span class="line"> ► 604 &#123;</span><br></pre></td></tr></table></figure>
<p>其中iface_hgcmConnect函数源码如下</p>
<h4 id="iface-hgcmConnect"><a href="#iface-hgcmConnect" class="headerlink" title="iface_hgcmConnect"></a>iface_hgcmConnect</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">static DECLCALLBACK(int) iface_hgcmConnect(PPDMIHGCMCONNECTOR pInterface, PVBOXHGCMCMD pCmd,</span><br><span class="line">                                           PHGCMSERVICELOCATION pServiceLocation,</span><br><span class="line">                                           uint32_t *pu32ClientID)</span><br><span class="line">&#123;</span><br><span class="line">    Log9((&quot;Enter\n&quot;));</span><br><span class="line"></span><br><span class="line">    PDRVMAINVMMDEV pDrv = RT_FROM_MEMBER(pInterface, DRVMAINVMMDEV, HGCMConnector);</span><br><span class="line"></span><br><span class="line">    if (    !pServiceLocation</span><br><span class="line">        || (   pServiceLocation-&gt;type != VMMDevHGCMLoc_LocalHost</span><br><span class="line">            &amp;&amp; pServiceLocation-&gt;type != VMMDevHGCMLoc_LocalHost_Existing))</span><br><span class="line">    &#123;</span><br><span class="line">        return VERR_INVALID_PARAMETER;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* Check if service name is a string terminated by zero*/</span><br><span class="line">    size_t cchInfo = 0;</span><br><span class="line">    if (RTStrNLenEx(pServiceLocation-&gt;u.host.achName, sizeof(pServiceLocation-&gt;u.host.achName), &amp;cchInfo) != VINF_SUCCESS)</span><br><span class="line">    &#123;</span><br><span class="line">        return VERR_INVALID_PARAMETER;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (!pDrv-&gt;pVMMDev || !pDrv-&gt;pVMMDev-&gt;hgcmIsActive())</span><br><span class="line">        return VERR_INVALID_STATE;</span><br><span class="line">    return HGCMGuestConnect(pDrv-&gt;pHGCMPort, pCmd, pServiceLocation-&gt;u.host.achName, pu32ClientID);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里，对于<code>pServiceLocation-&gt;type</code>字段，其值必须为<code>VMMDevHGCMLoc_LocalHost</code>或者<code>VMMDevHGCMLoc_LocalHost_Existing</code>。检查通过以后，就会继续调用<code>HGCMGuestConnect</code>函数<br>而<code>HGCMGuestConnect</code>函数是将数据封装为消息，然后调用<code>hgcmMsgPost</code>，<code>hgcmMsgPost</code>最后会调用<code>hgcmMsgPostInternal</code>函数向<code>HGCMThread</code>实例发送消息</p>
<h4 id="hgcmMsgPostInternal"><a href="#hgcmMsgPostInternal" class="headerlink" title="hgcmMsgPostInternal"></a>hgcmMsgPostInternal</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">DECLINLINE(int) hgcmMsgPostInternal(HGCMMsgCore *pMsg, PHGCMMSGCALLBACK pfnCallback, bool fWait)</span><br><span class="line">&#123;</span><br><span class="line">    LogFlow((&quot;MAIN::hgcmMsgPostInternal: pMsg = %p, pfnCallback = %p, fWait = %d\n&quot;, pMsg, pfnCallback, fWait));</span><br><span class="line">    Assert(pMsg);</span><br><span class="line"></span><br><span class="line">    pMsg-&gt;Reference(); /* paranoia? */</span><br><span class="line"></span><br><span class="line">    int rc = pMsg-&gt;Thread()-&gt;MsgPost(pMsg, pfnCallback, fWait);</span><br><span class="line"></span><br><span class="line">    pMsg-&gt;Dereference();</span><br><span class="line"></span><br><span class="line">    LogFlow((&quot;MAIN::hgcmMsgPostInternal: pMsg = %p, rc = %Rrc\n&quot;, pMsg, rc));</span><br><span class="line">    return rc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过gdb调试</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">In file: /home/sea/Desktop/VirtualBox-6.0.0/src/VBox/Main/src-client/HGCMThread.cpp</span><br><span class="line">   697     LogFlow((&quot;MAIN::hgcmMsgPostInternal: pMsg = %p, pfnCallback = %p, fWait = %d\n&quot;, pMsg, pfnCallback, fWait));</span><br><span class="line">   698     Assert(pMsg);</span><br><span class="line">   699 </span><br><span class="line">   700     pMsg-&gt;Reference(); /* paranoia? */</span><br><span class="line">   701 </span><br><span class="line"> ► 702     int rc = pMsg-&gt;Thread()-&gt;MsgPost(pMsg, pfnCallback, fWait);</span><br><span class="line">   703 </span><br><span class="line">   704     pMsg-&gt;Dereference();</span><br><span class="line">   705 </span><br><span class="line">   706     LogFlow((&quot;MAIN::hgcmMsgPostInternal: pMsg = %p, rc = %Rrc\n&quot;, pMsg, rc));</span><br><span class="line">   707     return rc;</span><br><span class="line">pwndbg&gt; p pMsg-&gt;Thread()-&gt;MsgPost</span><br><span class="line">$11 = &#123;int (HGCMThread * const, HGCMMsgCore *, PHGCMMSGCALLBACK, bool)&#125; 0x7fe5d8646a5c &lt;HGCMThread::MsgPost(HGCMMsgCore*, int (*)(int, HGCMMsgCore*), bool)&gt;</span><br></pre></td></tr></table></figure>
<p>HGCMThread::MsgPost函数只是简单的将消息插入到消息队列，当HGCMThread的线程取出消息时，便会进行处理。HGCMThread的主线程函数为<code>hgcmThread</code></p>
<h4 id="hgcmThread"><a href="#hgcmThread" class="headerlink" title="hgcmThread"></a>hgcmThread</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">/* The main HGCM thread handler. */</span><br><span class="line">static DECLCALLBACK(void) hgcmThread(HGCMThread *pThread, void *pvUser)</span><br><span class="line">&#123;</span><br><span class="line">    LogFlowFunc((&quot;pThread = %p, pvUser = %p\n&quot;, pThread, pvUser));</span><br><span class="line"></span><br><span class="line">    NOREF(pvUser);</span><br><span class="line"></span><br><span class="line">    bool fQuit = false;</span><br><span class="line"></span><br><span class="line">    while (!fQuit)</span><br><span class="line">    &#123;</span><br><span class="line">        HGCMMsgCore *pMsgCore;</span><br><span class="line">        int rc = hgcmMsgGet(pThread, &amp;pMsgCore);</span><br><span class="line"></span><br><span class="line">        if (RT_FAILURE(rc))</span><br><span class="line">        &#123;</span><br><span class="line">            /* The error means some serious unrecoverable problem in the hgcmMsg/hgcmThread layer. */</span><br><span class="line">            AssertMsgFailed((&quot;%Rrc\n&quot;, rc));</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        uint32_t u32MsgId = pMsgCore-&gt;MsgId();</span><br><span class="line"></span><br><span class="line">        switch (u32MsgId)</span><br><span class="line">        &#123;</span><br><span class="line">            case HGCM_MSG_CONNECT:</span><br><span class="line">            &#123;</span><br><span class="line">                HGCMMsgMainConnect *pMsg = (HGCMMsgMainConnect *)pMsgCore;</span><br><span class="line"></span><br><span class="line">                LogFlowFunc((&quot;HGCM_MSG_CONNECT pszServiceName %s, pu32ClientId %p\n&quot;,</span><br><span class="line">                             pMsg-&gt;pszServiceName, pMsg-&gt;pu32ClientId));</span><br><span class="line"></span><br><span class="line">                /* Resolve the service name to the pointer to service instance.</span><br><span class="line">                 */</span><br><span class="line">                HGCMService *pService;</span><br><span class="line">                rc = HGCMService::ResolveService(&amp;pService, pMsg-&gt;pszServiceName);</span><br><span class="line"></span><br><span class="line">                if (RT_SUCCESS(rc))</span><br><span class="line">                &#123;</span><br><span class="line">                    /* Call the service instance method. */</span><br><span class="line">                    rc = pService-&gt;CreateAndConnectClient(pMsg-&gt;pu32ClientId,</span><br><span class="line">                                                          0,</span><br><span class="line">                                                          pMsg-&gt;pHGCMPort-&gt;pfnGetRequestor(pMsg-&gt;pHGCMPort, pMsg-&gt;pCmd),</span><br><span class="line">                                                          pMsg-&gt;pHGCMPort-&gt;pfnIsCmdRestored(pMsg-&gt;pHGCMPort, pMsg-&gt;pCmd));</span><br><span class="line"></span><br><span class="line">                    /* Release the service after resolve. */</span><br><span class="line">                    pService-&gt;ReleaseService();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; break;</span><br><span class="line"></span><br><span class="line">            case HGCM_MSG_DISCONNECT:</span><br><span class="line">            &#123;</span><br></pre></td></tr></table></figure>
<p>当收到<code>HGCM_MSG_CONNECT</code>消息时，调用<code>HGCMService::ResolveService(&amp;pService, pMsg-&gt;pszServiceName)</code>得到对应服务的句柄，该函数实际上就是一个链表查找的过程</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">/** The method obtains a referenced pointer to the service with</span><br><span class="line"> *  specified name. The caller must call ReleaseService when</span><br><span class="line"> *  the pointer is no longer needed.</span><br><span class="line"> *</span><br><span class="line"> * @param ppSvc          Where to store the pointer to the service.</span><br><span class="line"> * @param pszServiceName The name of the service.</span><br><span class="line"> * @return VBox rc.</span><br><span class="line"> * @thread main HGCM</span><br><span class="line"> */</span><br><span class="line">/* static */ int HGCMService::ResolveService(HGCMService **ppSvc, const char *pszServiceName)</span><br><span class="line">&#123;</span><br><span class="line">    LogFlowFunc((&quot;ppSvc = %p name = %s\n&quot;,</span><br><span class="line">                 ppSvc, pszServiceName));</span><br><span class="line"></span><br><span class="line">    if (!ppSvc || !pszServiceName)</span><br><span class="line">    &#123;</span><br><span class="line">        return VERR_INVALID_PARAMETER;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    HGCMService *pSvc = sm_pSvcListHead;</span><br><span class="line"></span><br><span class="line">    while (pSvc)</span><br><span class="line">    &#123;</span><br><span class="line">        if (strcmp(pSvc-&gt;m_pszSvcName, pszServiceName) == 0)</span><br><span class="line">        &#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        pSvc = pSvc-&gt;m_pSvcNext;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    LogFlowFunc((&quot;lookup in the list is %p\n&quot;, pSvc));</span><br><span class="line"></span><br><span class="line">    if (pSvc == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        *ppSvc = NULL;</span><br><span class="line">        return VERR_HGCM_SERVICE_NOT_FOUND;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pSvc-&gt;ReferenceService();</span><br><span class="line"></span><br><span class="line">    *ppSvc = pSvc;</span><br><span class="line"></span><br><span class="line">    return VINF_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而该服务链表是在<code>HGCM_MSG_LOAD</code>时通过<code>LoadService</code>初始化的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">case HGCM_MSG_LOAD:</span><br><span class="line">&#123;</span><br><span class="line">    HGCMMsgMainLoad *pMsg = (HGCMMsgMainLoad *)pMsgCore;</span><br><span class="line"></span><br><span class="line">    LogFlowFunc((&quot;HGCM_MSG_LOAD pszServiceName = %s, pMsg-&gt;pszServiceLibrary = %s, pMsg-&gt;pUVM = %p\n&quot;,</span><br><span class="line">                 pMsg-&gt;pszServiceName, pMsg-&gt;pszServiceLibrary, pMsg-&gt;pUVM));</span><br><span class="line"></span><br><span class="line">    rc = HGCMService::LoadService(pMsg-&gt;pszServiceLibrary, pMsg-&gt;pszServiceName, pMsg-&gt;pUVM, pMsg-&gt;pHgcmPort);</span><br><span class="line">&#125; break;</span><br></pre></td></tr></table></figure>
<p>其中<code>LoadService</code>函数就是加载对应的名称的<code>动态库</code>，然后将句柄存储到链表中。<br>ResolveService得到服务模块句柄以后，就通过<code>CreateAndConnectClient</code>函数调用模块中初始化的函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">if (RT_SUCCESS(rc))</span><br><span class="line">&#123;</span><br><span class="line">    /* Call the service instance method. */</span><br><span class="line">    rc = pService-&gt;CreateAndConnectClient(pMsg-&gt;pu32ClientId,</span><br><span class="line">                                          0,</span><br><span class="line">                                          pMsg-&gt;pHGCMPort-&gt;pfnGetRequestor(pMsg-&gt;pHGCMPort, pMsg-&gt;pCmd),</span><br><span class="line">                                          pMsg-&gt;pHGCMPort-&gt;pfnIsCmdRestored(pMsg-&gt;pHGCMPort, pMsg-&gt;pCmd));</span><br><span class="line"></span><br><span class="line">    /* Release the service after resolve. */</span><br><span class="line">    pService-&gt;ReleaseService();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>CreateAndConnectClient函数如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line">/* Create a new client instance and connect it to the service.</span><br><span class="line"> *</span><br><span class="line"> * @param pu32ClientIdOut If not NULL, then the method must generate a new handle for the client.</span><br><span class="line"> *                        If NULL, use the given &#x27;u32ClientIdIn&#x27; handle.</span><br><span class="line"> * @param u32ClientIdIn   The handle for the client, when &#x27;pu32ClientIdOut&#x27; is NULL.</span><br><span class="line"> * @param fRequestor      The requestor flags, VMMDEV_REQUESTOR_LEGACY if not available.</span><br><span class="line"> * @param fRestoring      Set if we&#x27;re restoring a saved state.</span><br><span class="line"> * @return VBox status code.</span><br><span class="line"> */</span><br><span class="line">int HGCMService::CreateAndConnectClient(uint32_t *pu32ClientIdOut, uint32_t u32ClientIdIn, uint32_t fRequestor, bool fRestoring)</span><br><span class="line">&#123;</span><br><span class="line">    LogFlowFunc((&quot;pu32ClientIdOut = %p, u32ClientIdIn = %d, fRequestor = %#x, fRestoring = %d\n&quot;,</span><br><span class="line">                 pu32ClientIdOut, u32ClientIdIn, fRequestor, fRestoring));</span><br><span class="line"></span><br><span class="line">    /* Allocate a client information structure. */</span><br><span class="line">    HGCMClient *pClient = new (std::nothrow) HGCMClient(fRequestor);</span><br><span class="line"></span><br><span class="line">    if (!pClient)</span><br><span class="line">    &#123;</span><br><span class="line">        Log1WarningFunc((&quot;Could not allocate HGCMClient!!!\n&quot;));</span><br><span class="line">        return VERR_NO_MEMORY;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    uint32_t handle;</span><br><span class="line"></span><br><span class="line">    if (pu32ClientIdOut != NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        handle = hgcmObjGenerateHandle(pClient);</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        handle = hgcmObjAssignHandle(pClient, u32ClientIdIn);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    LogFlowFunc((&quot;client id = %d\n&quot;, handle));</span><br><span class="line"></span><br><span class="line">    AssertRelease(handle);</span><br><span class="line"></span><br><span class="line">    /* Initialize the HGCM part of the client. */</span><br><span class="line">    int rc = pClient-&gt;Init(this);</span><br><span class="line"></span><br><span class="line">    if (RT_SUCCESS(rc))</span><br><span class="line">    &#123;</span><br><span class="line">        /* Call the service. */</span><br><span class="line">        HGCMMsgCore *pCoreMsg;</span><br><span class="line"></span><br><span class="line">        rc = hgcmMsgAlloc(m_pThread, &amp;pCoreMsg, SVC_MSG_CONNECT, hgcmMessageAllocSvc);</span><br><span class="line"></span><br><span class="line">        if (RT_SUCCESS(rc))</span><br><span class="line">        &#123;</span><br><span class="line">            HGCMMsgSvcConnect *pMsg = (HGCMMsgSvcConnect *)pCoreMsg;</span><br><span class="line"></span><br><span class="line">            pMsg-&gt;u32ClientId = handle;</span><br><span class="line">            pMsg-&gt;fRequestor = fRequestor;</span><br><span class="line">            pMsg-&gt;fRestoring = fRestoring;</span><br><span class="line"></span><br><span class="line">            rc = hgcmMsgSend(pMsg);</span><br><span class="line"></span><br><span class="line">            if (RT_SUCCESS(rc))</span><br><span class="line">            &#123;</span><br><span class="line">                /* Add the client Id to the array. */</span><br><span class="line">                if (m_cClients == m_cClientsAllocated)</span><br><span class="line">                &#123;</span><br><span class="line">                    const uint32_t cDelta = 64;</span><br><span class="line"></span><br><span class="line">                    /* Guards against integer overflow on 32bit arch and also limits size of m_paClientIds array to 4GB*/</span><br><span class="line">                    if (m_cClientsAllocated &lt; UINT32_MAX / sizeof(m_paClientIds[0]) - cDelta)</span><br><span class="line">                    &#123;</span><br><span class="line">                        uint32_t *paClientIdsNew;</span><br><span class="line"></span><br><span class="line">                        paClientIdsNew = (uint32_t *)RTMemRealloc(m_paClientIds,</span><br><span class="line">                                                                  (m_cClientsAllocated + cDelta) * sizeof(m_paClientIds[0]));</span><br><span class="line">                        Assert(paClientIdsNew);</span><br><span class="line"></span><br><span class="line">                        if (paClientIdsNew)</span><br><span class="line">                        &#123;</span><br><span class="line">                            m_paClientIds = paClientIdsNew;</span><br><span class="line">                            m_cClientsAllocated += cDelta;</span><br><span class="line">                        &#125;</span><br><span class="line">                        else</span><br><span class="line">                        &#123;</span><br><span class="line">                            rc = VERR_NO_MEMORY;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    else</span><br><span class="line">                    &#123;</span><br><span class="line">                        rc = VERR_NO_MEMORY;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                m_paClientIds[m_cClients] = handle;</span><br><span class="line">                m_cClients++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (RT_FAILURE(rc))</span><br><span class="line">    &#123;</span><br><span class="line">        hgcmObjDeleteHandle(handle);</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        if (pu32ClientIdOut != NULL)</span><br><span class="line">        &#123;</span><br><span class="line">            *pu32ClientIdOut = handle;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ReferenceService();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    LogFlowFunc((&quot;rc = %Rrc\n&quot;, rc));</span><br><span class="line">    return rc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以知道，模块的id值最终被存入<code>m_paClientIds[m_cClients]</code>，同时通过<code> *pu32ClientIdOut = handle;</code>将值返回。<br>整个过程大概描述如下<br><img src="https://p4.ssl.qhimg.com/t014e8eb668bcd7d8e6.png"></p>
<h3 id="VBGL-IOCTL-HGCM-CALL"><a href="#VBGL-IOCTL-HGCM-CALL" class="headerlink" title="VBGL_IOCTL_HGCM_CALL"></a>VBGL_IOCTL_HGCM_CALL</h3><p>在分析完<code>VBGL_IOCTL_HGCM_CONNECT</code>操作以后，接下来就是分析<code>VBGL_IOCTL_HGCM_CALL</code>，其路线与前面分析的类似，首先会将IOCTL传入的数据指针转为<code>PVBGLIOCHGCMCALL</code>类型</p>
<h4 id="PVBGLIOCHGCMCALL"><a href="#PVBGLIOCHGCMCALL" class="headerlink" title="PVBGLIOCHGCMCALL"></a>PVBGLIOCHGCMCALL</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * For VBGL_IOCTL_HGCM_CALL and VBGL_IOCTL_HGCM_CALL_WITH_USER_DATA.</span><br><span class="line"> *</span><br><span class="line"> * @note This is used by alot of HGCM call structures.</span><br><span class="line"> */</span><br><span class="line">typedef struct VBGLIOCHGCMCALL</span><br><span class="line">&#123;</span><br><span class="line">    /** Common header. */</span><br><span class="line">    VBGLREQHDR  Hdr;</span><br><span class="line">    /** Input: The id of the caller. */</span><br><span class="line">    uint32_t    u32ClientID;</span><br><span class="line">    /** Input: Function number. */</span><br><span class="line">    uint32_t    u32Function;</span><br><span class="line">    /** Input: How long to wait (milliseconds) for completion before cancelling the</span><br><span class="line">     * call.  This is ignored if not a VBGL_IOCTL_HGCM_CALL_TIMED or</span><br><span class="line">     * VBGL_IOCTL_HGCM_CALL_TIMED_32 request. */</span><br><span class="line">    uint32_t    cMsTimeout;</span><br><span class="line">    /** Input: Whether a timed call is interruptible (ring-0 only).  This is ignored</span><br><span class="line">     * if not a VBGL_IOCTL_HGCM_CALL_TIMED or VBGL_IOCTL_HGCM_CALL_TIMED_32</span><br><span class="line">     * request, or if made from user land. */</span><br><span class="line">    bool        fInterruptible;</span><br><span class="line">    /** Explicit padding, MBZ. */</span><br><span class="line">    uint8_t     bReserved;</span><br><span class="line">    /** Input: How many parameters following this structure.</span><br><span class="line">     *</span><br><span class="line">     * The parameters are either HGCMFunctionParameter64 or HGCMFunctionParameter32,</span><br><span class="line">     * depending on whether we&#x27;re receiving a 64-bit or 32-bit request.</span><br><span class="line">     *</span><br><span class="line">     * The current maximum is 61 parameters (given a 1KB max request size,</span><br><span class="line">     * and a 64-bit parameter size of 16 bytes).</span><br><span class="line">     *</span><br><span class="line">     * @note This information is duplicated by Hdr.cbIn, but it&#x27;s currently too much</span><br><span class="line">     *       work to eliminate this. */</span><br><span class="line">    uint16_t    cParms;</span><br><span class="line">    /* Parameters follow in form HGCMFunctionParameter aParms[cParms] */</span><br><span class="line">&#125; VBGLIOCHGCMCALL, RT_FAR *PVBGLIOCHGCMCALL;</span><br></pre></td></tr></table></figure>
<p>经过一些列调用，会来到<code>vgdrvIoCtl_HGCMCallInner</code>函数</p>
<h4 id="vgdrvIoCtl-HGCMCallInner"><a href="#vgdrvIoCtl-HGCMCallInner" class="headerlink" title="vgdrvIoCtl_HGCMCallInner"></a>vgdrvIoCtl_HGCMCallInner</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">static int vgdrvIoCtl_HGCMCallInner(PVBOXGUESTDEVEXT pDevExt, PVBOXGUESTSESSION pSession, PVBGLIOCHGCMCALL pInfo,</span><br><span class="line">                                    uint32_t cMillies, bool fInterruptible, bool f32bit, bool fUserData,</span><br><span class="line">                                    size_t cbExtra, size_t cbData)</span><br><span class="line">&#123;</span><br><span class="line">    const uint32_t  u32ClientId = pInfo-&gt;u32ClientID;</span><br><span class="line">    uint32_t        fFlags;</span><br><span class="line">    size_t          cbActual;</span><br><span class="line">    unsigned        i;</span><br><span class="line">    int             rc;</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">     * Some more validations.</span><br><span class="line">     */</span><br><span class="line">    if (RT_LIKELY(pInfo-&gt;cParms &lt;= VMMDEV_MAX_HGCM_PARMS)) /* (Just make sure it doesn&#x27;t overflow the next check.) */</span><br><span class="line">    &#123; /* likely */&#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        LogRel((&quot;VBOXGUEST_IOCTL_HGCM_CALL: cParm=%RX32 is not sane\n&quot;, pInfo-&gt;cParms));</span><br><span class="line">        return VERR_INVALID_PARAMETER;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cbActual = cbExtra + sizeof(*pInfo);</span><br><span class="line">#ifdef RT_ARCH_AMD64</span><br><span class="line">    if (f32bit)</span><br><span class="line">        cbActual += pInfo-&gt;cParms * sizeof(HGCMFunctionParameter32);</span><br><span class="line">    else</span><br><span class="line">#endif</span><br><span class="line">        cbActual += pInfo-&gt;cParms * sizeof(HGCMFunctionParameter);</span><br><span class="line">    if (RT_LIKELY(cbData &gt;= cbActual))</span><br><span class="line">    &#123; /* likely */&#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        LogRel((&quot;VBOXGUEST_IOCTL_HGCM_CALL: cbData=%#zx (%zu) required size is %#zx (%zu)\n&quot;,</span><br><span class="line">               cbData, cbData, cbActual, cbActual));</span><br><span class="line">        return VERR_INVALID_PARAMETER;</span><br><span class="line">    &#125;</span><br><span class="line">    pInfo-&gt;Hdr.cbOut = (uint32_t)cbActual;</span><br><span class="line"></span><br><span class="line"> ........................................................</span><br><span class="line"></span><br><span class="line">        else</span><br><span class="line">            rc = VbglR0HGCMInternalCall(pInfo, cbInfo, fFlags, pSession-&gt;fRequestor,</span><br><span class="line">                                        vgdrvHgcmAsyncWaitCallback, pDevExt, cMillies);</span><br><span class="line">    &#125;</span><br><span class="line">.............................................................</span><br><span class="line">    return rc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从中可以看到<code>cbActual += pInfo-&gt;cParms * sizeof(HGCMFunctionParameter);</code>，并且该值最后赋值<code>pInfo-&gt;Hdr.cbOut = (uint32_t)cbActual;</code>，由此可见<code>pInfo-&gt;cParms</code>代表需要调用的函数的参数个数，而pInfo结构体下方就是cParms个<code>HGCMFunctionParameter</code>结构体对象。与<code>VBGL_IOCTL_HGCM_CONNECT</code>类似，最后驱动也是通过<code>IO端口操作</code>将数据发送到Host中的虚拟设备中，然后在设备的<code>vmmdevReqDispatcher</code>函数中处理。<br>如下代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># ifdef VBOX_WITH_64_BITS_GUESTS</span><br><span class="line">        case VMMDevReq_HGCMCall64:</span><br><span class="line"># endif</span><br><span class="line">        case VMMDevReq_HGCMCall32:</span><br><span class="line">            vmmdevReqHdrSetHgcmAsyncExecute(pThis, GCPhysReqHdr, *ppLock);</span><br><span class="line">            pReqHdr-&gt;rc = vmmdevReqHandler_HGCMCall(pThis, pReqHdr, GCPhysReqHdr, tsArrival, ppLock);</span><br><span class="line">            Assert(pReqHdr-&gt;rc == VINF_HGCM_ASYNC_EXECUTE || RT_FAILURE_NP(pReqHdr-&gt;rc));</span><br><span class="line">            if (RT_SUCCESS(pReqHdr-&gt;rc))</span><br><span class="line">                *pfPostOptimize |= VMMDEVREQDISP_POST_F_NO_WRITE_OUT;</span><br><span class="line">            break;</span><br></pre></td></tr></table></figure>
<p>该操作仍然是异步处理，需要等待处理完成后回调函数响应，将结果通过IO端口传回Guest。操作主要是调用<code>vmmdevHGCMCall</code>来对相应的service里的函数进行调用。</p>
<h4 id="vmmdevHGCMCall"><a href="#vmmdevHGCMCall" class="headerlink" title="vmmdevHGCMCall"></a>vmmdevHGCMCall</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Handles VMMDevHGCMCall request.</span><br><span class="line"> *</span><br><span class="line"> * @returns VBox status code that the guest should see.</span><br><span class="line"> * @param   pThis           The VMMDev instance data.</span><br><span class="line"> * @param   pHGCMCall       The request to handle (cached in host memory).</span><br><span class="line"> * @param   cbHGCMCall      Size of the entire request (including HGCM parameters).</span><br><span class="line"> * @param   GCPhys          The guest physical address of the request.</span><br><span class="line"> * @param   enmRequestType  The request type. Distinguishes 64 and 32 bit calls.</span><br><span class="line"> * @param   tsArrival       The STAM_GET_TS() value when the request arrived.</span><br><span class="line"> * @param   ppLock          Pointer to the lock info pointer (latter can be</span><br><span class="line"> *                          NULL).  Set to NULL if HGCM takes lock ownership.</span><br><span class="line"> */</span><br><span class="line">int vmmdevHGCMCall(PVMMDEV pThis, const VMMDevHGCMCall *pHGCMCall, uint32_t cbHGCMCall, RTGCPHYS GCPhys,</span><br><span class="line">                   VMMDevRequestType enmRequestType, uint64_t tsArrival, PVMMDEVREQLOCK *ppLock)</span><br><span class="line">&#123;</span><br><span class="line">.............................................................</span><br><span class="line">        rc = vmmdevHGCMCallFetchGuestParms(pThis, pCmd, pHGCMCall, cbHGCMCall, enmRequestType, cbHGCMParmStruct);</span><br><span class="line">        if (RT_SUCCESS(rc))</span><br><span class="line">        &#123;</span><br><span class="line">            /* Copy guest data to host parameters, so HGCM services can use the data. */</span><br><span class="line">            rc = vmmdevHGCMInitHostParameters(pThis, pCmd, (uint8_t const *)pHGCMCall);</span><br><span class="line">            if (RT_SUCCESS(rc))</span><br><span class="line">            &#123;</span><br><span class="line">                /*</span><br><span class="line">                 * Pass the function call to HGCM connector for actual processing</span><br><span class="line">                 */</span><br><span class="line">                vmmdevHGCMAddCommand(pThis, pCmd);</span><br><span class="line"></span><br><span class="line">#if 0 /* DONT ENABLE - for performance hacking. */</span><br><span class="line">                if (    pCmd-&gt;u.call.u32Function == 9</span><br><span class="line">                    &amp;&amp;  pCmd-&gt;u.call.cParms      == 5)</span><br><span class="line">                &#123;</span><br><span class="line">                    vmmdevHGCMRemoveCommand(pThis, pCmd);</span><br><span class="line"></span><br><span class="line">                    if (pCmd-&gt;pvReqLocked)</span><br><span class="line">                    &#123;</span><br><span class="line">                        VMMDevHGCMRequestHeader volatile *pHeader = (VMMDevHGCMRequestHeader volatile *)pCmd-&gt;pvReqLocked;</span><br><span class="line">                        pHeader-&gt;header.rc = VINF_SUCCESS;</span><br><span class="line">                        pHeader-&gt;result    = VINF_SUCCESS;</span><br><span class="line">                        pHeader-&gt;fu32Flags |= VBOX_HGCM_REQ_DONE;</span><br><span class="line">                    &#125;</span><br><span class="line">                    else</span><br><span class="line">                    &#123;</span><br><span class="line">                        VMMDevHGCMRequestHeader *pHeader = (VMMDevHGCMRequestHeader *)pHGCMCall;</span><br><span class="line">                        pHeader-&gt;header.rc = VINF_SUCCESS;</span><br><span class="line">                        pHeader-&gt;result    = VINF_SUCCESS;</span><br><span class="line">                        pHeader-&gt;fu32Flags |= VBOX_HGCM_REQ_DONE;</span><br><span class="line">                        PDMDevHlpPhysWrite(pThis-&gt;pDevInsR3, GCPhys, pHeader,  sizeof(*pHeader));</span><br><span class="line">                    &#125;</span><br><span class="line">                    vmmdevHGCMCmdFree(pThis, pCmd);</span><br><span class="line">                    return VINF_HGCM_ASYNC_EXECUTE; /* ignored, but avoids assertions. */</span><br><span class="line">                &#125;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">                rc = pThis-&gt;pHGCMDrv-&gt;pfnCall(pThis-&gt;pHGCMDrv, pCmd,</span><br><span class="line">                                              pCmd-&gt;u.call.u32ClientID, pCmd-&gt;u.call.u32Function,</span><br><span class="line">                                              pCmd-&gt;u.call.cParms, pCmd-&gt;u.call.paHostParms, tsArrival);</span><br><span class="line">...................................................</span><br><span class="line">    return rc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出，vmmdevHGCMCall中首先是使用<code>vmmdevHGCMCallFetchGuestParms</code>函数和<code>vmmdevHGCMInitHostParameters</code>函数，将参数从Guest中拷贝到了设备本地缓冲区中，然后通过<code>pThis-&gt;pHGCMDrv-&gt;pfnCall</code>调用了对应的函数。<br>通过调试</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">In file: /home/sea/Desktop/VirtualBox-6.0.0/src/VBox/Devices/VMMDev/VMMDevHGCM.cpp</span><br><span class="line">   1107                 &#125;</span><br><span class="line">   1108 #endif</span><br><span class="line">   1109 </span><br><span class="line">   1110                 rc = pThis-&gt;pHGCMDrv-&gt;pfnCall(pThis-&gt;pHGCMDrv, pCmd,</span><br><span class="line">   1111                                               pCmd-&gt;u.call.u32ClientID, pCmd-&gt;u.call.u32Function,</span><br><span class="line"> ► 1112                                               pCmd-&gt;u.call.cParms, pCmd-&gt;u.call.paHostParms, tsArrival);</span><br><span class="line">   1113 </span><br><span class="line">   1114                 if (rc == VINF_HGCM_ASYNC_EXECUTE)</span><br><span class="line">   1115                 &#123;</span><br><span class="line">   1116                     /*</span><br><span class="line">   1117                      * Done.  Just update statistics and return.</span><br><span class="line">pwndbg&gt; s</span><br><span class="line">   638 &#125;</span><br><span class="line">   639 </span><br><span class="line">   640 static DECLCALLBACK(int) iface_hgcmCall(PPDMIHGCMCONNECTOR pInterface, PVBOXHGCMCMD pCmd, uint32_t u32ClientID,</span><br><span class="line">   641                                         uint32_t u32Function, uint32_t cParms, PVBOXHGCMSVCPARM paParms, uint64_t tsArrival)</span><br></pre></td></tr></table></figure>
<p>可以知道该函数指针指向的是<code>iface_hgcmCall</code>函数</p>
<h4 id="iface-hgcmCall"><a href="#iface-hgcmCall" class="headerlink" title="iface_hgcmCall"></a>iface_hgcmCall</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">static DECLCALLBACK(int) iface_hgcmCall(PPDMIHGCMCONNECTOR pInterface, PVBOXHGCMCMD pCmd, uint32_t u32ClientID,</span><br><span class="line">                                        uint32_t u32Function, uint32_t cParms, PVBOXHGCMSVCPARM paParms, uint64_t tsArrival)</span><br><span class="line">&#123;</span><br><span class="line">    Log9((&quot;Enter\n&quot;));</span><br><span class="line"></span><br><span class="line">    PDRVMAINVMMDEV pDrv = RT_FROM_MEMBER(pInterface, DRVMAINVMMDEV, HGCMConnector);</span><br><span class="line"></span><br><span class="line">    if (!pDrv-&gt;pVMMDev || !pDrv-&gt;pVMMDev-&gt;hgcmIsActive())</span><br><span class="line">        return VERR_INVALID_STATE;</span><br><span class="line"></span><br><span class="line">    return HGCMGuestCall(pDrv-&gt;pHGCMPort, pCmd, u32ClientID, u32Function, cParms, paParms, tsArrival);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该函数简单的调用了<code>HGCMGuestCall</code>函数，而<code>HGCMGuestCall</code>函数继续调用<code>HGCMService::GuestCall</code>函数，同样也是通过<code>hgcmMsgPost</code>将消息挂到队列中，等待<code>hgcmServiceThread</code>线程取出消息并处理。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * The service thread. Loads the service library and calls the service entry points.</span><br><span class="line"> */</span><br><span class="line">DECLCALLBACK(void) hgcmServiceThread(HGCMThread *pThread, void *pvUser)</span><br><span class="line">&#123;</span><br><span class="line">    HGCMService *pSvc = (HGCMService *)pvUser;</span><br><span class="line">    AssertRelease(pSvc != NULL);</span><br><span class="line">       /* Cache required information to avoid unnecessary pMsgCore access. */</span><br><span class="line">        uint32_t u32MsgId = pMsgCore-&gt;MsgId();</span><br><span class="line"></span><br><span class="line">        switch (u32MsgId)</span><br><span class="line">        &#123;</span><br><span class="line">           case SVC_MSG_GUESTCALL:</span><br><span class="line">            &#123;</span><br><span class="line">                HGCMMsgCall *pMsg = (HGCMMsgCall *)pMsgCore;</span><br><span class="line"></span><br><span class="line">                LogFlowFunc((&quot;SVC_MSG_GUESTCALL u32ClientId = %d, u32Function = %d, cParms = %d, paParms = %p\n&quot;,</span><br><span class="line">                             pMsg-&gt;u32ClientId, pMsg-&gt;u32Function, pMsg-&gt;cParms, pMsg-&gt;paParms));</span><br><span class="line"></span><br><span class="line">                HGCMClient *pClient = (HGCMClient *)hgcmObjReference(pMsg-&gt;u32ClientId, HGCMOBJ_CLIENT);</span><br><span class="line"></span><br><span class="line">                if (pClient)</span><br><span class="line">                &#123;</span><br><span class="line">                    pSvc-&gt;m_fntable.pfnCall(pSvc-&gt;m_fntable.pvService, (VBOXHGCMCALLHANDLE)pMsg, pMsg-&gt;u32ClientId,</span><br><span class="line">                                            HGCM_CLIENT_DATA(pSvc, pClient), pMsg-&gt;u32Function,</span><br><span class="line">                                            pMsg-&gt;cParms, pMsg-&gt;paParms, pMsg-&gt;tsArrival);</span><br><span class="line"></span><br><span class="line">                    hgcmObjDereference(pClient);</span><br><span class="line">                &#125;</span><br><span class="line">                else</span><br><span class="line">                &#123;</span><br><span class="line">                    rc = VERR_HGCM_INVALID_CLIENT_ID;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; break;</span><br></pre></td></tr></table></figure>
<p>代码中，通过<code>HGCMClient *pClient = (HGCMClient *)hgcmObjReference(pMsg-&gt;u32ClientId, HGCMOBJ_CLIENT);</code>获取到了<code>HGCMClient</code>服务对象，然后通过<code>pSvc-&gt;m_fntable.pfnCall</code>进入了对应服务的处理函数。<br>调试如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">In file: /home/sea/Desktop/VirtualBox-6.0.0/src/VBox/HostServices/SharedClipboard/service.cpp</span><br><span class="line">   407                                    void *pvClient,</span><br><span class="line">   408                                    uint32_t u32Function,</span><br><span class="line">   409                                    uint32_t cParms,</span><br><span class="line">   410                                    VBOXHGCMSVCPARM paParms[],</span><br><span class="line">   411                                    uint64_t tsArrival)</span><br><span class="line"> ► 412 &#123;</span><br><span class="line">   413     RT_NOREF_PV(tsArrival);</span><br><span class="line">   414     int rc = VINF_SUCCESS;</span><br><span class="line">   415 </span><br><span class="line">   416     LogRel2((&quot;svcCall: u32ClientID = %d, fn = %d, cParms = %d, pparms = %d\n&quot;,</span><br><span class="line">   417              u32ClientID, u32Function, cParms, paParms));</span><br></pre></td></tr></table></figure>
<p>此时我们进入的是<code> SharedClipboard</code>服务的程序<code>svcCall</code>函数。对于<code>HostServices</code>目录下的各种服务都有一个<code>svcCall</code>函数的实现，由此可见，<code>svcCall</code>函数是服务程序的处理机入口。从代码可以看出这个函数是在<code>VBoxHGCMSvcLoad</code>中注册的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">extern &quot;C&quot; DECLCALLBACK(DECLEXPORT(int)) VBoxHGCMSvcLoad (VBOXHGCMSVCFNTABLE *ptable)</span><br><span class="line">&#123;</span><br><span class="line">    int rc = VINF_SUCCESS;</span><br><span class="line">            g_pHelpers = ptable-&gt;pHelpers;</span><br><span class="line"></span><br><span class="line">            ptable-&gt;cbClient = sizeof (VBOXCLIPBOARDCLIENTDATA);</span><br><span class="line"></span><br><span class="line">            ptable-&gt;pfnUnload     = svcUnload;</span><br><span class="line">            ptable-&gt;pfnConnect    = svcConnect;</span><br><span class="line">            ptable-&gt;pfnDisconnect = svcDisconnect;</span><br><span class="line">            ptable-&gt;pfnCall       = svcCall;</span><br><span class="line">            ptable-&gt;pfnHostCall   = svcHostCall;</span><br><span class="line">            ptable-&gt;pfnSaveState  = svcSaveState;</span><br><span class="line">            ptable-&gt;pfnLoadState  = svcLoadState;</span><br><span class="line">            ptable-&gt;pfnRegisterExtension  = svcRegisterExtension;</span><br><span class="line">            ptable-&gt;pfnNotify     = NULL;</span><br><span class="line">            ptable-&gt;pvService     = NULL;</span><br><span class="line"></span><br><span class="line">            /* Service specific initialization. */</span><br><span class="line">            rc = svcInit ();</span><br><span class="line">.................................................</span><br></pre></td></tr></table></figure>
<p>至此，我们对于<code>VBGL_IOCTL_HGCM_CALL</code>调用Service中的函数的整个流程也有所清楚了。</p>
<h3 id="VBGL-IOCTL-IDC-DISCONNECT"><a href="#VBGL-IOCTL-IDC-DISCONNECT" class="headerlink" title="VBGL_IOCTL_IDC_DISCONNECT"></a>VBGL_IOCTL_IDC_DISCONNECT</h3><p>对于<code>VBGL_IOCTL_IDC_DISCONNECT</code>，流程与前面类似，比较简单，调用了对应服务的<code>DisconnectClient</code>函数，然后使用<code>hgcmObjDereference(pClient);</code>将服务句柄从设备缓存列表中移除。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">case HGCM_MSG_DISCONNECT:</span><br><span class="line">&#123;</span><br><span class="line">    HGCMMsgMainDisconnect *pMsg = (HGCMMsgMainDisconnect *)pMsgCore;</span><br><span class="line"></span><br><span class="line">    LogFlowFunc((&quot;HGCM_MSG_DISCONNECT u32ClientId = %d\n&quot;,</span><br><span class="line">                 pMsg-&gt;u32ClientId));</span><br><span class="line"></span><br><span class="line">    HGCMClient *pClient = (HGCMClient *)hgcmObjReference(pMsg-&gt;u32ClientId, HGCMOBJ_CLIENT);</span><br><span class="line"></span><br><span class="line">    if (!pClient)</span><br><span class="line">    &#123;</span><br><span class="line">        rc = VERR_HGCM_INVALID_CLIENT_ID;</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* The service the client belongs to. */</span><br><span class="line">    HGCMService *pService = pClient-&gt;pService;</span><br><span class="line"></span><br><span class="line">    /* Call the service instance to disconnect the client. */</span><br><span class="line">    rc = pService-&gt;DisconnectClient(pMsg-&gt;u32ClientId, false);</span><br><span class="line"></span><br><span class="line">    hgcmObjDereference(pClient);</span><br><span class="line">&#125; break;</span><br></pre></td></tr></table></figure>
<p>至此，我们对HGCM协议已经有了进一步的深刻了解。</p>
<h2 id="0x02-HGCM调用库封装"><a href="#0x02-HGCM调用库封装" class="headerlink" title="0x02 HGCM调用库封装"></a>0x02 HGCM调用库封装</h2><p>经过上面的协议源代码分析，我们可以很轻松的写出HGCM的调用方法，国外<code>niklasb</code>大牛已经做了一个python版的封装库名为<a href="https://github.com/niklasb/3dpwn/">3dpwn</a>，而这里，我们自己同样实现了一个C语言版</p>
<h3 id="hgcm-h"><a href="#hgcm-h" class="headerlink" title="hgcm.h"></a>hgcm.h</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br></pre></td><td class="code"><pre><span class="line">#ifndef HGM_HELPER_H</span><br><span class="line">#define HGM_HELPER_H</span><br><span class="line"></span><br><span class="line">#define VBGLREQHDR_VERSION 0x10001</span><br><span class="line">#define VBGLREQHDR_TYPE_DEFAULT 0</span><br><span class="line">#define VERR_INTERNAL_ERROR -225</span><br><span class="line"></span><br><span class="line">#define VBGL_IOCTL_CODE_SIZE(func, size) (0xc0005600 + (size&lt;&lt;16) + func)</span><br><span class="line"></span><br><span class="line">#define VBGL_IOCTL_HGCM_CONNECT                    VBGL_IOCTL_CODE_SIZE(4, VBGL_IOCTL_HGCM_CONNECT_SIZE)</span><br><span class="line">#define VBGL_IOCTL_HGCM_CONNECT_SIZE               sizeof(VBGLIOCHGCMCONNECT)</span><br><span class="line"></span><br><span class="line"># define VBGL_IOCTL_HGCM_DISCONNECT                 VBGL_IOCTL_CODE_SIZE(5, VBGL_IOCTL_HGCM_DISCONNECT_SIZE)</span><br><span class="line"># define VBGL_IOCTL_HGCM_DISCONNECT_SIZE            sizeof(VBGLIOCHGCMDISCONNECT)</span><br><span class="line"></span><br><span class="line">#define IOCTL_HGCM_CALL 7</span><br><span class="line"></span><br><span class="line">/** Guest Physical Memory Address; limited to 64 bits.*/</span><br><span class="line">typedef uint64_t                RTGCPHYS64;</span><br><span class="line">/** Unsigned integer which can contain a 64 bits GC pointer. */</span><br><span class="line">typedef uint64_t                RTGCUINTPTR64;</span><br><span class="line">/** Guest context pointer, 64 bits.</span><br><span class="line"> */</span><br><span class="line">typedef RTGCUINTPTR64           RTGCPTR64;</span><br><span class="line"></span><br><span class="line">typedef uint8_t bool;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">typedef struct VBGLREQHDR</span><br><span class="line">&#123;</span><br><span class="line">    /** IN: The request input size, and output size if cbOut is zero.</span><br><span class="line">     * @sa VMMDevRequestHeader::size  */</span><br><span class="line">    uint32_t        cbIn;</span><br><span class="line">    /** IN: Structure version (VBGLREQHDR_VERSION)</span><br><span class="line">     * @sa VMMDevRequestHeader::version */</span><br><span class="line">    uint32_t        uVersion;</span><br><span class="line">    /** IN: The VMMDev request type, set to VBGLREQHDR_TYPE_DEFAULT unless this is a</span><br><span class="line">     * kind of VMMDev request.</span><br><span class="line">     * @sa VMMDevRequestType, VMMDevRequestHeader::requestType */</span><br><span class="line">    uint32_t        uType;</span><br><span class="line">    /** OUT: The VBox status code of the operation, out direction only. */</span><br><span class="line">    int32_t         rc;</span><br><span class="line">    /** IN: The output size.  This is optional - set to zero to use cbIn as the</span><br><span class="line">     * output size. */</span><br><span class="line">    uint32_t        cbOut;</span><br><span class="line">    /** Reserved / filled in by kernel, MBZ.</span><br><span class="line">     * @sa VMMDevRequestHeader::fRequestor */</span><br><span class="line">    uint32_t        uReserved;</span><br><span class="line">&#125; VBGLREQHDR;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * HGCM host service location.</span><br><span class="line"> * @ingroup grp_vmmdev_req</span><br><span class="line"> */</span><br><span class="line">typedef struct</span><br><span class="line">&#123;</span><br><span class="line">    char achName[128]; /**&lt; This is really szName. */</span><br><span class="line">&#125; HGCMServiceLocationHost;</span><br><span class="line"></span><br><span class="line">typedef enum</span><br><span class="line">&#123;</span><br><span class="line">    VMMDevHGCMLoc_Invalid    = 0,</span><br><span class="line">    VMMDevHGCMLoc_LocalHost  = 1,</span><br><span class="line">    VMMDevHGCMLoc_LocalHost_Existing = 2,</span><br><span class="line">    VMMDevHGCMLoc_SizeHack   = 0x7fffffff</span><br><span class="line">&#125; HGCMServiceLocationType;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * HGCM service location.</span><br><span class="line"> * @ingroup grp_vmmdev_req</span><br><span class="line"> */</span><br><span class="line">typedef struct HGCMSERVICELOCATION</span><br><span class="line">&#123;</span><br><span class="line">    /** Type of the location. */</span><br><span class="line">    HGCMServiceLocationType type;</span><br><span class="line"></span><br><span class="line">    union</span><br><span class="line">    &#123;</span><br><span class="line">        HGCMServiceLocationHost host;</span><br><span class="line">    &#125; u;</span><br><span class="line">&#125; HGCMServiceLocation;</span><br><span class="line"></span><br><span class="line">typedef struct VBGLIOCHGCMCONNECT</span><br><span class="line">&#123;</span><br><span class="line">    /** The header. */</span><br><span class="line">    VBGLREQHDR                  Hdr;</span><br><span class="line">    union</span><br><span class="line">    &#123;</span><br><span class="line">        struct</span><br><span class="line">        &#123;</span><br><span class="line">            HGCMServiceLocation Loc;</span><br><span class="line">        &#125; In;</span><br><span class="line">        struct</span><br><span class="line">        &#123;</span><br><span class="line">            uint32_t            idClient;</span><br><span class="line">        &#125; Out;</span><br><span class="line">    &#125; u;</span><br><span class="line">&#125; VBGLIOCHGCMCONNECT;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * For VBGL_IOCTL_HGCM_CALL and VBGL_IOCTL_HGCM_CALL_WITH_USER_DATA.</span><br><span class="line"> *</span><br><span class="line"> * @note This is used by alot of HGCM call structures.</span><br><span class="line"> */</span><br><span class="line">typedef struct VBGLIOCHGCMCALL</span><br><span class="line">&#123;</span><br><span class="line">    /** Common header. */</span><br><span class="line">    VBGLREQHDR  Hdr;</span><br><span class="line">    /** Input: The id of the caller. */</span><br><span class="line">    uint32_t    u32ClientID;</span><br><span class="line">    /** Input: Function number. */</span><br><span class="line">    uint32_t    u32Function;</span><br><span class="line">    /** Input: How long to wait (milliseconds) for completion before cancelling the</span><br><span class="line">     * call.  This is ignored if not a VBGL_IOCTL_HGCM_CALL_TIMED or</span><br><span class="line">     * VBGL_IOCTL_HGCM_CALL_TIMED_32 request. */</span><br><span class="line">    uint32_t    cMsTimeout;</span><br><span class="line">    /** Input: Whether a timed call is interruptible (ring-0 only).  This is ignored</span><br><span class="line">     * if not a VBGL_IOCTL_HGCM_CALL_TIMED or VBGL_IOCTL_HGCM_CALL_TIMED_32</span><br><span class="line">     * request, or if made from user land. */</span><br><span class="line">    bool        fInterruptible;</span><br><span class="line">    /** Explicit padding, MBZ. */</span><br><span class="line">    uint8_t     bReserved;</span><br><span class="line">    /** Input: How many parameters following this structure.</span><br><span class="line">     *</span><br><span class="line">     * The parameters are either HGCMFunctionParameter64 or HGCMFunctionParameter32,</span><br><span class="line">     * depending on whether we&#x27;re receiving a 64-bit or 32-bit request.</span><br><span class="line">     *</span><br><span class="line">     * The current maximum is 61 parameters (given a 1KB max request size,</span><br><span class="line">     * and a 64-bit parameter size of 16 bytes).</span><br><span class="line">     *</span><br><span class="line">     * @note This information is duplicated by Hdr.cbIn, but it&#x27;s currently too much</span><br><span class="line">     *       work to eliminate this. */</span><br><span class="line">    uint16_t    cParms;</span><br><span class="line">    /* Parameters follow in form HGCMFunctionParameter aParms[cParms] */</span><br><span class="line">&#125; VBGLIOCHGCMCALL;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * HGCM parameter type.</span><br><span class="line"> */</span><br><span class="line">typedef enum</span><br><span class="line">&#123;</span><br><span class="line">    VMMDevHGCMParmType_Invalid            = 0,</span><br><span class="line">    VMMDevHGCMParmType_32bit              = 1,</span><br><span class="line">    VMMDevHGCMParmType_64bit              = 2,</span><br><span class="line">    VMMDevHGCMParmType_PhysAddr           = 3,  /**&lt; @deprecated Doesn&#x27;t work, use PageList. */</span><br><span class="line">    VMMDevHGCMParmType_LinAddr            = 4,  /**&lt; In and Out */</span><br><span class="line">    VMMDevHGCMParmType_LinAddr_In         = 5,  /**&lt; In  (read;  host&lt;-guest) */</span><br><span class="line">    VMMDevHGCMParmType_LinAddr_Out        = 6,  /**&lt; Out (write; host-&gt;guest) */</span><br><span class="line">    VMMDevHGCMParmType_LinAddr_Locked     = 7,  /**&lt; Locked In and Out */</span><br><span class="line">    VMMDevHGCMParmType_LinAddr_Locked_In  = 8,  /**&lt; Locked In  (read;  host&lt;-guest) */</span><br><span class="line">    VMMDevHGCMParmType_LinAddr_Locked_Out = 9,  /**&lt; Locked Out (write; host-&gt;guest) */</span><br><span class="line">    VMMDevHGCMParmType_PageList           = 10, /**&lt; Physical addresses of locked pages for a buffer. */</span><br><span class="line">    VMMDevHGCMParmType_Embedded           = 11, /**&lt; Small buffer embedded in request. */</span><br><span class="line">    VMMDevHGCMParmType_ContiguousPageList = 12, /**&lt; Like PageList but with physically contiguous memory, so only one page entry. */</span><br><span class="line">    VMMDevHGCMParmType_SizeHack           = 0x7fffffff</span><br><span class="line">&#125; HGCMFunctionParameterType;</span><br><span class="line"></span><br><span class="line">#  pragma pack(4)</span><br><span class="line"></span><br><span class="line">typedef struct</span><br><span class="line">&#123;</span><br><span class="line">    HGCMFunctionParameterType type;</span><br><span class="line">    union</span><br><span class="line">    &#123;</span><br><span class="line">        uint32_t   value32;</span><br><span class="line">        uint64_t   value64;</span><br><span class="line">        struct</span><br><span class="line">        &#123;</span><br><span class="line">            uint32_t size;</span><br><span class="line"></span><br><span class="line">            union</span><br><span class="line">            &#123;</span><br><span class="line">                RTGCPHYS64 physAddr;</span><br><span class="line">                RTGCPTR64  linearAddr;</span><br><span class="line">            &#125; u;</span><br><span class="line">        &#125; Pointer;</span><br><span class="line">        struct</span><br><span class="line">        &#123;</span><br><span class="line">            uint32_t size;   /**&lt; Size of the buffer described by the page list. */</span><br><span class="line">            uint32_t offset; /**&lt; Relative to the request header, valid if size != 0. */</span><br><span class="line">        &#125; PageList;</span><br><span class="line">        struct</span><br><span class="line">        &#123;</span><br><span class="line">            uint32_t fFlags : 8;        /**&lt; VBOX_HGCM_F_PARM_*. */</span><br><span class="line">            uint32_t offData : 24;      /**&lt; Relative to the request header, valid if cb != 0. */</span><br><span class="line">            uint32_t cbData;            /**&lt; The buffer size. */</span><br><span class="line">        &#125; Embedded;</span><br><span class="line">    &#125; u;</span><br><span class="line">&#125; HGCMFunctionParameter64;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">typedef struct VBGLIOCHGCMDISCONNECT</span><br><span class="line">&#123;</span><br><span class="line">    /** The header. */</span><br><span class="line">    VBGLREQHDR          Hdr;</span><br><span class="line">    union</span><br><span class="line">    &#123;</span><br><span class="line">        struct</span><br><span class="line">        &#123;</span><br><span class="line">            uint32_t    idClient;</span><br><span class="line">        &#125; In;</span><br><span class="line">    &#125; u;</span><br><span class="line">&#125; VBGLIOCHGCMDISCONNECT;</span><br><span class="line"></span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>
<h3 id="hgcm-c"><a href="#hgcm-c" class="headerlink" title="hgcm.c"></a>hgcm.c</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;stdint.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line">#include &lt;sys/ioctl.h&gt;</span><br><span class="line">#include &lt;stdarg.h&gt;</span><br><span class="line">#include &quot;hgcm.h&quot;</span><br><span class="line"></span><br><span class="line">void die(char *msg) &#123;</span><br><span class="line">   perror(msg);</span><br><span class="line">   exit(-1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//device fd</span><br><span class="line">int fd;</span><br><span class="line"></span><br><span class="line">int hgcm_connect(const char *service_name) &#123;</span><br><span class="line">   VBGLIOCHGCMCONNECT data = &#123;</span><br><span class="line">      .Hdr.cbIn = sizeof(VBGLIOCHGCMCONNECT),</span><br><span class="line">      .Hdr.uVersion = VBGLREQHDR_VERSION,</span><br><span class="line">      .Hdr.uType = VBGLREQHDR_TYPE_DEFAULT,</span><br><span class="line">      .Hdr.rc = VERR_INTERNAL_ERROR,</span><br><span class="line">      .Hdr.cbOut = sizeof(VBGLREQHDR) + sizeof(uint32_t),</span><br><span class="line">      .Hdr.uReserved = 0,</span><br><span class="line">      .u.In.Loc.type = VMMDevHGCMLoc_LocalHost_Existing</span><br><span class="line">   &#125;;</span><br><span class="line">   memset(data.u.In.Loc.u.host.achName,0,128);</span><br><span class="line">   strncpy(data.u.In.Loc.u.host.achName,service_name,128);</span><br><span class="line">   ioctl(fd,VBGL_IOCTL_HGCM_CONNECT,&amp;data);</span><br><span class="line">   if (data.Hdr.rc) &#123; //error</span><br><span class="line">      return -1;</span><br><span class="line">   &#125;</span><br><span class="line">   return data.u.Out.idClient;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">HGCMFunctionParameter64 arg_buf[0x100];</span><br><span class="line"></span><br><span class="line">int hgcm_call(int client_id,int func,char *params_fmt,...) &#123;</span><br><span class="line">   va_list ap;</span><br><span class="line">   char *p,*bval,*type;</span><br><span class="line">   uint32_t ival;</span><br><span class="line">   uint64_t lval;</span><br><span class="line">   HGCMFunctionParameter64 params;</span><br><span class="line">   uint16_t index = 0;</span><br><span class="line"></span><br><span class="line">   va_start(ap,params_fmt);</span><br><span class="line">   for(p = params_fmt;*p;p++) &#123;</span><br><span class="line">      if(*p!=&#x27;%&#x27;) &#123;</span><br><span class="line">         continue;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      switch (*++p) &#123;</span><br><span class="line">         case &#x27;u&#x27;: //整数类型</span><br><span class="line">            ival = va_arg(ap,uint32_t);</span><br><span class="line">            params.type = VMMDevHGCMParmType_32bit;</span><br><span class="line">            params.u.value64 = 0;</span><br><span class="line">            params.u.value32 = ival;</span><br><span class="line">            arg_buf[index++] = params;</span><br><span class="line">            break;</span><br><span class="line">         case &#x27;l&#x27;:</span><br><span class="line">            lval = va_arg(ap,uint64_t);</span><br><span class="line">            params.type = VMMDevHGCMParmType_64bit;</span><br><span class="line">            params.u.value64 = lval;</span><br><span class="line">            arg_buf[index++] = params;</span><br><span class="line">         case &#x27;b&#x27;: //buffer类型</span><br><span class="line">            type = va_arg(ap,char *);</span><br><span class="line">            bval = va_arg(ap,char *);</span><br><span class="line">            ival = va_arg(ap,uint32_t);</span><br><span class="line">            if (!strcmp(type,&quot;in&quot;)) &#123;</span><br><span class="line">               params.type = VMMDevHGCMParmType_LinAddr_In;</span><br><span class="line">            &#125; else if (!strcmp(type,&quot;out&quot;)) &#123;</span><br><span class="line">               params.type = VMMDevHGCMParmType_LinAddr_Out;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">               params.type = VMMDevHGCMParmType_LinAddr;</span><br><span class="line">            &#125;</span><br><span class="line">            params.u.Pointer.size = ival;</span><br><span class="line">            params.u.Pointer.u.linearAddr = (uintptr_t)bval;</span><br><span class="line">            arg_buf[index++] = params;</span><br><span class="line">            break;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   va_end(ap);</span><br><span class="line">   //printf(&quot;params count=%d\n&quot;,index);</span><br><span class="line">   uint8_t *data_buf = (uint8_t *)malloc(sizeof(VBGLIOCHGCMCALL) + sizeof(HGCMFunctionParameter64)*index);</span><br><span class="line">   VBGLIOCHGCMCALL data = &#123;</span><br><span class="line">      .Hdr.cbIn = sizeof(VBGLIOCHGCMCALL) + sizeof(HGCMFunctionParameter64)*index,</span><br><span class="line">      .Hdr.uVersion = VBGLREQHDR_VERSION,</span><br><span class="line">      .Hdr.uType = VBGLREQHDR_TYPE_DEFAULT,</span><br><span class="line">      .Hdr.rc = VERR_INTERNAL_ERROR,</span><br><span class="line">      .Hdr.cbOut = sizeof(VBGLIOCHGCMCALL) + sizeof(HGCMFunctionParameter64)*index,</span><br><span class="line">      .Hdr.uReserved = 0,</span><br><span class="line">      .u32ClientID = client_id,</span><br><span class="line">      .u32Function = func,</span><br><span class="line">      .cMsTimeout = 100000, //忽略</span><br><span class="line">      .fInterruptible = 0,</span><br><span class="line">      .bReserved = 0,</span><br><span class="line">      .cParms = index</span><br><span class="line">   &#125;;</span><br><span class="line">   memcpy(data_buf,&amp;data,sizeof(VBGLIOCHGCMCALL));</span><br><span class="line">   memcpy(data_buf+sizeof(VBGLIOCHGCMCALL),arg_buf,sizeof(HGCMFunctionParameter64)*index);</span><br><span class="line"></span><br><span class="line">   /*for (int i=0;i&lt;sizeof(VBGLIOCHGCMCALL)+sizeof(HGCMFunctionParameter64)*index;i++) &#123;</span><br><span class="line">      printf(&quot;%02x&quot;,data_buf[i]);</span><br><span class="line">   &#125;</span><br><span class="line">   printf(&quot;\n&quot;);*/</span><br><span class="line"></span><br><span class="line">   ioctl(fd,VBGL_IOCTL_CODE_SIZE(IOCTL_HGCM_CALL,sizeof(VBGLIOCHGCMCALL) + sizeof(HGCMFunctionParameter64)*index),data_buf);</span><br><span class="line">   int error = ((VBGLIOCHGCMCALL *)data_buf)-&gt;Hdr.rc;</span><br><span class="line">   free(data_buf);</span><br><span class="line"></span><br><span class="line">   if (error) &#123; //error</span><br><span class="line">      return error;</span><br><span class="line">   &#125;</span><br><span class="line">   /*for (int i=0;i&lt;sizeof(VBGLIOCHGCMCALL)+sizeof(HGCMFunctionParameter64)*index;i++) &#123;</span><br><span class="line">      printf(&quot;%02x&quot;,data_buf[i]);</span><br><span class="line">   &#125;</span><br><span class="line">   printf(&quot;\n&quot;);*/</span><br><span class="line"></span><br><span class="line">   return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int hgcm_disconnect(int client_id) &#123;</span><br><span class="line">   VBGLIOCHGCMDISCONNECT data = &#123;</span><br><span class="line">      .Hdr.cbIn = sizeof(VBGLIOCHGCMDISCONNECT),</span><br><span class="line">      .Hdr.uVersion = VBGLREQHDR_VERSION,</span><br><span class="line">      .Hdr.uType = VBGLREQHDR_TYPE_DEFAULT,</span><br><span class="line">      .Hdr.rc = VERR_INTERNAL_ERROR,</span><br><span class="line">      .Hdr.cbOut = sizeof(VBGLREQHDR),</span><br><span class="line">      .Hdr.uReserved = 0,</span><br><span class="line">      .u.In.idClient = client_id,</span><br><span class="line">   &#125;;</span><br><span class="line">   ioctl(fd,VBGL_IOCTL_HGCM_DISCONNECT,&amp;data);</span><br><span class="line">   if (data.Hdr.rc) &#123; //error</span><br><span class="line">      return -1;</span><br><span class="line">   &#125;</span><br><span class="line">   return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">   //打开设备</span><br><span class="line">   fd = open(&quot;/dev/vboxuser&quot;,O_RDWR);</span><br><span class="line">   if (fd == -1) &#123;</span><br><span class="line">      die(&quot;open device error&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">   int idClient = hgcm_connect(&quot;VBoxGuestPropSvc&quot;);</span><br><span class="line">   printf(&quot;idClient=%d\n&quot;,idClient);</span><br><span class="line">   char ans[0x100] = &#123;0&#125;;</span><br><span class="line">   int ret = hgcm_call(idClient,2,&quot;%b%b&quot;,&quot;in&quot;,&quot;foo&quot;,4,&quot;in&quot;,&quot;bar&quot;,4);</span><br><span class="line">   ret = hgcm_call(idClient,1,&quot;%b%b%u%u&quot;,&quot;in&quot;,&quot;foo&quot;,4,&quot;out&quot;,ans,0x100,0,0);</span><br><span class="line"></span><br><span class="line">   printf(&quot;%s\n&quot;,ans);</span><br><span class="line">   printf(&quot;%d\n&quot;,hgcm_disconnect(idClient));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="0x03-感想"><a href="#0x03-感想" class="headerlink" title="0x03 感想"></a>0x03 感想</h2><p>学习漏洞挖掘，不应该只依赖于现成的库或工具，就像本文，虽然<code>niklasb</code>大牛已经封装了<code>3dpwn</code>库，但是对于我们研究员来说，还是得先自己弄懂，自己动手写工具，才能明白其本质。</p>
<h2 id="0x04-参考链接"><a href="#0x04-参考链接" class="headerlink" title="0x04 参考链接"></a>0x04 参考链接</h2><p><a target="_blank" rel="noopener" href="https://www.virtualbox.org/wiki/LinuxAdditionsDebug">Investigating generic problems with the Linux Guest Additions</a><br><a target="_blank" rel="noopener" href="https://www.coresecurity.com/sites/default/files/private-files/publications/2016/05/corelabs-Breaking_Out_of_VirtualBox_through_3D_Acceleration-Francisco_Falcon.pdf">corelabs-Breaking_Out_of_VirtualBox_through_3D_Acceleration-Francisco_Falcon.pdf</a></p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA%E9%80%83%E9%80%B8/" rel="tag"># 虚拟机逃逸</a>
              <a href="/tags/VirtualBox/" rel="tag"># VirtualBox</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/04/07/CVE-2017-15399/" rel="prev" title="CVE-2017-15399">
      <i class="fa fa-chevron-left"></i> CVE-2017-15399
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/05/06/virtualbox-SharedOpenGL/" rel="next" title="VirtualBox虚拟机逃逸之SharedOpenGL模块">
      VirtualBox虚拟机逃逸之SharedOpenGL模块 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#0x00-%E5%89%8D%E8%A8%80"><span class="nav-number">1.</span> <span class="nav-text">0x00 前言</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#0x01-VirtualBox-%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE"><span class="nav-number">2.</span> <span class="nav-text">0x01 VirtualBox 通信协议</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%95%E8%A8%80"><span class="nav-number">2.1.</span> <span class="nav-text">引言</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#GUEST-IOCTL"><span class="nav-number">2.2.</span> <span class="nav-text">GUEST IOCTL</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#VBGL-IOCTL-HGCM-CONNECT"><span class="nav-number">2.3.</span> <span class="nav-text">VBGL_IOCTL_HGCM_CONNECT</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#VbglR0HGCMInternalConnect"><span class="nav-number">2.3.1.</span> <span class="nav-text">VbglR0HGCMInternalConnect</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#VbglR0GRPerform"><span class="nav-number">2.3.2.</span> <span class="nav-text">VbglR0GRPerform</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#vmmdevRequestHandler"><span class="nav-number">2.3.3.</span> <span class="nav-text">vmmdevRequestHandler</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#vmmdevReqHandler-HGCMConnect"><span class="nav-number">2.3.4.</span> <span class="nav-text">vmmdevReqHandler_HGCMConnect</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#iface-hgcmConnect"><span class="nav-number">2.3.5.</span> <span class="nav-text">iface_hgcmConnect</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#hgcmMsgPostInternal"><span class="nav-number">2.3.6.</span> <span class="nav-text">hgcmMsgPostInternal</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#hgcmThread"><span class="nav-number">2.3.7.</span> <span class="nav-text">hgcmThread</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#VBGL-IOCTL-HGCM-CALL"><span class="nav-number">2.4.</span> <span class="nav-text">VBGL_IOCTL_HGCM_CALL</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#PVBGLIOCHGCMCALL"><span class="nav-number">2.4.1.</span> <span class="nav-text">PVBGLIOCHGCMCALL</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#vgdrvIoCtl-HGCMCallInner"><span class="nav-number">2.4.2.</span> <span class="nav-text">vgdrvIoCtl_HGCMCallInner</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#vmmdevHGCMCall"><span class="nav-number">2.4.3.</span> <span class="nav-text">vmmdevHGCMCall</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#iface-hgcmCall"><span class="nav-number">2.4.4.</span> <span class="nav-text">iface_hgcmCall</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#VBGL-IOCTL-IDC-DISCONNECT"><span class="nav-number">2.5.</span> <span class="nav-text">VBGL_IOCTL_IDC_DISCONNECT</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#0x02-HGCM%E8%B0%83%E7%94%A8%E5%BA%93%E5%B0%81%E8%A3%85"><span class="nav-number">3.</span> <span class="nav-text">0x02 HGCM调用库封装</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#hgcm-h"><span class="nav-number">3.1.</span> <span class="nav-text">hgcm.h</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#hgcm-c"><span class="nav-number">3.2.</span> <span class="nav-text">hgcm.c</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#0x03-%E6%84%9F%E6%83%B3"><span class="nav-number">4.</span> <span class="nav-text">0x03 感想</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#0x04-%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5"><span class="nav-number">5.</span> <span class="nav-text">0x04 参考链接</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">ha1vk</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">233</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">145</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ha1vk</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>


        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
